<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solveCobraLPCPLEX</title>
  <meta name="keywords" content="solveCobraLPCPLEX">
  <meta name="description" content="[solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html cobra --><!-- menu.html solvers -->
<h1>solveCobraLPCPLEX
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>[solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)
 call CPLEX to solve an LP problem
 By default, use the matlab interface to cplex written by TOMLAB, in
 preference to the one written by ILOG.
 
INPUT
 LPproblem Structure containing the following fields describing the LP
 problem to be solved
  A or S       m x n LHS matrix
  b            m x 1 RHS vector
  c            n x 1 Objective coeff vector
  lb           n x 1 Lower bound vector
  ub           n x 1 Upper bound vector
  osense       scalar Objective sense (-1 max, +1 min)

OPTIONAL INPUT
 LPProblem.rxns    cell array of reaction abbreviations (necessary for
                   making a readable confilict resolution file).
 LPProblem.csense  Constraint senses, a string containting the constraint sense for
                   each row in A ('E', equality, 'G' greater than, 'L' less than).

 LPProblem.LPBasis Basis from previous solution of similar LP problem. 
                   See basisReuse

 PrintLevel    Printing level in the CPLEX m-file and CPLEX C-interface.
               = 0    Silent 
               = 1    Warnings and Errors
               = 2    Summary information (Default)
               = 3    More detailed information
               &gt; 10   Pause statements, and maximal printing (debug mode)

 basisReuse = 0   Use this for one of soluion of an LP (Default)
            = 1   Returns a basis for reuse in the next LP 
                  i.e. outputs LPProblem.LPBasis

 conflictResolve  = 0   (Default)
                  = 1   If LP problem is proven to be infeasible by CPLEX,
                        it will print out a 'conflict resolution file', 
                        which indicates the irreducible infeasible set of
                        equaltiy &amp; inequality constraints that together, 
                        combine to make the problem infeasible. This is 
                        useful for debugging an LP problem if you want to
                        try to resolve a constraint conflict

 contFunctName        = [] Use all default CLPEX control parameters, (Default)
                      = someString e.g. 'someFunctionName'
                        uses the user specified control parameters defined
                        in someFunctionName.m
                       (see template function CPLEXParamSet for details).
                      = cpxControl structure (output from a file like CPLEXParamSet.m)

 minNorm       {(0), 1 , n x 1 vector} If not zero then, minimise the Euclidean length 
               of the solution to the LP problem. Gives the same objective,
               but minimises the square of flux. minNorm ~1e-6 should be
               high enough for regularisation yet keep the same objective</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../cobra/design/optGeneFitness.html" class="code" title="function [val] = optGeneFitness(rxn_vector_matrix, model, targetRxn, rxnListInput, isGeneList)">optGeneFitness</a>	optGeneFitness GeneOptFitness the fitness function</li><li><a href="../../cobra/design/optGeneFitnessTilt.html" class="code" title="function [val] = optGeneFitnessTilt(rxn_vector_matrix, model, targetRxn, rxnListInput, isGeneList)">optGeneFitnessTilt</a>	optGeneFitnessTilt GeneOptFitness the fitness function</li><li><a href="solveCobraLP.html" class="code" title="function solution = solveCobraLP(LPproblem, varargin)">solveCobraLP</a>	solveCobraLP Solve constraint-based LP problems</li><li><a href="solveCobraQP.html" class="code" title="function solution = solveCobraQP(QPproblem,varargin)">solveCobraQP</a>	solveCobraQP Solve constraint-based QP problems</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)</a>
0002 <span class="comment">% [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)</span>
0003 <span class="comment">% call CPLEX to solve an LP problem</span>
0004 <span class="comment">% By default, use the matlab interface to cplex written by TOMLAB, in</span>
0005 <span class="comment">% preference to the one written by ILOG.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%INPUT</span>
0008 <span class="comment">% LPproblem Structure containing the following fields describing the LP</span>
0009 <span class="comment">% problem to be solved</span>
0010 <span class="comment">%  A or S       m x n LHS matrix</span>
0011 <span class="comment">%  b            m x 1 RHS vector</span>
0012 <span class="comment">%  c            n x 1 Objective coeff vector</span>
0013 <span class="comment">%  lb           n x 1 Lower bound vector</span>
0014 <span class="comment">%  ub           n x 1 Upper bound vector</span>
0015 <span class="comment">%  osense       scalar Objective sense (-1 max, +1 min)</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%OPTIONAL INPUT</span>
0018 <span class="comment">% LPProblem.rxns    cell array of reaction abbreviations (necessary for</span>
0019 <span class="comment">%                   making a readable confilict resolution file).</span>
0020 <span class="comment">% LPProblem.csense  Constraint senses, a string containting the constraint sense for</span>
0021 <span class="comment">%                   each row in A ('E', equality, 'G' greater than, 'L' less than).</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% LPProblem.LPBasis Basis from previous solution of similar LP problem.</span>
0024 <span class="comment">%                   See basisReuse</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% PrintLevel    Printing level in the CPLEX m-file and CPLEX C-interface.</span>
0027 <span class="comment">%               = 0    Silent</span>
0028 <span class="comment">%               = 1    Warnings and Errors</span>
0029 <span class="comment">%               = 2    Summary information (Default)</span>
0030 <span class="comment">%               = 3    More detailed information</span>
0031 <span class="comment">%               &gt; 10   Pause statements, and maximal printing (debug mode)</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% basisReuse = 0   Use this for one of soluion of an LP (Default)</span>
0034 <span class="comment">%            = 1   Returns a basis for reuse in the next LP</span>
0035 <span class="comment">%                  i.e. outputs LPProblem.LPBasis</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% conflictResolve  = 0   (Default)</span>
0038 <span class="comment">%                  = 1   If LP problem is proven to be infeasible by CPLEX,</span>
0039 <span class="comment">%                        it will print out a 'conflict resolution file',</span>
0040 <span class="comment">%                        which indicates the irreducible infeasible set of</span>
0041 <span class="comment">%                        equaltiy &amp; inequality constraints that together,</span>
0042 <span class="comment">%                        combine to make the problem infeasible. This is</span>
0043 <span class="comment">%                        useful for debugging an LP problem if you want to</span>
0044 <span class="comment">%                        try to resolve a constraint conflict</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% contFunctName        = [] Use all default CLPEX control parameters, (Default)</span>
0047 <span class="comment">%                      = someString e.g. 'someFunctionName'</span>
0048 <span class="comment">%                        uses the user specified control parameters defined</span>
0049 <span class="comment">%                        in someFunctionName.m</span>
0050 <span class="comment">%                       (see template function CPLEXParamSet for details).</span>
0051 <span class="comment">%                      = cpxControl structure (output from a file like CPLEXParamSet.m)</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% minNorm       {(0), 1 , n x 1 vector} If not zero then, minimise the Euclidean length</span>
0054 <span class="comment">%               of the solution to the LP problem. Gives the same objective,</span>
0055 <span class="comment">%               but minimises the square of flux. minNorm ~1e-6 should be</span>
0056 <span class="comment">%               high enough for regularisation yet keep the same objective</span>
0057 
0058 <span class="comment">%OUTPUT</span>
0059 <span class="comment">% solution Structure containing the following fields describing a LP</span>
0060 <span class="comment">% solution</span>
0061 <span class="comment">%  full         Full LP solution vector</span>
0062 <span class="comment">%  obj          Objective value</span>
0063 <span class="comment">%  rcost        Lagrangian multipliers to the simple inequalties (Reduced costs)</span>
0064 <span class="comment">%  dual         Lagrangian multipliers to the equalities</span>
0065 <span class="comment">%  nInfeas      Number of infeasible constraints</span>
0066 <span class="comment">%  sumInfeas    Sum of constraint violation</span>
0067 <span class="comment">%  stat         COBRA Standardized solver status code:</span>
0068 <span class="comment">%               1   Optimal solution</span>
0069 <span class="comment">%               2   Unbounded solution</span>
0070 <span class="comment">%               0   Infeasible</span>
0071 <span class="comment">%               -1  No solution reported (timelimit, numerical problem etc)</span>
0072 <span class="comment">%  origStat     CPLEX status code. Use cplexStatus(solution.origStat) for</span>
0073 <span class="comment">%               more information from the CPLEX solver</span>
0074 <span class="comment">%  solver       solver used by cplex</span>
0075 <span class="comment">%  time         time taken to solve the optimization problem</span>
0076 <span class="comment">%</span>
0077 <span class="comment">%OPTIONAL OUTPUT</span>
0078 <span class="comment">% LPProblem.LPBasis When input basisReuse=1, we return a basis for reuse in</span>
0079 <span class="comment">%                   the next LP</span>
0080 <span class="comment">%</span>
0081 <span class="comment">% CPLEX consists of 4 different LP solvers which can be used to solve sysbio optimization problems</span>
0082 <span class="comment">% you can control which of the solvers, e.g. simplex vs interior point solver using the</span>
0083 <span class="comment">% CPLEX control parameter cpxControl.LPMETHOD. At the moment, the solver is</span>
0084 <span class="comment">% automatically chosen for you</span>
0085 <span class="comment">%</span>
0086 <span class="comment">% Ronan Fleming 10 June 08</span>
0087 <span class="comment">%               20 Mar  09  min norm can be specific to each variable</span>
0088 <span class="comment">%               12 Jul  09  more description of basis reuse</span>
0089 <span class="comment">%               23 Oct  09  ILOG-CPLEX matlab simple interface by default</span>
0090 <span class="comment">%                           See solveCobraCPLEX for full control of CPLEX</span>
0091 <span class="comment">%                           12.1 via API</span>
0092 
0093 <span class="keyword">if</span> ~exist(<span class="string">'printLevel'</span>,<span class="string">'var'</span>)
0094     printLevel=2;
0095 <span class="keyword">end</span>
0096 <span class="keyword">if</span> ~exist(<span class="string">'basisReuse'</span>,<span class="string">'var'</span>)
0097     basisReuse=0;
0098 <span class="keyword">end</span>
0099 <span class="keyword">if</span> ~exist(<span class="string">'conflictResolve'</span>,<span class="string">'var'</span>)
0100     conflictResolve=0;
0101 <span class="keyword">end</span>
0102 <span class="keyword">if</span> ~exist(<span class="string">'contFunctName'</span>,<span class="string">'var'</span>)
0103     cpxControl=[];
0104 <span class="keyword">else</span>
0105     <span class="keyword">if</span> isstruct(contFunctName)
0106         cpxControl=contFunctName;
0107     <span class="keyword">else</span>
0108         <span class="keyword">if</span> ~isempty(contFunctName)
0109             <span class="comment">%calls a user specified function to create a CPLEX control structure</span>
0110             <span class="comment">%specific to the users problem. A TEMPLATE for one such function is</span>
0111             <span class="comment">%CPLEXParamSet</span>
0112             cpxControl=eval(contFunctName);
0113         <span class="keyword">else</span>
0114             cpxControl=[];
0115         <span class="keyword">end</span>
0116     <span class="keyword">end</span>
0117 <span class="keyword">end</span>
0118 <span class="keyword">if</span> ~exist(<span class="string">'minNorm'</span>,<span class="string">'var'</span>)
0119     minNorm=0;
0120 <span class="keyword">end</span>
0121 
0122 <span class="keyword">if</span> basisReuse
0123     <span class="keyword">if</span> isfield(LPProblem,<span class="string">'LPBasis'</span>)
0124         basis=LPProblem.LPBasis;
0125         <span class="comment">%use advanced starting information when optimization is initiated.</span>
0126         cpxControl.ADVIND=1;
0127     <span class="keyword">else</span>
0128         basis=[];
0129     <span class="keyword">end</span>
0130 <span class="keyword">else</span>
0131     basis=[];
0132     <span class="comment">%do not use advanced starting information when optimization is initiated.</span>
0133     cpxControl.ADVIND=0;
0134 <span class="keyword">end</span>
0135 
0136 <span class="keyword">if</span> ~isfield(LPProblem,<span class="string">'A'</span>)
0137     <span class="keyword">if</span> ~isfield(LPProblem,<span class="string">'S'</span>)
0138             error(<span class="string">'Equality constraint matrix must either be a field denoted A or S.'</span>)
0139     <span class="keyword">end</span>
0140     LPProblem.A=LPProblem.S;
0141 <span class="keyword">end</span>
0142 
0143 <span class="keyword">if</span> ~isfield(LPProblem,<span class="string">'csense'</span>)
0144     nMet=size(LPProblem.A);
0145     <span class="keyword">if</span> printLevel&gt;0
0146         fprintf(<span class="string">'%s\n'</span>,<span class="string">'Assuming equality constraints, i.e. S*v=b'</span>);
0147     <span class="keyword">end</span>
0148     <span class="comment">%assuming equality constraints</span>
0149     LPProblem.csense(1:nMet,1)=<span class="string">'E'</span>;
0150 <span class="keyword">end</span>
0151     
0152 <span class="keyword">if</span> ~isfield(LPProblem,<span class="string">'osense'</span>)
0153     <span class="comment">%assuming maximisation</span>
0154     LPProblem.osense=-1;
0155     <span class="keyword">if</span> printLevel&gt;0
0156         fprintf(<span class="string">'%s\n'</span>,<span class="string">'Assuming maximisation of objective'</span>);
0157     <span class="keyword">end</span>
0158 <span class="keyword">end</span>
0159 
0160 <span class="comment">%get data</span>
0161 [c,x_L,x_U,b,csense,osense] = deal(LPProblem.c,LPProblem.lb,LPProblem.ub,LPProblem.b,LPProblem.csense,LPProblem.osense);
0162 <span class="comment">%modify objective to correspond to osense</span>
0163 c=full(c*osense);
0164 
0165 <span class="comment">%cplex expects it dense</span>
0166 b=full(b);
0167 <span class="comment">%Conflict groups descriptor (cpxBuildConflict can be used to generate the input). Set this if</span>
0168 <span class="comment">%conflict refinement is desired in the case that infeasibility is detected</span>
0169 <span class="comment">%by CPLEX.</span>
0170 <span class="keyword">if</span> conflictResolve
0171     [m_lin,n]=size(LPProblem.A);
0172     m_quad=0;
0173     m_sos=0;
0174     m_log=0;
0175     <span class="comment">%determines how elaborate the output is</span>
0176     mode=<span class="string">'full'</span>;<span class="comment">%'minimal';</span>
0177     fprintf(<span class="string">'%s\n%s\n'</span>,<span class="string">'Building Structure for Conflict Resolution...'</span>,<span class="string">'...this slows CPLEX down so should not be used for repeated LP'</span>);
0178     confgrps = cpxBuildConflict(n,m_lin,m_quad,m_sos,m_log,mode);
0179     prefix=pwd;
0180     suffix=<span class="string">'LP_CPLEX_conflict_file.txt'</span>;
0181     conflictFile=[prefix <span class="string">'\'</span> suffix];
0182 <span class="keyword">else</span>
0183     confgrps=[]; conflictFile=[];
0184 <span class="keyword">end</span>
0185 
0186 <span class="comment">%Name of file to write the CPLEX log information to. If empty, no log is</span>
0187 <span class="comment">%written.</span>
0188 logfile=[];
0189 
0190 <span class="comment">%Name of a file to save the CPLEX problem object (Used for submitting</span>
0191 <span class="comment">%possible bugs in CPLEX to ILOG)</span>
0192 savefile=[]; savemode=[];
0193 <span class="comment">% savefile='C:\CPLEX_possible_bug.txt';</span>
0194 
0195 <span class="comment">% vector defining which callbacks to use in CPLEX. If the ith entry of the logical vector</span>
0196 <span class="comment">% callback is set, the corresponding callback is defined. The callback calls the m-file specified</span>
0197 <span class="comment">% in Table 7 below. The user may edit this file, or make a new copy, which is put in a directory</span>
0198 <span class="comment">% that is searched before the cplex directory in the Matlab path.</span>
0199 callback=[]; <span class="comment">%I'm not really sure what this option means as yet</span>
0200 
0201 <span class="comment">%this is not a tomlab problem so this is not needed</span>
0202 Prob=[];
0203 
0204 <span class="comment">% variables not used in LP problems</span>
0205 IntVars=[]; PI=[]; SC=[]; SI=[]; sos1=[]; sos2=[];
0206 
0207 <span class="comment">%quadratic constraint matrix, size n x n</span>
0208 <span class="keyword">if</span> sum(minNorm)~=0
0209     <span class="keyword">if</span> length(minNorm)==1
0210         <span class="comment">% same weighting of min norm for all variables</span>
0211         F=speye(length(c))*minNorm;
0212     <span class="keyword">else</span>
0213         <span class="keyword">if</span> length(minNorm)~=length(c)
0214             error(<span class="string">'Either minNorm is a scalar, or is an n x 1 vector'</span>)
0215         <span class="keyword">else</span>
0216             <span class="comment">% individual weighting of min norm for all variables</span>
0217             F=spdiags(minNorm,0,length(c),length(c));
0218         <span class="keyword">end</span>
0219     <span class="keyword">end</span>
0220 <span class="keyword">else</span>
0221     F=[];
0222 <span class="keyword">end</span>
0223 <span class="comment">%Structure array defining quadratic constraints</span>
0224 qc=[];
0225 
0226 <span class="comment">%Structure telling whether and how you want CPLEX to perform a sensitivity analysis (SA).</span>
0227 <span class="comment">%This may be useful in future but probably will have more meaning with an</span>
0228 <span class="comment">%additional term in the objective</span>
0229 saRequest =[];
0230 
0231 <span class="comment">%Vector with MIP starting solution, if known</span>
0232 xIP=[];
0233 
0234 <span class="comment">%Logical constraints, i.e. an additional set of single-sided linear constraints that are controlled</span>
0235 <span class="comment">%by a binary variable (switch) in the problem</span>
0236 logcon=[];
0237    
0238 <span class="comment">%call cplex</span>
0239 tic;
0240 <span class="comment">%tic;</span>
0241 <span class="comment">%by default use the complex ILOG-CPLEX interface</span>
0242 ILOGcomplex=1;
0243 tomlab_cplex=1; <span class="comment">%by default use the tomlab_cplex interface</span>
0244 <span class="keyword">if</span> ~isempty(which(<span class="string">'cplexlp'</span>)) &amp;&amp; tomlab_cplex==0
0245     <span class="keyword">if</span> ILOGcomplex
0246         <span class="comment">%complex ibm ilog cplex interface</span>
0247         <span class="keyword">if</span> ~isempty(csense)
0248             <span class="comment">%set up constant vectors for CPLEX</span>
0249             b_L(csense == <span class="string">'E'</span>,1) = b(csense == <span class="string">'E'</span>);
0250             b_U(csense == <span class="string">'E'</span>,1) = b(csense == <span class="string">'E'</span>);
0251             b_L(csense == <span class="string">'G'</span>,1) = b(csense == <span class="string">'G'</span>);
0252             b_U(csense == <span class="string">'G'</span>,1) = Inf;
0253             b_L(csense == <span class="string">'L'</span>,1) = -Inf;
0254             b_U(csense == <span class="string">'L'</span>,1) = b(csense == <span class="string">'L'</span>);
0255         <span class="keyword">else</span>
0256             b_L = b;
0257             b_U = b;
0258         <span class="keyword">end</span>
0259 
0260         
0261         <span class="comment">% Initialize the CPLEX object</span>
0262         <span class="keyword">try</span>
0263             ILOGcplex = Cplex(<span class="string">'fba'</span>);
0264         <span class="keyword">catch</span> ME
0265             error(<span class="string">'CPLEX not installed or licence server not up'</span>)
0266         <span class="keyword">end</span>
0267 
0268         ILOGcplex.Model.sense = <span class="string">'minimize'</span>;
0269         
0270         <span class="comment">% Now populate the problem with the data</span>
0271         ILOGcplex.Model.obj   = c;
0272         ILOGcplex.Model.lb    = x_L;
0273         ILOGcplex.Model.ub    = x_U;
0274         ILOGcplex.Model.A     = LPProblem.A;
0275         ILOGcplex.Model.lhs   = b_L;
0276         ILOGcplex.Model.rhs   = b_U;
0277 
0278         <span class="keyword">if</span> ~isempty(F)
0279             <span class="comment">%quadratic constraint matrix, size n x n</span>
0280             ILOGcplex.Model.Q=F;
0281         <span class="keyword">end</span>
0282 
0283         <span class="keyword">if</span> ~isempty(cpxControl)
0284             <span class="keyword">if</span> isfield(cpxControl,<span class="string">'LPMETHOD'</span>)
0285                 <span class="comment">%set the solver</span>
0286                 ILOGcplex.Param.lpmethod.Cur=cpxControl.LPMETHOD;
0287             <span class="keyword">end</span>
0288         <span class="keyword">end</span>
0289         
0290         <span class="keyword">if</span> printLevel==0
0291             ILOGcplex.DisplayFunc=[];
0292         <span class="keyword">else</span>
0293             <span class="comment">%print level</span>
0294             ILOGcplex.Param.barrier.display.Cur = printLevel;
0295             ILOGcplex.Param.simplex.display.Cur = printLevel;
0296             ILOGcplex.Param.sifting.display.Cur = printLevel;
0297         <span class="keyword">end</span>
0298         
0299         <span class="comment">% Optimize the problem</span>
0300         ILOGcplex.solve();
0301 
0302         solution.obj        = osense*ILOGcplex.Solution.objval;
0303         solution.full       = ILOGcplex.Solution.x;
0304         solution.rcost      = ILOGcplex.Solution.reducedcost;
0305         solution.dual       = ILOGcplex.Solution.dual;
0306         solution.nInfeas    = NaN;
0307         solution.sumInfeas  = NaN;
0308         <span class="comment">%solution.stat       = ILOGcplex.Solution.</span>
0309         solution.origStat   = ILOGcplex.Solution.status;
0310         solution.solver     = ILOGcplex.Solution.method;
0311         solution.time       = ILOGcplex.Solution.time;
0312     <span class="keyword">else</span>
0313         <span class="keyword">try</span>
0314            ILOGcplex = Cplex(<span class="string">'fba'</span>);
0315         <span class="keyword">catch</span> ME
0316             error(<span class="string">'CPLEX not installed or licence server not up'</span>)
0317         <span class="keyword">end</span>
0318         <span class="comment">%simple ibm ilog cplex interface</span>
0319         options = cplexoptimset;
0320         <span class="keyword">switch</span> printLevel
0321             <span class="keyword">case</span> 0
0322                 options = cplexoptimset(options,<span class="string">'Display'</span>,<span class="string">'off'</span>);
0323             <span class="keyword">case</span> 1
0324                 options = cplexoptimset(options,<span class="string">'Display'</span>,<span class="string">'off'</span>);
0325                 <span class="keyword">case</span> 1
0326                 options = cplexoptimset(options,<span class="string">'Display'</span>,<span class="string">'off'</span>);
0327             <span class="keyword">case</span> 1
0328                 options = cplexoptimset(options,<span class="string">'Display'</span>,<span class="string">'off'</span>);
0329         <span class="keyword">end</span>
0330                 
0331         <span class="keyword">if</span> ~isempty(csense)
0332             <span class="keyword">if</span> sum(minNorm)~=0
0333                 Aineq = [LPProblem.A(csense == <span class="string">'L'</span>,:); - LPProblem.A(csense == <span class="string">'G'</span>,:)];
0334                 bineq = [b(csense == <span class="string">'L'</span>,:); - b(csense == <span class="string">'G'</span>,:)];
0335                 <span class="comment">%             min      0.5*x'*H*x+f*x or f*x</span>
0336                 <span class="comment">%             st.      Aineq*x     &lt;= bineq</span>
0337                 <span class="comment">%             Aeq*x    = beq</span>
0338                 <span class="comment">%             lb &lt;= x &lt;= ub</span>
0339                 [x,fval,exitflag,output,lambda] = cplexqp(F,c,Aineq,bineq,LPProblem.A(csense == <span class="string">'E'</span>,:),b(csense == <span class="string">'E'</span>,1),x_L,x_U,[],options);
0340             <span class="keyword">else</span>
0341                 Aineq = [LPProblem.A(csense == <span class="string">'L'</span>,:); - LPProblem.A(csense == <span class="string">'G'</span>,:)];
0342                 bineq = [b(csense == <span class="string">'L'</span>,:); - b(csense == <span class="string">'G'</span>,:)];
0343                 <span class="comment">%        min      c*x</span>
0344                 <span class="comment">%        st.      Aineq*x &lt;= bineq</span>
0345                 <span class="comment">%                 Aeq*x    = beq</span>
0346                 <span class="comment">%                 lb &lt;= x &lt;= ub</span>
0347                 [x,fval,exitflag,output,lambda] = cplexlp(c,Aineq,bineq,LPProblem.A(csense == <span class="string">'E'</span>,:),b(csense == <span class="string">'E'</span>,1),x_L,x_U,[],options);
0348             <span class="keyword">end</span>
0349             <span class="comment">%primal</span>
0350             solution.obj=osense*fval;
0351             solution.full=x;
0352             <span class="comment">%this is the dual to the equality constraints but it's not the chemical potential</span>
0353             solution.dual=lambda.eqlin;
0354         <span class="keyword">else</span>
0355             Aineq=[];
0356             bineq=[];
0357             <span class="keyword">if</span> sum(minNorm)~=0
0358                 [x,fval,exitflag,output,lambda] = cplexqp(F,c,Aineq,bineq,LPProblem.A,b,x_L,x_U,[],options);
0359             <span class="keyword">else</span>
0360                 [x,fval,exitflag,output,lambda] = cplexlp(c,Aineq,bineq,LPProblem.A,b,x_L,x_U,[],options);
0361             <span class="keyword">end</span>
0362             solution.obj=osense*fval;
0363             solution.full=x;
0364             <span class="comment">%this is the dual to the equality constraints but it's not the chemical potential</span>
0365             solution.dual=sparse(size(LPProblem.A,1),1);
0366             solution.dual(csense == <span class="string">'E'</span>)=lambda.eqlin;
0367             <span class="comment">%this is the dual to the inequality constraints but it's not the chemical potential</span>
0368             solution.dual(csense == <span class="string">'L'</span>)=lambda.ineqlin(1:nnz(csense == <span class="string">'L'</span>),1);
0369             solution.dual(csense == <span class="string">'G'</span>)=lambda.ineqlin(nnz(csense == <span class="string">'L'</span>)+1:<span class="keyword">end</span>,1);
0370         <span class="keyword">end</span>
0371         <span class="comment">%this is the dual to the simple ineequality constraints : reduced costs</span>
0372         solution.rcost=lambda.lower-lambda.upper;
0373         solution.nInfeas = [];
0374         solution.sumInfeas = [];
0375         solution.origStat = output.cplexstatus;
0376     <span class="keyword">end</span>
0377     <span class="comment">%1 = (Simplex or Barrier) Optimal solution is available.</span>
0378     Inform = solution.origStat;
0379     
0380 <span class="keyword">else</span>
0381     <span class="comment">%tomlab cplex interface</span>
0382     <span class="keyword">if</span> ~isempty(csense)
0383         <span class="comment">%set up constant vectors for CPLEX</span>
0384         b_L(csense == <span class="string">'E'</span>,1) = b(csense == <span class="string">'E'</span>);
0385         b_U(csense == <span class="string">'E'</span>,1) = b(csense == <span class="string">'E'</span>);
0386         b_L(csense == <span class="string">'G'</span>,1) = b(csense == <span class="string">'G'</span>);
0387         b_U(csense == <span class="string">'G'</span>,1) = Inf;
0388         b_L(csense == <span class="string">'L'</span>,1) = -Inf;
0389         b_U(csense == <span class="string">'L'</span>,1) = b(csense == <span class="string">'L'</span>);
0390     <span class="keyword">else</span>
0391         b_L = b;
0392         b_U = b;
0393     <span class="keyword">end</span>
0394 
0395     <span class="comment">%tomlab cplex interface</span>
0396     <span class="comment">%   minimize   0.5 * x'*F*x + c'x     subject to:</span>
0397     <span class="comment">%      x             x_L &lt;=    x   &lt;= x_U</span>
0398     <span class="comment">%                    b_L &lt;=   Ax   &lt;= b_U</span>
0399     [x, slack, v, rc, f_k, ninf, sinf, Inform, basis] = cplex(c, LPProblem.A, x_L, x_U, b_L, b_U, <span class="keyword">...</span>
0400         cpxControl, callback, printLevel, Prob, IntVars, PI, SC, SI, <span class="keyword">...</span>
0401         sos1, sos2, F, logfile, savefile, savemode, qc, <span class="keyword">...</span>
0402         confgrps, conflictFile, saRequest, basis, xIP, logcon);
0403 
0404     solution.full=x;
0405     <span class="comment">%this is the dual to the equality constraints but it's not the chemical potential</span>
0406     solution.dual=v;
0407     <span class="comment">%this is the dual to the simple ineequality constraints : reduced costs</span>
0408     solution.rcost=rc;
0409     <span class="keyword">if</span> Inform~=1
0410         solution.obj = NaN;
0411     <span class="keyword">else</span>
0412         <span class="keyword">if</span> minNorm==0
0413             solution.obj=f_k*osense;
0414         <span class="keyword">else</span>
0415             solution.obj=c'*x*osense;
0416         <span class="keyword">end</span>
0417         <span class="comment">%     solution.obj</span>
0418         <span class="comment">%     norm(x)</span>
0419     <span class="keyword">end</span>
0420     solution.nInfeas = ninf;
0421     solution.sumInfeas = sinf;
0422     solution.origStat = Inform;
0423 <span class="keyword">end</span>
0424 <span class="comment">%timeTaken=toc;</span>
0425 timeTaken=NaN;
0426 
0427 <span class="keyword">if</span> Inform~=1 &amp;&amp; ~isempty(which(<span class="string">'cplex'</span>))
0428     <span class="keyword">if</span> conflictResolve ==1
0429         <span class="keyword">if</span> isfield(LPProblem,<span class="string">'mets'</span>) &amp;&amp; isfield(LPProblem,<span class="string">'rxns'</span>)
0430             <span class="comment">%this code reads the conflict resolution file and replaces the</span>
0431             <span class="comment">%arbitrary names with the abbreviations of metabolites and reactions</span>
0432             [nMet,nRxn]=size(LPProblem.A);
0433             totAbbr=nMet+nRxn;
0434             conStrFind=cell(nMet+nRxn,1);
0435             conStrReplace=cell(nMet+nRxn,1);
0436             <span class="comment">%only equality constraint rows</span>
0437             <span class="keyword">for</span> m=1:nMet
0438                 conStrFind{m,1}=[<span class="string">'c'</span> int2str(m) <span class="string">':'</span>];
0439                 conStrReplace{m,1}=[LPProblem.mets{m} <span class="string">':  '</span>];
0440             <span class="keyword">end</span>
0441             <span class="comment">%reactions</span>
0442             <span class="keyword">for</span> n=1:nRxn
0443                 conStrFind{nMet+n,1}=[<span class="string">'x'</span> int2str(n) <span class="string">' '</span>];
0444                 conStrReplace{nMet+n,1}=[LPProblem.rxns{n} <span class="string">' '</span>];
0445             <span class="keyword">end</span>
0446             fid1 = fopen(suffix);
0447             fid2 = fopen([<span class="string">'COBRA_'</span> suffix], <span class="string">'w'</span>);
0448             <span class="keyword">while</span> ~feof(fid1)
0449                 tline{1}=fgetl(fid1);
0450                 <span class="comment">%replaces all occurrences of the string str2 within string str1</span>
0451                 <span class="comment">%with the string str3.</span>
0452                 <span class="comment">%str= strrep(str1, str2, str3)</span>
0453                 <span class="keyword">for</span> t=1:totAbbr
0454                     tline= strrep(tline, conStrFind{t}, conStrReplace{t});
0455                 <span class="keyword">end</span>
0456                 fprintf(fid2,<span class="string">'%s\n'</span>, tline{1});
0457             <span class="keyword">end</span>
0458             fclose(fid1);
0459             fclose(fid2);
0460             <span class="comment">%delete other file without replacements</span>
0461             <span class="comment">%         delete(suffix)</span>
0462         <span class="keyword">else</span>
0463             warning(<span class="string">'Need reaction and metabolite abbreviations in order to make a readable conflict resolution file'</span>);
0464         <span class="keyword">end</span>
0465         fprintf(<span class="string">'%s\n'</span>,[<span class="string">'Conflict resolution file written to: '</span> prefix <span class="string">'\COBRA_'</span> suffix]);
0466         fprintf(<span class="string">'%s\n%s\n'</span>,<span class="string">'The Conflict resolution file gives an irreducible infeasible subset '</span>,<span class="string">'of constraints which are making this LP Problem infeasible'</span>);
0467     <span class="keyword">else</span>
0468         <span class="keyword">if</span> printLevel&gt;0
0469             fprintf(<span class="string">'%s\n'</span>,<span class="string">'No conflict resolution file. Perhaps set conflictResolve = 1 next time.'</span>);
0470         <span class="keyword">end</span>
0471     <span class="keyword">end</span>
0472     solution.solver = <span class="string">'cplex_direct'</span>;
0473 <span class="keyword">end</span>
0474 
0475 <span class="comment">% Try to give back COBRA Standardized solver status:</span>
0476 <span class="comment">%           1   Optimal solution</span>
0477 <span class="comment">%           2   Unbounded solution</span>
0478 <span class="comment">%           0   Infeasible</span>
0479 <span class="comment">%           -1  No solution reported (timelimit, numerical problem etc)</span>
0480 <span class="keyword">if</span> Inform==1
0481     solution.stat = 1;
0482     <span class="keyword">if</span> printLevel&gt;0
0483     <span class="comment">%use tomlab code to print out exit meassage</span>
0484     [ExitText,ExitFlag] = cplexStatus(Inform);
0485     solution.ExitText=ExitText;
0486     solution.ExitFlag=ExitFlag;
0487     fprintf(<span class="string">'\n%s%g\n'</span>,[ExitText <span class="string">', Objective '</span>],  c'*solution.full*osense);
0488     <span class="keyword">end</span>
0489 <span class="keyword">else</span>
0490     <span class="keyword">if</span> Inform==2
0491         solution.stat = 2;
0492         <span class="comment">%use tomlab code to print out exit meassage</span>
0493         [ExitText,ExitFlag] = cplexStatus(Inform);
0494         solution.ExitText=ExitText;
0495         solution.ExitFlag=ExitFlag;
0496         fprintf(<span class="string">'\n%s%g\n'</span>,[ExitText <span class="string">', Objective '</span>],  c'*solution.full*osense);
0497     <span class="keyword">else</span>
0498         <span class="keyword">if</span> Inform==3
0499             solution.stat = 0;
0500         <span class="keyword">else</span>
0501             <span class="comment">%this is a conservative view</span>
0502             solution.stat = -1;
0503             <span class="comment">%use tomlab code to print out exit meassage</span>
0504             [ExitText,ExitFlag] = cplexStatus(Inform);
0505             solution.ExitText=ExitText;
0506             solution.ExitFlag=ExitFlag;
0507             fprintf(<span class="string">'\n%s%g\n'</span>,[ExitText <span class="string">', Objective '</span>],  c'*solution.full*osense);
0508         <span class="keyword">end</span>
0509     <span class="keyword">end</span>
0510 <span class="keyword">end</span>
0511 solution.time = timeTaken;
0512 
0513 <span class="comment">%return basis</span>
0514 <span class="keyword">if</span> basisReuse
0515     LPProblem.LPBasis=basis;
0516 <span class="keyword">end</span>
0517 
0518 <span class="keyword">if</span> sum(minNorm)~=0
0519     fprintf(<span class="string">'%s\n'</span>,<span class="string">'This objective corresponds to a flux with minimum Euclidean norm.'</span>);
0520     fprintf(<span class="string">'%s%d%s\n'</span>,<span class="string">'The weighting for minimising the norm was '</span>,minNorm,<span class="string">'.'</span>);
0521     fprintf(<span class="string">'%s\n'</span>,<span class="string">'Check that the objective is the same without minimising the norm.'</span>);
0522 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Jun-2012 15:39:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>