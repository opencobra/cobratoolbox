<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solveCobraLP</title>
  <meta name="keywords" content="solveCobraLP">
  <meta name="description" content="solveCobraLP Solve constraint-based LP problems">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html cobra --><!-- menu.html solvers -->
<h1>solveCobraLP
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>solveCobraLP Solve constraint-based LP problems</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function solution = solveCobraLP(LPproblem, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">solveCobraLP Solve constraint-based LP problems

 solution = solveCobraLP(LPproblem, parameters)

INPUT
 LPproblem Structure containing the following fields describing the LP
 problem to be solved
  A      LHS matrix
  b      RHS vector
  c      Objective coeff vector
  lb     Lower bound vector
  ub     Upper bound vector
  osense Objective sense (-1 max, +1 min)
  csense Constraint senses, a string containting the constraint sense for
         each row in A ('E', equality, 'G' greater than, 'L' less than).

OPTIONAL INPUTS
 Optional parameters can be entered using parameters structure or as
 parameter followed by parameter value: i.e. ,'printLevel',3)

 parameters    Structure containing optional parameters as fields.
               Setting parameters = 'default' uses default setting set in
               getCobraSolverParameters.
 printLevel    Printing level
               = 0    Silent (Default)
               = 1    Warnings and Errors
               = 2    Summary information 
               = 3    More detailed information
               &gt; 10   Pause statements, and maximal printing (debug mode)
 saveInput     Saves LPproblem to filename specified in field. 
               i.e. parameters.saveInput = 'LPproblem.mat';
 minNorm       {(0), scalar , n x 1 vector}, where [m,n]=size(S); 
               If not zero then, minimise the Euclidean length 
               of the solution to the LP problem. minNorm ~1e-6 should be
               high enough for regularisation yet maintain the same value for 
               the linear part of the objective. However, this should be
               checked on a case by case basis, by optimization with and
               without regularisation.
 primalOnly    {(0),1} 1=only return the primal vector (lindo solvers)
               
 optional parameters can also be set through the
 solver can be set through changeCobraSolver('LP', value);
 changeCobraSolverParames('LP', 'parameter', value) function.  This
 includes the minNorm and the printLevel flags

OUTPUT
 solution Structure containing the following fields describing a LP
 solution
  full     Full LP solution vector
  obj      Objective value
  rcost    Reduced costs
  dual     Dual solution
  solver   Solver used to solve LP problem

  stat     Solver status in standardized form
            1   Optimal solution
            2   Unbounded solution
            0   Infeasible
           -1   No solution reported (timelimit, numerical problem etc)

  origStat Original status returned by the specific solver
  time     Solve time in seconds


 Markus Herrgard    08/29/06
 Ronan Fleming      11/12/08 'cplex_direct' allows for more refined control
                             of cplex than tomlab tomrun
 Ronan Fleming      04/25/09 Option to minimise the Euclidean Norm of internal
                             fluxes using either 'cplex_direct' solver or 'pdco'
 Jan Schellenberger 09/28/09 Changed header to be much simpler.  All parameters
                             now accessed through 
                             changeCobraSolverParams(LP, parameter,value)
 Richard Que        11/30/09 Changed handling of optional parameters to use
                             getCobraSolverParams().
 Ronan Fleming      12/07/09 Commenting of input/output
 Ronan Fleming      21/01/10 Not having second input, means use the parameters as specified in the
                             global paramerer variable, rather than 'default' parameters
 Steinn Gudmundsson 03/03/10 Added support for the Gurobi solver
 Tim Harrington     05/18/12 Added support for the Gurobi 5.0 solver</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../cobra/external/BuildMPS/BuildMPS.html" class="code" title="function [Contain OK]=BuildMPS(A, b, Aeq, beq, cost, L, U, PbName, varargin)">BuildMPS</a>	</li><li><a href="getCobraSolverParams.html" class="code" title="function varargout = getCobraSolverParams(solverType, paramNames, parameters)">getCobraSolverParams</a>	This function gets the specified parameters in paramNames from</li><li><a href="lp_solve.html" class="code" title="function [obj, x, duals, stat] = lp_solve(f, a, b, e, vlb, vub, xint, scalemode, keep)">lp_solve</a>	LP_SOLVE  Solves mixed integer linear programming problems.</li><li><a href="solveCobraLPCPLEX.html" class="code" title="function [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)">solveCobraLPCPLEX</a>	[solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)</li><li><a href="solveCobraLPLindo.html" class="code" title="function [obj,x,y,w,s,solStatus] = solveCobraLPLindo(A,b,c,csense,lb,ub,osense,primalOnlyFlag,oldAPIFlag,verbLevel,method)">solveCobraLPLindo</a>	solveCobraLPLindo Solve a LP problem using Lindo</li><li><a href="../../cobra/tools/columnVector.html" class="code" title="function vec = columnVector(vec)">columnVector</a>	columnVector Converts a vector to a column vector</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../cobra/fluxVariability.html" class="code" title="function [minFlux,maxFlux,Vmin,Vmax] = fluxVariability(model,optPercentage,osenseStr,rxnNameList,verbFlag, allowLoops)">fluxVariability</a>	fluxVariability Performs flux variablity analysis</li><li><a href="../../cobra/fluxomics/C13ConfidenceInterval.html" class="code" title="function [vs, output, v0] = C13ConfidenceInterval(v0, expdata, model, max_score, directions, majorIterationLimit)">C13ConfidenceInterval</a>	v0 - set of flux vectors to be used as initial guesses.  They may be</li><li><a href="../../cobra/fluxomics/defineLinearConstraints.html" class="code" title="function [A, b_L, b_U, model] = defineLinearConstraints(model, method)">defineLinearConstraints</a>	</li><li><a href="../../cobra/geometricFBA.html" class="code" title="function flux = geometricFBA(model,varargin)">geometricFBA</a>	geometricFBA finds a unique optimal FBA solution that is (in some sense)</li><li><a href="../../cobra/linearMOMA.html" class="code" title="function [solutionDel,solutionWT,totalFluxDiff,solStatus] =linearMOMA(modelWT,modelDel,osenseStr,minFluxFlag,verbFlag)">linearMOMA</a>	linearMOMA Performs a linear version of the MOMA (minimization of</li><li><a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>	optimizeCbModel Solve a flux balance analysis problem</li><li><a href="../../cobra/optimizeTwoCbModels.html" class="code" title="function [solution1,solution2,totalFluxDiff] = optimizeTwoCbModels(model1,model2,osenseStr,minFluxFlag,verbFlag)">optimizeTwoCbModels</a>	optimizeTwoCbModels Simultaneously solve two flux balance problems and</li><li><a href="../../cobra/sampling/createHRWarmup.html" class="code" title="function warmupPts= createHRWarmup(model,nPoints,verbFlag,bias,nPointsCheck)">createHRWarmup</a>	createHRWarmup Create a warmup point set for hit-and-run sampling by</li><li><a href="../../cobra/sampling/gpSampler.html" class="code" title="function [sampleStructOut, mixedFrac] = gpSampler(sampleStruct, nPoints, bias, maxTime, maxSteps, threads, nPointsCheck)">gpSampler</a>	gpSampler Samples an arbitrary linearly constrained space using a fixed</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [x,f,y,w,stat,origStat] = solveGlpk(c,A,b,lb,ub,csense,osense,params)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function solution = solveCobraLP(LPproblem, varargin)</a>
0002 <span class="comment">%solveCobraLP Solve constraint-based LP problems</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% solution = solveCobraLP(LPproblem, parameters)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%INPUT</span>
0007 <span class="comment">% LPproblem Structure containing the following fields describing the LP</span>
0008 <span class="comment">% problem to be solved</span>
0009 <span class="comment">%  A      LHS matrix</span>
0010 <span class="comment">%  b      RHS vector</span>
0011 <span class="comment">%  c      Objective coeff vector</span>
0012 <span class="comment">%  lb     Lower bound vector</span>
0013 <span class="comment">%  ub     Upper bound vector</span>
0014 <span class="comment">%  osense Objective sense (-1 max, +1 min)</span>
0015 <span class="comment">%  csense Constraint senses, a string containting the constraint sense for</span>
0016 <span class="comment">%         each row in A ('E', equality, 'G' greater than, 'L' less than).</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%OPTIONAL INPUTS</span>
0019 <span class="comment">% Optional parameters can be entered using parameters structure or as</span>
0020 <span class="comment">% parameter followed by parameter value: i.e. ,'printLevel',3)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% parameters    Structure containing optional parameters as fields.</span>
0023 <span class="comment">%               Setting parameters = 'default' uses default setting set in</span>
0024 <span class="comment">%               getCobraSolverParameters.</span>
0025 <span class="comment">% printLevel    Printing level</span>
0026 <span class="comment">%               = 0    Silent (Default)</span>
0027 <span class="comment">%               = 1    Warnings and Errors</span>
0028 <span class="comment">%               = 2    Summary information</span>
0029 <span class="comment">%               = 3    More detailed information</span>
0030 <span class="comment">%               &gt; 10   Pause statements, and maximal printing (debug mode)</span>
0031 <span class="comment">% saveInput     Saves LPproblem to filename specified in field.</span>
0032 <span class="comment">%               i.e. parameters.saveInput = 'LPproblem.mat';</span>
0033 <span class="comment">% minNorm       {(0), scalar , n x 1 vector}, where [m,n]=size(S);</span>
0034 <span class="comment">%               If not zero then, minimise the Euclidean length</span>
0035 <span class="comment">%               of the solution to the LP problem. minNorm ~1e-6 should be</span>
0036 <span class="comment">%               high enough for regularisation yet maintain the same value for</span>
0037 <span class="comment">%               the linear part of the objective. However, this should be</span>
0038 <span class="comment">%               checked on a case by case basis, by optimization with and</span>
0039 <span class="comment">%               without regularisation.</span>
0040 <span class="comment">% primalOnly    {(0),1} 1=only return the primal vector (lindo solvers)</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% optional parameters can also be set through the</span>
0043 <span class="comment">% solver can be set through changeCobraSolver('LP', value);</span>
0044 <span class="comment">% changeCobraSolverParames('LP', 'parameter', value) function.  This</span>
0045 <span class="comment">% includes the minNorm and the printLevel flags</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%OUTPUT</span>
0048 <span class="comment">% solution Structure containing the following fields describing a LP</span>
0049 <span class="comment">% solution</span>
0050 <span class="comment">%  full     Full LP solution vector</span>
0051 <span class="comment">%  obj      Objective value</span>
0052 <span class="comment">%  rcost    Reduced costs</span>
0053 <span class="comment">%  dual     Dual solution</span>
0054 <span class="comment">%  solver   Solver used to solve LP problem</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%  stat     Solver status in standardized form</span>
0057 <span class="comment">%            1   Optimal solution</span>
0058 <span class="comment">%            2   Unbounded solution</span>
0059 <span class="comment">%            0   Infeasible</span>
0060 <span class="comment">%           -1   No solution reported (timelimit, numerical problem etc)</span>
0061 <span class="comment">%</span>
0062 <span class="comment">%  origStat Original status returned by the specific solver</span>
0063 <span class="comment">%  time     Solve time in seconds</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% Markus Herrgard    08/29/06</span>
0067 <span class="comment">% Ronan Fleming      11/12/08 'cplex_direct' allows for more refined control</span>
0068 <span class="comment">%                             of cplex than tomlab tomrun</span>
0069 <span class="comment">% Ronan Fleming      04/25/09 Option to minimise the Euclidean Norm of internal</span>
0070 <span class="comment">%                             fluxes using either 'cplex_direct' solver or 'pdco'</span>
0071 <span class="comment">% Jan Schellenberger 09/28/09 Changed header to be much simpler.  All parameters</span>
0072 <span class="comment">%                             now accessed through</span>
0073 <span class="comment">%                             changeCobraSolverParams(LP, parameter,value)</span>
0074 <span class="comment">% Richard Que        11/30/09 Changed handling of optional parameters to use</span>
0075 <span class="comment">%                             getCobraSolverParams().</span>
0076 <span class="comment">% Ronan Fleming      12/07/09 Commenting of input/output</span>
0077 <span class="comment">% Ronan Fleming      21/01/10 Not having second input, means use the parameters as specified in the</span>
0078 <span class="comment">%                             global paramerer variable, rather than 'default' parameters</span>
0079 <span class="comment">% Steinn Gudmundsson 03/03/10 Added support for the Gurobi solver</span>
0080 <span class="comment">% Tim Harrington     05/18/12 Added support for the Gurobi 5.0 solver</span>
0081 
0082 
0083 <span class="comment">%% Process arguments etc</span>
0084 
0085 <span class="keyword">global</span> CBTLPSOLVER
0086 <span class="keyword">if</span> (~isempty(CBTLPSOLVER))
0087     solver = CBTLPSOLVER;
0088 <span class="keyword">else</span>
0089     error(<span class="string">'No solver found.  call changeCobraSolver(solverName)'</span>);
0090 <span class="keyword">end</span>
0091 optParamNames = {<span class="string">'minNorm'</span>,<span class="string">'printLevel'</span>,<span class="string">'primalOnly'</span>,<span class="string">'saveInput'</span>, <span class="keyword">...</span>
0092     <span class="string">'feasTol'</span>,<span class="string">'optTol'</span>,<span class="string">'EleNames'</span>,<span class="string">'EqtNames'</span>,<span class="string">'VarNames'</span>,<span class="string">'EleNameFun'</span>, <span class="keyword">...</span>
0093     <span class="string">'EqtNameFun'</span>,<span class="string">'VarNameFun'</span>,<span class="string">'PbName'</span>,<span class="string">'MPSfilename'</span>};
0094 parameters = <span class="string">''</span>;
0095 <span class="keyword">if</span> nargin ~=1
0096     <span class="keyword">if</span> mod(length(varargin),2)==0
0097         <span class="keyword">for</span> i=1:2:length(varargin)-1
0098             <span class="keyword">if</span> ismember(varargin{i},optParamNames)
0099                 parameters.(varargin{i}) = varargin{i+1};
0100             <span class="keyword">else</span>
0101                 error([varargin{i} <span class="string">' is not a valid optional parameter'</span>]);
0102             <span class="keyword">end</span>
0103         <span class="keyword">end</span>
0104     <span class="keyword">elseif</span> strcmp(varargin{1},<span class="string">'default'</span>)
0105         parameters = <span class="string">'default'</span>;
0106     <span class="keyword">elseif</span> isstruct(varargin{1})
0107         parameters = varargin{1};
0108     <span class="keyword">else</span>
0109         display(<span class="string">'Warning: Invalid number of parameters/values'</span>)
0110         solution=[];
0111         <span class="keyword">return</span>;
0112     <span class="keyword">end</span>
0113 <span class="keyword">end</span>
0114 [minNorm, printLevel, primalOnlyFlag, saveInput, feasTol, optTol] = <span class="keyword">...</span>
0115     <a href="getCobraSolverParams.html" class="code" title="function varargout = getCobraSolverParams(solverType, paramNames, parameters)">getCobraSolverParams</a>(<span class="string">'LP'</span>,optParamNames(1:6),parameters);
0116 
0117 
0118 <span class="comment">%Save Input if selected</span>
0119 <span class="keyword">if</span> ~isempty(saveInput)
0120     fileName = parameters.saveInput;
0121     <span class="keyword">if</span> ~find(regexp(fileName,<span class="string">'.mat'</span>))
0122         fileName = [fileName <span class="string">'.mat'</span>];
0123     <span class="keyword">end</span>
0124     display([<span class="string">'Saving LPproblem in '</span> fileName]);
0125     save(fileName,<span class="string">'LPproblem'</span>)
0126 <span class="keyword">end</span>
0127 
0128 
0129 [A,b,c,lb,ub,csense,osense] = deal(LPproblem.A,LPproblem.b,LPproblem.c,LPproblem.lb,LPproblem.ub,LPproblem.csense,LPproblem.osense);
0130 
0131 <span class="comment">% if any(any(~isfinite(A)))</span>
0132 <span class="comment">%     error('Cannot perform LP on a stoichiometric matrix with NaN of Inf coefficents.')</span>
0133 <span class="comment">% end</span>
0134 
0135 <span class="comment">% Defaults in case the solver does not return anything</span>
0136 f = [];
0137 x = [];
0138 y = [];
0139 w = [];
0140 origStat = -99;
0141 stat = -99;
0142 
0143 t_start = clock;
0144 <span class="keyword">switch</span> solver
0145     <span class="comment">%% GLPK</span>
0146     <span class="keyword">case</span> <span class="string">'glpk'</span>
0147         params.msglev = printLevel; <span class="comment">% level of verbosity</span>
0148         params.tolbnd = feasTol; <span class="comment">%tolerance</span>
0149         params.toldj = optTol; <span class="comment">%tolerance</span>
0150         <span class="keyword">if</span> (isempty(csense))
0151             clear csense
0152             csense(1:length(b),1) = <span class="string">'S'</span>;
0153         <span class="keyword">else</span>
0154             csense(csense == <span class="string">'L'</span>) = <span class="string">'U'</span>;
0155             csense(csense == <span class="string">'G'</span>) = <span class="string">'L'</span>;
0156             csense(csense == <span class="string">'E'</span>) = <span class="string">'S'</span>;
0157             csense = <a href="../../cobra/tools/columnVector.html" class="code" title="function vec = columnVector(vec)">columnVector</a>(csense);
0158         <span class="keyword">end</span>
0159         <span class="comment">%glpk needs b to be full, not sparse -Ronan</span>
0160         b=full(b);
0161         [x,f,y,w,stat,origStat] = <a href="#_sub1" class="code" title="subfunction [x,f,y,w,stat,origStat] = solveGlpk(c,A,b,lb,ub,csense,osense,params)">solveGlpk</a>(c,A,b,lb,ub,csense,osense,params);
0162 
0163     <span class="keyword">case</span> {<span class="string">'lindo_new'</span>,<span class="string">'lindo_old'</span>}
0164         <span class="comment">%% LINDO</span>
0165         <span class="keyword">if</span> (strcmp(solver,<span class="string">'lindo_new'</span>))
0166             <span class="comment">% Use new API (&gt;= 2.0)</span>
0167             [f,x,y,w,s,origStat] = <a href="solveCobraLPLindo.html" class="code" title="function [obj,x,y,w,s,solStatus] = solveCobraLPLindo(A,b,c,csense,lb,ub,osense,primalOnlyFlag,oldAPIFlag,verbLevel,method)">solveCobraLPLindo</a>(A,b,c,csense,lb,ub,osense,primalOnlyFlag,false);
0168             <span class="comment">% Note that status handling may change (see Lindo.h)</span>
0169             <span class="keyword">if</span> (origStat == 1 || origStat == 2)
0170                 stat = 1; <span class="comment">% Optimal solution found</span>
0171             <span class="keyword">elseif</span> (origStat == 4)
0172                 stat = 2; <span class="comment">% Unbounded</span>
0173             <span class="keyword">elseif</span> (origStat == 3 || origStat == 6)
0174                 stat = 0; <span class="comment">% Infeasible</span>
0175             <span class="keyword">else</span>
0176                 stat = -1; <span class="comment">% Solution not optimal or solver problem</span>
0177             <span class="keyword">end</span>
0178         <span class="keyword">else</span>
0179             <span class="comment">% Use old API</span>
0180             [f,x,y,w,s,origStat] = <a href="solveCobraLPLindo.html" class="code" title="function [obj,x,y,w,s,solStatus] = solveCobraLPLindo(A,b,c,csense,lb,ub,osense,primalOnlyFlag,oldAPIFlag,verbLevel,method)">solveCobraLPLindo</a>(A,b,c,csense,lb,ub,osense,primalOnlyFlag,true);
0181             <span class="comment">% Note that status handling may change (see Lindo.h)</span>
0182             <span class="keyword">if</span> (origStat == 2 || origStat == 3)
0183                 stat = 1; <span class="comment">% Optimal solution found</span>
0184             <span class="keyword">elseif</span> (origStat == 5)
0185                 stat = 2; <span class="comment">% Unbounded</span>
0186             <span class="keyword">elseif</span> (origStat == 4 || origStat == 6)
0187                 stat = 0; <span class="comment">% Infeasible</span>
0188             <span class="keyword">else</span>
0189                 stat = -1; <span class="comment">% Solution not optimal or solver problem</span>
0190             <span class="keyword">end</span>
0191         <span class="keyword">end</span>
0192         <span class="comment">%[f,x,y,s,w,stat] = LMSolveLPNew(A,b,c,csense,lb,ub,osense,0);</span>
0193 
0194     <span class="keyword">case</span> <span class="string">'lp_solve'</span>
0195         <span class="comment">%% lp_solve</span>
0196         <span class="keyword">if</span> (isempty(csense))
0197             [f,x,y,origStat] = <a href="lp_solve.html" class="code" title="function [obj, x, duals, stat] = lp_solve(f, a, b, e, vlb, vub, xint, scalemode, keep)">lp_solve</a>(c*(-osense),A,b,zeros(size(A,1),1),lb,ub);
0198             f = f*(-osense);
0199         <span class="keyword">else</span>
0200             e(csense == <span class="string">'E'</span>) = 0;
0201             e(csense == <span class="string">'G'</span>) = 1;
0202             e(csense == <span class="string">'L'</span>) = -1;
0203             [f,x,y,origStat] = <a href="lp_solve.html" class="code" title="function [obj, x, duals, stat] = lp_solve(f, a, b, e, vlb, vub, xint, scalemode, keep)">lp_solve</a>(c*(-osense),A,b,e,lb,ub);
0204             f = f*(-osense);
0205         <span class="keyword">end</span>
0206         <span class="comment">% Note that status handling may change (see lp_lib.h)</span>
0207         <span class="keyword">if</span> (origStat == 0)
0208             stat = 1; <span class="comment">% Optimal solution found</span>
0209         <span class="keyword">elseif</span> (origStat == 3)
0210             stat = 2; <span class="comment">% Unbounded</span>
0211         <span class="keyword">elseif</span> (origStat == 2)
0212             stat = 0; <span class="comment">% Infeasible</span>
0213         <span class="keyword">else</span>
0214             stat = -1; <span class="comment">% Solution not optimal or solver problem</span>
0215         <span class="keyword">end</span>
0216         s = [];
0217         w = [];
0218     <span class="keyword">case</span> <span class="string">'mosek'</span>
0219         <span class="comment">%% mosek</span>
0220         <span class="comment">%if mosek is installed, and the paths are added ahead of matlab's</span>
0221         <span class="comment">%built in paths, then mosek linprog shaddows matlab linprog and</span>
0222         <span class="comment">%is used preferentially</span>
0223         <span class="keyword">switch</span> printLevel
0224             <span class="keyword">case</span> 0
0225                options.Display=<span class="string">'off'</span>;
0226             <span class="keyword">case</span> 1
0227                 options.Display=<span class="string">'final'</span>;
0228             <span class="keyword">case</span> 2
0229                 options.Display=<span class="string">'iter'</span>;
0230             <span class="keyword">otherwise</span>
0231                 <span class="comment">% Ask for default options for a function.</span>
0232                 options  = optimset;
0233         <span class="keyword">end</span>
0234                      
0235         <span class="keyword">if</span> (isempty(csense))
0236             [x,f,origStat,output,lambda] = linprog(c*osense,[],[],A,b,lb,ub,[],options);
0237         <span class="keyword">else</span>
0238             Aeq = A(csense == <span class="string">'E'</span>,:);
0239             beq = b(csense == <span class="string">'E'</span>);
0240             Ag = A(csense == <span class="string">'G'</span>,:);
0241             bg = b(csense == <span class="string">'G'</span>);
0242             Al = A(csense == <span class="string">'L'</span>,:);
0243             bl = b(csense == <span class="string">'L'</span>);
0244             clear A;
0245             A = [Al;-Ag];
0246             clear b;
0247             b = [bl;-bg];
0248             [x,f,origStat,output,lambda] = linprog(c*osense,A,b,Aeq,beq,lb,ub,[],options);
0249         <span class="keyword">end</span>
0250         y = [];
0251         <span class="keyword">if</span> (origStat &gt; 0)
0252             stat = 1; <span class="comment">% Optimal solution found</span>
0253             f = f*osense;
0254             y = lambda.eqlin;
0255         <span class="keyword">elseif</span> (origStat &lt; 0)
0256             stat = 0; <span class="comment">% Infeasible</span>
0257         <span class="keyword">else</span>
0258             stat = -1; <span class="comment">% Solution did not converge</span>
0259         <span class="keyword">end</span>
0260         
0261     <span class="keyword">case</span> <span class="string">'gurobi'</span>
0262         <span class="comment">%% gurobi</span>
0263         <span class="comment">% Free academic licenses for the Gurobi solver can be obtained from</span>
0264         <span class="comment">% http://www.gurobi.com/html/academic.html</span>
0265         <span class="comment">%</span>
0266         <span class="comment">% The code below uses Gurobi Mex to interface with Gurobi. It can be downloaded from</span>
0267         <span class="comment">% http://www.convexoptimization.com/wikimization/index.php/Gurobi_Mex:_A_MATLAB_interface_for_Gurobi</span>
0268 
0269         clear opts            <span class="comment">% Use the default parameter settings</span>
0270         <span class="keyword">if</span> printLevel == 0
0271            <span class="comment">% Version v1.10 of Gurobi Mex has a minor bug. For complete silence</span>
0272            <span class="comment">% Remove Line 736 of gurobi_mex.c: mexPrintf(&quot;\n&quot;);</span>
0273            opts.Display = 0;
0274            opts.DisplayInterval = 0;
0275         <span class="keyword">else</span>
0276            opts.Display = 1;
0277         <span class="keyword">end</span>
0278 
0279         opts.FeasibilityTol = feasTol;
0280         opts.OptimalityTol = optTol;
0281         
0282         <span class="keyword">if</span> (isempty(csense))
0283             clear csense
0284             csense(1:length(b),1) = <span class="string">'='</span>;
0285         <span class="keyword">else</span>
0286             csense(csense == <span class="string">'L'</span>) = <span class="string">'&lt;'</span>;
0287             csense(csense == <span class="string">'G'</span>) = <span class="string">'&gt;'</span>;
0288             csense(csense == <span class="string">'E'</span>) = <span class="string">'='</span>;
0289             csense = csense(:);
0290         <span class="keyword">end</span>
0291     <span class="comment">%gurobi_mex doesn't cast logicals to doubles automatically</span>
0292     c = double(c);
0293         [x,f,origStat,output,y] = gurobi_mex(c,osense,sparse(A),b, <span class="keyword">...</span>
0294                                              csense,lb,ub,[],opts);
0295         <span class="keyword">if</span> origStat==2
0296            stat = 1; <span class="comment">% Optimal solutuion found</span>
0297         <span class="keyword">elseif</span> origStat==3
0298            stat = 0; <span class="comment">% Infeasible</span>
0299         <span class="keyword">elseif</span> origStat==5
0300            stat = 2; <span class="comment">% Unbounded</span>
0301         <span class="keyword">elseif</span> origStat==4
0302            stat = 0; <span class="comment">% Gurobi reports infeasible *or* unbounded</span>
0303         <span class="keyword">else</span>
0304            stat = -1; <span class="comment">% Solution not optimal or solver problem</span>
0305         <span class="keyword">end</span>
0306         
0307     <span class="keyword">case</span> <span class="string">'gurobi5'</span>
0308         <span class="comment">%% gurobi 5</span>
0309         <span class="comment">% Free academic licenses for the Gurobi solver can be obtained from</span>
0310         <span class="comment">% http://www.gurobi.com/html/academic.html</span>
0311         resultgurobi = struct(<span class="string">'x'</span>,[],<span class="string">'objval'</span>,[],<span class="string">'pi'</span>,[]);
0312         LPproblem.A = deal(sparse(LPproblem.A));
0313         clear params            <span class="comment">% Use the default parameter settings</span>
0314         
0315         <span class="keyword">if</span> printLevel == 0 
0316            params.OutputFlag = 0;
0317            params.DisplayInterval = 1;
0318         <span class="keyword">else</span>
0319            params.OutputFlag = 1;
0320            params.DisplayInterval = 5;
0321         <span class="keyword">end</span>
0322 
0323         params.FeasibilityTol = feasTol;
0324         params.OptimalityTol = optTol;
0325         
0326         <span class="keyword">if</span> (isempty(LPproblem.csense))
0327             clear LPproblem.csense
0328             LPproblem.csense(1:length(b),1) = <span class="string">'='</span>;
0329         <span class="keyword">else</span>
0330             LPproblem.csense(LPproblem.csense == <span class="string">'L'</span>) = <span class="string">'&lt;'</span>;
0331             LPproblem.csense(LPproblem.csense == <span class="string">'G'</span>) = <span class="string">'&gt;'</span>;
0332             LPproblem.csense(LPproblem.csense == <span class="string">'E'</span>) = <span class="string">'='</span>;
0333             LPproblem.csense = LPproblem.csense(:);
0334         <span class="keyword">end</span>
0335     
0336         <span class="keyword">if</span> LPproblem.osense == -1
0337             LPproblem.osense = <span class="string">'max'</span>;
0338         <span class="keyword">else</span>
0339             LPproblem.osense = <span class="string">'min'</span>;
0340         <span class="keyword">end</span>
0341         
0342         LPproblem.modelsense = LPproblem.osense;
0343         [LPproblem.rhs,LPproblem.obj,LPproblem.sense] = deal(LPproblem.b,double(LPproblem.c),LPproblem.csense);
0344         resultgurobi = gurobi(LPproblem,params);
0345         
0346         <span class="keyword">if</span> strcmp(resultgurobi.status,<span class="string">'OPTIMAL'</span>)
0347            stat = 1; <span class="comment">% Optimal solution found</span>
0348            [x,f,y] = deal(resultgurobi.x,resultgurobi.objval,resultgurobi.pi);
0349         <span class="keyword">elseif</span> strcmp(resultgurobi.status,<span class="string">'INFEASIBLE'</span>)
0350            stat = 0; <span class="comment">% Infeasible</span>
0351         <span class="keyword">elseif</span> strcmp(resultgurobi.status,<span class="string">'UNBOUNDED'</span>)
0352            stat = 2; <span class="comment">% Unbounded</span>
0353         <span class="keyword">elseif</span> strcmp(resultgurobi.status,<span class="string">'INF_OR_UNBD'</span>)
0354            stat = 0; <span class="comment">% Gurobi reports infeasible *or* unbounded</span>
0355         <span class="keyword">else</span>
0356            stat = -1; <span class="comment">% Solution not optimal or solver problem</span>
0357         <span class="keyword">end</span>
0358         
0359     <span class="keyword">case</span> <span class="string">'matlab'</span>
0360         <span class="comment">%matlab is not a reliable LP solver</span>
0361         <span class="keyword">if</span> (isempty(csense))
0362             [x,f,origStat,output,lambda] = linprog(c*osense,[],[],A,b,lb,ub);
0363         <span class="keyword">else</span>
0364             Aeq = A(csense == <span class="string">'E'</span>,:);
0365             beq = b(csense == <span class="string">'E'</span>);
0366             Ag = A(csense == <span class="string">'G'</span>,:);
0367             bg = b(csense == <span class="string">'G'</span>);
0368             Al = A(csense == <span class="string">'L'</span>,:);
0369             bl = b(csense == <span class="string">'L'</span>);
0370             clear A;
0371             A = [Al;-Ag];
0372             clear b;
0373             b = [bl;-bg];
0374             [x,f,origStat,output,lambda] = linprog(c*osense,A,b,Aeq,beq,lb,ub);
0375         <span class="keyword">end</span>
0376         y = [];
0377         <span class="keyword">if</span> (origStat &gt; 0)
0378             stat = 1; <span class="comment">% Optimal solution found</span>
0379             f = f*osense;
0380             y = lambda.eqlin;
0381         <span class="keyword">elseif</span> (origStat &lt; 0)
0382             stat = 0; <span class="comment">% Infeasible</span>
0383         <span class="keyword">else</span>
0384             stat = -1; <span class="comment">% Solution did not converge</span>
0385         <span class="keyword">end</span>
0386 
0387     <span class="keyword">case</span> <span class="string">'tomlab_cplex'</span>
0388         <span class="comment">%% Tomlab</span>
0389         <span class="keyword">if</span> (~isempty(csense))
0390             b_L(csense == <span class="string">'E'</span>) = b(csense == <span class="string">'E'</span>);
0391             b_U(csense == <span class="string">'E'</span>) = b(csense == <span class="string">'E'</span>);
0392             b_L(csense == <span class="string">'G'</span>) = b(csense == <span class="string">'G'</span>);
0393             b_U(csense == <span class="string">'G'</span>) = 1e6;
0394             b_L(csense == <span class="string">'L'</span>) = -1e6;
0395             b_U(csense == <span class="string">'L'</span>) = b(csense == <span class="string">'L'</span>);
0396         <span class="keyword">else</span>
0397             b_L = b;
0398             b_U = b;
0399         <span class="keyword">end</span>
0400         tomlabProblem = lpAssign(osense*c,A,b_L,b_U,lb,ub);
0401         <span class="comment">%Result = tomRun('cplex', tomlabProblem, 0);</span>
0402         <span class="comment">% This is faster than using tomRun</span>
0403         
0404         <span class="comment">%set parameters</span>
0405         tomlabProblem.optParam = optParamDef(<span class="string">'cplex'</span>,tomlabProblem.probType);
0406         tomlabProblem.QP.F = [];
0407         tomlabProblem.PriLevOpt = printLevel;
0408         
0409         <span class="comment">%if basis is availible use it</span>
0410         <span class="keyword">if</span> isfield(LPproblem,<span class="string">'basis'</span>) &amp;&amp; ~isempty(LPproblem.basis)
0411             tomlabProblem.MIP.basis = LPproblem.basis;
0412         <span class="keyword">end</span>
0413         
0414         <span class="comment">%set tolerance</span>
0415         tomlabProblem.MIP.cpxControl.EPRHS = feasTol;
0416         tomlabProblem.MIP.cpxControl.EPOPT = optTol;
0417         
0418         <span class="comment">%solve</span>
0419         Result = cplexTL(tomlabProblem);
0420 
0421         <span class="comment">% Assign results</span>
0422         x = Result.x_k;
0423         f = osense*sum(tomlabProblem.QP.c.*Result.x_k);
0424         <span class="comment">%        [Result.f_k f]</span>
0425 
0426         origStat = Result.Inform;
0427         w = Result.v_k(1:length(lb));
0428         y = Result.v_k((length(lb)+1):end);
0429         basis = Result.MIP.basis;
0430         <span class="keyword">if</span> (origStat == 1)
0431             stat = 1;
0432         <span class="keyword">elseif</span> (origStat == 3)
0433             stat = 0;
0434         <span class="keyword">elseif</span> (origStat == 2 || origStat == 4)
0435             stat = 2;
0436         <span class="keyword">else</span>
0437             stat = -1;
0438         <span class="keyword">end</span>
0439     <span class="keyword">case</span> <span class="string">'cplex_direct'</span>
0440         <span class="comment">%% Tomlab cplex.m direct</span>
0441         <span class="comment">%Used with the current script, only some of the control affoarded with</span>
0442         <span class="comment">%this interface is provided. Primarily, this is to change the print</span>
0443         <span class="comment">%level and whether to minimise the Euclidean Norm of the internal</span>
0444         <span class="comment">%fluxes or not.</span>
0445         <span class="comment">%See solveCobraLPCPLEX.m for more refined control of cplex</span>
0446         <span class="comment">%Ronan Fleming 11/12/2008</span>
0447         <span class="keyword">if</span> isfield(LPproblem,<span class="string">'basis'</span>) &amp;&amp; ~isempty(LPproblem.basis)
0448             LPproblem.LPBasis = LPproblem.basis;
0449         <span class="keyword">end</span>
0450         [solution LPprob] = <a href="solveCobraLPCPLEX.html" class="code" title="function [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)">solveCobraLPCPLEX</a>(LPproblem,printLevel,1,[],[],minNorm);
0451         solution.basis = LPprob.LPBasis;
0452         solution.solver = solver;
0453 
0454     <span class="keyword">case</span> <span class="string">'lindo'</span>
0455         error(<span class="string">'Solver type lindo is obsolete - use lindo_new or lindo_old instead'</span>);
0456     <span class="keyword">case</span> <span class="string">'pdco'</span>
0457         <span class="comment">%-----------------------------------------------------------------------</span>
0458         <span class="comment">% pdco.m: Primal-Dual Barrier Method for Convex Objectives (16 Dec 2008)</span>
0459         <span class="comment">%-----------------------------------------------------------------------</span>
0460         <span class="comment">% AUTHOR:</span>
0461         <span class="comment">%    Michael Saunders, Systems Optimization Laboratory (SOL),</span>
0462         <span class="comment">%    Stanford University, Stanford, California, USA.</span>
0463         <span class="comment">%Interfaced with Cobra toolbox by Ronan Fleming, 27 June 2009</span>
0464         [nMet,nRxn]=size(LPproblem.A);
0465         x0 = ones(nRxn,1);
0466         y0 = ones(nMet,1);
0467         z0 = ones(nRxn,1);
0468  
0469         <span class="comment">%setting d1 to zero is dangerous numerically, but is necessary to avoid</span>
0470         <span class="comment">%minimising the Euclidean norm of the optimal flux. A more</span>
0471         <span class="comment">%numerically stable way is to use pdco via solveCobraQP, which has</span>
0472         <span class="comment">%a more reasonable d1 and should be more numerically robust. -Ronan</span>
0473         d1=0; 
0474         d2=1e-6;
0475         options = pdcoSet;
0476         options.FeaTol    = 1e-12;
0477         options.OptTol    = 1e-12;
0478         <span class="comment">%pdco is a general purpose convex optization solver, not only a</span>
0479         <span class="comment">%linear optimization solver. As such, much control over the optimal</span>
0480         <span class="comment">%solution and the method for solution is available. However, this</span>
0481         <span class="comment">%also means you may have to tune the various parameters here,</span>
0482         <span class="comment">%especially xsize and zsize (see pdco.m) to get the real optimal</span>
0483         <span class="comment">%objective value</span>
0484         xsize = 1000;
0485         zsize = 10000;
0486         
0487         options.Method=2; <span class="comment">%QR</span>
0488         options.MaxIter=100;
0489         options.Print=printLevel;
0490         [x,y,w,inform,PDitns,CGitns,time] = <span class="keyword">...</span>
0491             pdco(osense*c*10000,A,b,lb,ub,d1,d2,options,x0,y0,z0,xsize,zsize);
0492         f= c'*x;
0493         <span class="comment">% inform = 0 if a solution is found;</span>
0494 <span class="comment">%        = 1 if too many iterations were required;</span>
0495 <span class="comment">%        = 2 if the linesearch failed too often;</span>
0496 <span class="comment">%        = 3 if the step lengths became too small;</span>
0497 <span class="comment">%        = 4 if Cholesky said ADDA was not positive definite.</span>
0498         <span class="keyword">if</span> (inform == 0)
0499             stat = 1;
0500         <span class="keyword">elseif</span> (inform == 1 || inform == 2 || inform == 3)
0501             stat = 0;
0502         <span class="keyword">else</span>
0503             stat = -1;
0504         <span class="keyword">end</span>
0505         origStat=inform;
0506     <span class="keyword">case</span> <span class="string">'mps'</span>
0507         <span class="comment">%% BuildMPS</span>
0508         <span class="comment">% This calls buildMPS and generates a MPS format description of the</span>
0509         <span class="comment">% problem as the result</span>
0510         <span class="comment">% Build MPS Author: Bruno Luong</span>
0511         <span class="comment">% Interfaced with CobraToolbox by Richard Que (12/18/09)</span>
0512         display(<span class="string">'Solver set to MPS. This function will output an MPS matrix string for the LP problem'</span>);
0513         <span class="comment">%Get optional parameters</span>
0514         [EleNames,EqtNames,VarNames,EleNameFun,EqtNameFun,VarNameFun,PbName,MPSfilename] = <span class="keyword">...</span>
0515             <a href="getCobraSolverParams.html" class="code" title="function varargout = getCobraSolverParams(solverType, paramNames, parameters)">getCobraSolverParams</a>(<span class="string">'LP'</span>,{<span class="string">'EleNames'</span>,<span class="string">'EqtNames'</span>,<span class="string">'VarNames'</span>,<span class="string">'EleNameFun'</span>,<span class="string">'EqtNameFun'</span>,<span class="string">'VarNameFun'</span>,<span class="string">'PbName'</span>,<span class="string">'MPSfilename'</span>},parameters);
0516         <span class="comment">%split A matrix for L and E csense</span>
0517         Ale = A(csense==<span class="string">'L'</span>,:);
0518         ble = b(csense==<span class="string">'L'</span>);
0519         Aeq = A(csense==<span class="string">'E'</span>,:);
0520         beq = b(csense==<span class="string">'E'</span>);
0521         
0522         <span class="comment">%%%%Adapted from BuildMPS%%%%%</span>
0523         [neq nvar]=size(Aeq);
0524         nle=size(Ale,1);
0525         <span class="keyword">if</span> isempty(EleNames)
0526             EleNames=arrayfun(EleNameFun,(1:nle),<span class="string">'UniformOutput'</span>, false);
0527         <span class="keyword">end</span>
0528         <span class="keyword">if</span> isempty(EqtNames)
0529             EqtNames=arrayfun(EqtNameFun,(1:neq),<span class="string">'UniformOutput'</span>, false);
0530         <span class="keyword">end</span>
0531         <span class="keyword">if</span> isempty(VarNames)
0532             VarNames=arrayfun(VarNameFun,(1:nvar),<span class="string">'UniformOutput'</span>, false);
0533         <span class="keyword">end</span>
0534         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0535         
0536         [solution] = <a href="../../cobra/external/BuildMPS/BuildMPS.html" class="code" title="function [Contain OK]=BuildMPS(A, b, Aeq, beq, cost, L, U, PbName, varargin)">BuildMPS</a>(Ale, ble, Aeq, beq, c, lb, ub, PbName,<span class="string">'MPSfilename'</span>,MPSfilename,<span class="string">'EleNames'</span>,EleNames,<span class="string">'EqtNames'</span>,EqtNames,<span class="string">'VarNames'</span>,VarNames);
0537         
0538         
0539     <span class="keyword">otherwise</span>
0540         error([<span class="string">'Unknown solver: '</span> solver]);
0541         
0542 <span class="keyword">end</span>
0543 <span class="keyword">if</span> ~strcmp(solver,<span class="string">'cplex_direct'</span>) &amp;&amp; ~strcmp(solver,<span class="string">'mps'</span>)
0544     <span class="comment">%% Assign solution</span>
0545     t = etime(clock, t_start);
0546     <span class="keyword">if</span> ~exist(<span class="string">'basis'</span>,<span class="string">'var'</span>), basis=[]; <span class="keyword">end</span>
0547     [solution.full,solution.obj,solution.rcost,solution.dual,solution.solver,solution.stat,solution.origStat,solution.time,solution.basis] = <span class="keyword">...</span>
0548         deal(x,f,w,y,solver,stat,origStat,t,basis);
0549 <span class="keyword">end</span>
0550 
0551 <span class="comment">%% solveGlpk Solve actual LP problem using glpk and return relevant results</span>
0552 <a name="_sub1" href="#_subfunctions" class="code">function [x,f,y,w,stat,origStat] = solveGlpk(c,A,b,lb,ub,csense,osense,params)</a>
0553 
0554 <span class="comment">% Old way of calling glpk</span>
0555 <span class="comment">%[x,f,stat,extra] = glpkmex(osense,c,A,b,csense,lb,ub,[],params);</span>
0556 [x,f,origStat,extra] = glpk(c,A,b,lb,ub,csense,[],osense,params);
0557 y = extra.lambda;
0558 w = extra.redcosts;
0559 <span class="comment">% Note that status handling may change (see glplpx.h)</span>
0560 <span class="keyword">if</span> (origStat == 180 || origStat == 5)
0561     stat = 1; <span class="comment">% Optimal solution found</span>
0562 <span class="keyword">elseif</span> (origStat == 182 || origStat == 183 || origStat == 3 || origStat == 110)
0563     stat = 0; <span class="comment">% Infeasible</span>
0564 <span class="keyword">elseif</span> (origStat == 184 || origStat == 6)
0565     stat = 2; <span class="comment">% Unbounded</span>
0566 <span class="keyword">else</span>
0567     stat = -1; <span class="comment">% Solution not optimal or solver problem</span>
0568 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Jun-2012 15:39:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>