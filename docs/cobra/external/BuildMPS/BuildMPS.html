<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of BuildMPS</title>
  <meta name="keywords" content="BuildMPS">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html cobra --><!-- ../menu.html external --><!-- menu.html BuildMPS -->
<h1>BuildMPS
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [Contain OK]=BuildMPS(A, b, Aeq, beq, cost, L, U, PbName, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">
 function Contain=BuildMPS(A, b, Aeq, beq, cost, L, U, PbName); OR
          Contain=BuildMPS(..., Param1, Value1, ...);

 Build ascii fixed-width MPS matrix string that contains linear
 programming (LP) problem:

 Minimizing (for x in R^n): f(x) = cost'*x, subject to
       A*x &lt;= b        (LE)
       Aeq*x = beq     (EQ)
       L &lt;= x &lt;= U     (BD).

 Also supported is integer/mixte programming problem similar to the above,
 where a subset of components of x is restricted to be integer (N set) or
 binary set {0,1}.

 INPUTS:
   A: (m x n) matrix
   b: (m x 1) matrix
   Aeq: (k x n) matrix
   beq: (k x 1) matrix
   cost: (n x 1) matrix
   L: (1 x n), (n x 1) or (1 x 1)
   U: (1 x n), (n x 1) or (1 x 1)

 Remark: To disable constraint(s) (LE, EQ, BD), please use empty []
         for corresponding input matrix/rhs parameters.

 Optional:
   - PbName is a string of problem name, default value is 'GENERIC'.
 Other Params:
    'EltNames', 'EqtNames', or 'VarNames'
     Cells contain string of respectively
        (LE) equations, (EQ) equations, or variable names
   - 'EltNameFun', 'EqtNameFun', or 'VarNameFun'
     Corresponding Value are function handles that return
     Equation/Variable name from equation/Variable number
       Example: &gt; VarNameFun=@(m) char('x'+(m-1));
     These functions will NOT be used if names of equations/variables
     are defined.
   - Param is 'MPSfilename': output MPS file to be saved
     No saving if MPSfilename is undefined.
   - 'I', 'Int' 'Integer', 'Integers'
       Array that stores the index of the set of integer variables (&gt;=0).
       The indexes must belong to [1,..., n] and correspond to the column
       of A, Aeq.
   - 'B', 'Bin' 'Binary', 'Binaries'
       Array that stores the index of the set of binary variables {0,1}.
       Indexes follow the same convention as with integer case.

 OUTPUT:
   Contain: char matrix of the MPS format description of LP/IP problem.

 RESTRICTION:
   Only single rhs (b and beq) is supported.

 The MPS (Mathematical Programming System) file format was introduced by
 IBM in 1970s, but has also been accepted by most subsequent linear
 programming codes. To learn about MPS format, please see:
   http://lpsolve.sourceforge.net/5.5/mps-format.htm

 See also: <a href="SaveMPS.html" class="code" title="function OK=SaveMPS(filename, Contain)">SaveMPS</a>

 Usage example:

   A = [1 1 0; -1 0 -1];
   b = [5; -10];
   L = [0; -1; 0];
   U = [4; +1; +inf];
   Aeq = [0 -1 1];
   beq = 7;
   cost = [1 4 9];
   VarNameFun = @(m) (char('x'+(m-1))); % returning varname 'x', 'y' 'z'

   Contain = BuildMPS(A, b, Aeq, beq, cost, L, U, 'Pbtest', ...
                      'VarNameFun', VarNameFun, ...
                      'EqtNames', {'Equality'}, ...
                       'Integer', [1], ... % first variable 'x' is integer
                      'MPSfilename', 'Pbtest.mps');

 Author: Bruno Luong
 update: 15-Jul-2008: sligly improved number formatting
         25-Aug-2009: Improvement in handling sparse matrix
         03-Sep-2009: integer/binary variables</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SaveMPS.html" class="code" title="function OK=SaveMPS(filename, Contain)">SaveMPS</a>	function OK=SaveMPS(filename, Contain);</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../cobra/solvers/convertCobraLP2mps.html" class="code" title="function OK=convertCobraLP2mps(LPProblem,name)">convertCobraLP2mps</a>	create an MPS (Mathematical Programming System) format ascii file</li><li><a href="../../../cobra/solvers/solveCobraLP.html" class="code" title="function solution = solveCobraLP(LPproblem, varargin)">solveCobraLP</a>	solveCobraLP Solve constraint-based LP problems</li><li><a href="../../../cobra/solvers/solveCobraMILP.html" class="code" title="function solution = solveCobraMILP(MILPproblem,varargin)">solveCobraMILP</a>	solveCobraMILP Solve constraint-based MILP problems</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function l=emptyline(n)</a></li><li><a href="#_sub2" class="code">function str=num2fixedlengthstr(num, maxlength, roundingflag)</a></li><li><a href="#_sub3" class="code">function l=setfield(l,field,var)</a></li><li><a href="#_sub4" class="code">function l=setfields(l, varargin)</a></li><li><a href="#_sub5" class="code">function name=elename(m)</a></li><li><a href="#_sub6" class="code">function name=eqtname(m)</a></li><li><a href="#_sub7" class="code">function name=varname(n)</a></li><li><a href="#_sub8" class="code">function parseoption(strname, value)</a></li><li><a href="#_sub9" class="code">function parseoptions(varargin)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Contain OK]=BuildMPS(A, b, Aeq, beq, cost, L, U, PbName, varargin)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">% function Contain=BuildMPS(A, b, Aeq, beq, cost, L, U, PbName); OR</span>
0004 <span class="comment">%          Contain=BuildMPS(..., Param1, Value1, ...);</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Build ascii fixed-width MPS matrix string that contains linear</span>
0007 <span class="comment">% programming (LP) problem:</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Minimizing (for x in R^n): f(x) = cost'*x, subject to</span>
0010 <span class="comment">%       A*x &lt;= b        (LE)</span>
0011 <span class="comment">%       Aeq*x = beq     (EQ)</span>
0012 <span class="comment">%       L &lt;= x &lt;= U     (BD).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Also supported is integer/mixte programming problem similar to the above,</span>
0015 <span class="comment">% where a subset of components of x is restricted to be integer (N set) or</span>
0016 <span class="comment">% binary set {0,1}.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% INPUTS:</span>
0019 <span class="comment">%   A: (m x n) matrix</span>
0020 <span class="comment">%   b: (m x 1) matrix</span>
0021 <span class="comment">%   Aeq: (k x n) matrix</span>
0022 <span class="comment">%   beq: (k x 1) matrix</span>
0023 <span class="comment">%   cost: (n x 1) matrix</span>
0024 <span class="comment">%   L: (1 x n), (n x 1) or (1 x 1)</span>
0025 <span class="comment">%   U: (1 x n), (n x 1) or (1 x 1)</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Remark: To disable constraint(s) (LE, EQ, BD), please use empty []</span>
0028 <span class="comment">%         for corresponding input matrix/rhs parameters.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Optional:</span>
0031 <span class="comment">%   - PbName is a string of problem name, default value is 'GENERIC'.</span>
0032 <span class="comment">% Other Params:</span>
0033 <span class="comment">%    'EltNames', 'EqtNames', or 'VarNames'</span>
0034 <span class="comment">%     Cells contain string of respectively</span>
0035 <span class="comment">%        (LE) equations, (EQ) equations, or variable names</span>
0036 <span class="comment">%   - 'EltNameFun', 'EqtNameFun', or 'VarNameFun'</span>
0037 <span class="comment">%     Corresponding Value are function handles that return</span>
0038 <span class="comment">%     Equation/Variable name from equation/Variable number</span>
0039 <span class="comment">%       Example: &gt; VarNameFun=@(m) char('x'+(m-1));</span>
0040 <span class="comment">%     These functions will NOT be used if names of equations/variables</span>
0041 <span class="comment">%     are defined.</span>
0042 <span class="comment">%   - Param is 'MPSfilename': output MPS file to be saved</span>
0043 <span class="comment">%     No saving if MPSfilename is undefined.</span>
0044 <span class="comment">%   - 'I', 'Int' 'Integer', 'Integers'</span>
0045 <span class="comment">%       Array that stores the index of the set of integer variables (&gt;=0).</span>
0046 <span class="comment">%       The indexes must belong to [1,..., n] and correspond to the column</span>
0047 <span class="comment">%       of A, Aeq.</span>
0048 <span class="comment">%   - 'B', 'Bin' 'Binary', 'Binaries'</span>
0049 <span class="comment">%       Array that stores the index of the set of binary variables {0,1}.</span>
0050 <span class="comment">%       Indexes follow the same convention as with integer case.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% OUTPUT:</span>
0053 <span class="comment">%   Contain: char matrix of the MPS format description of LP/IP problem.</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% RESTRICTION:</span>
0056 <span class="comment">%   Only single rhs (b and beq) is supported.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% The MPS (Mathematical Programming System) file format was introduced by</span>
0059 <span class="comment">% IBM in 1970s, but has also been accepted by most subsequent linear</span>
0060 <span class="comment">% programming codes. To learn about MPS format, please see:</span>
0061 <span class="comment">%   http://lpsolve.sourceforge.net/5.5/mps-format.htm</span>
0062 <span class="comment">%</span>
0063 <span class="comment">% See also: SaveMPS</span>
0064 <span class="comment">%</span>
0065 <span class="comment">% Usage example:</span>
0066 <span class="comment">%</span>
0067 <span class="comment">%   A = [1 1 0; -1 0 -1];</span>
0068 <span class="comment">%   b = [5; -10];</span>
0069 <span class="comment">%   L = [0; -1; 0];</span>
0070 <span class="comment">%   U = [4; +1; +inf];</span>
0071 <span class="comment">%   Aeq = [0 -1 1];</span>
0072 <span class="comment">%   beq = 7;</span>
0073 <span class="comment">%   cost = [1 4 9];</span>
0074 <span class="comment">%   VarNameFun = @(m) (char('x'+(m-1))); % returning varname 'x', 'y' 'z'</span>
0075 <span class="comment">%</span>
0076 <span class="comment">%   Contain = BuildMPS(A, b, Aeq, beq, cost, L, U, 'Pbtest', ...</span>
0077 <span class="comment">%                      'VarNameFun', VarNameFun, ...</span>
0078 <span class="comment">%                      'EqtNames', {'Equality'}, ...</span>
0079 <span class="comment">%                       'Integer', [1], ... % first variable 'x' is integer</span>
0080 <span class="comment">%                      'MPSfilename', 'Pbtest.mps');</span>
0081 <span class="comment">%</span>
0082 <span class="comment">% Author: Bruno Luong</span>
0083 <span class="comment">% update: 15-Jul-2008: sligly improved number formatting</span>
0084 <span class="comment">%         25-Aug-2009: Improvement in handling sparse matrix</span>
0085 <span class="comment">%         03-Sep-2009: integer/binary variables</span>
0086 
0087 <span class="keyword">if</span> nargin&lt;8 || isempty(PbName)
0088     PbName=<span class="string">'GENERIC'</span>;
0089 <span class="keyword">end</span>
0090 
0091 <span class="comment">%</span>
0092 <span class="comment">% Columns indices of MPS fields</span>
0093 <span class="comment">%</span>
0094 idx1=02:03;
0095 idx2=05:12;
0096 idx3=15:22;
0097 idx4=25:36;
0098 idx5=40:47;
0099 idx6=50:61;
0100 idxlist={idx1 idx2 idx3 idx4 idx5 idx6};
0101 
0102 <span class="comment">%</span>
0103 <span class="comment">% Default returned value if error occurs</span>
0104 <span class="comment">%</span>
0105 Contain=[]; <span class="comment">%#ok</span>
0106 OK = 0;  <span class="comment">%#ok</span>
0107 
0108 <span class="comment">%</span>
0109 <span class="comment">% Get the size of the input matrices</span>
0110 <span class="comment">%</span>
0111 [neq nvar]=size(Aeq);
0112 [nle sizeA2]=size(A);
0113 
0114 <span class="keyword">if</span> neq==0 <span class="comment">% Aeq is empty, i.e., no equality constraint</span>
0115     nvar=sizeA2;
0116     Aeq=zeros(0,nvar);
0117 <span class="keyword">elseif</span> nle==0 <span class="comment">% A is empty, i.e., no LE constraint</span>
0118     sizeA2=nvar;
0119     A=zeros(0,nvar);
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">%</span>
0123 <span class="comment">% Default values for naming functions (nested functions)</span>
0124 <span class="comment">%</span>
0125 elenamefun = @<a href="#_sub5" class="code" title="subfunction name=elename(m)">elename</a>;
0126 eqtnamefun = @<a href="#_sub6" class="code" title="subfunction name=eqtname(m)">eqtname</a>;
0127 varnamefun = @<a href="#_sub7" class="code" title="subfunction name=varname(n)">varname</a>;
0128 MPSfilename = <span class="string">''</span>; <span class="comment">% MPSfilename</span>
0129 
0130 <span class="comment">% default empty integer and binary sets</span>
0131 iset = [];
0132 bset = [];
0133 
0134 <span class="comment">%</span>
0135 <span class="comment">% Parse options (varargin)</span>
0136 <span class="comment">%</span>
0137 <a href="#_sub9" class="code" title="subfunction parseoptions(varargin)">parseoptions</a>(varargin{:});
0138 
0139 <span class="keyword">if</span> ~exist(<span class="string">'elenames'</span>,<span class="string">'var'</span>)
0140     elenames=arrayfun(elenamefun, (1:nle), <span class="string">'UniformOutput'</span>, false);
0141 <span class="keyword">end</span>
0142 <span class="keyword">if</span> ~exist(<span class="string">'eqtnames'</span>,<span class="string">'var'</span>)
0143     eqtnames=arrayfun(eqtnamefun, (1:neq), <span class="string">'UniformOutput'</span>, false);
0144 <span class="keyword">end</span>
0145 <span class="keyword">if</span> ~exist(<span class="string">'varnames'</span>,<span class="string">'var'</span>)
0146     varnames=arrayfun(varnamefun, (1:nvar), <span class="string">'UniformOutput'</span>, false);
0147 <span class="keyword">end</span>
0148 
0149 <span class="keyword">if</span> nargin&lt;6 || isempty(L)
0150     L=-inf(1,nvar);
0151 <span class="keyword">elseif</span> isscalar(L) <span class="comment">% extend L if it's a scalar input</span>
0152     Lval=L;
0153     L=zeros(1,nvar);
0154     L(:)=Lval;
0155 <span class="keyword">else</span> <span class="comment">% BUG corrected, reshape L in row</span>
0156     L = reshape(L,1,[]);
0157 <span class="keyword">end</span>
0158 <span class="keyword">if</span> nargin&lt;7 || isempty(U)
0159     U=+inf(1,nvar);
0160 <span class="keyword">elseif</span> isscalar(U) <span class="comment">% extend U if it's a scalar input</span>
0161     Uval=U;
0162     U=zeros(1,nvar);
0163     U(:)=Uval;
0164 <span class="keyword">else</span> <span class="comment">% BUG corrected, reshape U in row</span>
0165     U = reshape(U,1,[]);
0166 <span class="keyword">end</span>
0167 
0168 <span class="comment">%</span>
0169 <span class="comment">% Dimension check</span>
0170 <span class="comment">%</span>
0171 <span class="keyword">if</span> length(beq)~=neq || length(b)~=nle || <span class="keyword">...</span>
0172    length(cost)~=nvar || <span class="keyword">...</span>
0173    length(L)~=nvar || length(U)~=nvar || <span class="keyword">...</span>
0174    sizeA2~=nvar
0175     error(<span class="string">'BuildMPS:DimensionsUnMatched'</span>, <span class="keyword">...</span>
0176           <span class="string">'BuildMPS: dimensions do not match'</span>);
0177 <span class="keyword">end</span>
0178 
0179 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0180 <span class="comment">% Set problem name</span>
0181 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0182 l_name=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],0,<span class="string">'NAME'</span>);
0183 l_name=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_name,3,PbName);
0184 
0185 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0186 <span class="comment">% Set equations in ROWS and COST</span>
0187 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0188 l_rows=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],0,<span class="string">'ROWS'</span>);
0189 
0190 l_cost=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],1,<span class="string">'N'</span>,2,<span class="string">'COST'</span>);
0191 
0192 l_rows_eq=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>(neq);
0193 <span class="keyword">for</span> m=1:neq
0194     l_rows_eq(m,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_rows_eq(m,:),1,<span class="string">'E'</span>,2,eqtnames{m});
0195 <span class="keyword">end</span>
0196 
0197 l_rows_le=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>(nle);
0198 <span class="keyword">for</span> m=1:nle
0199     l_rows_le(m,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_rows_le(m,:),1,<span class="string">'L'</span>,2,elenames{m});
0200 <span class="keyword">end</span>
0201 
0202 CostAeq = [cost(:)'; Aeq; A]; <span class="comment">% CostAeq is sparse if any is sparse</span>
0203 MustWrite = (CostAeq ~= 0);
0204 NWrite = sum(MustWrite,1);
0205 NLines = sum(ceil(NWrite/2));
0206 
0207 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0208 <span class="comment">% Set coefficients of constraint equations in COLUMNS</span>
0209 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0210 l_columns=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],0,<span class="string">'COLUMNS'</span>);
0211 l_columnsbody=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>(NLines);
0212 
0213 c=0;
0214 <span class="keyword">for</span> n=1:nvar <span class="comment">% Loop over variables</span>
0215     var=varnames{n};
0216     field=3;
0217     eqtn = find(MustWrite(:,n)); <span class="comment">% subset of (1:1+neq+nle)</span>
0218     <span class="keyword">for</span> m=eqtn(:).' <span class="comment">% 1:1+neq+nle % Loop over eqt</span>
0219         <span class="keyword">if</span> m==1
0220             colname=<span class="string">'COST'</span>;
0221             val = cost(n);
0222         <span class="keyword">elseif</span> m&lt;=1+neq
0223             colname=eqtnames{m-1};
0224             val=Aeq(m-1,n);
0225         <span class="keyword">else</span>
0226             colname=elenames{m-(1+neq)};
0227             val=A(m-(1+neq),n);            
0228         <span class="keyword">end</span>
0229         <span class="keyword">if</span> field==3
0230             c=c+1;
0231             l_columnsbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_columnsbody(c,:),<span class="keyword">...</span>
0232                 2,var,<span class="keyword">...</span>
0233                 field,colname, <span class="keyword">...</span>
0234                 field+1,val);
0235             field=5;
0236         <span class="keyword">else</span> <span class="comment">% field==5</span>
0237             l_columnsbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_columnsbody(c,:),<span class="keyword">...</span>
0238                 field,colname, <span class="keyword">...</span>
0239                 field+1,val);
0240             field=3;
0241         <span class="keyword">end</span>
0242     <span class="keyword">end</span> <span class="comment">% for-loop eqt</span>
0243 <span class="keyword">end</span> <span class="comment">% for-loop variables</span>
0244 l_columnsbody(c+1:<span class="keyword">end</span>,:)=[];
0245 
0246 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0247 <span class="comment">% Set equation RHS</span>
0248 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0249 rhs=[beq(:); b(:)];
0250 MustWrite = (rhs ~= 0);
0251 NWrite = sum(MustWrite);
0252 NLines = ceil(NWrite/2);
0253 
0254 l_rhs=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],0,<span class="string">'RHS'</span>);
0255 l_rhsbody=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>(NLines);
0256 c=0;
0257 field=3;
0258 eqt = find(MustWrite); <span class="comment">% subset of (1:neq+nle)</span>
0259 <span class="keyword">for</span> m=eqt(:).' <span class="comment">% 1:neq+nle % Loop over eqt</span>
0260     <span class="keyword">if</span> m&lt;=neq
0261         colname=eqtnames{m};
0262         val=rhs(m);
0263     <span class="keyword">else</span>
0264         colname=elenames{m-neq};
0265         val=rhs(m);
0266     <span class="keyword">end</span>
0267     <span class="keyword">if</span> field==3
0268         c=c+1;
0269         l_rhsbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_rhsbody(c,:),<span class="keyword">...</span>
0270             2,<span class="string">'RHS'</span>,<span class="keyword">...</span>
0271             field,colname, <span class="keyword">...</span>
0272             field+1,val);
0273         field=5;
0274     <span class="keyword">else</span>
0275         l_rhsbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_rhsbody(c,:),<span class="keyword">...</span>
0276             field,colname, <span class="keyword">...</span>
0277             field+1,val);
0278         field=3;
0279     <span class="keyword">end</span>
0280 <span class="keyword">end</span> <span class="comment">% for-loop eqt</span>
0281 l_rhsbody(c+1:<span class="keyword">end</span>,:)=[];
0282 
0283 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0284 <span class="comment">% Set bound constraints</span>
0285 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0286 l_bound=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],0,<span class="string">'BOUNDS'</span>);
0287 
0288 VarType=zeros(size(U));
0289 <span class="comment">%</span>
0290 <span class="comment">% Var types (local definition)</span>
0291 <span class="comment">%</span>
0292 VarType(:)=0; <span class="comment">% real</span>
0293 VarType(iset) = 1; <span class="comment">% integer</span>
0294 VarType(bset) = 2; <span class="comment">% binary</span>
0295 
0296 <span class="comment">% Force lower/upper bound for integer variables to be integer as well</span>
0297 L(iset) = max(ceil(L(iset)),0); <span class="comment">% integer lower bound cannot be negative</span>
0298 U(iset) = floor(U(iset));
0299 
0300 <span class="comment">% Values not used, but we set for clarity</span>
0301 L(bset) = 0;
0302 U(bset) = 1;
0303 
0304 upinf=(U==inf);
0305 loinf=(L==-inf);
0306 lonz=(L~=0) &amp; ~loinf;
0307 
0308 BoundType=zeros(size(U));
0309 
0310 <span class="comment">%</span>
0311 <span class="comment">% Bound types (local definition)</span>
0312 <span class="comment">%</span>
0313 BoundType(:) = 3; <span class="comment">% Default, 0&lt;=x, real variable</span>
0314 BoundType(upinf &amp; loinf) = 1; <span class="comment">% free, real</span>
0315 BoundType(upinf &amp; lonz) = 2; <span class="comment">% lo&lt;=x (lo ~= 0), real</span>
0316 BoundType(~upinf &amp; lonz) = 4; <span class="comment">% lo&lt;=x&lt;=up, integer or real</span>
0317 BoundType(~upinf &amp; loinf) = 5; <span class="comment">% x&lt;=up, real</span>
0318 BoundType(~upinf &amp; ~loinf &amp; ~lonz) = 6; <span class="comment">% 0&lt;=x&lt;=up, integer or real</span>
0319 BoundType(upinf &amp; VarType==1) = 7; <span class="comment">%  lo&lt;=x, integer</span>
0320 BoundType(bset) = 8; <span class="comment">% binary, x = 0 or 1</span>
0321 
0322 NLines = sum(ismember(BoundType,[1 2 6 7 8])) + <span class="keyword">...</span>
0323          sum(ismember(BoundType,[4 5]))*2;
0324 l_boundbody=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>(NLines);
0325 c=0;
0326 <span class="keyword">for</span> n=1:nvar
0327     var=varnames{n};
0328     lo=L(n);
0329     up=U(n);
0330     vtype = VarType(n);
0331     <span class="keyword">if</span> (vtype==2) <span class="comment">% Type 8, binary variables</span>
0332         c=c+1;
0333         l_boundbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_boundbody(c,:),<span class="keyword">...</span>
0334             1, <span class="string">'BV'</span>, <span class="keyword">...</span>
0335             2, <span class="string">'BND1'</span>, <span class="keyword">...</span>
0336             3, var, <span class="keyword">...</span>
0337             4, 1); <span class="comment">% Field 4 must be 1.0 or blank</span>
0338     <span class="keyword">elseif</span> (up==inf)
0339         <span class="keyword">if</span> (lo==-inf) <span class="comment">% Type 1, Free real variable, one line</span>
0340             c=c+1;
0341             l_boundbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_boundbody(c,:),<span class="keyword">...</span>
0342                 1, <span class="string">'FR'</span>, <span class="keyword">...</span>
0343                 2, <span class="string">'BND1'</span>, <span class="keyword">...</span>
0344                 3, var, <span class="keyword">...</span>
0345                 4, 0);
0346         <span class="keyword">elseif</span> (lo~=0) || (vtype==1) <span class="comment">% Type 2, or Type 7 lo&lt;=x, one line</span>
0347             c = c+1;
0348             <span class="keyword">if</span> vtype==1 <span class="comment">% integer, Type 7</span>
0349                 LOstr = <span class="string">'LI'</span>;
0350             <span class="keyword">else</span> <span class="comment">% real, Type 2</span>
0351                 LOstr = <span class="string">'LO'</span>;
0352             <span class="keyword">end</span>
0353             l_boundbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_boundbody(c,:),<span class="keyword">...</span>
0354                 1, LOstr, <span class="keyword">...</span>
0355                 2, <span class="string">'BND1'</span>, <span class="keyword">...</span>
0356                 3, var, <span class="keyword">...</span>
0357                 4, lo);
0358         <span class="comment">% else 0&lt;=x&lt;=inf: Type3, real variable nothing to write</span>
0359         <span class="keyword">end</span>
0360     <span class="keyword">else</span> <span class="comment">% up&lt;inf</span>
0361         <span class="keyword">if</span> lo&gt;-inf
0362             <span class="keyword">if</span> lo~=0 <span class="comment">% Type 4, lo&lt;=x&lt;=up</span>
0363                 c=c+1;
0364                 <span class="keyword">if</span> vtype==1 <span class="comment">% integer</span>
0365                     LOstr = <span class="string">'LI'</span>;
0366                 <span class="keyword">else</span> <span class="comment">% real</span>
0367                     LOstr = <span class="string">'LO'</span>;
0368                 <span class="keyword">end</span>
0369                 l_boundbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_boundbody(c,:),<span class="keyword">...</span>
0370                     1, LOstr, <span class="keyword">...</span>
0371                     2, <span class="string">'BND1'</span>, <span class="keyword">...</span>
0372                     3, var, <span class="keyword">...</span>
0373                     4, lo);
0374             <span class="comment">%else % 0&lt;=x&lt;=up % Type 6</span>
0375             <span class="keyword">end</span>
0376         <span class="keyword">else</span> <span class="comment">% if lo==-inf % Type 5, x&lt;=up</span>
0377             c=c+1;
0378             l_boundbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_boundbody(c,:),<span class="keyword">...</span>
0379                 1, <span class="string">'MI'</span>, <span class="keyword">...</span>
0380                 2, <span class="string">'BND1'</span>, <span class="keyword">...</span>
0381                 3, var, <span class="keyword">...</span>
0382                 4, 0);
0383         <span class="keyword">end</span>
0384         <span class="comment">% Common Type 4, 5, or 6</span>
0385         <span class="comment">% Type 6 is 0&lt;=x&lt;=up</span>
0386         c=c+1;
0387         <span class="keyword">if</span> vtype==1 <span class="comment">% integer</span>
0388             HIstr = <span class="string">'UI'</span>;
0389         <span class="keyword">else</span> <span class="comment">% real</span>
0390             HIstr = <span class="string">'UP'</span>;
0391         <span class="keyword">end</span>
0392         l_boundbody(c,:)=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l_boundbody(c,:),<span class="keyword">...</span>
0393             1, HIstr, <span class="keyword">...</span>
0394             2, <span class="string">'BND1'</span>, <span class="keyword">...</span>
0395             3, var, <span class="keyword">...</span>
0396             4, up);
0397     <span class="keyword">end</span>
0398 <span class="keyword">end</span> <span class="comment">% for-loop on variable</span>
0399 l_boundbody(c+1:<span class="keyword">end</span>,:)=[];
0400 
0401 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0402 <span class="comment">% Set the last card</span>
0403 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0404 l_end=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>([],0,<span class="string">'ENDATA'</span>);
0405 
0406 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0407 <span class="comment">% Concatenate together all parts of mps format</span>
0408 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0409 Contain=[l_name; <span class="keyword">...</span>
0410     l_rows; <span class="keyword">...</span>
0411     l_cost; <span class="keyword">...</span>
0412     l_rows_eq; <span class="keyword">...</span>
0413     l_rows_le; <span class="keyword">...</span>
0414     l_columns; <span class="keyword">...</span>
0415     l_columnsbody; <span class="keyword">...</span>
0416     l_rhs; <span class="keyword">...</span>
0417     l_rhsbody; <span class="keyword">...</span>
0418     l_bound; <span class="keyword">...</span>
0419     l_boundbody; <span class="keyword">...</span>
0420     l_end];
0421 
0422 <span class="keyword">if</span> ~isempty(MPSfilename)
0423     <span class="comment">%</span>
0424     <span class="comment">% Save the Contain in MPSfilename</span>
0425     <span class="comment">%</span>
0426     OK = <a href="SaveMPS.html" class="code" title="function OK=SaveMPS(filename, Contain)">SaveMPS</a>(MPSfilename, Contain);
0427     <span class="keyword">if</span> ~OK <span class="comment">% Something is wrong during saving</span>
0428         warning(<span class="string">'BuildMPS:SavingFailure'</span>, <span class="keyword">...</span>
0429                 [<span class="string">'BuildMPS: Cannot save '</span> MPSfilename]);
0430     <span class="keyword">end</span>
0431 <span class="keyword">else</span> <span class="comment">% Nothing to save</span>
0432     OK = 1;
0433 <span class="keyword">end</span>
0434 
0435 <span class="comment">% return % Uncomment the RETURN statement causes M-lint to crash on 2009A</span>
0436 <span class="comment">% There is no instructions from now on, juts nested functions</span>
0437 
0438 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0439 <span class="comment">% Nested functions: BE AWARE, the functions have access to local</span>
0440 <span class="comment">% variables of BuildMPS</span>
0441 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0442 
0443    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0444    <span class="comment">% Generate n empty lines of MPS data</span>
0445    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0446     <span class="keyword">function</span> l=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>(n)
0447         <span class="keyword">if</span> nargin&lt;1 || isempty(n)
0448             n=1;
0449         <span class="keyword">end</span>
0450         l=char(zeros(n,61));
0451         l(:)=<span class="string">' '</span>;
0452     <span class="keyword">end</span>
0453 
0454    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0455    <span class="comment">% Convert to string at the fixed length of 12</span>
0456    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0457     <span class="keyword">function</span> str=<a href="#_sub2" class="code" title="subfunction str=num2fixedlengthstr(num, maxlength, roundingflag)">num2fixedlengthstr</a>(num, maxlength, roundingflag)
0458         <span class="comment">% function str=num2fixedlengthstr(num); OR</span>
0459         <span class="comment">% str=num2fixedlengthstr(..., maxlength, roundingflag);</span>
0460         <span class="comment">%</span>
0461         <span class="comment">% Convert double NUM to decimal string having MAXLENGTH [12] as maximum</span>
0462         <span class="comment">% length. Smart conversion with accurate result despite length constraint.</span>
0463         <span class="comment">%</span>
0464         <span class="comment">% ROUNDINGFLAG: 0 or [1]</span>
0465         <span class="comment">%   0: truncate fracional part (quicker)</span>
0466         <span class="comment">%   1: rounding fracional part (more accurate).</span>
0467         <span class="comment">%</span>
0468         <span class="comment">% Last update: 15/Aug/2008, remove leading &quot;0&quot; when the string starts</span>
0469         <span class="comment">%              as &quot;0.xxxx&quot;</span>
0470         <span class="comment">%</span>
0471         <span class="keyword">if</span> nargin&lt;2
0472             maxlength=12;
0473         <span class="keyword">end</span>
0474 
0475         <span class="keyword">if</span> nargin&lt;3
0476             roundingflag=1; <span class="comment">% rounding by default</span>
0477         <span class="keyword">end</span>
0478 
0479         <span class="keyword">if</span> num&gt;=0
0480             fracNDigits=maxlength;
0481         <span class="keyword">else</span>
0482             fracNDigits=maxlength-1;
0483         <span class="keyword">end</span>
0484         <span class="comment">% &quot;%G&quot; format:</span>
0485         <span class="comment">% ANSI specification X3.159-1989: &quot;Programming Language C,&quot;</span>
0486         <span class="comment">% ANSI, 1430 Broadway, New York, NY 10018.</span>
0487         str=num2str(num,[<span class="string">'%0.'</span> num2str(fracNDigits) <span class="string">'G'</span>]);
0488         <span class="comment">%</span>
0489         <span class="comment">% Try to compact the string data to fit inside the field length</span>
0490         <span class="comment">%</span>
0491         <span class="keyword">while</span> length(str)&gt;maxlength
0492             <span class="keyword">if</span> regexp(str,<span class="string">'^0\.'</span>) <span class="comment">% delete the leading 0 in &quot;0.xxx&quot;</span>
0493                 str(1)=[];
0494                 <span class="keyword">continue</span>;
0495             <span class="keyword">end</span>
0496             [istart iend]=regexp(str,<span class="string">'[+-](0)+'</span>); <span class="comment">% +/- followed by multiples 0</span>
0497             <span class="keyword">if</span> ~isempty(istart) <span class="comment">% Remove zero in xxxE+000yy or xxxE-000yy</span>
0498                 str(istart+1:iend)=[];
0499                 <span class="keyword">continue</span>
0500             <span class="keyword">else</span>
0501                 [istart iend]=regexp(str,<span class="string">'E[+]'</span>);
0502                 <span class="keyword">if</span> ~isempty(istart) <span class="comment">% Remove &quot;+&quot; char in xxxE+yyy</span>
0503                     str(iend)=[];
0504                     <span class="keyword">continue</span>
0505                 <span class="keyword">end</span>
0506             <span class="keyword">end</span>
0507             idot=find(str==<span class="string">'.'</span>,1,<span class="string">'first'</span>);
0508             <span class="keyword">if</span> ~isempty(idot)
0509                 iE=find(str==<span class="string">'E'</span>,1,<span class="string">'first'</span>);
0510                 <span class="keyword">if</span> roundingflag <span class="comment">% rounding fraction part</span>
0511                     <span class="comment">% Calculate the Length of the fractional part</span>
0512                     <span class="comment">% Adjust its number of digits and start over again</span>
0513                     <span class="keyword">if</span> ~isempty(iE) <span class="comment">% before the mantissa</span>
0514                         fracNDigits=maxlength-length(str)+iE-idot-1;
0515                         str=num2str(num,[<span class="string">'%0.'</span> num2str(fracNDigits) <span class="string">'E'</span>]);
0516                     <span class="keyword">else</span> <span class="comment">%if idot&lt;=maxlength+1 % no manissa</span>
0517                         fracNDigits=maxlength-idot;
0518                         str=num2str(num,[<span class="string">'%0.'</span> num2str(fracNDigits) <span class="string">'f'</span>]);
0519                     <span class="keyword">end</span>
0520                     roundingflag=0; <span class="comment">% won't do rounding again</span>
0521                     <span class="keyword">continue</span> <span class="comment">% second pass with new string</span>
0522                 <span class="keyword">else</span>
0523                     <span class="comment">% truncate the fractional part</span>
0524                     <span class="keyword">if</span> ~isempty(iE) <span class="comment">% before the mantissa</span>
0525                         str(maxlength-length(str)+iE:iE-1)=[];
0526                         <span class="keyword">return</span>;
0527                     <span class="keyword">else</span> <span class="comment">%if idot&lt;=maxlength+1 % no mantissa</span>
0528                         str(maxlength+1:end)=[];
0529                         <span class="keyword">return</span>;
0530                     <span class="keyword">end</span>
0531                 <span class="keyword">end</span>
0532             <span class="keyword">end</span>
0533             <span class="comment">% it should not never go here, unless BUG</span>
0534             error(<span class="string">'BuildMPS: cannot convert %0.12e to string\n'</span>,num);
0535         <span class="keyword">end</span> <span class="comment">% while loop</span>
0536 
0537     <span class="keyword">end</span>
0538 
0539     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0540     <span class="comment">% Set the field of an MPS line by value</span>
0541     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0542     <span class="keyword">function</span> l=<a href="#_sub3" class="code" title="subfunction l=setfield(l,field,var)">setfield</a>(l,field,var)
0543 
0544         <span class="keyword">if</span> isnumeric(var) <span class="comment">% numerical data, convert to string</span>
0545             var=<a href="#_sub2" class="code" title="subfunction str=num2fixedlengthstr(num, maxlength, roundingflag)">num2fixedlengthstr</a>(var); <span class="comment">% convert to 12-length string</span>
0546         <span class="keyword">end</span>
0547 
0548         <span class="keyword">if</span> isempty(l)
0549             l=<a href="#_sub1" class="code" title="subfunction l=emptyline(n)">emptyline</a>;
0550         <span class="keyword">end</span>
0551         <span class="keyword">if</span> ~isempty(field) &amp;&amp; field&gt;0
0552             idx=idxlist{field};
0553         <span class="keyword">else</span>
0554             idx=1:61;
0555         <span class="keyword">end</span>
0556         <span class="keyword">if</span> length(var)&gt;length(idx)
0557             var=var(1:length(idx));
0558         <span class="keyword">else</span>
0559             idx=idx(1:length(var));
0560         <span class="keyword">end</span>
0561         l(idx)=var;
0562 
0563     <span class="keyword">end</span>
0564 
0565     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0566     <span class="comment">% Set multiple fields of an MPS line by values</span>
0567     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0568     <span class="keyword">function</span> l=<a href="#_sub4" class="code" title="subfunction l=setfields(l, varargin)">setfields</a>(l, varargin)
0569         <span class="keyword">for</span> k=1:2:length(varargin)
0570             l=<a href="#_sub3" class="code" title="subfunction l=setfield(l,field,var)">setfield</a>(l, varargin{k}, varargin{k+1});
0571         <span class="keyword">end</span>
0572     <span class="keyword">end</span>
0573 
0574     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0575     <span class="comment">% Generate equation name for (LE) constraint</span>
0576     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0577     <span class="keyword">function</span> name=<a href="#_sub5" class="code" title="subfunction name=elename(m)">elename</a>(m)
0578         name=[<span class="string">'LE'</span> num2str(m)];
0579     <span class="keyword">end</span>
0580 
0581     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0582     <span class="comment">% Generate equation name for (EQ) constraint</span>
0583     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0584     <span class="keyword">function</span> name=<a href="#_sub6" class="code" title="subfunction name=eqtname(m)">eqtname</a>(m)
0585         name=[<span class="string">'EQ'</span> num2str(m)];
0586     <span class="keyword">end</span>
0587 
0588     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0589     <span class="comment">% Generate variable name</span>
0590     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0591     <span class="keyword">function</span> name=<a href="#_sub7" class="code" title="subfunction name=varname(n)">varname</a>(n)
0592         name=[<span class="string">'X'</span> num2str(n)];
0593     <span class="keyword">end</span>
0594 
0595     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0596     <span class="comment">% Parse a pair of Name/Value option</span>
0597     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0598     <span class="keyword">function</span> <a href="#_sub8" class="code" title="subfunction parseoption(strname, value)">parseoption</a>(strname, value)
0599         <span class="keyword">if</span> ischar(strname)
0600             strname = strtrim(lower(strname));
0601             <span class="keyword">switch</span> strname
0602                 <span class="keyword">case</span> <span class="string">'elenames'</span>,                   
0603                     <span class="keyword">if</span> ~iscell(value) || length(value)~=nle || <span class="keyword">...</span>
0604                         ~all(cellfun(@ischar, value))
0605                         error(<span class="string">'BuildMPS:IncorrectEleNames'</span>, <span class="keyword">...</span>
0606                     <span class="string">'BuildMPS: EleNames must be cell of %d strings'</span>, nle);
0607                     <span class="keyword">end</span>
0608                     elenames = value;
0609                 <span class="keyword">case</span> <span class="string">'eqtnames'</span>,
0610                     <span class="keyword">if</span> ~iscell(value) || length(value)~=neq || <span class="keyword">...</span>
0611                             ~all(cellfun(@ischar, value))
0612                         error(<span class="string">'BuildMPS:IncorrectEqtNames'</span>, <span class="keyword">...</span>
0613                     <span class="string">'BuildMPS: EqtNames must be cell of %d strings'</span>, neq);
0614                     <span class="keyword">end</span>
0615                     eqtnames = value;
0616                 <span class="keyword">case</span> <span class="string">'varnames'</span>,
0617                     <span class="keyword">if</span> ~iscell(value) || length(value)~=nvar || <span class="keyword">...</span>
0618                             ~all(cellfun(@ischar, value))
0619                         error(<span class="string">'BuildMPS:IncorrectVarNames'</span>, <span class="keyword">...</span>
0620                     <span class="string">'BuildMPS: VarNames must be cell of %d strings'</span>, nvar);
0621                     <span class="keyword">end</span>
0622                     varnames = value;
0623                 <span class="keyword">case</span> <span class="string">'varnamefun'</span>,
0624                     <span class="keyword">if</span> ischar(value)
0625                         value=str2func(value);
0626                     <span class="keyword">end</span>
0627                     <span class="keyword">if</span> ~isa(value,<span class="string">'function_handle'</span>)
0628                         error(<span class="string">'BuildMPS:IncorrectVarNameFun'</span>, <span class="keyword">...</span>
0629                               <span class="string">'BuildMPS: VarNameFun must be a function'</span>);
0630                     <span class="keyword">end</span>
0631                     varnamefun = value;
0632                 <span class="keyword">case</span> <span class="string">'eqtnamefun'</span>,
0633                     <span class="keyword">if</span> ischar(value)
0634                         value=str2func(value);
0635                     <span class="keyword">end</span>
0636                     <span class="keyword">if</span> ~isa(value,<span class="string">'function_handle'</span>)
0637                         error(<span class="string">'BuildMPS:IncorrectEqtNameFun'</span>, <span class="keyword">...</span>
0638                               <span class="string">'BuildMPS: EqtNameFun must be a function'</span>);
0639                     <span class="keyword">end</span>
0640                     eqtnamefun = value;
0641                 <span class="keyword">case</span> <span class="string">'elenamefun'</span>,
0642                     <span class="keyword">if</span> ischar(value)
0643                         value=str2func(value);
0644                     <span class="keyword">end</span>
0645                     <span class="keyword">if</span> ~isa(value,<span class="string">'function_handle'</span>)
0646                         error(<span class="string">'BuildMPS:IncorrectEleNameFun'</span>, <span class="keyword">...</span>
0647                               <span class="string">'BuildMPS: EleNameFun must be a function'</span>);
0648                     <span class="keyword">end</span>
0649                     elenamefun = value;
0650                 <span class="keyword">case</span> <span class="string">'mpsfilename'</span>,
0651                     <span class="keyword">if</span> ~ischar(value)
0652                         error(<span class="string">'BuildMPS:IncorrectMPSfilename'</span>, <span class="keyword">...</span>
0653                               <span class="string">'BuildMPS: MPSfilename must be a string'</span>);
0654                     <span class="keyword">end</span>
0655                     MPSfilename = value;
0656                 <span class="keyword">case</span>  {<span class="string">'i'</span> <span class="string">'int'</span> <span class="string">'integer'</span> <span class="string">'integers'</span>},
0657                     iset = value(:);
0658                     <span class="keyword">if</span> any(iset&lt;1 | iset&gt;nvar)
0659                         error(<span class="string">'Integer set contains invalid index'</span>);
0660                     <span class="keyword">end</span>
0661                 <span class="keyword">case</span> {<span class="string">'b'</span> <span class="string">'bin'</span> <span class="string">'binary'</span>, <span class="string">'binaries'</span>},
0662                     bset = value(:);
0663                     <span class="keyword">if</span> any(bset&lt;1 | bset&gt;nvar)
0664                         error(<span class="string">'Binary set contains invalid index'</span>);                        
0665                     <span class="keyword">end</span>
0666                 <span class="keyword">otherwise</span>
0667                     warning(<span class="string">'BuildMPS:UnknownParams'</span>, <span class="keyword">...</span>
0668                         [<span class="string">'BuildMPS: Unknown parameter '</span> strname]);
0669             <span class="keyword">end</span>
0670         <span class="keyword">else</span>
0671             error(<span class="string">'BuildMPS:IncorrectCall'</span>, <span class="keyword">...</span>
0672                   <span class="string">'BuildMPS: options must be pair of Name/Value'</span>);
0673         <span class="keyword">end</span>
0674     <span class="keyword">end</span>
0675 
0676     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0677     <span class="comment">% Parse options</span>
0678     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0679     <span class="keyword">function</span> <a href="#_sub9" class="code" title="subfunction parseoptions(varargin)">parseoptions</a>(varargin)
0680         <span class="keyword">if</span> mod(nargin,2)
0681             error(<span class="string">'BuildMPS:IncorrectCall'</span>, <span class="keyword">...</span>
0682                   <span class="string">'BuildMPS: options must be pair of Name/Value'</span>);            
0683         <span class="keyword">end</span>
0684         <span class="comment">%</span>
0685         <span class="comment">% Loop over pair of Name/Value option</span>
0686         <span class="comment">%</span>
0687         <span class="keyword">for</span> ivararg=1:2:nargin
0688             <a href="#_sub8" class="code" title="subfunction parseoption(strname, value)">parseoption</a>(varargin{ivararg},varargin{ivararg+1});
0689         <span class="keyword">end</span>
0690     <span class="keyword">end</span>
0691 
0692 <span class="keyword">end</span> <span class="comment">% BuildMPS</span></pre></div>
<hr><address>Generated on Thu 21-Jun-2012 15:39:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>