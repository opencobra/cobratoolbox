function [map, flux2, fluxMap] = addFluxWidthAndColor(map, reactionIDs, fluxValues)
    % Function to add flux widths and corresponding color shades to a map based on flux values.
    % Rxn line width is
    % proportional to flux magnitude. Positive fluxes are displayed in
    % shades of red, and negative fluxes in shades of indigo. Higher flux
    % magnitudes have higher hue saturation.
    %
    % INPUTS:
    %   map:           A parsed model structure generated by
    %                  'transformXML2Map' function.
    %   reactionIDs:   Cell array of reaction IDs.
    %   fluxValues:    Array of flux values corresponding to the reaction IDs.
    %
    % OUTPUTS:
    %   map:           Updated map with reaction fluxes and colors.
    %   flux2:         Fluxes and line widths through all reactions.
    %   fluxMap:       List of reactions carrying flux in the map and their
    %                  corresponding line widths.
    %
    % .. Author: - Cyrille C. Thinnes. University of Galway, Ireland, 26/09/2024.

    % Ensure reaction IDs are cell array of strings
    if isnumeric(reactionIDs)
        reactionIDs = cellstr(num2str(reactionIDs));
    elseif isstring(reactionIDs)
        reactionIDs = cellstr(reactionIDs);
    end

    % Obtain the non-zero flux reactions.
    idx = fluxValues ~= 0;
    rxn = reactionIDs(idx);  % Reactions with non-zero flux.

    % Obtain list of reactions carrying flux and their flux values.
    flux2 = [rxn, num2cell(fluxValues(idx))];

    % Normalize fluxes to assign widths.
    absFlux = abs(fluxValues);
    maxAbsFlux = max(absFlux);

    % Avoid division by zero if maxAbsFlux is zero
    if maxAbsFlux == 0
        rxnWidth = zeros(size(absFlux));
    else
        rxnWidth = absFlux / maxAbsFlux;  % Normalized between 0 and 1.
    end

    % Cap rxnWidth at 1
    rxnWidth(rxnWidth > 1) = 1;

    % Assign line widths based on thresholds.
    rxnWidthValues = ones(size(rxnWidth)); % Initialize with ones for zero fluxes.

    % Define thresholds for line widths.
    rxnWidthValues(rxnWidth > 0 & rxnWidth <= 0.2) = 2;
    rxnWidthValues(rxnWidth > 0.2 & rxnWidth <= 0.5) = 5;
    rxnWidthValues(rxnWidth > 0.5 & rxnWidth <= 0.8) = 8;
    rxnWidthValues(rxnWidth > 0.8 & rxnWidth <= 1) = 10;

    flux2 = [flux2, num2cell(rxnWidthValues(idx))];

    % Add specific widths to reactions in the map.
    map.rxnWidth = cell(size(map.rxnName));
    for i = 1:length(map.rxnName)
        a = find(strcmp(map.rxnName{i}, reactionIDs));
        if isempty(a)
            map.rxnWidth{i} = 1;  % Default width for reactions not in the flux data.
        else
            map.rxnWidth{i} = rxnWidthValues(a);
        end
    end

    fluxMap = [map.rxnName, map.rxnWidth];

    % Define color shades with alpha channel (FF for full opacity).
    redShades = {'FFffc9c9', 'FFff8787', 'FFfa5252', 'FFc92a2a'}; % Lightest to darkest.
    indigoShades = {'FFbac8ff', 'FF748ffc', 'FF4c6ef5', 'FF364fc7'}; % Lightest to darkest.
    LIGHTGRAY = 'FFD3D3D3';
    WHITE = 'FFFFFFFF';

    % Map line widths to shade indices.
    lineWidths = [1, 2, 5, 8, 10];  % Unique line widths.
    shadeIndices = [1, 1, 2, 3, 4]; % Corresponding shade indices.

    % Create mapping from line widths to shade indices.
    lineWidthToShadeIndex = containers.Map(lineWidths, shadeIndices);

    % Initialize reaction colors to LIGHTGRAY for reactions with zero flux.
    idZeroFlux = fluxValues == 0;
    rxZeroFlux = reactionIDs(idZeroFlux);
    indexZeroFlux = ismember(map.rxnName, rxZeroFlux);
    map.rxnColor(indexZeroFlux, 1) = {LIGHTGRAY};

    % Set all metabolite colors to WHITE.
    map.molColor = repmat({WHITE}, size(map.molAlias));

    % Assign colors to reactions with non-zero flux.
    idNonZeroFlux = ~idZeroFlux;
    rxNonZeroFlux = reactionIDs(idNonZeroFlux);
    fluxNonZero = fluxValues(idNonZeroFlux);
    rxnWidthsNonZero = rxnWidthValues(idNonZeroFlux);

    % Loop over reactions with non-zero flux.
    for i = 1:length(rxNonZeroFlux)
        rxnName = rxNonZeroFlux{i};
        idxMap = find(strcmp(map.rxnName, rxnName));
        if isempty(idxMap)
            continue;  % Skip if reaction not in map.
        end
        lineWidth = rxnWidthsNonZero(i);
        shadeIdx = lineWidthToShadeIndex(lineWidth);

        if fluxNonZero(i) > 0
            % Positive flux: use red shades.
            color = redShades{shadeIdx};
        else
            % Negative flux: use indigo shades.
            color = indigoShades{shadeIdx};
        end
        map.rxnColor{idxMap, 1} = color;

        % Update colors of reactants and products.
        reactants = [map.rxnBaseReactantAlias{idxMap}; map.rxnReactantAlias{idxMap}];
        for j = 1:length(reactants)
            a = reactants{j};
            idMol = strcmp(map.molAlias, a);
            map.molColor{idMol, 1} = color;
        end
        products = [map.rxnBaseProductAlias{idxMap}; map.rxnProductAlias{idxMap}];
        for j = 1:length(products)
            a = products{j};
            idMol = strcmp(map.molAlias, a);
            map.molColor{idMol, 1} = color;
        end
    end
end