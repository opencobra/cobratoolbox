function [map, flux2, fluxMap] = addFluxFromFileWidthAndColor(map, csvFilePath)
    % Visualizes fluxes on a CellDesigner map. Rxn line width is
    % proportional to flux magnitude. Positive fluxes are displayed in
    % shades of red, and negative fluxes in shades of indigo. Higher flux
    % magnitudes have higher hue saturation.
    %
    % INPUTS:
    %   map:           A parsed model structure generated by
    %                  'transformXML2Map' function.
    %   csvFilePath:   Path to the CSV file containing reaction IDs in the
    %                  first column and fluxes in the second column. The first row
    %                  contains the respective headers.
    %
    % OUTPUTS:
    %   map:           Updated map with reaction fluxes and colors.
    %   flux2:         Fluxes and line widths through all reactions.
    %   fluxMap:       List of reactions carrying flux in the map and their
    %                  corresponding line widths.
    %
    % .. Author: - Cyrille C. Thinnes. University of Galway, Ireland, 25/09/2024.

    % Load the CSV data, ignoring headers.
    fluxData = readtable(csvFilePath, 'ReadVariableNames', false);  

    % Extract reaction IDs and flux values from the first and second columns.
    reactionIDs = fluxData{:, 1};  % First column contains reaction IDs.
    fluxValues = fluxData{:, 2};   % Second column contains flux values.

    % Convert reaction IDs to cell array of strings if necessary.
    if isnumeric(reactionIDs)
        reactionIDs = cellstr(num2str(reactionIDs));
    elseif isstring(reactionIDs)
        reactionIDs = cellstr(reactionIDs);
    end

    % Obtain the non-zero flux reactions.
    idx = fluxValues ~= 0;
    rxn = reactionIDs(idx);  % Get reactions with non-zero flux.

    % Obtain list of reactions carrying flux and their flux values.
    flux2 = [rxn, num2cell(fluxValues(idx))];

    % Normalize fluxes to give width.
    absFlux = abs(fluxValues);
    maxAbsFlux = max(absFlux);

    % Avoid division by zero if maxAbsFlux is zero.
    if maxAbsFlux == 0
        rxnWidth = zeros(size(absFlux));
    else
        rxnWidth = absFlux / maxAbsFlux;  % Normalized flux values between 0 and 1
    end

    % Cap rxnWidth at 1
    rxnWidth(rxnWidth > 1) = 1;

    % Assign line widths based on non-linear gradations that reflect the decimal thresholds.
    rxnWidthValues = ones(size(rxnWidth)); % Initialize with ones for zero fluxes.

    % Define non-linear ranges for line widths with values reflecting the
    % decimal thresholds.
    rxnWidthValues(rxnWidth > 0 & rxnWidth <= 0.2) = 2;
    rxnWidthValues(rxnWidth > 0.2 & rxnWidth <= 0.5) = 5;
    rxnWidthValues(rxnWidth > 0.5 & rxnWidth <= 0.8) = 8;
    rxnWidthValues(rxnWidth > 0.8 & rxnWidth <= 1) = 10;

    flux2 = [flux2 num2cell(rxnWidthValues(idx))];

    % Add specific width to each reaction in the map based on the fluxes.
    map.rxnWidth = cell(size(map.rxnName));
    for i = 1:length(map.rxnName)
        a = find(strcmp(map.rxnName{i}, reactionIDs));
        if isempty(a)
            map.rxnWidth{i} = 1;
        else
            map.rxnWidth{i} = rxnWidthValues(a);
        end
    end

    fluxMap = [map.rxnName, map.rxnWidth];

    % Define color shades (4 shades each for red and
    % indigo) as specified. Add FF before the hex code to account for the
    % alpha channel. We used Open Color to inform the color choice
    % (https://yeun.github.io/open-color/).
    redShades = {'FFffc9c9', 'FFff8787', 'FFfa5252', 'FFc92a2a'}; % Lightest to darkest
    indigoShades = {'FFbac8ff', 'FF748ffc', 'FF4c6ef5', 'FF364fc7'}; % Lightest to darkest
    LIGHTGRAY = 'FFD3D3D3';
    WHITE = 'FFFFFFFF';

    % Map line widths to shade indices.
    lineWidths = [1, 2, 5, 8, 10]; % Unique line widths.
    shadeIndices = [1, 1, 2, 3, 4]; % Map line widths to shades.

    % Create a mapping from line widths to shade indices.
    lineWidthToShadeIndex = containers.Map(lineWidths, shadeIndices);

    % Initialize reaction colors to LIGHTGRAY for reactions with zero flux.
    idZeroFlux = fluxValues == 0;
    rxZeroFlux = reactionIDs(idZeroFlux);
    indexZeroFlux = ismember(map.rxnName, rxZeroFlux);
    map.rxnColor(indexZeroFlux, 1) = {LIGHTGRAY}; % LIGHTGRAY

    % Change all nodes' color to WHITE.
    map.molColor = repmat({WHITE}, size(map.molAlias));

    % For reactions with non-zero flux, assign colors based on line width
    % and sign.
    idNonZeroFlux = ~idZeroFlux;
    rxNonZeroFlux = reactionIDs(idNonZeroFlux);
    fluxNonZero = fluxValues(idNonZeroFlux);
    rxnWidthsNonZero = rxnWidthValues(idNonZeroFlux);

    % Now, for each reaction with non-zero flux.
    for i = 1:length(rxNonZeroFlux)
        rxnName = rxNonZeroFlux{i};
        idxMap = find(strcmp(map.rxnName, rxnName));
        if isempty(idxMap)
            continue;
        end
        lineWidth = rxnWidthsNonZero(i);
        shadeIdx = lineWidthToShadeIndex(lineWidth); % Get the shade index corresponding to the line width.

        if fluxNonZero(i) > 0
            % Positive flux, use red shades.
            color = redShades{shadeIdx};
        else
            % Negative flux, use indigo shades.
            color = indigoShades{shadeIdx};
        end
        map.rxnColor{idxMap, 1} = color;

        % Also change color of reactants and products accordingly.
        % Reactants.
        reactants = [map.rxnBaseReactantAlias{idxMap}; map.rxnReactantAlias{idxMap}];
        for j = 1:length(reactants)
            a = reactants{j};
            idMol = strcmp(map.molAlias, a);
            map.molColor{idMol, 1} = color;
        end
        % Products.
        products = [map.rxnBaseProductAlias{idxMap}; map.rxnProductAlias{idxMap}];
        for j = 1:length(products)
            a = products{j};
            idMol = strcmp(map.molAlias, a);
            map.molColor{idMol, 1} = color;
        end
    end
end