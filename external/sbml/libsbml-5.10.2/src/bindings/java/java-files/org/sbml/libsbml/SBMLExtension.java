/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.sbml.libsbml;

/** 
 *  Core class for SBML Level 3 package plug-ins.
 <p>
 * @internal 
 <p>
 * {@link SBMLExtension} class (abstract class) is a core component of package extension
 * which needs to be extended by package developers. 
 * The class provides functions for getting common attributes of package extension 
 * (e.g., package name, package version, and etc.), functions for adding (registering) 
 * each instantiated SBasePluginCreator object, and a static function (defined in each 
 * {@link SBMLExtension} extended class) for initializing/registering the package extension 
 * when the library of the package is loaded.
 <p>
 * <h2>How to implement an {@link SBMLExtension} extended class for each package extension</h2>
 <p>
 * Package developers must implement an {@link SBMLExtension} extended class for
 * their packages (e.g. GroupsExtension class is implemented for groups extension).
 * The extended class is implemented based on the following steps:
 <p>
 * (NOTE: 
 *   'src/packages/groups/extension/GroupsExtension.{h,cpp}' and
 *   'src/packages/layout/extension/LayoutExtension.{h,cpp}' are
 *   example files in which {@link SBMLExtension} derived classes are implemented)
 <p>
 * <ol>
 <p>
 * <li> Define the following static functions in the extended class:
 *      (examples of groups extension are shown respectively)
 *   <ol>
 *     <li> <p>A string of package name (label) (The function name must be 'getPackageName'.)</p>
 <p>
<pre class='fragment'>
  String {@link GroupsExtension#getPackageName ()}
  {
	static String pkgName = 'groups';
	return pkgName;
  }
</pre>
 *     </li>
 <p>
 *     <li> <p>
 *        Methods returning an integer of Default SBML level, version, and package version
 *        (The method names must be 'getDefaultLevel()', 'getDefaultVersion()', and 
 *        'getDefaultPackageVersion()' respectively.)
 *        </p>
<pre class='fragment'>
  long {@link GroupsExtension#getDefaultLevel()}
  {
	return 3;
  }  
  long {@link GroupsExtension#getDefaultVersion()}
  {
	return 1; 
  }
  long {@link GroupsExtension#getDefaultPackageVersion()}
  {
	return 1;
  }  
</pre>
 *     </li>
 *     <li> <p> Methods returning Strings that represent the URI of packages </p>
<pre class='fragment'>
  String {@link GroupsExtension#getXmlnsL3V1V1 ()}
  {
	static String xmlns = 'http://www.sbml.org/sbml/level3/version1/groups/version1';
	return xmlns;
  }
</pre> 
 *     </li>
 *     <li> <p>Strings that represent the other URI needed in this package (if any) </p>
 *     </li>
 *   </ol> 
 * </li>
 <p>
 * <li> Override the following pure virtual functions
      <ul>
       <li> <code>virtual String getName () =0</code>. This function returns the name of the package (e.g., 'layout', 'groups'). </li>
       <li> <code>virtual long getLevel (String uri) =0</code>. This function returns the SBML level with the given URI of this package. </li>
       <li> <code>virtual long getVersion (String uri) =0</code>. This function returns the SBML version with the given URI of this package. </li>
       <li> <code>virtual long getPackageVersion (String uri) =0</code>. This function returns the package version with the given URI of this package.</li>
       <li> <code>virtual long getURI (long sbmlLevel, long sbmlVersion, long pkgVersion) =0</code>. 
             This function returns the URI (namespace) of the package corresponding to the combination of the given sbml level, sbml version, and pacakege version</li>
       <li> <code>virtual {@link SBMLExtension} clone () = 0</code>. This function creates and returns a deep copy of this derived object.</li>
      </ul>
      <p>For example, the above functions are overridden in the groups
	package ('src/packages/groups/extension/GroupsExtension.cpp') as follows:</p>
<pre class='fragment'>
String
{@link GroupsExtension#getName()} const
{
  return getPackageName();
}

long 
{@link GroupsExtension#getLevel(String uri)} const
{
  if (uri == getXmlnsL3V1V1())
  {
    return 3;
  }
  
  return 0;
}

long 
{@link GroupsExtension#getVersion(String uri)} const
{
  if (uri == getXmlnsL3V1V1())
  {
    return 1;
  }

  return 0;
}

long
{@link GroupsExtension#getPackageVersion(String uri)} const
{
  if (uri == getXmlnsL3V1V1())
  {
    return 1;
  }

  return 0;
}

String 
{@link GroupsExtension#getURI(long sbmlLevel, long sbmlVersion, long pkgVersion)} const
{
  if (sbmlLevel == 3)
  {
    if (sbmlVersion == 1)
    {
      if (pkgVersion == 1)
      {
        return getXmlnsL3V1V1();
      }
    }
  }

  static String empty = '';

  return empty;
}

GroupsExtension* 
{@link GroupsExtension#clone ()} const
{
  return new GroupsExtension(*this);  
}
</pre>
 <p>
 * Constructor, copy Constructor, and destructor also must be overridden
 * if additional data members are defined in the derived class.
 <p>
 * </li>
 <p>
 * <li> <p>
 *  Define typedef and template instantiation code for the package specific {@link SBMLExtensionNamespaces} template class
 *  </p>
 <p>
 *   <ol>
 *     <li> typedef for the package specific {@link SBMLExtensionNamespaces} template class
 <p> For example, the typedef for GroupsExtension (defined in the groups package) is implemented in GroupsExtension.h as follows:</p>
<pre class='fragment'>
  // GroupsPkgNamespaces is derived from the {@link SBMLNamespaces} class and used when creating an object of 
  // {@link SBase} derived classes defined in groups package.
  typedef {@link SBMLExtensionNamespaces}&lt;GroupsExtension&gt; GroupsPkgNamespaces;
</pre>
 *     </li>
 <p>
 *     <li> template instantiation code for the above typedef definition in the implementation file (i.e., *.cpp file).
 <p> For example, the template instantiation code for GroupsExtension is implemented in GroupsExtension.cpp 
 *           as follows:
 *       </p>
 <p>
<pre class='fragment'>
  // Instantiate {@link SBMLExtensionNamespaces}&lt;GroupsExtension&gt; (GroupsPkgNamespaces) for DLL.
  template class LIBSBML_EXTERN {@link SBMLExtensionNamespaces}&lt;GroupsExtension&gt;;
</pre>
 <p>
 *     </li>
 *  </ol>
 <p> The {@link SBMLExtensionNamespaces} template class is a derived class of
 *      {@link SBMLNamespaces} and can be used as an argument of constructors 
 *      of {@link SBase} derived classes defined in the package extensions.
 *      For example, a GroupsPkgNamespaces object can be used when creating a group 
 *      object as follows:
 *  </P>
<pre class='fragment'>
   GroupPkgNamespaces gpns(3,1,1);  // The arguments are SBML Level, SBML Version, and Groups Package Version.

   Group g = new Group(&gpns);      // Creates a group object of L3V1 Groups V1.
</pre>
 <p>
 *     Also, the GroupsPkgNamespaces object can be used when creating an
 *     {@link SBMLDocument} object with the groups package as follows:
 *   </p>
 <p>
<pre class='fragment'>
   GroupsPkgNamespaces gpns(3,1,1);
   {@link SBMLDocument} doc;

   doc  = new {@link SBMLDocument}(&gnps); // Creates an {@link SBMLDocument} of L3V1 with Groups V1.
</pre>
 <p>
 * </li>
 <p>
 * <li> Override the following pure virtual function which returns the {@link SBMLNamespaces} derived object 
<pre class='fragment'>
       virtual {@link SBMLNamespaces} getSBMLExtensionNamespaces (String uri) =0
</pre>
 <p> For example, the function is overridden in GroupsExtension
 class as follows:</p>
<pre class='fragment'>
{@link SBMLNamespaces}
{@link GroupsExtension#getSBMLExtensionNamespaces(String uri)} const
{
  GroupsPkgNamespaces* pkgns = null;
  if ( uri == getXmlnsL3V1V1())
  {
    pkgns = new GroupsPkgNamespaces(3,1,1);    
  }  
  return pkgns;
}
</pre>
   </li>
 <p>
 *  <li> Define an enum type for representing the typecode of elements (SBase extended classes) defined in the package extension
 <p>  For example, SBMLGroupsTypeCode_t for groups package is
 *  defined in GroupsExtension.h as follows: </p>
<pre class='fragment'>
      typedef enum
      {
         SBML_GROUPS_GROUP  = 200
       , SBML_GROUPS_MEMBER = 201
      } SBMLGroupsTypeCode_t;
</pre>    
 <p> <em>SBML_GROUPS_GROUP</em> corresponds to the Group class (&lt;group&gt;)
 * and <em>SBML_GROUPS_MEMBER</em> corresponds to the Member (&lt;member&gt;) class, respectively.
 <p> Similarly, SBMLLayoutTypeCode_t 
 *   for layout package is defined in LayoutExtension.h as follows: </p>
 <p>
<pre class='fragment'>  
      typedef enum
      {
         SBML_LAYOUT_BOUNDINGBOX           = 100
       , SBML_LAYOUT_COMPARTMENTGLYPH      = 101
       , SBML_LAYOUT_CUBICBEZIER           = 102
       , SBML_LAYOUT_CURVE                 = 103
       , SBML_LAYOUT_DIMENSIONS            = 104
       , SBML_LAYOUT_GRAPHICALOBJECT       = 105
       , SBML_LAYOUT_LAYOUT                = 106   
       , SBML_LAYOUT_LINESEGMENT           = 107   
       , SBML_LAYOUT_POINT                 = 108    
       , SBML_LAYOUT_REACTIONGLYPH         = 109    
       , SBML_LAYOUT_SPECIESGLYPH          = 110    
       , SBML_LAYOUT_SPECIESREFERENCEGLYPH = 111
       , SBML_LAYOUT_TEXTGLYPH             = 112
      } SBMLLayoutTypeCode_t;
</pre>
 <p>
 *   These enum values are returned by corresponding getTypeCode() functions.
 *   (e.g. SBML_GROUPS_GROUP is returned in {@link Group#getTypeCode()})
 *  </p>
 <p>
 *   The value of each typecode can be duplicated between those of different 
 *   packages (In the above SBMLLayoutTypeCode_t and SBMLGroupsTypeCode_t types, 
 *   unique values are assigned to enum values, but this is not mandatory.)
 *  </p>
 <p>
 *   Thus, to distinguish the typecodes of different packages, not only the return
 *   value of getTypeCode() function but also that of getPackageName()
 *   function should be checked as follows:
 *  </p>
<pre class='fragment'>
          void example (SBase sb)
          {
            String pkgName = sb-&gt;getPackageName();
            if (pkgName == 'core') {
              switch (sb-&gt;getTypeCode()) {
                case SBML_MODEL:
                   ....
                   break;
                case SBML_REACTION:
                   ....
              }
            } 
            else if (pkgName == 'layout') {
              switch (sb-&gt;getTypeCode()) {
                case SBML_LAYOUT_LAYOUT:
                   ....
                   break;
                case SBML_LAYOUT_REACTIONGLYPH:
                   ....
              }
            } 
            else if (pkgName == 'groups') {
              switch (sb-&gt;getTypeCode()) {
                case SBML_GROUPS_GROUP:
                   ....
                   break;
                case SBML_GROUPS_MEMBER:
                   ....
              }
            }
            ...
          } 
</pre>
 <p>
 *  </li>
 *  <li> Override the following pure virtual function which returns a string corresponding to the given typecode:
 <p>
<pre class='fragment'>  
       virtual String {@link SBMLExtension#getStringFromTypeCode(int typeCode)} const;
</pre> 
 <p> For example, the function for groups extension is implemented as follows: </p>
<pre class='fragment'>  
static
String SBML_GROUPS_TYPECODE_STRINGS[] =
{
    'Group'
  , 'Member'
};

String 
{@link GroupsExtension#getStringFromTypeCode(int typeCode)} const
{
  int min = SBML_GROUPS_GROUP;
  int max = SBML_GROUPS_MEMBER;

  if ( typeCode &lt; min || typeCode &gt; max)
  {
    return '(Unknown SBML Groups Type)';  
  }

  return SBML_GROUPS_TYPECODE_STRINGS[typeCode - min];
}
</pre> 
 <p>
 *  </li>
 <p>
 * <li> Implements a 'static void init()' function in the derived class
 <p> In the init() function, initialization code which creates an instance of 
 *     the derived class and registering code which registers the instance to 
 *     {@link SBMLExtensionRegistry} class are implemented.
 * </p>
 <p>
 * For example, the init() function for groups package is implemented as follows: 
<pre class='fragment'>
void 
{@link GroupsExtension#init()}
{
  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
  //
  // 1. Checks if the groups package has already been registered.
  //
  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-

  if ( {@link SBMLExtensionRegistry#getInstance()}.isRegistered(getPackageName()) )
  {
    // do nothing;
    return;
  }

  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
  //
  // 2. Creates an {@link SBMLExtension} derived object.
  //
  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-

  GroupsExtension groupsExtension;

  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
  //
  // 3. Creates SBasePluginCreatorBase derived objects required for this 
  //    extension. The derived classes can be instantiated by using the following 
  //     template class.
  //
  //    temaplate&lt;class SBasePluginType&gt; class SBasePluginCreator
  //
  //    The constructor of the creator class has two arguments:
  //
  //        (1) {@link SBaseExtensionPoint} : extension point to which the plugin object connected
  //        (2) std.vector&lt;String&gt; : a std.vector object that contains a list of URI
  //                                       (package versions) supported by the plugin object.
  //
  //    For example, two plugin objects (plugged in {@link SBMLDocument} and {@link Model} elements) are 
  //    required for the groups extension.
  //
  //    Since only 'required' attribute is used in {@link SBMLDocument} by the groups package, and
  //    the 'required' flag must always be 'false', the existing
  //    SBMLDocumentPluginNotRequired class can be used as-is for the plugin.
  //
  //    Since the lists of supported package versions (currently only L3V1-groups-V1 supported )
  //    are equal in the both plugin objects, the same vector object is given to each 
  //    constructor.
  //
  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;

  std.vector&lt;String&gt; packageURIs;
  packageURIs.push_back(getXmlnsL3V1V1());

  {@link SBaseExtensionPoint} sbmldocExtPoint('core',SBML_DOCUMENT);
  {@link SBaseExtensionPoint} modelExtPoint('core',SBML_MODEL);

  SBasePluginCreator&lt;SBMLDocumentPluginNotRequired, GroupsExtension&gt; sbmldocPluginCreator(sbmldocExtPoint,packageURIs);
  SBasePluginCreator&lt;GroupsModelPlugin,   GroupsExtension&gt; modelPluginCreator(modelExtPoint,packageURIs);

  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;--
  //
  // 3. Adds the above SBasePluginCreatorBase derived objects to the {@link SBMLExtension} derived object.
  //
  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;--

  groupsExtension.addSBasePluginCreator(&sbmldocPluginCreator);
  groupsExtension.addSBasePluginCreator(&modelPluginCreator);

  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
  //
  // 4. Registers the {@link SBMLExtension} derived object to {@link SBMLExtensionRegistry}
  //
  //&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-

  int result = {@link SBMLExtensionRegistry#getInstance()}.addExtension(&groupsExtension);

  if (result != LIBSBML_OPERATION_SUCCESS)
  {
    std.cerr &lt;&lt; '[Error] {@link GroupsExtension#init()} failed.' &lt;&lt; std.endl;
  }
}
</pre>
 *    </p> 
 * </li>
 <p>
 * <li> Instantiate a global SBMLExtensionRegister variable in appropriate 
 *      implementation file
 <p> For example, the global variable for the groups extension is instantiated in GroupsExtension.cpp as follows: </p>
<pre class='fragment'>
  static SBMLExtensionRegister&lt;GroupsExtension&gt; groupsExtensionRegister;
</pre>
 *    The init() function is invoked when the global variable is instantiated,
 *    by which initialization and registering the package extension are performed.
 * </li>
 <p>
 * </ol>
 */

public class SBMLExtension {
   private long swigCPtr;
   protected boolean swigCMemOwn;

   protected SBMLExtension(long cPtr, boolean cMemoryOwn)
   {
     swigCMemOwn = cMemoryOwn;
     swigCPtr    = cPtr;
   }

   protected static long getCPtr(SBMLExtension obj)
   {
     return (obj == null) ? 0 : obj.swigCPtr;
   }

   protected static long getCPtrAndDisown (SBMLExtension obj)
   {
     long ptr = 0;

     if (obj != null)
     {
       ptr             = obj.swigCPtr;
       obj.swigCMemOwn = false;
     }

     return ptr;
   }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libsbmlJNI.delete_SBMLExtension(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   * SBMLExtension derived classes must override this method
   */
  public SBasePlugin DowncastSBasePlugin(long cPtr, boolean owner)
  {
    if (cPtr == 0) return null;

    return new SBasePlugin(cPtr,false);
  }


  /**
   * SBMLExtension derived classes must override this method
   */
  public SBase DowncastSBase(long cPtr, boolean owner)
  {
    if (cPtr == 0) return null;

    return new SBase(cPtr, owner);
  }

  
/**
   * Returns the number of {@link SBasePlugin} objects stored in this object.
   <p>
   * @return the number of {@link SBasePlugin} objects stored in this object.
   */ public
 int getNumOfSBasePlugins() {
    return libsbmlJNI.SBMLExtension_getNumOfSBasePlugins(swigCPtr, this);
  }

  
/**
   * Returns the number of supported package Namespace (package versions) of this 
   * package extension.
   <p>
   * @return the number of supported package Namespace (package versions) of this 
   * package extension.
   */ public
 long getNumOfSupportedPackageURI() {
    return libsbmlJNI.SBMLExtension_getNumOfSupportedPackageURI(swigCPtr, this);
  }

  
/**
   * Returns a flag indicating, whether the given URI (package version) is 
   * supported by this package extension.
   <p>
   * @return true if the given URI (package version) is supported by this 
   * package extension, otherwise false is returned.
   */ public
 boolean isSupported(String uri) {
    return libsbmlJNI.SBMLExtension_isSupported(swigCPtr, this, uri);
  }

  
/**
   <p>
   * Returns the ith URI (the supported package version)
   <p>
   * @param i the index of the list of URI (the list of supporeted package versions)
   * @return the URI of supported package version with the given index.
   */ public
 String getSupportedPackageURI(long i) {
    return libsbmlJNI.SBMLExtension_getSupportedPackageURI(swigCPtr, this, i);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * Creates and returns a deep copy of this {@link SBMLExtension} object.
   <p>
   * @return a (deep) copy of this {@link SBase} object
   */ public
 SBMLExtension cloneObject() {
	return libsbml.DowncastExtension(libsbmlJNI.SBMLExtension_cloneObject(swigCPtr, this), true);
}

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * Returns the name of this package (e.g. 'layout', 'multi').
   <p>
   * @return the name of package extension
   */ public
 String getName() {
    return libsbmlJNI.SBMLExtension_getName(swigCPtr, this);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * Returns the uri corresponding to the given SBML level, SBML version, and package version.
   <p>
   * @param sbmlLevel the level of SBML
   * @param sbmlVersion the version of SBML
   * @param pkgVersion the version of package
   <p>
   * @return a string of the package URI
   */ public
 String getURI(long sbmlLevel, long sbmlVersion, long pkgVersion) {
    return libsbmlJNI.SBMLExtension_getURI(swigCPtr, this, sbmlLevel, sbmlVersion, pkgVersion);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * Returns the SBML level associated with the given URI of this package.
   <p>
   * @param uri the string of URI that represents a versions of the package
   * @return the SBML level associated with the given URI of this package.
   */ public
 long getLevel(String uri) {
    return libsbmlJNI.SBMLExtension_getLevel(swigCPtr, this, uri);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * Returns the SBML version associated with the given URI of this package.
   <p>
   * @param uri the string of URI that represents a versions of the package
   * @return the SBML version associated with the given URI of this package.
   */ public
 long getVersion(String uri) {
    return libsbmlJNI.SBMLExtension_getVersion(swigCPtr, this, uri);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * Returns the package version associated with the given URI of this package.
   <p>
   * @param uri the string of URI that represents a versions of this package
   * @return the package version associated with the given URI of this package.
   */ public
 long getPackageVersion(String uri) {
    return libsbmlJNI.SBMLExtension_getPackageVersion(swigCPtr, this, uri);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
   *           in their derived class.
   <p>
   * This method takes a type code of this package and returns a string 
   * representing the code.
   */ public
 String getStringFromTypeCode(int typeCode) {
    return libsbmlJNI.SBMLExtension_getStringFromTypeCode(swigCPtr, this, typeCode);
  }

  
/**
   *  (NOTICE) Package developers MUST OVERRIDE this pure virtual function in 
   *           their derived class.
   <p>
   * Returns an {@link SBMLExtensionNamespaces}<class SBMLExtensionType> object 
   * (e.g. {@link SBMLExtensionNamespaces}<LayoutExtension> whose alias type is 
   * LayoutPkgNamespaces) corresponding to the given uri.
   * Null will be returned if the given uri is not defined in the corresponding 
   * package.
   <p>
   * @param uri the string of URI that represents one of versions of the package
   * @return an {@link SBMLExtensionNamespaces}<class SBMLExtensionType> object. null
   *         will be returned if the given uri is not defined in the corresponding 
   *         package. 
   */ public
 SBMLNamespaces getSBMLExtensionNamespaces(String uri) {
  return libsbml.DowncastSBMLNamespaces(libsbmlJNI.SBMLExtension_getSBMLExtensionNamespaces(swigCPtr, this, uri), false);
}

  
/**
   * enable/disable this package.
   * Returned value is the result of this function.
   <p>
   * @param isEnabled the boolean value: true (enabled) or false (disabled)
   <p>
   * @return true if this function call succeeded, otherwise false is returned.
   */ public
 boolean setEnabled(boolean isEnabled) {
    return libsbmlJNI.SBMLExtension_setEnabled(swigCPtr, this, isEnabled);
  }

  
/**
   * Check if this package is enabled (true) or disabled (false).
   <p>
   * @return true if this package is enabled, otherwise false is returned.
   */ public
 boolean isEnabled() {
    return libsbmlJNI.SBMLExtension_isEnabled(swigCPtr, this);
  }

  
/**
   * Removes the L2 Namespaces. 
   <p>
   * This method should be overridden by all extensions that want to serialize
   * to an L2 annotation.
   */ public
 void removeL2Namespaces(XMLNamespaces xmlns) {
    libsbmlJNI.SBMLExtension_removeL2Namespaces(swigCPtr, this, XMLNamespaces.getCPtr(xmlns), xmlns);
  }

  
/**
   * Adds all L2 Extension namespaces to the namespace list. 
   <p>
   * This method should be overridden by all extensions that want to serialize
   * to an L2 annotation.
   */ public
 void addL2Namespaces(XMLNamespaces xmlns) {
    libsbmlJNI.SBMLExtension_addL2Namespaces(swigCPtr, this, XMLNamespaces.getCPtr(xmlns), xmlns);
  }

  
/**
   * Adds the L2 Namespace to the document and enables the extension.
   <p>
   * If the extension supports serialization to SBML L2 Annotations, this 
   * method should be overrridden, so it will be activated.
   */ public
 void enableL2NamespaceForDocument(SBMLDocument doc) {
    libsbmlJNI.SBMLExtension_enableL2NamespaceForDocument(swigCPtr, this, SBMLDocument.getCPtr(doc), doc);
  }

  
/** 
   * Indicates whether this extension is being used by the given {@link SBMLDocument}.
   <p>
   * The default implementation returns true. This means that when a document
   * had this extension enabled, it will not be possible to convert it to L2
   * as we cannot make sure that the extension can be converted.
   <p>
   * @param doc the SBML document to test. 
   <p>
   * @return a boolean indicating whether the extension is actually being used
   *         by the document. 
   */ public
 boolean isInUse(SBMLDocument doc) {
    return libsbmlJNI.SBMLExtension_isInUse(swigCPtr, this, SBMLDocument.getCPtr(doc), doc);
  }

  
/** * @internal */ public
 long getErrorTableIndex(long errorId) {
    return libsbmlJNI.SBMLExtension_getErrorTableIndex(swigCPtr, this, errorId);
  }

  public long getErrorIdOffset() {
    return libsbmlJNI.SBMLExtension_getErrorIdOffset(swigCPtr, this);
  }

  public long getSeverity(long index, long pkgVersion) {
    return libsbmlJNI.SBMLExtension_getSeverity(swigCPtr, this, index, pkgVersion);
  }

  public long getCategory(long index) {
    return libsbmlJNI.SBMLExtension_getCategory(swigCPtr, this, index);
  }

  public String getMessage(long index, long pkgVersion, String details) {
    return libsbmlJNI.SBMLExtension_getMessage(swigCPtr, this, index, pkgVersion, details);
  }

  public String getShortMessage(long index) {
    return libsbmlJNI.SBMLExtension_getShortMessage(swigCPtr, this, index);
  }

}
