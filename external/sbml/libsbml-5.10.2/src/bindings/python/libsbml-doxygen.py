# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libsbml', [dirname(__file__)])
        except ImportError:
            import _libsbml
            return _libsbml
        if fp is not None:
            try:
                _mod = imp.load_module('_libsbml', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libsbml = swig_import_helper()
    del swig_import_helper
else:
    import _libsbml
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class ModelCreatorList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelCreatorList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelCreatorList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_ModelCreatorList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ModelCreatorList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.ModelCreatorList_add(self, *args)
    def get(self, *args): return _libsbml.ModelCreatorList_get(self, *args)
    def prepend(self, *args): return _libsbml.ModelCreatorList_prepend(self, *args)
    def remove(self, *args): return _libsbml.ModelCreatorList_remove(self, *args)
    def getSize(self): return _libsbml.ModelCreatorList_getSize(self)
ModelCreatorList_swigregister = _libsbml.ModelCreatorList_swigregister
ModelCreatorList_swigregister(ModelCreatorList)

class DateList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DateList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DateList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_DateList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_DateList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.DateList_add(self, *args)
    def get(self, *args): return _libsbml.DateList_get(self, *args)
    def prepend(self, *args): return _libsbml.DateList_prepend(self, *args)
    def remove(self, *args): return _libsbml.DateList_remove(self, *args)
    def getSize(self): return _libsbml.DateList_getSize(self)
DateList_swigregister = _libsbml.DateList_swigregister
DateList_swigregister(DateList)

class CVTermList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CVTermList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CVTermList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_CVTermList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_CVTermList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.CVTermList_add(self, *args)
    def get(self, *args): return _libsbml.CVTermList_get(self, *args)
    def prepend(self, *args): return _libsbml.CVTermList_prepend(self, *args)
    def remove(self, *args): return _libsbml.CVTermList_remove(self, *args)
    def getSize(self): return _libsbml.CVTermList_getSize(self)
CVTermList_swigregister = _libsbml.CVTermList_swigregister
CVTermList_swigregister(CVTermList)

class ASTNodeList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASTNodeList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ASTNodeList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_ASTNodeList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ASTNodeList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.ASTNodeList_add(self, *args)
    def get(self, *args): return _libsbml.ASTNodeList_get(self, *args)
    def prepend(self, *args): return _libsbml.ASTNodeList_prepend(self, *args)
    def remove(self, *args): return _libsbml.ASTNodeList_remove(self, *args)
    def getSize(self): return _libsbml.ASTNodeList_getSize(self)
ASTNodeList_swigregister = _libsbml.ASTNodeList_swigregister
ASTNodeList_swigregister(ASTNodeList)

class SBMLNamespacesList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLNamespacesList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLNamespacesList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_SBMLNamespacesList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLNamespacesList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.SBMLNamespacesList_add(self, *args)
    def get(self, *args): return _libsbml.SBMLNamespacesList_get(self, *args)
    def prepend(self, *args): return _libsbml.SBMLNamespacesList_prepend(self, *args)
    def remove(self, *args): return _libsbml.SBMLNamespacesList_remove(self, *args)
    def getSize(self): return _libsbml.SBMLNamespacesList_getSize(self)
SBMLNamespacesList_swigregister = _libsbml.SBMLNamespacesList_swigregister
SBMLNamespacesList_swigregister(SBMLNamespacesList)

class SBaseList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBaseList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBaseList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libsbml.new_SBaseList()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBaseList
    __del__ = lambda self : None;
    def add(self, *args): return _libsbml.SBaseList_add(self, *args)
    def get(self, *args): return _libsbml.SBaseList_get(self, *args)
    def prepend(self, *args): return _libsbml.SBaseList_prepend(self, *args)
    def remove(self, *args): return _libsbml.SBaseList_remove(self, *args)
    def getSize(self): return _libsbml.SBaseList_getSize(self)
SBaseList_swigregister = _libsbml.SBaseList_swigregister
SBaseList_swigregister(SBaseList)

class AutoProperty(type):
    """
    Metaclass for automatically detecting getX/setX methods and adding
    properties to the class dictionary.

    This class is attached to SBase and automatically applies for all classes
    which inherit from it.  Its purpose is to make libSBML more convenient to
    use from Python.  It works by analyzing classes at class creation time
    (not at instantiation) and adding corresponding properties (directly
    calling C methods where possible) to the class dictionary.

    @note Currently this class only works for Python 2.x, but should not break
    in Python 3.
    """
    def __new__(cls, classname, bases, classdict):
        """
        Iterate over the items in the classdict looking for get/set pairs
        and declaring them as properties.
        """

        import re
        import keyword

        re_mangle = re.compile(r'[A-Za-z][a-z]+|[A-Z]+(?=$|[A-Z0-9])|\d+')
        re_id = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')
        re_getdoc = re.compile(r'^\s*[A-Za-z_][A-Za-z0-9_]*\(self\)')
        re_setdoc = re.compile(r'^\s*[A-Za-z_][A-Za-z0-9_]*\(self,[^,)]+\)')

        #convert ACapitalCasedStringXYZ123 -> a_capital_cased_string_xyz_123
        mangle_name = lambda x: ('_'.join(re_mangle.findall(x))).lower()

        get_methods = set()
        set_methods = set()
        swig_setter = classdict.get('__swig_setmethods__', {})

        #only search for get/set methods
        #we assume that any unset method also has either get or set
        #a small number of set without get cases exist so we can't only
        #search for get methods
        for k, v in classdict.items():
            name = k[3:]
            prefix = k[:3]
            mangled = mangle_name(name)
            if name:
                if callable(v):
                    if re_id.match(mangled) and mangled not in keyword.kwlist:
                        if prefix == 'get':
                            get_methods.add(name)
                        elif prefix == 'set':
                            set_methods.add(name)

        for name in get_methods | set_methods:

            mangled = mangle_name(name)

            #ListOfFoobars -> foobars
            if mangled.startswith('list_of_'):
                mangled = mangled[8:]

            getter = setter = deleter = None
            if name in get_methods:
                getter = classdict['get'+name]
            
                #this is a very dirty way of checking if the get method
                #requires extra arguments (and hence cannot be a property)
                #it should be possible to do this properly in SWIG?
                if getter.__doc__:
                    if not re_getdoc.match(getter.__doc__):
                        continue

                #use the c-level get function if the python function
                #only consists of a call to it
                cname = classname + '_get' + name
                #test if function is "return _libsbml.CLASS_getNAME(__args__)"
                if getter.func_code.co_names == ('_libsbml', cname):
                    getter = getattr(_libsbml, cname)
    
            if name in set_methods:
                setter = classdict['set'+name]
                if setter.__doc__:
                    if not re_setdoc.match(setter.__doc__):
                        continue

                cname = classname + '_set' + name
                if setter.func_code.co_names == ('_libsbml', cname):
                    setter = getattr(_libsbml, cname)
                #property fget does not get intercepted by __getattr__
                #but fset does, so we implement property setting via
                #the __swig_setmethods__ dict
                swig_setter[mangled] = setter
            
            if 'unset' + name in classdict:
                deleter = classdict['unset'+name]
                if deleter.__doc__:
                    #like a get method, a delete method should
                    #only require a self argument
                    if not re_getdoc.match(deleter.__doc__):
                        continue
                
                cname = classname + '_unset' + name
                if deleter.func_code.co_names == ('_libsbml', cname):
                    deleter = getattr(_libsbml, cname)

            if getter or setter or deleter:
                #fset is technically redundant since the method is dispatched
                #via _swig_setattr rather than through the property due to that
                #function not delegating to object.__setattr__ which properly
                #handles properties
                classdict[mangled] = property(fget=getter, fset=setter, fdel=deleter)

            def __repr__(self):
                desc = self.__class__.__name__
                if hasattr(self, '__len__'):
                    desc += '[%s]' % self.__len__()
                if hasattr(self, 'id') and self.id:
                    desc += ' %s' % self.id
                if hasattr(self, 'name') and self.name:
                    desc += ' "%s"' % self.name
                return '<' + desc + '>'
                
            if classdict.get('__repr__', None) in (_swig_repr, None):
                classdict['__repr__'] = __repr__


        return type.__new__(cls, classname, bases, classdict)


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _libsbml.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _libsbml.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _libsbml.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _libsbml.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _libsbml.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _libsbml.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _libsbml.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _libsbml.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _libsbml.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _libsbml.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _libsbml.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libsbml.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _libsbml.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class string(_object):
    """Proxy of C++ std::basic_string<(char)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, string, name)
    __repr__ = _swig_repr
    def length(self):
        """length(self) -> size_type"""
        return _libsbml.string_length(self)

    def max_size(self):
        """max_size(self) -> size_type"""
        return _libsbml.string_max_size(self)

    def copy(self, *args):
        """
        copy(self, char __s, size_type __n, size_type __pos = 0) -> size_type
        copy(self, char __s, size_type __n) -> size_type
        """
        return _libsbml.string_copy(self, *args)

    def c_str(self):
        """c_str(self) -> char"""
        return _libsbml.string_c_str(self)

    def find(self, *args):
        """
        find(self, char __s, size_type __pos, size_type __n) -> size_type
        find(self, string __str, size_type __pos = 0) -> size_type
        find(self, string __str) -> size_type
        find(self, char __c, size_type __pos = 0) -> size_type
        find(self, char __c) -> size_type
        """
        return _libsbml.string_find(self, *args)

    def rfind(self, *args):
        """
        rfind(self, string __str, size_type __pos = std::basic_string< char >::npos) -> size_type
        rfind(self, string __str) -> size_type
        rfind(self, char __s, size_type __pos, size_type __n) -> size_type
        rfind(self, char __c, size_type __pos = std::basic_string< char >::npos) -> size_type
        rfind(self, char __c) -> size_type
        """
        return _libsbml.string_rfind(self, *args)

    def find_first_of(self, *args):
        """
        find_first_of(self, string __str, size_type __pos = 0) -> size_type
        find_first_of(self, string __str) -> size_type
        find_first_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_first_of(self, char __c, size_type __pos = 0) -> size_type
        find_first_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_first_of(self, *args)

    def find_last_of(self, *args):
        """
        find_last_of(self, string __str, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_of(self, string __str) -> size_type
        find_last_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_last_of(self, char __c, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_last_of(self, *args)

    def find_first_not_of(self, *args):
        """
        find_first_not_of(self, string __str, size_type __pos = 0) -> size_type
        find_first_not_of(self, string __str) -> size_type
        find_first_not_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_first_not_of(self, char __c, size_type __pos = 0) -> size_type
        find_first_not_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_first_not_of(self, *args)

    def find_last_not_of(self, *args):
        """
        find_last_not_of(self, string __str, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_not_of(self, string __str) -> size_type
        find_last_not_of(self, char __s, size_type __pos, size_type __n) -> size_type
        find_last_not_of(self, char __c, size_type __pos = std::basic_string< char >::npos) -> size_type
        find_last_not_of(self, char __c) -> size_type
        """
        return _libsbml.string_find_last_not_of(self, *args)

    def substr(self, *args):
        """
        substr(self, size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string
        substr(self, size_type __pos = 0) -> string
        substr(self) -> string
        """
        return _libsbml.string_substr(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _libsbml.string_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _libsbml.string_size(self)

    def swap(self, *args):
        """swap(self, string v)"""
        return _libsbml.string_swap(self, *args)

    def erase(self, *args):
        """
        erase(self, size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string
        erase(self, size_type __pos = 0) -> string
        erase(self) -> string
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _libsbml.string_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, char __s, size_type __n) -> string
        __init__(self) -> string
        __init__(self, string arg0) -> string
        __init__(self, size_type size, value_type value) -> string
        """
        this = _libsbml.new_string(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, string __str) -> string
        assign(self, string __str, size_type __pos, size_type __n) -> string
        assign(self, char __s, size_type __n) -> string
        assign(self, size_type n, value_type x)
        """
        return _libsbml.string_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _libsbml.string_resize(self, *args)

    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _libsbml.string_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _libsbml.string___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _libsbml.string___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _libsbml.string___len__(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> string"""
        return _libsbml.string___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, string v = std::basic_string< char,std::char_traits< char >,std::allocator< char > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _libsbml.string___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _libsbml.string___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _libsbml.string___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> string
        __getitem__(self, difference_type i) -> value_type
        """
        return _libsbml.string___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, string v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _libsbml.string___setitem__(self, *args)

    def insert(self, *args):
        """
        insert(self, size_type __pos1, string __str) -> string
        insert(self, size_type __pos1, string __str, size_type __pos2, size_type __n) -> string
        insert(self, size_type __pos, char __s, size_type __n) -> string
        insert(self, size_type __pos, size_type __n, char __c) -> string
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        insert(self, iterator __p, size_type __n, char __c)
        """
        return _libsbml.string_insert(self, *args)

    def replace(self, *args):
        """
        replace(self, size_type __pos, size_type __n, string __str) -> string
        replace(self, size_type __pos1, size_type __n1, string __str, size_type __pos2, 
            size_type __n2) -> string
        replace(self, size_type __pos, size_type __n1, char __s, size_type __n2) -> string
        replace(self, size_type __pos, size_type __n1, size_type __n2, char __c) -> string
        replace(self, iterator __i1, iterator __i2, string __str) -> string
        replace(self, iterator __i1, iterator __i2, char __s, size_type __n) -> string
        replace(self, iterator __i1, iterator __i2, size_type __n, char __c) -> string
        replace(self, iterator __i1, iterator __i2, char __k1, char __k2) -> string
        replace(self, iterator __i1, iterator __i2, const_iterator __k1, 
            const_iterator __k2) -> string
        """
        return _libsbml.string_replace(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, string v) -> string"""
        return _libsbml.string___iadd__(self, *args)

    def __add__(self, *args):
        """__add__(self, string v) -> string"""
        return _libsbml.string___add__(self, *args)

    def __radd__(self, *args):
        """__radd__(self, string v) -> string"""
        return _libsbml.string___radd__(self, *args)

    def __str__(self):
        """__str__(self) -> string"""
        return _libsbml.string___str__(self)

    def __rlshift__(self, *args):
        """__rlshift__(self, ostream out) -> ostream"""
        return _libsbml.string___rlshift__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, string v) -> bool"""
        return _libsbml.string___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, string v) -> bool"""
        return _libsbml.string___ne__(self, *args)

    def __gt__(self, *args):
        """__gt__(self, string v) -> bool"""
        return _libsbml.string___gt__(self, *args)

    def __lt__(self, *args):
        """__lt__(self, string v) -> bool"""
        return _libsbml.string___lt__(self, *args)

    def __ge__(self, *args):
        """__ge__(self, string v) -> bool"""
        return _libsbml.string___ge__(self, *args)

    def __le__(self, *args):
        """__le__(self, string v) -> bool"""
        return _libsbml.string___le__(self, *args)

    __swig_destroy__ = _libsbml.delete_string
    __del__ = lambda self : None;
string_swigregister = _libsbml.string_swigregister
string_swigregister(string)
cvar = _libsbml.cvar
string.npos = _libsbml.cvar.string_npos

class ostream(_object):
    """Proxy of C++ std::basic_ostream<(char)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ostream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ostream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, std::basic_streambuf<(char,std::char_traits<(char)>)> __sb) -> ostream"""
        this = _libsbml.new_ostream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ostream
    __del__ = lambda self : None;
ostream_swigregister = _libsbml.ostream_swigregister
ostream_swigregister(ostream)

class ostringstream(ostream):
    """Proxy of C++ std::basic_ostringstream<(char)> class"""
    __swig_setmethods__ = {}
    for _s in [ostream]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ostringstream, name, value)
    __swig_getmethods__ = {}
    for _s in [ostream]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ostringstream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, std::ios_base::openmode __mode = std::ios_base::out) -> ostringstream
        __init__(self) -> ostringstream
        """
        this = _libsbml.new_ostringstream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ostringstream
    __del__ = lambda self : None;
    def str(self, *args):
        """
        str(self) -> string
        str(self, string __s)
        """
        return _libsbml.ostringstream_str(self, *args)

ostringstream_swigregister = _libsbml.ostringstream_swigregister
ostringstream_swigregister(ostringstream)


def endl(*args):
  """endl(ostream arg0) -> ostream"""
  return _libsbml.endl(*args)

def flush(*args):
  """flush(ostream arg0) -> ostream"""
  return _libsbml.flush(*args)
import sys
import os.path

# @cond doxygenLibsbmlInternal

def conditional_abspath (filename):
  """conditional_abspath (filename) -> filename

  Returns filename with an absolute path prepended, if necessary.
  Some combinations of platforms and underlying XML parsers *require*
  an absolute path to a filename while others do not.  This function
  encapsulates the appropriate logic.  It is used by readSBML() and
  SBMLReader.readSBML().
  """
  if sys.platform.find('cygwin') != -1:
    return filename
  else:
    return os.path.abspath(filename)

# @endcond

def readSBML(*args):
  """
  @copydoc doc_readsbmlfromfile

  This method is identical to
  SBMLReader::readSBMLFromFile(@if java String@endif).

  @param filename the name or full pathname of the file to be read.

  @return a pointer to the SBMLDocument object created from the SBML
  content in @p filename.

  @copydetails doc_note_sbmlreader_error_handling

  @see readSBMLFromString(@if java String@endif)
  @see SBMLError
  @see SBMLDocument
  """
  reader = SBMLReader()
  return reader.readSBML(args[0])

LIBSBML_DOTTED_VERSION = _libsbml.LIBSBML_DOTTED_VERSION
LIBSBML_VERSION = _libsbml.LIBSBML_VERSION
LIBSBML_VERSION_STRING = _libsbml.LIBSBML_VERSION_STRING

def getLibSBMLVersion():
  """
    getLibSBMLVersion() -> int

    Returns the version number of this copy of libSBML as an integer.

    @return the libSBML version as an integer; version 1.2.3 becomes 10203.

    """
  return _libsbml.getLibSBMLVersion()

def getLibSBMLDottedVersion():
  """
    getLibSBMLDottedVersion() -> char

    Returns the version number of this copy of libSBML as a string.

    @return the libSBML version as a string; version 1.2.3 becomes
    '1.2.3'.

    @see getLibSBMLVersionString()

    """
  return _libsbml.getLibSBMLDottedVersion()

def getLibSBMLVersionString():
  """
    getLibSBMLVersionString() -> char

    Returns the version number of this copy of libSBML as a string without
    periods.

    @return the libSBML version as a string: version 1.2.3 becomes '10203'.

    @see getLibSBMLDottedVersion()

    """
  return _libsbml.getLibSBMLVersionString()

def isLibSBMLCompiledWith(*args):
  """
    isLibSBMLCompiledWith(char option) -> int

    Returns an indication whether libSBML has been compiled with
    against a specific library. 

    @param option the library to test against, this can be one of
    'expat', 'libxml', 'xerces-c', 'bzip2', 'zip'

    @return 0 in case the libSBML has not been compiled against 
    that library and non-zero otherwise (for libraries 
    that define an integer version number that number will 
    be returned).

    @see getLibSBMLDependencyVersionOf()

    """
  return _libsbml.isLibSBMLCompiledWith(*args)

def getLibSBMLDependencyVersionOf(*args):
  """
    getLibSBMLDependencyVersionOf(char option) -> char

    Returns the version string for the dependency library used. 

    @param option the library for which the version
    should be retrieved, this can be one of
    'expat', 'libxml', 'xerces-c', 'bzip2', 'zip'

    @return None in case libSBML has not been compiled against 
    that library and a version string otherwise.

    @see isLibSBMLCompiledWith()

    """
  return _libsbml.getLibSBMLDependencyVersionOf(*args)
LIBSBML_OPERATION_SUCCESS = _libsbml.LIBSBML_OPERATION_SUCCESS
LIBSBML_INDEX_EXCEEDS_SIZE = _libsbml.LIBSBML_INDEX_EXCEEDS_SIZE
LIBSBML_UNEXPECTED_ATTRIBUTE = _libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE
LIBSBML_OPERATION_FAILED = _libsbml.LIBSBML_OPERATION_FAILED
LIBSBML_INVALID_ATTRIBUTE_VALUE = _libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE
LIBSBML_INVALID_OBJECT = _libsbml.LIBSBML_INVALID_OBJECT
LIBSBML_DUPLICATE_OBJECT_ID = _libsbml.LIBSBML_DUPLICATE_OBJECT_ID
LIBSBML_LEVEL_MISMATCH = _libsbml.LIBSBML_LEVEL_MISMATCH
LIBSBML_VERSION_MISMATCH = _libsbml.LIBSBML_VERSION_MISMATCH
LIBSBML_INVALID_XML_OPERATION = _libsbml.LIBSBML_INVALID_XML_OPERATION
LIBSBML_NAMESPACES_MISMATCH = _libsbml.LIBSBML_NAMESPACES_MISMATCH
LIBSBML_DUPLICATE_ANNOTATION_NS = _libsbml.LIBSBML_DUPLICATE_ANNOTATION_NS
LIBSBML_ANNOTATION_NAME_NOT_FOUND = _libsbml.LIBSBML_ANNOTATION_NAME_NOT_FOUND
LIBSBML_ANNOTATION_NS_NOT_FOUND = _libsbml.LIBSBML_ANNOTATION_NS_NOT_FOUND
LIBSBML_PKG_VERSION_MISMATCH = _libsbml.LIBSBML_PKG_VERSION_MISMATCH
LIBSBML_PKG_UNKNOWN = _libsbml.LIBSBML_PKG_UNKNOWN
LIBSBML_PKG_UNKNOWN_VERSION = _libsbml.LIBSBML_PKG_UNKNOWN_VERSION
LIBSBML_PKG_DISABLED = _libsbml.LIBSBML_PKG_DISABLED
LIBSBML_PKG_CONFLICTED_VERSION = _libsbml.LIBSBML_PKG_CONFLICTED_VERSION
LIBSBML_PKG_CONFLICT = _libsbml.LIBSBML_PKG_CONFLICT
LIBSBML_CONV_INVALID_TARGET_NAMESPACE = _libsbml.LIBSBML_CONV_INVALID_TARGET_NAMESPACE
LIBSBML_CONV_PKG_CONVERSION_NOT_AVAILABLE = _libsbml.LIBSBML_CONV_PKG_CONVERSION_NOT_AVAILABLE
LIBSBML_CONV_INVALID_SRC_DOCUMENT = _libsbml.LIBSBML_CONV_INVALID_SRC_DOCUMENT
LIBSBML_CONV_CONVERSION_NOT_AVAILABLE = _libsbml.LIBSBML_CONV_CONVERSION_NOT_AVAILABLE
LIBSBML_CONV_PKG_CONSIDERED_UNKNOWN = _libsbml.LIBSBML_CONV_PKG_CONSIDERED_UNKNOWN

def OperationReturnValue_toString(*args):
  """
    OperationReturnValue_toString(int returnValue) -> char

    This method takes an SBML operation return value and returns a string representing
    the code.

    @param returnValue the operation return value to convert to a string

    @return a human readable name for the given
    @if clike #OperationReturnValues_t value@else operation return value @endif.

    @note The caller does not own the returned string and is therefore not
    allowed to modify it.

    """
  return _libsbml.OperationReturnValue_toString(*args)
class IdList(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Maintains a list of SIds.
    @internal

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IdList, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IdList
        __init__(self, string commaSeparated) -> IdList

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html Maintains a list of SIds.
        @internal

        """
        this = _libsbml.new_IdList(*args)
        try: self.this.append(this)
        except: self.this = this
    def append(self, *args):
        """
        append(self, string id)

        @internal
        Appends id to the list of ids.

        @internal

        """
        return _libsbml.IdList_append(self, *args)

    def contains(self, *args):
        """
        contains(self, string id) -> bool

        @internal
        Returns true if id is already in this IdList, false otherwise.

        @return true if id is already in this IdList, false otherwise.

        @internal

        """
        return _libsbml.IdList_contains(self, *args)

    def removeIdsBefore(self, *args):
        """
        removeIdsBefore(self, string id)

        @internal
        Removes all ids in this IdList before the given @p id.

        @internal

        """
        return _libsbml.IdList_removeIdsBefore(self, *args)

    def size(self):
        """
        size(self) -> unsigned int

        @internal
        Returns the number of ids in this IdList.

        @return the number of ids in this IdList.

        @internal

        """
        return _libsbml.IdList_size(self)

    def clear(self):
        """clear(self)"""
        return _libsbml.IdList_clear(self)

    def at(self, *args):
        """at(self, int n) -> string"""
        return _libsbml.IdList_at(self, *args)

    __swig_destroy__ = _libsbml.delete_IdList
    __del__ = lambda self : None;
IdList_swigregister = _libsbml.IdList_swigregister
IdList_swigregister(IdList)
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

class IdentifierTransformer(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base class for identifier transformers.
    @internal

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdentifierTransformer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IdentifierTransformer, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> IdentifierTransformer

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html Base class for identifier transformers.
        @internal

        """
        if self.__class__ == IdentifierTransformer:
            _self = None
        else:
            _self = self
        this = _libsbml.new_IdentifierTransformer(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_IdentifierTransformer
    __del__ = lambda self : None;
    def transform(self, *args):
        """transform(self, SBase element) -> int"""
        return _libsbml.IdentifierTransformer_transform(self, *args)

    def __disown__(self):
        self.this.disown()
        _libsbml.disown_IdentifierTransformer(self)
        return weakref_proxy(self)
IdentifierTransformer_swigregister = _libsbml.IdentifierTransformer_swigregister
IdentifierTransformer_swigregister(IdentifierTransformer)

class ElementFilter(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base class for filter functions.

    @htmlinclude libsbml-facility-only-warning.html

    Some libSBML objects provide the ability to return lists of components.
    To provide callers with greater control over exactly what is
    returned, these methods take optional arguments in the form of filters.
    The ElementFilter class is the parent class for these filters.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElementFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElementFilter, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> ElementFilter

        Creates a new ElementFilter object.

        """
        if self.__class__ == ElementFilter:
            _self = None
        else:
            _self = self
        this = _libsbml.new_ElementFilter(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ElementFilter
    __del__ = lambda self : None;
    def filter(self, *args):
        """
        filter(self, SBase element) -> bool

        Predicate to test elements.

        This is the central predicate of the ElementFilter class.  In subclasses
        of ElementFilter, callers should implement this method such that it
        returns @c True for @p element arguments that are 'desirable' and @c False for those that are 'undesirable' in whatever filtering context the
        ElementFilter subclass is designed to be used.

        @param element the element to be tested.

        @return @c True if the @p element is desirable or should be kept,
        @c False otherwise.

        """
        return _libsbml.ElementFilter_filter(self, *args)

    def __disown__(self):
        self.this.disown()
        _libsbml.disown_ElementFilter(self)
        return weakref_proxy(self)
ElementFilter_swigregister = _libsbml.ElementFilter_swigregister
ElementFilter_swigregister(ElementFilter)

class SBMLReader(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html File and text-string SBML reader.

    @htmlinclude not-sbml-warning.html

    The SBMLReader class provides the main interface for reading SBML content
    from files and strings.  The methods for reading SBML all return an
    @if python @link libsbml.SBMLDocument SBMLDocument@endlink@else SBMLDocument@endif@~
    object representing the results.  In the case of failures (such as if the
    SBML contains errors or a file cannot be read), the errors will be
    recorded with the SBMLErrorLog object kept in the
    @if python @link libsbml.SBMLDocument SBMLDocument@endlink@else SBMLDocument@endif@~
    returned by SBMLReader.  Consequently, immediately after calling a method
    on SBMLReader, callers should always check for errors and warnings using
    the methods for this purpose provided by @if python @link
    libsbml.SBMLDocument SBMLDocument@endlink@else SBMLDocument@endif.

    For convenience as well as easy access from other languages besides C++,
    this file also defines two global functions, @sbmlfunction{readSBML,
    String} and @sbmlfunction{readSBMLFromString, String}.  They are
    equivalent to creating an SBMLReader object and then calling the
    @if python @link SBMLReader.readSBML() SBMLReader.readSBML()@endlink@endif@if java SBMLReader.readSBML()@endif@if cpp SBMLReader.readSBML()@endif@if csharp SBMLReader.readSBML()@endif@~ and
    @if python @link SBMLReader.readSBMLFromString() SBMLReader.readSBMLFromString()@endlink@endif@if java SBMLReader.readSBMLFromString()@endif@if cpp SBMLReader.readSBMLFromString()@endif@if csharp SBMLReader.readSBMLFromString()@endif@~ methods, respectively.

    @section compression Support for reading compressed files

    LibSBML provides support for reading (as well as writing) compressed
    SBML files.  The process is transparent to the calling
    application---the application does not need to do anything
    deliberate to invoke the functionality.  If a given SBML filename ends
    with an extension for the @em gzip, @em zip or @em bzip2 compression
    formats (respectively, @c .gz, @c .zip, or @c .bz2), then the methods
    @if python @link SBMLReader.readSBML() SBMLReader.readSBML()@endlink@endif@if java @link SBMLReader.readSBML() SBMLReader.readSBML(String)@endlink@endif@if cpp SBMLReader.readSBML()@endif@if csharp SBMLReader.readSBML()@endif@~ and
    @if python @link SBMLWriter.writeSBML() SBMLWriter.writeSBML()@endlink@endif@if java @link SBMLWriter.writeSBML() SBMLWriter.writeSBML(String)@endlink@endif@if cpp SBMLWriter.writeSBML()@endif@if csharp SBMLWriter.writeSBML()@endif@~
    will automatically decompress and compress the file while reading and
    writing it.  If the filename has no such extension, it will be read and
    written uncompressed as normal.

    The compression feature requires that the @em zlib (for @em gzip and @em
    zip formats) and/or @em bzip2 (for @em bzip2 format) be available on the
    system running libSBML, and that libSBML was configured with their
    support compiled-in.  Please see the libSBML
    @if java <a href='../../../libsbml-installation.html'>installation instructions</a> @else <a href='libsbml-installation.html'>installation instructions</a>@endif@~
    for more information about this.  The methods
    @if java SBMLReader.hasZlib()@else hasZlib()@endif@~ and
    @if java SBMLReader.hasBzip2()@else hasBzip2()@endif@~
    can be used by an application to query at run-time whether support
    for the compression libraries is available in the present copy of
    libSBML.

    Support for compression is not mandated by the SBML standard, but
    applications may find it helpful, particularly when large SBML models
    are being communicated across data links of limited bandwidth.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLReader, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> SBMLReader

        Creates a new SBMLReader object and returns it.

        The libSBML SBMLReader object offers methods for reading SBML in
        XML form from files and text strings.

        """
        this = _libsbml.new_SBMLReader()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLReader
    __del__ = lambda self : None;
    def readSBML(*args):
      """
      readSBML(self, string filename) -> SBMLDocument

      Reads an SBML document from a file.

      This method is identical to readSBMLFromFile().

      If the file named 'filename' does not exist or its content is not
      valid SBML, one or more errors will be logged with the SBMLDocument
      object returned by this method.  Callers can use the methods on
      SBMLDocument such as SBMLDocument.getNumErrors() and
      SBMLDocument.getError() to get the errors.  The object returned by
      SBMLDocument.getError() is an SBMLError object, and it has methods to
      get the error code, category, and severity level of the problem, as
      well as a textual description of the problem.  The possible severity
      levels range from informational messages to fatal errors; see the
      documentation for SBMLError for more information.

      If the file 'filename' could not be read, the file-reading error will
      appear first.  The error code can provide a clue about what happened.
      For example, a file might be unreadable (either because it does not
      actually exist or because the user does not have the necessary access
      priviledges to read it) or some sort of file operation error may have
      been reported by the underlying operating system.  Callers can check
      for these situations using a program fragment such as the following:

       reader = SBMLReader()
       doc    = reader.readSBML(filename)

       if doc.getNumErrors() > 0:
         if doc.getError(0).getErrorId() == libsbml.XMLFileUnreadable:
           # Handle case of unreadable file here.
         elif doc.getError(0).getErrorId() == libsbml.XMLFileOperationError:
           # Handle case of other file error here.
         else:
           # Handle other error cases here.

      If the given filename ends with the suffix \".gz\" (for example,
      \"myfile.xml.gz\"), the file is assumed to be compressed in gzip format
      and will be automatically decompressed upon reading.  Similarly, if the
      given filename ends with \".zip\" or \".bz2\", the file is assumed to be
      compressed in zip or bzip2 format (respectively).  Files whose names
      lack these suffixes will be read uncompressed.  Note that if the file
      is in zip format but the archive contains more than one file, only the
      first file in the archive will be read and the rest ignored.

      To read a gzip/zip file, libSBML needs to be configured and linked with
      the zlib library at compile time.  It also needs to be linked with the
      bzip2 library to read files in bzip2 format.  (Both of these are the
      default configurations for libSBML.)  Errors about unreadable files
      will be logged if a compressed filename is given and libSBML was not
      linked with the corresponding required library.

      Parameter 'filename is the name or full pathname of the file to be
      read.

      Returns a pointer to the SBMLDocument created from the SBML content.

      See also SBMLError.

      Note:

      LibSBML versions 2.x and later versions behave differently in
      error handling in several respects.  One difference is how early some
      errors are caught and whether libSBML continues processing a file in
      the face of some early errors.  In general, libSBML versions after 2.x
      stop parsing SBML inputs sooner than libSBML version 2.x in the face
      of XML errors, because the errors may invalidate any further SBML
      content.  For example, a missing XML declaration at the beginning of
      the file was ignored by libSBML 2.x but in version 3.x and later, it
      will cause libSBML to stop parsing the rest of the input altogether.
      While this behavior may seem more severe and intolerant, it was
      necessary in order to provide uniform behavior regardless of which
      underlying XML parser (Expat, Xerces, libxml2) is being used by
      libSBML.  The XML parsers themselves behave differently in their error
      reporting, and sometimes libSBML has to resort to the lowest common
      denominator.
      """
      args_copy    = list(args)
      args_copy[1] = conditional_abspath(args[1])
      return _libsbml.SBMLReader_readSBML(*args_copy)


    def readSBMLFromFile(*args):
      """
      @copydoc doc_readsbmlfromfile

      This method is identical to
      SBMLReader::readSBML(@if java String@endif).

      @param filename the name or full pathname of the file to be read.

      @return a pointer to the SBMLDocument object created from the SBML
      content in @p filename.

      @copydetails doc_note_sbmlreader_error_handling

      @see readSBMLFromString(@if java String@endif)
      @see SBMLError
      @see SBMLDocument
      """
      args_copy    = list(args)
      args_copy[1] = conditional_abspath(args[1])
      return _libsbml.SBMLReader_readSBML(*args_copy)


    def readSBMLFromString(self, *args):
        """
        readSBMLFromString(self, string xml) -> SBMLDocument

        Reads an SBML document from a text string.

        This method is flexible with respect to the presence of an XML
        declaration at the beginning of the string.  In particular, if the
        string in @p xml does not begin with the XML declaration
        @verbatim
        <?xml version='1.0' encoding='UTF-8'?>
        @endverbatim
        then this method will automatically prepend the declaration
        to @p xml.

        This method will log a fatal error if the content given in the parameter
        @p xml is not in SBML format.  See the method documentation for
        SBMLReader.readSBML() for an example of code for
        testing the returned error code.

        @param xml a string containing a full SBML model

        @return a pointer to the SBMLDocument created from the SBML content,
        or a null pointer if @p xml is null.

        @note When using this method to read an SBMLDocument that uses the SBML
        Level&nbsp;3 Hierarchical %Model Composition package (comp) the document
        location cannot be set automatically. Thus, if the model contains
        references to ExternalModelDefinition objects, it will be necessary to
        manually set the document URI location
        (SBMLDocument.setLocationURI() in order to facilitate
        resolving these models.

        @see SBMLReader.readSBML()

        """
        return _libsbml.SBMLReader_readSBMLFromString(self, *args)

    def hasZlib():
        """
        hasZlib() -> bool

        Static method; returns @c True if this copy of libSBML supports
        <i>gzip</I> and <i>zip</i> format compression.

        @return @c True if libSBML has been linked with the <i>zlib</i>
        library, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike hasBzip2() @else SBMLReader.hasBzip2()@endif@~

        """
        return _libsbml.SBMLReader_hasZlib()

    if _newclass:hasZlib = staticmethod(hasZlib)
    __swig_getmethods__["hasZlib"] = lambda x: hasZlib
    def hasBzip2():
        """
        hasBzip2() -> bool

        Static method; returns @c True if this copy of libSBML supports
        <i>bzip2</i> format compression.

        @return @c True if libSBML is linked with the <i>bzip2</i>
        libraries, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike hasZlib() @else SBMLReader.hasZlib()@endif@~

        """
        return _libsbml.SBMLReader_hasBzip2()

    if _newclass:hasBzip2 = staticmethod(hasBzip2)
    __swig_getmethods__["hasBzip2"] = lambda x: hasBzip2
    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLReader_swigregister = _libsbml.SBMLReader_swigregister
SBMLReader_swigregister(SBMLReader)

def SBMLReader_hasZlib():
  """
    SBMLReader_hasZlib() -> bool

    Static method; returns @c True if this copy of libSBML supports
    <i>gzip</I> and <i>zip</i> format compression.

    @return @c True if libSBML has been linked with the <i>zlib</i>
    library, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike hasBzip2() @else SBMLReader.hasBzip2()@endif@~

    """
  return _libsbml.SBMLReader_hasZlib()

def SBMLReader_hasBzip2():
  """
    SBMLReader_hasBzip2() -> bool

    Static method; returns @c True if this copy of libSBML supports
    <i>bzip2</i> format compression.

    @return @c True if libSBML is linked with the <i>bzip2</i>
    libraries, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike hasZlib() @else SBMLReader.hasZlib()@endif@~

    """
  return _libsbml.SBMLReader_hasBzip2()


def readSBMLFromFile(*args):
  """
    readSBMLFromFile(char filename) -> SBMLDocument_t

    Reads an SBML document from the given file.

    If the file named @p filename does not exist or its content is not
    valid SBML, one or more errors will be logged with the
    @if python @link libsbml.SBMLDocument SBMLDocument@endlink@else SBMLDocument@endif@~
    object returned by this method.  Callers can use the methods on
    @if python @link libsbml.SBMLDocument SBMLDocument@endlink@else SBMLDocument@endif@~ such as
    @if python @link libsbml.SBMLDocument.getNumErrors() SBMLDocument.getNumErrors()@endlink@else SBMLDocument.getNumErrors()@endif@~
    and
    @if python @link libsbml.SBMLDocument.getError() SBMLDocument.getError()@endlink@endif@if java SBMLDocument.getError()@endif@if cpp SBMLDocument.getError()@endif@if csharp SBMLDocument.getError()@endif@~
    to get the errors.  The object returned by
    @if python @link libsbml.SBMLDocument.getError() SBMLDocument.getError()@endlink@endif@if java SBMLDocument.getError()@endif@if cpp SBMLDocument.getError()@endif@if csharp SBMLDocument.getError()@endif@~
    is an SBMLError object, and it has methods to get the error code,
    category, and severity level of the problem, as well as a textual
    description of the problem.  The possible severity levels range from
    informational messages to fatal errors; see the documentation for
    @if python @link libsbml.SBMLError SBMLError@endlink@else SBMLError@endif@~
    for more information.

    If the file @p filename could not be read, the file-reading error will
    appear first.  The error code @if clike (a value drawn from the
    enumeration #XMLErrorCode_t)@endif@~ can provide a clue about what
    happened.  For example, a file might be unreadable (either because it does
    not actually exist or because the user does not have the necessary access
    priviledges to read it) or some sort of file operation error may have been
    reported by the underlying operating system.  Callers can check for these
    situations using a program fragment such as the following:
    @if cpp
    @code{.cpp}
    SBMLReader reader;
    SBMLDocument doc  = reader.readSBMLFromFile(filename);

    if (doc->getNumErrors() > 0)
    {
      if (doc->getError(0)->getErrorId() == XMLError::XMLFileUnreadable)
      {
        // Handle case of unreadable file here.
      }
      else if (doc->getError(0)->getErrorId() == XMLError::XMLFileOperationError)
      {
        // Handle case of other file operation error here.
      }
      else
      {
        // Handle other cases -- see error codes defined in XMLErrorCode_t
        // for other possible cases to check.
      }
    }
    @endcode
    @endif
    @if conly
    @code{.c}
    SBMLReader_t   *sr;
    SBMLDocument_t *d;

    sr = SBMLReader_create();

    d = SBMLReader_readSBML(sr, filename);

    if (SBMLDocument_getNumErrors(d) > 0)
    {
      if (XMLError_getId(SBMLDocument_getError(d, 0))
          == SBML_READ_ERROR_FILE_NOT_FOUND)
      {
         ...
      }
      if (XMLError_getId(SBMLDocument_getError(d, 0))
          == SBML_READ_ERROR_NOT_SBML)
      {
         ...
      }
    }
    @endcode
    @endif
    @if java
    @code{.java}
    SBMLReader reader = new SBMLReader();
    SBMLDocument doc  = reader.readSBMLFromFile(filename);

    if (doc.getNumErrors() > 0)
    {
        if (doc.getError(0).getErrorId() == libsbmlConstants.XMLFileUnreadable)
        {
            // Handle case of unreadable file here.
        }
        else if (doc.getError(0).getErrorId() == libsbmlConstants.XMLFileOperationError)
        {
            // Handle case of other file operation error here.
        }
        else
        {
            // Handle other error cases.
        }
    }
    @endcode
    @endif
    @if python
    @code{.py}
    reader = SBMLReader()
    if reader == None:
      # Handle the truly exceptional case of no object created here.

    doc = reader.readSBMLFromFile(filename)
    if doc.getNumErrors() > 0:
      if doc.getError(0).getErrorId() == XMLFileUnreadable:
        # Handle case of unreadable file here.
      elif doc.getError(0).getErrorId() == XMLFileOperationError:
        # Handle case of other file error here.
      else:
        # Handle other error cases here.
    @endcode
    @endif
    @if csharp
    @code{.cs}
    SBMLReader reader = new SBMLReader();
    SBMLDocument doc = reader.readSBMLFromFile(filename);

    if (doc.getNumErrors() > 0)
    {
        if (doc.getError(0).getErrorId() == libsbmlcs.libsbml.XMLFileUnreadable)
        {
             // Handle case of unreadable file here.
        }
        else if (doc.getError(0).getErrorId() == libsbmlcs.libsbml.XMLFileOperationError)
        {
             // Handle case of other file operation error here.
        }
        else
        {
             // Handle other cases -- see error codes defined in XMLErrorCode_t
             // for other possible cases to check.
        }
     }
    @endcode
    @endif@~

    @par
    If the given filename ends with the suffix @c '.gz' (for example, @c
    'myfile.xml.gz'), the file is assumed to be compressed in @em gzip
    format and will be automatically decompressed upon reading.
    Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the
    file is assumed to be compressed in @em zip or @em bzip2 format
    (respectively).  Files whose names lack these suffixes will be read
    uncompressed.  Note that if the file is in @em zip format but the
    archive contains more than one file, only the first file in the
    archive will be read and the rest ignored.

    @par
    To read a gzip/zip file, libSBML needs to be configured and linked with the
    <a target='_blank' href='http://www.zlib.net/'>zlib</a> library at compile
    time.  It also needs to be linked with the <a target='_blank'
    href=''>bzip2</a> library to read files in <em>bzip2</em> format.  (Both of
    these are the default configurations for libSBML.)  Errors about unreadable
    files will be logged if a compressed filename is given and libSBML was
    <em>not</em> linked with the corresponding required library.

    @param filename the name or full pathname of the file to be read.

    @return a pointer to the SBMLDocument structure created from the SBML
    content in @p filename.

    @if conly
    @memberof SBMLReader_t
    @endif

    """
  return _libsbml.readSBMLFromFile(*args)

def readSBMLFromString(*args):
  """
    readSBMLFromString(char xml) -> SBMLDocument_t

    Reads an SBML document from a text string.

    This method is flexible with respect to the presence of an XML
    declaration at the beginning of the string.  In particular, if the
    string in @p xml does not begin with the XML declaration
    @verbatim
    <?xml version='1.0' encoding='UTF-8'?>
    @endverbatim
    then this method will automatically prepend the declaration
    to @p xml.

    This method will log a fatal error if the content given in the parameter
    @p xml is not in SBML format.  See the method documentation for
    SBMLReader.readSBML() for an example of code for
    testing the returned error code.

    @param xml a string containing a full SBML model

    @return a pointer to the SBMLDocument structure created from the SBML
    content in @p xml.

    @note When using this method to read an SBMLDocument that uses the SBML
    Level&nbsp;3 Hierarchical %Model Composition package (comp) the document
    location cannot be set automatically. Thus, if the model contains
    references to ExternalModelDefinition objects, it will be necessary to
    manually set the document URI location
    (SBMLDocument.setLocationURI() in order to facilitate
    resolving these models.

    @if conly
    @memberof SBMLReader_t
    @endif

    """
  return _libsbml.readSBMLFromString(*args)
class SBMLWriter(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html File and text-string SBML writer.

    @htmlinclude not-sbml-warning.html

    The SBMLWriter class is the converse of SBMLReader, and provides the
    main interface for serializing SBML models into XML and writing the
    result to an output stream or to files and text strings.  The methods 
    for writing SBML all take an SBMLDocument object and a destination.  
    They return a boolean or integer value to indicate success or failure.

    @section sbmlwriter-compression Support for writing compressed files

    LibSBML provides support for writing (as well as reading) compressed
    SBML files.  The process is transparent to the calling
    application---the application does not need to do anything
    deliberate to invoke the functionality.  If a given SBML filename ends
    with an extension for the @em gzip, @em zip or @em bzip2 compression
    formats (respectively, <code>&quot;.gz&quot;</code>,
    <code>&quot;.zip&quot;</code>, or <code>&quot;.bz2&quot;</code>),
    then the methods
    SBMLWriter.writeSBML()
    and SBMLReader.readSBML()
    will automatically compress and decompress the file while writing and
    reading it.  If the filename has no such extension, it
    will be written and read uncompressed as normal.

    The compression feature requires that the @em zlib (for @em gzip and @em
    zip formats) and/or @em bzip2 (for @em bzip2 format) be available on the
    system running libSBML, and that libSBML was configured with their
    support compiled-in.  Please see the libSBML @if clike <a href='libsbml-installation.html'>installation instructions</a>@endif@if python <a href='libsbml-installation.html'>installation instructions</a>@endif@if java  <a href='../../../libsbml-installation.html'>installation instructions</a>@endif@~ for 
    more information about this.  The methods
    SBMLWriter.hasZlib() and
    SBMLWriter.hasBzip2()
    can be used by an application to query at run-time whether support
    for the compression libraries is available in the present copy of
    libSBML.

    Support for compression is not mandated by the SBML standard, but
    applications may find it helpful, particularly when large SBML models
    are being communicated across data links of limited bandwidth.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLWriter, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> SBMLWriter

        Creates a new SBMLWriter.

        The libSBML SBMLWriter objects offer methods for writing SBML in
        XML form to files and text strings.

        """
        this = _libsbml.new_SBMLWriter()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLWriter
    __del__ = lambda self : None;
    def setProgramName(self, *args):
        """
        setProgramName(self, string name) -> int

        Sets the name of this program, i.e., the program that is about to
        write out the SBMLDocument.

        If the program name and version are set (see
        SBMLWriter.setProgramVersion()), the
        following XML comment, intended for human consumption, will be written
        at the beginning of the XML document:
        @verbatim
         <!-- Created by <program name> version <program version>
         on yyyy-MM-dd HH:mm with libSBML version <libsbml version>. -->
         @endverbatim

        If the program name and version are not set at some point before
        calling the writeSBML() methods, no such comment is written out.

        @param name the name of this program (where 'this program' refers to
        program in which libSBML is embedded, not libSBML itself!)

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see setProgramVersion()

        """
        return _libsbml.SBMLWriter_setProgramName(self, *args)

    def setProgramVersion(self, *args):
        """
        setProgramVersion(self, string version) -> int

        Sets the version of this program, i.e., the program that is about to
        write out the SBMLDocument.

        If the program version and name are set (see
        SBMLWriter.setProgramName()), the
        following XML comment, intended for human consumption, will be written
        at the beginning of the document:
        @verbatim
         <!-- Created by <program name> version <program version>
         on yyyy-MM-dd HH:mm with libSBML version <libsbml version>. -->
         @endverbatim

        If the program version and name are not set at some point before
        calling the writeSBML() methods, no such comment is written out.

        @param version the version of this program (where 'this program'
        refers to program in which libSBML is embedded, not libSBML itself!)

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see setProgramName()

        """
        return _libsbml.SBMLWriter_setProgramVersion(self, *args)

    def writeSBML(self, *args):
        """
        writeSBML(self, SBMLDocument d, string filename) -> bool
        writeSBML(self, SBMLDocument d, ostream stream) -> bool

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeSBML(SBMLDocument d, string filename)</pre>

        Writes the given SBML document to filename.

        @htmlinclude assuming-compressed-file.html

        @param d the SBML document to be written

        @param filename the name or full pathname of the file where the SBML
        is to be written. 

        @return @c True on success and @c False if the filename could not be
        opened for writing.

        @note @htmlinclude note-writing-zipped-files.html

        @see setProgramVersion()
        @see setProgramName()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeSBML(SBMLDocument d, std::ostream stream)</pre>

        Writes the given SBML document to the output stream.

        @param d the SBML document to be written

        @param stream the stream object where the SBML is to be written.

        @return @c True on success and @c False if one of the underlying
        parser components fail (rare).

        @see setProgramVersion()
        @see setProgramName()

        """
        return _libsbml.SBMLWriter_writeSBML(self, *args)

    def writeToString(self, *args):
        """
        writeToString(self, SBMLDocument d) -> char

        @internal
        Writes the given SBML document to an in-memory string and returns a
        pointer to it.

        The string is owned by the caller and should be freed (with @c free())
        when no longer needed.

        @param d the SBML document to be written

        @return the string on success and @c 0 if one of the underlying parser
        components fail.

        @see setProgramVersion()
        @see setProgramName()

        @internal

        """
        return _libsbml.SBMLWriter_writeToString(self, *args)

    def writeSBMLToFile(self, *args):
        """
        writeSBMLToFile(self, SBMLDocument d, string filename) -> bool

        Writes the given SBML document to filename.

        @htmlinclude assuming-compressed-file.html

        @param d the SBML document to be written

        @param filename the name or full pathname of the file where the SBML
        is to be written. 

        @return @c True on success and @c False if the filename could not be
        opened for writing.

        @note @htmlinclude note-writing-zipped-files.html

        @see setProgramVersion()
        @see setProgramName()

        """
        return _libsbml.SBMLWriter_writeSBMLToFile(self, *args)

    def writeSBMLToString(self, *args):
        """
        writeSBMLToString(self, SBMLDocument d) -> char

        Writes the given SBML document to an in-memory string and returns a
        pointer to it.

        The string is owned by the caller and should be freed (with @c free())
        when no longer needed.

        @param d the SBML document to be written

        @return the string on success and @c 0 if one of the underlying parser
        components fail.

        @see setProgramVersion()
        @see setProgramName()

        """
        return _libsbml.SBMLWriter_writeSBMLToString(self, *args)

    def hasZlib():
        """
        hasZlib() -> bool

        Predicate returning @c True if this copy of libSBML has been linked
        with the <em>zlib</em> library.

        LibSBML supports reading and writing files compressed with either
        bzip2 or zip/gzip compression.  The facility depends on libSBML having
        been compiled with the necessary support libraries.  This method
        allows a calling program to inquire whether that is the case for the
        copy of libSBML it is using.

        @return @c True if libSBML is linked with zlib, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike hasBzip2() @else SBMLWriter.hasBzip2() @endif@~

        """
        return _libsbml.SBMLWriter_hasZlib()

    if _newclass:hasZlib = staticmethod(hasZlib)
    __swig_getmethods__["hasZlib"] = lambda x: hasZlib
    def hasBzip2():
        """
        hasBzip2() -> bool

        Predicate returning @c True if this copy of libSBML has been linked
        with the <em>bzip2</em> library.

        LibSBML supports reading and writing files compressed with either
        bzip2 or zip/gzip compression.  The facility depends on libSBML having
        been compiled with the necessary support libraries.  This method
        allows a calling program to inquire whether that is the case for the
        copy of libSBML it is using.

        @return @c True if libSBML is linked with bzip2, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike hasZlib() @else SBMLWriter.hasZlib() @endif@~

        """
        return _libsbml.SBMLWriter_hasBzip2()

    if _newclass:hasBzip2 = staticmethod(hasBzip2)
    __swig_getmethods__["hasBzip2"] = lambda x: hasBzip2
    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLWriter_swigregister = _libsbml.SBMLWriter_swigregister
SBMLWriter_swigregister(SBMLWriter)

def SBMLWriter_hasZlib():
  """
    SBMLWriter_hasZlib() -> bool

    Predicate returning @c True if this copy of libSBML has been linked
    with the <em>zlib</em> library.

    LibSBML supports reading and writing files compressed with either
    bzip2 or zip/gzip compression.  The facility depends on libSBML having
    been compiled with the necessary support libraries.  This method
    allows a calling program to inquire whether that is the case for the
    copy of libSBML it is using.

    @return @c True if libSBML is linked with zlib, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike hasBzip2() @else SBMLWriter.hasBzip2() @endif@~

    """
  return _libsbml.SBMLWriter_hasZlib()

def SBMLWriter_hasBzip2():
  """
    SBMLWriter_hasBzip2() -> bool

    Predicate returning @c True if this copy of libSBML has been linked
    with the <em>bzip2</em> library.

    LibSBML supports reading and writing files compressed with either
    bzip2 or zip/gzip compression.  The facility depends on libSBML having
    been compiled with the necessary support libraries.  This method
    allows a calling program to inquire whether that is the case for the
    copy of libSBML it is using.

    @return @c True if libSBML is linked with bzip2, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike hasZlib() @else SBMLWriter.hasZlib() @endif@~

    """
  return _libsbml.SBMLWriter_hasBzip2()


def writeSBML(*args):
  """
    writeSBML(SBMLDocument_t d, char filename) -> int

    Writes the given SBML document @p d to the file named by @p filename.
    This convenience function is functionally equivalent to:

    SBMLWriter_writeSBML(SBMLWriter_create(), d, filename);

    @htmlinclude assuming-compressed-file.html

    @param d the SBMLDocument object to be written out in XML format

    @param filename a string giving the path to a file where the XML
    content is to be written.

    @return @c 1 on success and @c 0 (zero) if @p filename could not be
    written.  Some possible reasons for failure include (a) being unable to
    open the file, and (b) using a filename that indicates a compressed SBML
    file (i.e., a filename ending in <code>&quot;.zip&quot;</code> or
    similar) when the compression functionality has not been enabled in
    the underlying copy of libSBML.

    @see SBMLWriter.hasZlib()
    @see SBMLWriter.hasBzip2()

    @if conly
    @memberof SBMLWriter_t
    @endif

    """
  return _libsbml.writeSBML(*args)

def writeSBMLToString(*args):
  """
    writeSBMLToString(SBMLDocument_t d) -> char

    Writes the given SBML document @p d to an in-memory string and returns a
    pointer to it.  The string is owned by the caller and should be freed
    (with free()) when no longer needed.  This convenience function is
    functionally equivalent to:

    SBMLWriter_writeSBMLToString(SBMLWriter_create(), d);

    but does not require the caller to create an SBMLWriter object first.

    @param d an SBMLDocument object to be written out in XML format

    @return the string on success and @c None if one of the underlying parser
    components fail.

    @if clike @warning Note that the string is owned by the caller and
    should be freed after it is no longer needed.@endif@~

    @if conly
    @memberof SBMLWriter_t
    @endif

    """
  return _libsbml.writeSBMLToString(*args)

def writeSBMLToFile(*args):
  """
    writeSBMLToFile(SBMLDocument_t d, char filename) -> int

    Writes the given SBML document @p d to the file @p filename.
    This convenience function is functionally equivalent to:

    SBMLWriter_writeSBMLToFile(SBMLWriter_create(), d, filename);

    but that does not require the caller to create an SBMLWriter object first.

    @htmlinclude assuming-compressed-file.html

    @param d an SBMLDocument object to be written out in XML format

    @param filename a string giving the path to a file where the XML
    content is to be written.

    @return @c 1 on success and @c 0 (zero) if @p filename could not be
    written.  Some possible reasons for failure include (a) being unable to
    open the file, and (b) using a filename that indicates a compressed SBML
    file (i.e., a filename ending in <code>&quot;.zip&quot;</code> or
    similar) when the compression functionality has not been enabled in
    the underlying copy of libSBML.

    @if clike @warning Note that the string is owned by the caller and
    should be freed (with the normal string <code>free()</code> C++
    function) after it is no longer needed.@endif@~

    @see SBMLWriter.hasZlib()
    @see SBMLWriter.hasBzip2()

    @if conly
    @memberof SBMLWriter_t
    @endif

    """
  return _libsbml.writeSBMLToFile(*args)
SBML_UNKNOWN = _libsbml.SBML_UNKNOWN
SBML_COMPARTMENT = _libsbml.SBML_COMPARTMENT
SBML_COMPARTMENT_TYPE = _libsbml.SBML_COMPARTMENT_TYPE
SBML_CONSTRAINT = _libsbml.SBML_CONSTRAINT
SBML_DOCUMENT = _libsbml.SBML_DOCUMENT
SBML_EVENT = _libsbml.SBML_EVENT
SBML_EVENT_ASSIGNMENT = _libsbml.SBML_EVENT_ASSIGNMENT
SBML_FUNCTION_DEFINITION = _libsbml.SBML_FUNCTION_DEFINITION
SBML_INITIAL_ASSIGNMENT = _libsbml.SBML_INITIAL_ASSIGNMENT
SBML_KINETIC_LAW = _libsbml.SBML_KINETIC_LAW
SBML_LIST_OF = _libsbml.SBML_LIST_OF
SBML_MODEL = _libsbml.SBML_MODEL
SBML_PARAMETER = _libsbml.SBML_PARAMETER
SBML_REACTION = _libsbml.SBML_REACTION
SBML_RULE = _libsbml.SBML_RULE
SBML_SPECIES = _libsbml.SBML_SPECIES
SBML_SPECIES_REFERENCE = _libsbml.SBML_SPECIES_REFERENCE
SBML_SPECIES_TYPE = _libsbml.SBML_SPECIES_TYPE
SBML_MODIFIER_SPECIES_REFERENCE = _libsbml.SBML_MODIFIER_SPECIES_REFERENCE
SBML_UNIT_DEFINITION = _libsbml.SBML_UNIT_DEFINITION
SBML_UNIT = _libsbml.SBML_UNIT
SBML_ALGEBRAIC_RULE = _libsbml.SBML_ALGEBRAIC_RULE
SBML_ASSIGNMENT_RULE = _libsbml.SBML_ASSIGNMENT_RULE
SBML_RATE_RULE = _libsbml.SBML_RATE_RULE
SBML_SPECIES_CONCENTRATION_RULE = _libsbml.SBML_SPECIES_CONCENTRATION_RULE
SBML_COMPARTMENT_VOLUME_RULE = _libsbml.SBML_COMPARTMENT_VOLUME_RULE
SBML_PARAMETER_RULE = _libsbml.SBML_PARAMETER_RULE
SBML_TRIGGER = _libsbml.SBML_TRIGGER
SBML_DELAY = _libsbml.SBML_DELAY
SBML_STOICHIOMETRY_MATH = _libsbml.SBML_STOICHIOMETRY_MATH
SBML_LOCAL_PARAMETER = _libsbml.SBML_LOCAL_PARAMETER
SBML_PRIORITY = _libsbml.SBML_PRIORITY
SBML_GENERIC_SBASE = _libsbml.SBML_GENERIC_SBASE

def SBMLTypeCode_toString(*args):
  """
    SBMLTypeCode_toString(int tc, char pkgName) -> char

    This method takes an SBML type code and returns a string representing
    the code.

    @if clike LibSBML attaches an identifying code to every kind of SBML
    object.  These are known as <em>SBML type codes</em>.  The set of
    possible type codes is defined in the enumeration #SBMLTypeCode_t.
    The names of the type codes all begin with the characters @c
    SBML_. @endif@if java LibSBML attaches an identifying code to every
    kind of SBML object.  These are known as <em>SBML type codes</em>.  In
    other languages, the set of type codes is stored in an enumeration; in
    the Java language interface for libSBML, the type codes are defined as
    static integer constants in the interface class {@link
    libsbmlConstants}.  The names of the type codes all begin with the
    characters @c SBML_. @endif@if python LibSBML attaches an identifying
    code to every kind of SBML object.  These are known as <em>SBML type
    codes</em>.  In the Python language interface for libSBML, the type
    codes are defined as static integer constants in the interface class
    @link libsbml@endlink.  The names of the type codes all begin with the
    characters @c SBML_. @endif@if csharp LibSBML attaches an identifying
    code to every kind of SBML object.  These are known as <em>SBML type
    codes</em>.  In the C# language interface for libSBML, the type codes
    are defined as static integer constants in the interface class @link
    libsbml@endlink.  The names of the type codes all begin with
    the characters @c SBML_. @endif@~

    @return a human readable name for the given
    @if clike #SBMLTypeCode_t value@else SBML type code@endif.

    @note The caller does not own the returned string and is therefore not
    allowed to modify it.

    """
  return _libsbml.SBMLTypeCode_toString(*args)
class SBase(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html SBML's <em>%SBase</em>, the base class of most SBML objects.

    Most components in SBML are derived from a single abstract base type,
    SBase.  In addition to serving as the parent class for most other
    classes of objects in SBML, this base type is designed to allow a
    modeler or a software package to attach arbitrary information to each
    major element or list in an SBML model.

    SBase has an optional subelement called 'notes'.  It is intended to
    serve as a place for storing optional information intended to be seen by
    humans.  An example use of the 'notes' element would be to contain
    formatted user comments about the model element in which the 'notes'
    element is enclosed.  There are certain conditions on the XHTML content
    permitted inside the 'notes' element; please consult the <a
    target='_blank' href='http://sbml.org/Documents/Specifications'>SBML
    specification document</a> corresponding to the SBML Level and Version
    of your model for more information about the requirements for 'notes'
    content.

    SBase has another optional subelement called 'annotation'.  Whereas the
    'notes' element described above is a container for content to be shown
    directly to humans, the 'annotation' element is a container for optional
    software-generated content @em not meant to be shown to humans.  The
    element's content type is <a target='_blank'
    href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
    'any'</a>, allowing essentially arbitrary data content.  SBML places
    only a few restrictions on the organization of the content; these are
    intended to help software tools read and write the data as well as help
    reduce conflicts between annotations added by different tools.  As is
    the case with 'notes', it is important to refer to the <a
    target='_blank' href='http://sbml.org/Documents/Specifications'>SBML
    specification document</a> corresponding to the SBML Level and Version
    of your model for more information about the requirements for
    'annotation' content.

    It is worth pointing out that the 'annotation' element in the definition
    of SBase exists in order that software developers may attach optional
    application-specific data to the elements in an SBML model.  However, it
    is important that this facility not be misused.  In particular, it is
    <em>critical</em> that data essential to a model definition or that can
    be encoded in existing SBML elements is <em>not</em> stored in
    'annotation'. Parameter values, functional dependencies between model
    elements, etc., should not be recorded as annotations.  It is crucial to
    keep in mind the fact that data placed in annotations can be freely
    ignored by software applications.  If such data affects the
    interpretation of a model, then software interoperability is greatly
    impeded.

    SBML Level 2 introduced an optional SBase attribute named 'metaid' for
    supporting metadata annotations using RDF (<a target='_blank'
    href='http://www.w3.org/RDF/'>Resource Description Format</a>). The
    attribute value has the data type <a
    href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML identifier
    type, which means each 'metaid' value must be globally unique within an
    SBML file.  (Importantly, this uniqueness criterion applies across any
    attribute with type <a href='http://www.w3.org/TR/REC-xml/#id'>XML
    ID</a>, not just the 'metaid' attribute used by SBML---something to
    be aware of if your application-specific XML content inside the
    'annotation' subelement happens to use <a
    href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)  The 'metaid' value
    serves to identify a model component for purposes such as referencing
    that component from metadata placed within 'annotation' subelements.

    Beginning with SBML Level 2 Version 3, SBase also has an optional
    attribute named 'sboTerm' for supporting the use of the Systems Biology
    Ontology.  In SBML proper, the data type of the attribute is a string of
    the form 'SBO:NNNNNNN', where 'NNNNNNN' is a seven digit integer number;
    libSBML simplifies the representation by only storing the 'NNNNNNN'
    integer portion.  Thus, in libSBML, the 'sboTerm' attribute on SBase has
    data type @c int, and SBO identifiers are stored simply as integers.
    (For convenience, SBase offers methods for returning both the integer
    form and a text-string form of the SBO identifier.)  SBO terms are a
    type of optional annotation, and each different class of SBML object
    derived from SBase imposes its own requirements about the values
    permitted for 'sboTerm'.  Please consult the SBML Level&nbsp;2
    Version&nbsp;4 specification for more information about the use of SBO
    and the 'sboTerm' attribute.

    Finally, note that, in the list of methods on SBase, there is no public
    constructor because SBase is an abstract class.  The constructors reside
    in the subclasses derived from SBase.


    @section sbase-miriam Standard format for annotations linking data resources

    SBML Level 2 Versions 2, 3 and 4, and Level&nbsp;3, define a proposed
    regular format for encoding two particular categories of annotations:
    (a) references to controlled vocabulary terms and database identifiers
    which define and describe biological and biochemical entities in a
    model; and (b) descriptions of the provenance of a model, including its
    author(s) and modification history.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBase
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBase

        Creates and returns a deep copy of this SBase object.

        @return the (deep) copy of this SBase object.

        """
        return _libsbml.SBase_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide @c SId namespace, or @c None if no such object is found.

        @param id string representing the 'id' attribute value of the object
        to find.

        @return pointer to the first element found with the given identifier.

        """
        return _libsbml.SBase_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with a specific 'metaid'
        attribute value, or @c None if no such object is found.

        @par
        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF (<a
        href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
        attribute value has the data type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
        identifier type, which means each 'metaid' value must be globally unique
        within an SBML file.  The latter point is important, because the
        uniqueness criterion applies across <em>any</em> attribute with type
        <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
        by SBML---something to be aware of if your application-specific XML
        content inside the 'annotation' subelement happens to use the XML
        <code>ID</code> type.  Although SBML itself specifies the use of <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
        the 'metaid' attribute, SBML-compatible applications should be careful if
        they use XML <code>ID</code>'s in XML portions of a model that are not
        defined by SBML, such as in the application-specific content of the
        'annotation' subelement.  Finally, note that LibSBML does not provide an
        explicit XML <code>ID</code> data type; it uses ordinary character
        strings, which is easier for applications to support.

        @param metaid string representing the 'metaid' attribute value of the
        object to find.

        @return pointer to the first element found with the given meta-identifier.

        """
        return _libsbml.SBase_getElementByMetaId(self, *args)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.SBase_renameSIdRefs(self, *args)

    def renameMetaIdRefs(self, *args):
        """
        renameMetaIdRefs(self, string oldid, string newid)

        Replaces all uses of a given meta identifier attribute value with
        another value.

        @par
        In SBML, object 'meta' identifiers are of the XML data type <code>ID</code>;
        the SBML object attribute itself is typically named <code>metaid</code>.  All
        attributes that hold values <em>referring</em> to values of type
        <code>ID</code> are of the XML data type <code>IDREF</code>.  They are also
        sometimes informally referred to as 'metaid refs', in analogy to the
        SBML-defined type <code>SIdRef</code>.

        This method works by looking at all meta-identifier attribute values,
        comparing the identifiers to the value of @p oldid.  If any matches are
        found, the matching identifiers are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.SBase_renameMetaIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.SBase_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        If this object has a child 'math' object (or anything with ASTNodes in
        general), replace all nodes with the name 'id' with the provided
        function.

        @note This function does nothing itself---subclasses with ASTNode
        subelements must override this function.

        @internal

        """
        return _libsbml.SBase_replaceSIDWithFunction(self, *args)

    def divideAssignmentsToSIdByFunction(self, *args):
        """
        divideAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If the function of this object is to assign a value has a child 'math'
        object (or anything with ASTNodes in general), replace the 'math'
        object with the function (existing/function).

        @note This function does nothing itself---subclasses with ASTNode
        subelements must override this function.

        @internal

        """
        return _libsbml.SBase_divideAssignmentsToSIdByFunction(self, *args)

    def multiplyAssignmentsToSIdByFunction(self, *args):
        """
        multiplyAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing*function).

        @internal

        """
        return _libsbml.SBase_multiplyAssignmentsToSIdByFunction(self, *args)

    def getElementFromPluginsBySId(self, *args):
        """
        getElementFromPluginsBySId(self, string id) -> SBase

        @internal
        Returns the first child element found that has the given @p id in the
        model-wide SId namespace from all plug-ins associated with this
        element, or @c None if no such object is found.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        @internal

        """
        return _libsbml.SBase_getElementFromPluginsBySId(self, *args)

    def getElementFromPluginsByMetaId(self, *args):
        """
        getElementFromPluginsByMetaId(self, string metaid) -> SBase

        @internal
        Returns the first child element it can find with the given @p metaid from
        all plug-ins associated with this element, or @c None if no such object
        is found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        @internal

        """
        return _libsbml.SBase_getElementFromPluginsByMetaId(self, *args)

    def hasNonstandardIdentifierBeginningWith(self, *args):
        """
        hasNonstandardIdentifierBeginningWith(self, string prefix) -> bool

        @internal
        Check to see if the given prefix is used by any of the IDs defined by
        extension elements *excluding* 'id' and 'metaid' attributes (as, for
        example, the spatial id attributes 'spid').

        @internal

        """
        return _libsbml.SBase_hasNonstandardIdentifierBeginningWith(self, *args)

    def prependStringToAllIdentifiers(self, *args):
        """
        prependStringToAllIdentifiers(self, string prefix) -> int

        @internal
        Add the given string to all identifiers in the object.  If the string
        is added to anything other than an id or a metaid, this code is
        responsible for tracking down and renaming all *idRefs in the package
        extention that identifier comes from.

        @internal

        """
        return _libsbml.SBase_prependStringToAllIdentifiers(self, *args)

    def transformIdentifiers(self, *args):
        """
        transformIdentifiers(self, IdentifierTransformer idTransformer) -> int

        @internal

        @internal

        """
        return _libsbml.SBase_transformIdentifiers(self, *args)

    def getMetaId(self):
        """
        getMetaId(self) -> string

        Returns the value of the 'metaid' attribute of this object.

        @par
        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF (<a
        href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
        attribute value has the data type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
        identifier type, which means each 'metaid' value must be globally unique
        within an SBML file.  The latter point is important, because the
        uniqueness criterion applies across <em>any</em> attribute with type
        <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
        by SBML---something to be aware of if your application-specific XML
        content inside the 'annotation' subelement happens to use the XML
        <code>ID</code> type.  Although SBML itself specifies the use of <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
        the 'metaid' attribute, SBML-compatible applications should be careful if
        they use XML <code>ID</code>'s in XML portions of a model that are not
        defined by SBML, such as in the application-specific content of the
        'annotation' subelement.  Finally, note that LibSBML does not provide an
        explicit XML <code>ID</code> data type; it uses ordinary character
        strings, which is easier for applications to support.

        @return the meta-identifier of this SBML object.

        @see isSetMetaId()
        @see setMetaId()

        """
        return _libsbml.SBase_getMetaId(self)

    def getId(self):
        """
        getId(self) -> string

        @internal

        @internal

        """
        return _libsbml.SBase_getId(self)

    def getName(self):
        """
        getName(self) -> string

        @internal

        @internal

        """
        return _libsbml.SBase_getName(self)

    def getNotes(self, *args):
        """
        getNotes(self) -> XMLNode
        getNotes(self) -> XMLNode

        Returns the content of the 'notes' subelement of this object as
        a tree of XMLNode objects.

        @par
        The optional SBML element named 'notes', present on every major SBML
        component type (and in SBML Level&nbsp;3, the 'message' subelement of
        Constraint), is intended as a place for storing optional information
        intended to be seen by humans.  An example use of the 'notes' element
        would be to contain formatted user comments about the model element in
        which the 'notes' element is enclosed.  Every object derived directly or
        indirectly from type SBase can have a separate value for 'notes', allowing
        users considerable freedom when adding comments to their models.

        The format of 'notes' elements conform to the definition of <a
        target='_blank' href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.
        However, the content cannot be @em entirely free-form; it must satisfy
        certain requirements defined in the <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specifications</a>
        for specific SBML Levels.  To help verify the formatting of 'notes'
        content, libSBML provides the static utility method
        SyntaxChecker.hasExpectedXHTMLSyntax(); this
        method implements a verification process that lets callers check whether
        the content of a given XMLNode object conforms to the SBML requirements
        for 'notes' and 'message' structure.  Developers are urged to consult the
        appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more in-depth
        explanations of using 'notes' in SBML.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element content
        must be structured. 

        The 'notes' element content returned by this method will be in XML
        form, but libSBML does not provide an object model specifically for
        the content of notes.  Callers will need to traverse the XML tree
        structure using the facilities available on XMLNode and related
        objects.  For an alternative method of accessing the notes, see
        getNotesString().

        @return the content of the 'notes' subelement of this SBML object as a
        tree structure composed of XMLNode objects.

        @see getNotesString()
        @see isSetNotes()
        @see setNotes()
        @see setNotes()
        @see appendNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()

        """
        return _libsbml.SBase_getNotes(self, *args)

    def getNotesString(self, *args):
        """
        getNotesString(self) -> string
        getNotesString(self) -> string

        Returns the content of the 'notes' subelement of this object as a
        string.

        @par
        The optional SBML element named 'notes', present on every major SBML
        component type (and in SBML Level&nbsp;3, the 'message' subelement of
        Constraint), is intended as a place for storing optional information
        intended to be seen by humans.  An example use of the 'notes' element
        would be to contain formatted user comments about the model element in
        which the 'notes' element is enclosed.  Every object derived directly or
        indirectly from type SBase can have a separate value for 'notes', allowing
        users considerable freedom when adding comments to their models.

        The format of 'notes' elements conform to the definition of <a
        target='_blank' href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.
        However, the content cannot be @em entirely free-form; it must satisfy
        certain requirements defined in the <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specifications</a>
        for specific SBML Levels.  To help verify the formatting of 'notes'
        content, libSBML provides the static utility method
        SyntaxChecker.hasExpectedXHTMLSyntax(); this
        method implements a verification process that lets callers check whether
        the content of a given XMLNode object conforms to the SBML requirements
        for 'notes' and 'message' structure.  Developers are urged to consult the
        appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more in-depth
        explanations of using 'notes' in SBML.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element content
        must be structured. 

        For an alternative method of accessing the notes, see getNotes(),
        which returns the content as an XMLNode tree structure.  Depending on
        an application's needs, one or the other method may be more
        convenient.

        @return the content of the 'notes' subelement of this SBML object as a
        string.

        @see getNotes()
        @see isSetNotes()
        @see setNotes()
        @see setNotes()
        @see appendNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()

        """
        return _libsbml.SBase_getNotesString(self, *args)

    def getAnnotation(self, *args):
        """
        getAnnotation(self) -> XMLNode
        getAnnotation(self) -> XMLNode

        Returns the content of the 'annotation' subelement of this object as
        a tree of XMLNode objects.

        @par
        Whereas the SBML 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details. 

        The annotations returned by this method will be in XML form.  LibSBML
        provides an object model and related interfaces for certain specific
        kinds of annotations, namely model history information and RDF
        content.  See the ModelHistory, CVTerm and RDFAnnotationParser classes
        for more information about the facilities available.

        @return the annotation of this SBML object as a tree of XMLNode objects.

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()

        """
        return _libsbml.SBase_getAnnotation(self, *args)

    def getAnnotationString(self, *args):
        """
        getAnnotationString(self) -> string
        getAnnotationString(self) -> string

        Returns the content of the 'annotation' subelement of this object as a
        character string.

        @par
        Whereas the SBML 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details. 

        The annotations returned by this method will be in string form.  See the
        method getAnnotation() for a version that returns annotations in XML form.

        @return the annotation of this SBML object as a character string.

        @see getAnnotation()
        @see isSetAnnotation()
        @see setAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()

        """
        return _libsbml.SBase_getAnnotationString(self, *args)

    def getNamespaces(self):
        """
        getNamespaces(self) -> XMLNamespaces

        Returns a list of the XML Namespaces declared on this SBML document.

        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.

        @return the XML Namespaces associated with this SBML object, or @c None
        in certain very usual circumstances where a namespace is not set.

        @see getLevel()
        @see getVersion()

        """
        return _libsbml.SBase_getNamespaces(self)

    def getSBMLDocument(self, *args):
        """
        getSBMLDocument(self) -> SBMLDocument
        getSBMLDocument(self) -> SBMLDocument

        Returns the SBMLDocument object containing @em this object instance.

        @par
        LibSBML uses the class SBMLDocument as a top-level container for
        storing SBML content and data associated with it (such as warnings and
        error messages).  An SBML model in libSBML is contained inside an
        SBMLDocument object.  SBMLDocument corresponds roughly to the class
        <i>SBML</i> defined in the SBML Level&nbsp;3 and Level&nbsp;2
        specifications, but it does not have a direct correspondence in SBML
        Level&nbsp;1.  (But, it is created by libSBML no matter whether the
        model is Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)

        This method allows the caller to obtain the SBMLDocument for the
        current object.

        @return the parent SBMLDocument object of this SBML object.

        @see getParentSBMLObject()
        @see getModel()

        """
        return _libsbml.SBase_getSBMLDocument(self, *args)

    def getParentSBMLObject(self, *args):
        """
        getParentSBMLObject(self) -> SBase
        getParentSBMLObject(self) -> SBase

        Returns the parent SBML object containing this object.

        This returns the immediately-containing object.  This method is
        convenient when holding an object nested inside other objects in an
        SBML model.  

        @return the parent SBML object of this SBML object.

        @see getSBMLDocument()
        @see getModel()

        """
        return _libsbml.SBase_getParentSBMLObject(self, *args)

    def getAncestorOfType(self, *args):
        """
        getAncestorOfType(self, int type, string pkgName = "core") -> SBase
        getAncestorOfType(self, int type) -> SBase
        getAncestorOfType(self, int type, string pkgName = "core") -> SBase
        getAncestorOfType(self, int type) -> SBase

        Returns the first ancestor object that has the given SBML type code from the given package.

        @if clike LibSBML attaches an identifying code to every kind of SBML
        object.  These are known as <em>SBML type codes</em>.  The set of
        possible type codes is defined in the enumeration #SBMLTypeCode_t.
        The names of the type codes all begin with the characters @c
        SBML_. @endif@if java LibSBML attaches an identifying code to every
        kind of SBML object.  These are known as <em>SBML type codes</em>.  In
        other languages, the set of type codes is stored in an enumeration; in
        the Java language interface for libSBML, the type codes are defined as
        static integer constants in the interface class {@link
        libsbmlConstants}.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if python LibSBML attaches an identifying
        code to every kind of SBML object.  These are known as <em>SBML type
        codes</em>.  In the Python language interface for libSBML, the type
        codes are defined as static integer constants in the interface class
        @link libsbml@endlink.  The names of the type codes all begin with the
        characters @c SBML_. @endif@if csharp LibSBML attaches an identifying
        code to every kind of SBML object.  These are known as <em>SBML type
        codes</em>.  In the C# language interface for libSBML, the type codes
        are defined as static integer constants in the interface class @link
        libsbmlcs.libsbml libsbml@endlink.  The names of the type codes all begin with
        the characters @c SBML_. @endif@~

        This method searches the tree of objects that are parents of this
        object, and returns the first one that has the given SBML type code from 
        the given @p pkgName.

        @param type the SBML type code of the object sought

        @param pkgName (optional) the short name of an SBML Level&nbsp;3
        package to which the sought-after object must belong

        @return the ancestor SBML object of this SBML object that corresponds
        to the given @if clike #SBMLTypeCode_t value@else SBML object type
        code@endif, or @c None if no ancestor exists.

        @warning The optional argument @p pkgName must be used for all type codes
        from SBML Level&nbsp;3 packages.  Otherwise, the function will search the 
        'core' namespace alone, not find any corresponding elements, and return 
        None.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.SBase_getAncestorOfType(self, *args)

    def getSBOTerm(self):
        """
        getSBOTerm(self) -> int

        Returns the integer portion of the value of the 'sboTerm' attribute of
        this object.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers.  (For convenience, libSBML offers
        methods for returning both the integer form and a text-string form of
        the SBO identifier.)

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @return the value of the 'sboTerm' attribute as an integer, or @c -1
        if the value is not set.

        """
        return _libsbml.SBase_getSBOTerm(self)

    def getSBOTermID(self):
        """
        getSBOTermID(self) -> string

        Returns the string representation of the 'sboTerm' attribute of
        this object.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers.  This method returns the entire SBO
        identifier as a text string in the form 'SBO:NNNNNNN'.

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @return the value of the 'sboTerm' attribute as a string (its value
        will be of the form 'SBO:NNNNNNN'), or an empty string if
        the value is not set.

        """
        return _libsbml.SBase_getSBOTermID(self)

    def getSBOTermAsURL(self):
        """
        getSBOTermAsURL(self) -> string

        Returns the identifiers.org URL representation of the 'sboTerm' attribute of
        this object.

        This method returns the entire SBO
        identifier as a text string in the form 
        'http://identifiers.org/biomodels.sbo/SBO:NNNNNNN'.

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @return the value of the 'sboTerm' attribute as an identifiers.org URL
        (its value will be of the form 
        'http://identifiers.org/biomodels.sbo/SBO:NNNNNNN'), or an empty string if
        the value is not set.

        """
        return _libsbml.SBase_getSBOTermAsURL(self)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        Returns the line number on which this object first appears in the XML
        representation of the SBML document.

        @return the line number of this SBML object.

        @note The line number for each construct in an SBML model is set upon
        reading the model.  The accuracy of the line number depends on the
        correctness of the XML representation of the model, and on the
        particular XML parser library being used.  The former limitation
        relates to the following problem: if the model is actually invalid
        XML, then the parser may not be able to interpret the data correctly
        and consequently may not be able to establish the real line number.
        The latter limitation is simply that different parsers seem to have
        their own accuracy limitations, and out of all the parsers supported
        by libSBML, none have been 100% accurate in all situations. (At this
        time, libSBML supports the use of <a target='_blank'
        href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'
        href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'
        href='http://xerces.apache.org/xerces-c/'>Xerces</a>.)

        @see getColumn()

        """
        return _libsbml.SBase_getLine(self)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        Returns the column number on which this object first appears in the XML
        representation of the SBML document.

        @return the column number of this SBML object.

        @note The column number for each construct in an SBML model is set
        upon reading the model.  The accuracy of the column number depends on
        the correctness of the XML representation of the model, and on the
        particular XML parser library being used.  The former limitation
        relates to the following problem: if the model is actually invalid
        XML, then the parser may not be able to interpret the data correctly
        and consequently may not be able to establish the real column number.
        The latter limitation is simply that different parsers seem to have
        their own accuracy limitations, and out of all the parsers supported
        by libSBML, none have been 100% accurate in all situations. (At this
        time, libSBML supports the use of <a target='_blank'
        href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'
        href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'
        href='http://xerces.apache.org/xerces-c/'>Xerces</a>.)

        @see getLine()

        """
        return _libsbml.SBase_getColumn(self)

    def getModelHistory(self, *args):
        """
        getModelHistory(self) -> ModelHistory
        getModelHistory(self) -> ModelHistory

        Returns the ModelHistory object, if any, attached to this object.

        @return the ModelHistory object attached to this object, or @c None if
        none exist.

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.

        """
        return _libsbml.SBase_getModelHistory(self, *args)

    def isSetMetaId(self):
        """
        isSetMetaId(self) -> bool

        Predicate returning @c True if this object's 'metaid' attribute is set.

        @par
        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF (<a
        href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
        attribute value has the data type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
        identifier type, which means each 'metaid' value must be globally unique
        within an SBML file.  The latter point is important, because the
        uniqueness criterion applies across <em>any</em> attribute with type
        <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
        by SBML---something to be aware of if your application-specific XML
        content inside the 'annotation' subelement happens to use the XML
        <code>ID</code> type.  Although SBML itself specifies the use of <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
        the 'metaid' attribute, SBML-compatible applications should be careful if
        they use XML <code>ID</code>'s in XML portions of a model that are not
        defined by SBML, such as in the application-specific content of the
        'annotation' subelement.  Finally, note that LibSBML does not provide an
        explicit XML <code>ID</code> data type; it uses ordinary character
        strings, which is easier for applications to support. 

        @return @c True if the 'metaid' attribute of this SBML object is
        set, @c False otherwise.

        @see getMetaId()
        @see setMetaId()

        """
        return _libsbml.SBase_isSetMetaId(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        @internal

        @internal

        """
        return _libsbml.SBase_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        @internal

        @internal

        """
        return _libsbml.SBase_isSetName(self)

    def isSetNotes(self):
        """
        isSetNotes(self) -> bool

        Predicate returning @c True if this
        object's 'notes' subelement exists and has content.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @return @c True if a 'notes' subelement exists, @c False otherwise.

        @see getNotes()
        @see getNotesString()
        @see setNotes()
        @see setNotes()
        @see appendNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()

        """
        return _libsbml.SBase_isSetNotes(self)

    def isSetAnnotation(self):
        """
        isSetAnnotation(self) -> bool

        Predicate returning @c True if this
        object's 'annotation' subelement exists and has content.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        @return @c True if a 'annotation' subelement exists, @c False
        otherwise.

        @see getAnnotation()
        @see getAnnotationString()
        @see setAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()

        """
        return _libsbml.SBase_isSetAnnotation(self)

    def isSetSBOTerm(self):
        """
        isSetSBOTerm(self) -> bool

        Predicate returning @c True if this
        object's 'sboTerm' attribute is set.

        @return @c True if the 'sboTerm' attribute of this SBML object is
        set, @c False otherwise.

        """
        return _libsbml.SBase_isSetSBOTerm(self)

    def setMetaId(self, *args):
        """
        setMetaId(self, string metaid) -> int

        Sets the value of the meta-identifier attribute of this object.

        @par
        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF (<a
        href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
        attribute value has the data type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
        identifier type, which means each 'metaid' value must be globally unique
        within an SBML file.  The latter point is important, because the
        uniqueness criterion applies across <em>any</em> attribute with type
        <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
        by SBML---something to be aware of if your application-specific XML
        content inside the 'annotation' subelement happens to use the XML
        <code>ID</code> type.  Although SBML itself specifies the use of <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
        the 'metaid' attribute, SBML-compatible applications should be careful if
        they use XML <code>ID</code>'s in XML portions of a model that are not
        defined by SBML, such as in the application-specific content of the
        'annotation' subelement.  Finally, note that LibSBML does not provide an
        explicit XML <code>ID</code> data type; it uses ordinary character
        strings, which is easier for applications to support. 

        The string @p metaid is copied.  

        @param metaid the identifier string to use as the value of the
        'metaid' attribute

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @see getMetaId()
        @see isSetMetaId()

        """
        return _libsbml.SBase_setMetaId(self, *args)

    def isSetModelHistory(self):
        """
        isSetModelHistory(self) -> bool

        Predicate returning @c True if this
        object has a ModelHistory object attached to it.

        @return @c True if the ModelHistory of this object is set, @c False otherwise.

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.

        """
        return _libsbml.SBase_isSetModelHistory(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        @internal

        @internal

        """
        return _libsbml.SBase_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        @internal

        @internal

        """
        return _libsbml.SBase_setName(self, *args)

    def setAnnotation(self, *args):
        """
        setAnnotation(self, XMLNode annotation) -> int
        setAnnotation(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setAnnotation(XMLNode annotation)</pre>

        Sets the value of the 'annotation' subelement of this SBML object.

        The content of @p annotation is copied, and any previous content of
        this object's 'annotation' subelement is deleted.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Call this method will result in any existing content of the
        'annotation' subelement to be discarded.  Unless you have taken steps
        to first copy and reconstitute any existing annotations into the @p
        annotation that is about to be assigned, it is likely that performing
        such wholesale replacement is unfriendly towards other software
        applications whose annotations are discarded.  An alternative may be
        to use SBase.appendAnnotation() or
        SBase.appendAnnotation().

        @param annotation an XML structure that is to be used as the new content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setAnnotation(string annotation)</pre>

        Sets the value of the 'annotation' subelement of this SBML object.

        The content of @p annotation is copied, and any previous content of
        this object's 'annotation' subelement is deleted.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Call this method will result in any existing content of the
        'annotation' subelement to be discarded.  Unless you have taken steps
        to first copy and reconstitute any existing annotations into the @p
        annotation that is about to be assigned, it is likely that performing
        such wholesale replacement is unfriendly towards other software
        applications whose annotations are discarded.  An alternative may be
        to use SBase.appendAnnotation() or
        SBase.appendAnnotation().

        @param annotation an XML string that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()

        """
        return _libsbml.SBase_setAnnotation(self, *args)

    def appendAnnotation(self, *args):
        """
        appendAnnotation(self, XMLNode annotation) -> int
        appendAnnotation(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendAnnotation(XMLNode annotation)</pre>

        Appends the given @p annotation to the 'annotation' subelement of this
        object.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a
        target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type 'any'</a>,
        allowing essentially arbitrary well-formed XML data content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Unlike SBase.setAnnotation() or
        SBase.setAnnotation(), this method
        allows other annotations to be preserved when an application adds its
        own data.

        @param annotation an XML structure that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendAnnotation(string annotation)</pre>

        Appends the given @p annotation to the 'annotation' subelement of this
        object.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a
        target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type 'any'</a>,
        allowing essentially arbitrary well-formed XML data content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Unlike SBase.setAnnotation() or
        SBase.setAnnotation(), this method
        allows other annotations to be preserved when an application adds its
        own data.

        @param annotation an XML string that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see unsetAnnotation()

        """
        return _libsbml.SBase_appendAnnotation(self, *args)

    def removeTopLevelAnnotationElement(self, *args):
        """
        removeTopLevelAnnotationElement(self, string elementName, string elementURI = "", bool removeEmpty = True) -> int
        removeTopLevelAnnotationElement(self, string elementName, string elementURI = "") -> int
        removeTopLevelAnnotationElement(self, string elementName) -> int

        Removes the top-level element within the 'annotation' subelement of this
        SBML object with the given name and optional URI.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        Calling this method allows a particular annotation element to be removed
        whilst the remaining annotations remain intact.

        @param elementName a string representing the name of the top level
        annotation element that is to be removed
        @param elementURI an optional string that is used to check both the name
        and URI of the top level element to be removed
        @param removeEmpty if after removing of the element, the annotation is 
        empty, and the removeEmpty argument is true, the annotation node will be 
        deleted (default). 

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_ANNOTATION_NAME_NOT_FOUND LIBSBML_ANNOTATION_NAME_NOT_FOUND@endlink
        @li @link libsbml#LIBSBML_ANNOTATION_NS_NOT_FOUND LIBSBML_ANNOTATION_NS_NOT_FOUND@endlink

        @see replaceTopLevelAnnotationElement()
        @see replaceTopLevelAnnotationElement()

        """
        return _libsbml.SBase_removeTopLevelAnnotationElement(self, *args)

    def replaceTopLevelAnnotationElement(self, *args):
        """
        replaceTopLevelAnnotationElement(self, XMLNode annotation) -> int
        replaceTopLevelAnnotationElement(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>replaceTopLevelAnnotationElement(XMLNode annotation)</pre>

        Replaces the given top-level element within the 'annotation' 
        subelement of this SBML object and with the annotation element supplied.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        This method determines the name of the element to be replaced from the
        annotation argument. Functionally it is equivalent to calling <code>
        removeTopLevelAnnotationElement(name)</code> followed by calling
        <code>appendAnnotation(annotation_with_name)</code>, with the exception
        that the placement of the annotation element remains the same.

        @param annotation XMLNode representing the replacement top level annotation 

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see removeTopLevelAnnotationElement()
        @see replaceTopLevelAnnotationElement()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>replaceTopLevelAnnotationElement(string annotation)</pre>

        Replaces the given top-level element within the 'annotation' 
        subelement of this SBML object and with the annotation element supplied.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        This method determines the name of the element to be replaced from the
        annotation argument. Functionally it is equivalent to calling <code>
        removeTopLevelAnnotationElement(name)</code> followed by calling
        <code>appendAnnotation(annotation_with_name)</code>, with the exception
        that the placement of the annotation element remains the same.

        @param annotation string representing the replacement top level annotation 

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see removeTopLevelAnnotationElement()
        @see replaceTopLevelAnnotationElement()

        """
        return _libsbml.SBase_replaceTopLevelAnnotationElement(self, *args)

    def setNotes(self, *args):
        """
        setNotes(self, XMLNode notes) -> int
        setNotes(self, string notes, bool addXHTMLMarkup = False) -> int
        setNotes(self, string notes) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setNotes(string notes, bool addXHTMLMarkup = false)</pre>

        Sets the value of the 'notes' subelement of this SBML object to a copy
        of the string @p notes.

        The content of @p notes is copied, and any existing content of this
        object's 'notes' subelement is deleted.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        The following code illustrates a very simple way of setting the notes
        using this method.  Here, the object being annotated is the whole SBML
        document, but that is for illustration purposes only; you could of
        course use this same approach to annotate any other SBML component.
        @if cpp
        @code{.cpp}
        SBMLDocument s = new SBMLDocument(3, 1);
        s->setNotes('<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>');
        @endcode
        @endif
        @if java
        @code{.java}
        SBMLDocument s = new SBMLDocument(3, 1);
        s.setNotes('<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>');
        @endcode
        @endif
        @if python
        @code{.py}
        try:
          sbmlDoc = SBMLDocument(3, 1)
        except ValueError:
          print('Could not create SBMLDocument object')
          sys.exit(1)

        note = '<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>'

        status = sbmlDoc.setNotes(note)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Do something to handle the error here.
          print('Unable to set notes on the SBML document object')
          sys.exit(1)
        @endcode
        @endif
        @if csharp
        @code
        SBMLDocument s = new SBMLDocument(3, 1);
        s.setNotes('<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>');
        @endcode
        @endif@~

        @param notes an XML string that is to be used as the content of the
        'notes' subelement of this object

        @param addXHTMLMarkup a boolean indicating whether to wrap the contents
        of the @p notes argument with XHTML paragraph (<code>&lt;p&gt;</code>)
        tags.  This is appropriate when the string in @p notes does not already
        containg the appropriate XHTML markup.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes()
        @see appendNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setNotes(XMLNode notes)</pre>

        Sets the value of the 'notes' subelement of this SBML object.

        The content of @p notes is copied, and any existing content of this
        object's 'notes' subelement is deleted.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @param notes an XML structure that is to be used as the content of the
        'notes' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes()
        @see appendNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()

        """
        return _libsbml.SBase_setNotes(self, *args)

    def appendNotes(self, *args):
        """
        appendNotes(self, XMLNode notes) -> int
        appendNotes(self, string notes) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendNotes(string notes)</pre>

        Appends the given @p notes to the 'notes' subelement of this object.

        The content of the parameter @p notes is copied.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @param notes an XML string that is to appended to the content of
        the 'notes' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes()
        @see setNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendNotes(XMLNode notes)</pre>

        Appends the given @p notes to the 'notes' subelement of this object.

        The content of @p notes is copied.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @param notes an XML node structure that is to appended to the content
        of the 'notes' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes()
        @see setNotes()
        @see appendNotes()
        @see unsetNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()

        """
        return _libsbml.SBase_appendNotes(self, *args)

    def setModelHistory(self, *args):
        """
        setModelHistory(self, ModelHistory history) -> int

        Sets the ModelHistory of this object.

        The content of @p history is copied, and this object's existing model
        history content is deleted.

        @param history ModelHistory of this object.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.

        """
        return _libsbml.SBase_setModelHistory(self, *args)

    def connectToParent(self, *args):
        """
        connectToParent(self, SBase parent)

        @internal
        Sets the parent SBML object of this SBML object.
        (Creates a child-parent relationship by the child)
        This function is called when a child element is
        set/added/created by its parent element (e.g. by setXXX,
        addXXX, createXXX, and connectToChild functions of the
        parent element).

        @param parent the SBML object to use

        @internal

        """
        return _libsbml.SBase_connectToParent(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor, assignment operator.

        @if clike
        @see setSBMLDocument()
        @see enablePackageInternal()
        @endif@~

        @internal

        """
        return _libsbml.SBase_connectToChild(self)

    def setSBOTerm(self, *args):
        """
        setSBOTerm(self, int value) -> int
        setSBOTerm(self, string sboid) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setSBOTerm(int value)</pre>

        Sets the value of the 'sboTerm' attribute.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers. 

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @param value the NNNNNNN integer portion of the SBO identifier

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @see setSBOTerm()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setSBOTerm(string &sboid)</pre>

        Sets the value of the 'sboTerm' attribute by string.

        Beginning with SBML Level 2 Version 3, objects derived from SBase have
        an optional attribute named 'sboTerm' for supporting the use of the
        Systems Biology Ontology.  In SBML proper, the data type of the
        attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a
        seven digit integer number; libSBML simplifies the representation by
        only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the
        'sboTerm' attribute on SBase has data type @c int, and SBO identifiers
        are stored simply as integers.  This method lets you set the value of
        'sboTerm' as a complete string of the form 'SBO:NNNNNNN', whereas
        setSBOTerm(int value) allows you to set it using the integer form.

        SBO terms are a type of optional annotation, and each different class
        of SBML object derived from SBase imposes its own requirements about
        the values permitted for 'sboTerm'.  Please consult the SBML
        Level&nbsp;2 Version&nbsp;4 specification for more information about
        the use of SBO and the 'sboTerm' attribute.

        @param sboid the SBO identifier string of the form 'SBO:NNNNNNN'

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @see setSBOTerm()

        """
        return _libsbml.SBase_setSBOTerm(self, *args)

    def setNamespaces(self, *args):
        """
        setNamespaces(self, XMLNamespaces xmlns) -> int

        Sets the namespaces relevant of this SBML object.

        The content of @p xmlns is copied, and this object's existing
        namespace content is deleted.

        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and
        (in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.

        @param xmlns the namespaces to set

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.SBase_setNamespaces(self, *args)

    def unsetMetaId(self):
        """
        unsetMetaId(self) -> int

        Unsets the value of the 'metaid' attribute of this SBML object.

        @par
        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF (<a
        href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
        attribute value has the data type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
        identifier type, which means each 'metaid' value must be globally unique
        within an SBML file.  The latter point is important, because the
        uniqueness criterion applies across <em>any</em> attribute with type
        <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
        by SBML---something to be aware of if your application-specific XML
        content inside the 'annotation' subelement happens to use the XML
        <code>ID</code> type.  Although SBML itself specifies the use of <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
        the 'metaid' attribute, SBML-compatible applications should be careful if
        they use XML <code>ID</code>'s in XML portions of a model that are not
        defined by SBML, such as in the application-specific content of the
        'annotation' subelement.  Finally, note that LibSBML does not provide an
        explicit XML <code>ID</code> data type; it uses ordinary character
        strings, which is easier for applications to support. 

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SBase_unsetMetaId(self)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this SBML object.

        Most (but not all) objects in SBML include two common attributes: 'id'
        and 'name'.  The identifier given by an object's 'id' attribute value
        is used to identify the object within the SBML model definition.
        Other objects can refer to the component using this identifier.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SBase_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this SBML object.

        Most (but not all) objects in SBML include two common attributes: 'id'
        and 'name'.  In contrast to the 'id' attribute, the 'name' attribute is
        optional and is not intended to be used for cross-referencing purposes
        within a model.  Its purpose instead is to provide a human-readable
        label for the component.  The data type of 'name' is the type
        <code>string</code> defined in XML Schema.  SBML imposes no
        restrictions as to the content of 'name' attributes beyond those
        restrictions defined by the <code>string</code> type in XML Schema.

        The recommended practice for handling 'name' is as follows.  If a
        software tool has the capability for displaying the content of 'name'
        attributes, it should display this content to the user as a
        component's label instead of the component's 'id'.  If the user
        interface does not have this capability (e.g., because it cannot
        display or use special characters in symbol names), or if the 'name'
        attribute is missing on a given component, then the user interface
        should display the value of the 'id' attribute instead.  (Script
        language interpreters are especially likely to display 'id' instead of
        'name'.)

        As a consequence of the above, authors of systems that automatically
        generate the values of 'id' attributes should be aware some systems
        may display the 'id''s to the user.  Authors therefore may wish to
        take some care to have their software create 'id' values that are: (a)
        reasonably easy for humans to type and read; and (b) likely to be
        meaningful, for example by making the 'id' attribute be an abbreviated
        form of the name attribute value.

        An additional point worth mentioning is although there are
        restrictions on the uniqueness of 'id' values, there are no
        restrictions on the uniqueness of 'name' values in a model.  This
        allows software applications leeway in assigning component identifiers.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SBase_unsetName(self)

    def unsetNotes(self):
        """
        unsetNotes(self) -> int

        Unsets the value of the 'notes' subelement of this SBML object.

        The optional SBML element named 'notes', present on every major SBML
        component type, is intended as a place for storing optional
        information intended to be seen by humans.  An example use of the
        'notes' element would be to contain formatted user comments about the
        model element in which the 'notes' element is enclosed.  Every object
        derived directly or indirectly from type SBase can have a separate
        value for 'notes', allowing users considerable freedom when adding
        comments to their models.

        The format of 'notes' elements must be <a target='_blank'
        href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help
        verify the formatting of 'notes' content, libSBML provides the static
        utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,
        readers are urged to consult the appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more
        in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element
        content must be structured.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see getNotesString()
        @see isSetNotes()
        @see setNotes()
        @see setNotes()
        @see appendNotes()
        @see appendNotes()
        @see SyntaxChecker.hasExpectedXHTMLSyntax()

        """
        return _libsbml.SBase_unsetNotes(self)

    def unsetAnnotation(self):
        """
        unsetAnnotation(self) -> int

        Unsets the value of the 'annotation' subelement of this SBML object.

        Whereas the SBase 'notes' subelement is a container for content to be
        shown directly to humans, the 'annotation' element is a container for
        optional software-generated content @em not meant to be shown to
        humans.  Every object derived from SBase can have its own value for
        'annotation'.  The element's content type is <a target='_blank'
        href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type
        'any'</a>, allowing essentially arbitrary well-formed XML data
        content.

        SBML places a few restrictions on the organization of the content of
        annotations; these are intended to help software tools read and write
        the data as well as help reduce conflicts between annotations added by
        different tools.  Please see the SBML specifications for more details.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see getAnnotation()
        @see getAnnotationString()
        @see isSetAnnotation()
        @see setAnnotation()
        @see setAnnotation()
        @see appendAnnotation()
        @see appendAnnotation()

        """
        return _libsbml.SBase_unsetAnnotation(self)

    def unsetSBOTerm(self):
        """
        unsetSBOTerm(self) -> int

        Unsets the value of the 'sboTerm' attribute of this SBML object.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.SBase_unsetSBOTerm(self)

    def addCVTerm(self, *args):
        """
        addCVTerm(self, CVTerm term, bool newBag = False) -> int
        addCVTerm(self, CVTerm term) -> int

        Adds a copy of the given CVTerm object to this SBML object.

        @param term the CVTerm to assign.

        @param newBag if @c True, creates a new RDF bag with the same identifier
        as a previous bag, and if @c False, adds the term to an existing
        RDF bag with the same type of qualifier as the term being added.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink, if
        this object lacks a 'metaid' attribute
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note Since the CV Term uses the 'metaid' attribute of the object as a
        reference, if the object has no 'metaid' attribute value set, then the
        CVTerm will not be added.

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.SBase_addCVTerm(self, *args)

    def getCVTerms(self):
      """
      getCVTerms(self) -> CVTermList

      Get the CVTermList of CVTerm objects in this SBase.

      Returns the CVTermList for this SBase.


      """
      return _libsbml.SBase_getCVTerms(self)


    def getNumCVTerms(self):
        """
        getNumCVTerms(self) -> unsigned int

        Returns the number of CVTerm objects in the annotations of this SBML
        object.

        @return the number of CVTerms for this SBML object.

        """
        return _libsbml.SBase_getNumCVTerms(self)

    def getCVTerm(self, *args):
        """
        getCVTerm(self, unsigned int n) -> CVTerm

        Returns the nth CVTerm in the list of CVTerms of this SBML
        object.

        @param n long the index of the CVTerm to retrieve

        @return the nth CVTerm in the list of CVTerms for this SBML object.

        """
        return _libsbml.SBase_getCVTerm(self, *args)

    def unsetCVTerms(self):
        """
        unsetCVTerms(self) -> int

        Clears the list of CVTerm objects attached to this SBML object.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SBase_unsetCVTerms(self)

    def unsetModelHistory(self):
        """
        unsetModelHistory(self) -> int

        Unsets the ModelHistory object attached to this object.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note In SBML Level&nbsp;2, model history annotations were only
        permitted on the Model element.  In SBML Level&nbsp;3, they are
        permitted on all SBML components derived from SBase.

        """
        return _libsbml.SBase_unsetModelHistory(self)

    def getResourceBiologicalQualifier(self, *args):
        """
        getResourceBiologicalQualifier(self, string resource) -> BiolQualifierType_t

        Returns the MIRIAM <em>biological qualifier</em> associated with the
        given resource.

        In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,
        qualifiers are an optional means of indicating the relationship
        between a model component and its annotations.  There are two broad
        kinds of annotations: <em>model</em> and <em>biological</em>.  The
        latter kind is used to qualify the relationship between a model
        component and a biological entity which it represents.  Examples of
        relationships include 'is' and 'has part', but many others are
        possible.  MIRIAM defines <a target='_blank'
        href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous
        relationship qualifiers</a> to enable different software tools to
        qualify biological annotations in the same standardized way.  In
        libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model
        element are represented using lists of CVTerm objects, and the
        the MIRIAM biological qualifiers are represented using
        values @if clike from the enumeration
        type #BiolQualifierType_t.@endif@if python whose
        names begin with <code>BQB_</code> in the interface class
        @link libsbml libsbml@endlink.@endif@if java whose
        names begin with <code>BQB_</code> in the interface class
        {@link libsbmlConstants}.@endif@if csharp whose
        names begin with <code>BQB_</code> in the interface class
        @link libsbmlcs.libsbml libsbml@endlink.@endif@~

        This method searches the controlled-vocabulary annotations
        (i.e., the list of CVTerm objects) on the present object, then out of
        those that have biological qualifiers, looks for an annotation to the
        given @p resource.  If such an annotation is found, it returns the
        type of biological qualifier associated with that resource as a 
        value @if clike from the enumeration type
        #BiolQualifierType_t.@endif@if python whose name begins with
        <code>BQB_</code> from the interface
        class @link libsbml libsbml@endlink.@endif@if java whose name
        begins with <code>BQB_</code> from the interface
        class {@link libsbmlConstants}.@endif@if csharp whose
        names begin with <code>BQB_</code> in the interface class
        @link libsbmlcs.libsbml libsbml@endlink.@endif@~

        @param resource string representing the resource; e.g.,
        <code>'http://www.geneontology.org/#GO:0005892'</code>.

        @return the qualifier associated with the resource,
        or @link libsbml#BQB_UNKNOWN BQB_UNKNOWN@endlink if the
        resource does not exist.

        @if clike
        @note The set of MIRIAM biological qualifiers grows over
        time, although relatively slowly.  The values in the enumeration
        #BiolQualifierType_t are up to date with MIRIAM at the time of a given
        libSBML release.  The set of values may be expanded in later libSBML
        releases, to match the values defined by MIRIAM at that later time.
        @endif@if python
        @note The set of MIRIAM biological qualifiers grows over
        time, although relatively slowly.  The values are up to date with
        MIRIAM at the time of a given libSBML release.  The set of values in
        list of <code>BQB_</code> constants defined in @link libsbml
        libsbml@endlink may be expanded in later libSBML releases, to match
        the values defined by MIRIAM at that later time.
        @endif@if java
        @note The set of MIRIAM biological qualifiers grows over
        time, although relatively slowly.  The values are up to date with
        MIRIAM at the time of a given libSBML release.  The set of values in
        list of <code>BQB_</code> constants defined in {@link libsbmlConstants}
        may be expanded in later libSBML releases, to match
        the values defined by MIRIAM at that later time.
        @endif@if csharp
        @note The set of MIRIAM biological qualifiers grows over
        time, although relatively slowly.  The values are up to date with
        MIRIAM at the time of a given libSBML release.  The set of values in
        list of <code>BQB_</code> constants defined in @link libsbmlcs.libsbml libsbml@endlink
        may be expanded in later libSBML releases, to match
        the values defined by MIRIAM at that later time.
        @endif@~

        """
        return _libsbml.SBase_getResourceBiologicalQualifier(self, *args)

    def getResourceModelQualifier(self, *args):
        """
        getResourceModelQualifier(self, string resource) -> ModelQualifierType_t

        Returns the MIRIAM <em>model qualifier</em> associated with the
        given resource.

        In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,
        qualifiers are an optional means of indicating the relationship
        between a model component and its annotations.  There are two broad
        kinds of annotations: <em>model</em> and <em>biological</em>.  The
        former kind is used to qualify the relationship between a model
        component and another modeling object.  An example qualifier is
        'isDerivedFrom', to indicate that a given component of the model is
        derived from the modeling object represented by the referenced
        resource.  MIRIAM defines <a target='_blank'
        href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous
        relationship qualifiers</a> to enable different software tools to
        qualify model annotations in the same standardized way.  In libSBML,
        the MIRIAM controlled-vocabulary annotations on an SBML model element
        are represented using lists of CVTerm objects, and the 
        the MIRIAM model qualifiers are represented using
        values @if clike from the enumeration
        type #ModelQualifierType_t.@endif@if python whose
        names begin with <code>BQM_</code> in the interface class
        @link libsbml libsbml@endlink.@endif@if java whose
        names begin with <code>BQM_</code> in the interface class
        {@link libsbmlConstants}.@endif@if csharp whose
        names begin with <code>BQB_</code> in the interface class
        @link libsbmlcs.libsbml libsbml@endlink.@endif@~

        This method method searches the controlled-vocabulary annotations
        (i.e., the list of CVTerm objects) on the present object, then out of
        those that have model qualifiers, looks for an annotation to the given
        @p resource.  If such an annotation is found, it returns the type of
        type of model qualifier associated with that resource as a 
        value @if clike from the enumeration type
        #ModelQualifierType_t.@endif@if python whose name begins with
        <code>BQM_</code> from the interface
        class @link libsbml libsbml@endlink.@endif@if java whose name
        begins with <code>BQM_</code> from the interface
        class {@link libsbmlConstants}.@endif@if csharp whose
        names begin with <code>BQB_</code> in the interface class
        @link libsbmlcs.libsbml libsbml@endlink.@endif@~

        @param resource string representing the resource; e.g.,
        <code>'http://www.geneontology.org/#GO:0005892'</code>.

        @return the @if clike #ModelQualifierType_t value@else model qualifier
        type@endif@~ associated with the resource, or @link libsbml#BQM_UNKNOWN BQM_UNKNOWN@endlink if the resource does not exist.

        @if clike
        @note The set of MIRIAM biological qualifiers grows over
        time, although relatively slowly.  The values in the enumeration
        #ModelQualifierType_t are up to date with MIRIAM at the time of a given
        libSBML release.  The set of values may be expanded in later libSBML
        releases, to match the values defined by MIRIAM at that later time.
        @endif@if python
        @note The set of MIRIAM model qualifiers grows over
        time, although relatively slowly.  The values are up to date with
        MIRIAM at the time of a given libSBML release.  The set of values in
        list of <code>BQM_</code> constants defined in @link libsbml
        libsbml@endlink may be expanded in later libSBML releases, to match
        the values defined by MIRIAM at that later time.
        @endif@if java
        @note The set of MIRIAM model qualifiers grows over
        time, although relatively slowly.  The values are up to date with
        MIRIAM at the time of a given libSBML release.  The set of values in
        list of <code>BQM_</code> constants defined in {@link libsbmlConstants}
        may be expanded in later libSBML releases, to match
        the values defined by MIRIAM at that later time.
        @endif@if csharp
        @note The set of MIRIAM model qualifiers grows over
        time, although relatively slowly.  The values are up to date with
        MIRIAM at the time of a given libSBML release.  The set of values in
        list of <code>BQM_</code> constants defined in @link libsbmlcs.libsbml libsbml@endlink
        may be expanded in later libSBML releases, to match
        the values defined by MIRIAM at that later time.
        @endif@~

        """
        return _libsbml.SBase_getResourceModelQualifier(self, *args)

    def getModel(self):
        """
        getModel(self) -> Model

        Returns the Model object for the SBML Document in which the current object is located.

        @return the Model object for the SBML Document of this SBML object.

        @see getParentSBMLObject()
        @see getSBMLDocument()

        """
        return _libsbml.SBase_getModel(self)

    def getLevel(self):
        """
        getLevel(self) -> unsigned int

        Returns the SBML Level of the SBMLDocument object containing @em this
        object.

        @par
        LibSBML uses the class SBMLDocument as a top-level container for
        storing SBML content and data associated with it (such as warnings and
        error messages).  An SBML model in libSBML is contained inside an
        SBMLDocument object.  SBMLDocument corresponds roughly to the class
        <i>SBML</i> defined in the SBML Level&nbsp;3 and Level&nbsp;2
        specifications, but it does not have a direct correspondence in SBML
        Level&nbsp;1.  (But, it is created by libSBML no matter whether the
        model is Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)

        @return the SBML level of this SBML object.

        @see getVersion()
        @see getNamespaces()
        @see getPackageVersion()

        """
        return _libsbml.SBase_getLevel(self)

    def getVersion(self):
        """
        getVersion(self) -> unsigned int

        Returns the Version within the SBML Level of the SBMLDocument object
        containing @em this object.

        @par
        LibSBML uses the class SBMLDocument as a top-level container for
        storing SBML content and data associated with it (such as warnings and
        error messages).  An SBML model in libSBML is contained inside an
        SBMLDocument object.  SBMLDocument corresponds roughly to the class
        <i>SBML</i> defined in the SBML Level&nbsp;3 and Level&nbsp;2
        specifications, but it does not have a direct correspondence in SBML
        Level&nbsp;1.  (But, it is created by libSBML no matter whether the
        model is Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)

        @return the SBML version of this SBML object.

        @see getLevel()
        @see getNamespaces()

        """
        return _libsbml.SBase_getVersion(self)

    def getPackageVersion(self):
        """
        getPackageVersion(self) -> unsigned int

        Returns the Version of the SBML Level&nbsp;3 package to which this
        element belongs to.

        @return the version of the SBML Level&nbsp;3 package to which this
        element belongs. The value @c 0 will be returned if this element
        belongs to the SBML Level&nbsp;3 Core package.

        @see getLevel()
        @see getVersion()

        """
        return _libsbml.SBase_getPackageVersion(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        Returns the name of the SBML Level&nbsp;3 package in which this element
        is defined.

        @return the name of the SBML package in which this element is defined.
        The string <code>&quot;core&quot;</code> will be returned if this
        element is defined in SBML Level&nbsp;3 Core. The string
        <code>&quot;unknown&quot;</code> will be returned if this element is
        not defined in any SBML package.

        """
        return _libsbml.SBase_getPackageName(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @par
        Here follow some additional general information about libSBML type codes:

        @li The codes are the possible return values (integers) for the following
        functions:
        <ul>
        <li> SBase.getTypeCode()
        <li> ListOf.getItemTypeCode()
        </ul>
        (Compatibility note: in libSBML 5, the type of return values of these
        functions changed from an enumeration to an integer for extensibility
        in the face of different programming languages.)

        @li Each package extension must define similar sets of values for each
        SBase subclass (e.g. <code>SBMLLayoutTypeCode_t</code> for the SBML Level&nbsp;3
        %Layout extension, <code>SBMLFbcTypeCode_t</code> for the SBML Level&nbsp;3 Flux
        Balance Constraints extension, etc.).

        @li The value of each package-specific type code can be duplicated between
        those of different packages.  (This is necessary because the development
        of libSBML extensions for different SBML packages may be undertaken by
        different developers at different times; requiring the developers to
        coordinate their use of type codes would be nettlesome and probably
        doomed to failure.)

        @li To distinguish between the type codes of different packages, both the
        return value of SBase.getTypeCode() and SBase.getPackageName() must be
        checked.  This is particularly important for functions that take an SBML
        type code as an argument, such as
        SBase.getAncestorOfType(), which by
        default assumes you are handing it a core type, and will return @c None if
        the value you give it is actually from a package.

        The following example code illustrates the combined use of
        SBase.getPackageName() and SBase.getTypeCode():
        @if cpp
        @code{.cpp}
         void example (SBasesb)
         {
           cons string pkgName = sb->getPackageName();
           if (pkgName == 'core')
           {
             switch (sb->getTypeCode())
             {
               case SBML_MODEL:
                  ....
                  break;
               case SBML_REACTION:
                  ....
             }
           }
           else if (pkgName == 'layout')
           {
             switch (sb->getTypeCode())
             {
               case SBML_LAYOUT_LAYOUT:
                  ....
                  break;
               case SBML_LAYOUT_REACTIONGLYPH:
                  ....
             }
           }
           ...
         }
        @endcode
        @endif
        @if python
        @code{.py}
        def example(item):
          pkg_name  = item.getPackageName()
          type_code = item.getTypeCode()
          if pkg_name == 'core':
            print('Got a ' + SBMLTypeCode_toString(type_code, 'core') + ' object')
            if type_code == SBML_MODEL:
              print('This is a very, very nice model')
              # Do whatever the application wants to do with the model.
            elif type_code == SBML_COMPARTMENT:
              print('This is a very, very nice compartment')
              # Do whatever the application wants to do with the compartment.
            elif type_code == SBML_SPECIES:
              print('This is a very, very nice species')
              # Do whatever the application wants to do with the species.
            elif ...
              ...
          elif pkg_name == 'layout':
            print('Got a ' + SBMLTypeCode_toString(type_code, 'layout') + ' object')
            if type_code == SBML_LAYOUT_POINT:
              print('This is a very, very nice layout point')
              # Do whatever the application wants to do with the layout point.
            elif type_code == SBML_LAYOUT_BOUNDINGBOX:
              print('This is a very, very nice layout bounding box')
              # Do whatever the application wants to do with the layout bounding box.
            elif ...
              ...
          elif pkg_name == 'unknown':
            print('Something went wrong -- libSBML did not recognize the object type')
            # Handle errors
        @endcode
        @endif
        @if java
        @code{.java}
        void example (SBase sb)
        {
          String pkgName = sb.getPackageName();
          if (pkgName.equals('core'))
          {
            switch (sb.getTypeCode())
            {
              case libsbml.SBML_MODEL:
                 ....
                 break;
              case libsbml.SBML_REACTION:
                 ....
            }
          }
          else if (pkgName.equals('layout'))
          {
            switch (sb.getTypeCode())
            {
              case libsbml.SBML_LAYOUT_LAYOUT:
                 ....
                 break;
              case libsbml.SBML_LAYOUT_REACTIONGLYPH:
                 ....
            }
          }
          ...
        }
        @endcode
        @endif

        @return the @if clike #SBMLTypeCode_t value@else SBML object type
        code@endif@~ of this SBML object, or @link libsbml#SBML_UNKNOWN SBML_UNKNOWN@endlink (the default).  The latter is possible because
        subclasses of SBase are not required to implement this method to return
        a type code.

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getPackageName()
        @see getElementName()

        """
        return _libsbml.SBase_getTypeCode(self)

    def hasValidLevelVersionNamespaceCombination(self):
        """hasValidLevelVersionNamespaceCombination(self) -> bool"""
        return _libsbml.SBase_hasValidLevelVersionNamespaceCombination(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        This is overridden by subclasses to return a string appropriate to the
        SBML component.  For example, Model defines it as returning @c
        'model', CompartmentType defines it as returning @c 'compartmentType',
        and so on.

        """
        return _libsbml.SBase_getElementName(self)

    def toSBML(self):
        """
        toSBML(self) -> char

        Returns a string consisting of a partial SBML corresponding to just
        this object.

        @return the partial SBML that describes this SBML object.

        @warning <span class='warning'>This is primarily provided for testing
        and debugging purposes.  It may be removed in a future version of
        libSBML.</span>

        """
        return _libsbml.SBase_toSBML(self)

    def toXMLNode(self):
        """
        toXMLNode(self) -> XMLNode

        Returns this element as an XMLNode.

        @return this element as an XMLNode.

        @warning <span class='warning'>This operation is computationally
        expensive, because the element has to be fully serialized to a string
        and then parsed into the XMLNode structure.  Attempting to convert a
        large tree structure (e.g., a large Model) may consume significant
        computer memory and time.</span>

        """
        return _libsbml.SBase_toXMLNode(self)

    def getPlugin(self, *args):
        """
        getPlugin(self, string package) -> SBasePlugin
        getPlugin(self, string package) -> SBasePlugin
        getPlugin(self, unsigned int n) -> SBasePlugin
        getPlugin(self, unsigned int n) -> SBasePlugin

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getPlugin(long n)</pre>

        Returns the nth plug-in object (extension interface) for an SBML Level&nbsp;3
        package extension.

        @par
        SBML Level&nbsp;3 consists of a <em>Core</em> definition that can be extended
        via optional SBML Level&nbsp;3 <em>packages</em>.  A given model may indicate
        that it uses one or more SBML packages, and likewise, a software tool may be
        able to support one or more packages.  LibSBML does not come preconfigured
        with all possible packages included and enabled, in part because not all
        package specifications have been finalized.  To support the ability for
        software systems to enable support for the Level&nbsp;3 packages they choose,
        libSBML features a <em>plug-in</em> mechanism.  Each SBML Level&nbsp;3
        package is implemented in a separate code plug-in that can be enabled by the
        application to support working with that SBML package.  A given SBML model
        may thus contain not only objects defined by SBML Level&nbsp;3 Core, but also
        objects created by libSBML plug-ins supporting additional Level&nbsp;3
        packages.

        @param n the index of the plug-in to return

        @return the plug-in object (the libSBML extension interface) of a
        package extension with the given package name or URI.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getPlugin(string package)</pre>

        Returns a plug-in object (extension interface) for an SBML Level&nbsp;3
        package extension with the given package name or URI.

        @par
        SBML Level&nbsp;3 consists of a <em>Core</em> definition that can be extended
        via optional SBML Level&nbsp;3 <em>packages</em>.  A given model may indicate
        that it uses one or more SBML packages, and likewise, a software tool may be
        able to support one or more packages.  LibSBML does not come preconfigured
        with all possible packages included and enabled, in part because not all
        package specifications have been finalized.  To support the ability for
        software systems to enable support for the Level&nbsp;3 packages they choose,
        libSBML features a <em>plug-in</em> mechanism.  Each SBML Level&nbsp;3
        package is implemented in a separate code plug-in that can be enabled by the
        application to support working with that SBML package.  A given SBML model
        may thus contain not only objects defined by SBML Level&nbsp;3 Core, but also
        objects created by libSBML plug-ins supporting additional Level&nbsp;3
        packages.

        @param package the name or URI of the package

        @return the plug-in object (the libSBML extension interface) of a
        package extension with the given package name or URI.

        """
        return _libsbml.SBase_getPlugin(self, *args)

    def getNumPlugins(self):
        """
        getNumPlugins(self) -> unsigned int

        Returns the number of plug-in objects (extenstion interfaces) for SBML
        Level&nbsp;3 package extensions known.

        @par
        SBML Level&nbsp;3 consists of a <em>Core</em> definition that can be extended
        via optional SBML Level&nbsp;3 <em>packages</em>.  A given model may indicate
        that it uses one or more SBML packages, and likewise, a software tool may be
        able to support one or more packages.  LibSBML does not come preconfigured
        with all possible packages included and enabled, in part because not all
        package specifications have been finalized.  To support the ability for
        software systems to enable support for the Level&nbsp;3 packages they choose,
        libSBML features a <em>plug-in</em> mechanism.  Each SBML Level&nbsp;3
        package is implemented in a separate code plug-in that can be enabled by the
        application to support working with that SBML package.  A given SBML model
        may thus contain not only objects defined by SBML Level&nbsp;3 Core, but also
        objects created by libSBML plug-ins supporting additional Level&nbsp;3
        packages.

        @return the number of plug-in objects (extension interfaces) of
        package extensions known by this instance of libSBML.

        """
        return _libsbml.SBase_getNumPlugins(self)

    def enablePackage(self, *args):
        """
        enablePackage(self, string pkgURI, string pkgPrefix, bool flag) -> int

        Enables or disables the given SBML Level&nbsp;3 package on this object.

        This method enables the specified package on this object and other
        objects connected by child-parent links in the same SBMLDocument object.
        This method is the converse of
        SBase.disablePackage().

        @param pkgURI the URI of the package.

        @param pkgPrefix the XML prefix of the package

        @param flag whether to enable (@c True) or disable (@c False) the package

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_PKG_UNKNOWN LIBSBML_PKG_UNKNOWN@endlink
        @li @link libsbml#LIBSBML_PKG_VERSION_MISMATCH LIBSBML_PKG_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_PKG_CONFLICTED_VERSION LIBSBML_PKG_CONFLICTED_VERSION@endlink

        @see disablePackage()

        """
        return _libsbml.SBase_enablePackage(self, *args)

    def disablePackage(self, *args):
        """
        disablePackage(self, string pkgURI, string pkgPrefix) -> int

        Disables the given SBML Level&nbsp;3 package on this object.

        This method disables the specified package on this object
        and other objects connected by child-parent links in the same
        SBMLDocument object.

        An example of when this may be useful is during construction of model
        components when mixing existing and new models.  Suppose your
        application read an SBML document containing a model that used the SBML
        Hierarchical %Model Composition (&ldquo;comp&rdquo;) package, and
        extracted parts of that model in order to construct a new model in
        memory.  The new, in-memory model will not accept a component drawn from
        an other SBMLDocument with different package namespace declarations.
        You could reconstruct the same namespaces in the in-memory model first,
        but as a shortcut, you could also disable the package namespace on the
        object being added.  Here is a code example to help clarify this:
        @if cpp
        @code{.cpp}
        // We read in an SBML L3V1 model that uses the 'comp' package namespace
        doc = readSBML('sbml-file-with-comp-elements.xml');

        // We extract one of the species from the model we just read in.
        Species s1 = doc->getModel()->getSpecies(0);

        // We construct a new model.  This model does not use the 'comp' package.
        Model newModel = new Model(3,1);

        // The following will fail with an error, because addSpecies() will
        // first check that the parent of the given object has namespaces
        // declared, and will discover that s1 does but newModel does not.

        // newModel->addSpecies(s1);

        // However, if we disable the 'comp' package on s1, then the call
        // to addSpecies will work.

        s1->disablePackage('http://www.sbml.org/sbml/level3/version1/comp/version1',
                           'comp');
        newModel->addSpecies(s1);
        @endcode
        @endif
        @if python
        @code{.py}
        import sys
        import os.path
        from libsbml import *

        # We read an SBML L3V1 model that uses the 'comp' package.

        doc = readSBML('sbml-file-with-comp-elements.xml');
        if doc.getNumErrors() > 0:
          print('readSBML encountered errors while reading the file.')
          doc.printErrors()
          sys.exit(1)

        # We extract one of the species from the model we just read in.

        model = doc.getModel()
        if model == None:
          print('Unable to retrieve Model object')
          sys.exit(1)

        s1 = model.getSpecies(0)
        if s1 == None:
          print('Unable to retrieve Species object')
          sys.exit(1)

        # We construct a new model.
        # This model does not use the 'comp' package.

        try:
          newDoc = SBMLDocument(3, 1)
        except ValueError:
          print('Could not create SBMLDocument object')
          sys.exit(1)

        newModel = newDoc.createModel()
        if newModel == None:
          print('Unable to create new Model object')
          sys.exit(1)

        # The following would normally fail with an error, because
        # addSpecies() would first check that the parent of the given
        # object has namespaces declared, and will discover that s1
        # does but newModel does not.

        #   newModel.addSpecies(s1)

        # However, if we disable the 'comp' package on s1, then the
        # call to addSpecies will work.

        compNS = 'http://www.sbml.org/sbml/level3/version1/comp/version1'
        status = s1.disablePackage(compNS, 'comp')
        if status != LIBSBML_OPERATION_SUCCESS:
          print('Unable to disable package.')
          sys.exit(1)

        newSpecies = newModel.addSpecies(s1)   # This will work now.
        if newSpecies == None:
          print('Could not add Species')       # (This will not happen,
          sys.exit(1)                          # but always check errors.)
        @endcode
        @endif
        @if java
        @code{.java}
        // We read in an SBML L3V1 model that uses the 'comp' package namespace
        SBMLReader reader = new SBMLReader();
        SBMLDocument doc = reader.readSBML('sbml-file-with-comp-elements.xml');

        // We extract one of the species from the model we just read in.
        Species s1 = doc.getModel().getSpecies(0);

        // We construct a new model.  This model does not use the 'comp' package.
        Model newModel = new Model(3,1);

        // The following will fail with an error, because addSpecies() will
        // first check that the parent of the given object has namespaces
        // declared, and will discover that s1 does but newModel does not.

        // newModel->addSpecies(s1);

        // However, if we disable the 'comp' package on s1, then the call
        // to addSpecies will work.

        s1->disablePackage('http://www.sbml.org/sbml/level3/version1/comp/version1',
                           'comp');
        newModel.addSpecies(s1);
        @endcode
        @endif

        @param pkgURI the URI of the package

        @param pkgPrefix the XML prefix of the package

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_PKG_UNKNOWN LIBSBML_PKG_UNKNOWN@endlink
        @li @link libsbml#LIBSBML_PKG_VERSION_MISMATCH LIBSBML_PKG_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_PKG_CONFLICTED_VERSION LIBSBML_PKG_CONFLICTED_VERSION@endlink

        @see enablePackage()

        """
        return _libsbml.SBase_disablePackage(self, *args)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses in which one or more child elements are defined 
        must override this function.

        @if clike
        @see setSBMLDocument()
        @endif@~
        @see connectToChild()

        @internal

        """
        return _libsbml.SBase_enablePackageInternal(self, *args)

    def isPackageURIEnabled(self, *args):
        """
        isPackageURIEnabled(self, string pkgURI) -> bool

        Predicate returning @c True if an SBML Level&nbsp;3 package with the
        given URI is enabled with this object.

        @param pkgURI the URI of the package

        @return @c True if the given package is enabled within this object, @c False otherwise.

        @see isPackageEnabled()

        """
        return _libsbml.SBase_isPackageURIEnabled(self, *args)

    def isPackageEnabled(self, *args):
        """
        isPackageEnabled(self, string pkgName) -> bool

        Predicate returning @c True if the given SBML Level&nbsp;3 package is
        enabled with this object.

        The search ignores the package version.

        @param pkgName the name of the package

        @return @c True if the given package is enabled within this object, @c False otherwise.

        @see isPackageURIEnabled()

        """
        return _libsbml.SBase_isPackageEnabled(self, *args)

    def isPkgURIEnabled(self, *args):
        """
        isPkgURIEnabled(self, string pkgURI) -> bool

        Predicate returning @c True if an SBML Level&nbsp;3 package with the
        given URI is enabled with this object.

        @param pkgURI the URI of the package

        @return @c True if the given package is enabled within this object, @c False otherwise.

        @see isPkgEnabled()

        @deprecated Replaced in libSBML 5.2.0 by
        isPackageURIEnabled(@if java String@endif)

        """
        return _libsbml.SBase_isPkgURIEnabled(self, *args)

    def isPkgEnabled(self, *args):
        """
        isPkgEnabled(self, string pkgName) -> bool

        Predicate returning @c True if the given SBML Level&nbsp;3 package is
        enabled with this object.

        The search ignores the package version.

        @param pkgName the name of the package

        @return @c True if the given package is enabled within this object, @c False otherwise.

        @see isPkgURIEnabled()

        @deprecated Replaced in libSBML 5.2.0 by
        isPackageEnabled(@if java String@endif)

        """
        return _libsbml.SBase_isPkgEnabled(self, *args)

    def writeExtensionElements(self, *args):
        """
        writeExtensionElements(self, XMLOutputStream stream)

        @internal
        Writes out contained SBML objects of package extensions (if any)
        as XML elements.

        @internal

        """
        return _libsbml.SBase_writeExtensionElements(self, *args)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        @internal

        @internal

        """
        return _libsbml.SBase_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        @internal

        @internal

        """
        return _libsbml.SBase_hasRequiredElements(self)

    def checkCompatibility(self, *args):
        """
        checkCompatibility(self, SBase object) -> int

        @internal

        @internal

        """
        return _libsbml.SBase_checkCompatibility(self, *args)

    def setSBMLNamespacesAndOwn(self, *args):
        """
        setSBMLNamespacesAndOwn(self, SBMLNamespaces sbmlns)

        @internal

        @internal

        """
        return _libsbml.SBase_setSBMLNamespacesAndOwn(self, *args)

    def getSBMLNamespaces(self):
        """
        getSBMLNamespaces(self) -> SBMLNamespaces

        @internal

        @internal

        """
        return _libsbml.SBase_getSBMLNamespaces(self)

    def checkMathMLNamespace(self, *args):
        """
        checkMathMLNamespace(self, XMLToken elem) -> string

        @internal

        @internal

        """
        return _libsbml.SBase_checkMathMLNamespace(self, *args)

    def getDerivedUnitDefinition(self):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition

        @internal

        @internal

        """
        return _libsbml.SBase_getDerivedUnitDefinition(self)

    def containsUndeclaredUnits(self):
        """
        containsUndeclaredUnits(self) -> bool

        @internal

        @internal

        """
        return _libsbml.SBase_containsUndeclaredUnits(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Removes this object from its parent.

        If the parent was storing this object as a pointer, it is deleted.  If
        not, it is simply cleared (as in ListOf objects).  This is a pure
        virtual method, as every SBase element has different parents, and
        therefore different methods of removing itself.  Will fail (and not
        delete itself) if it has no parent object.  This function is designed to
        be overridden, but for all objects whose parent is of the class ListOf,
        the default implementation will work.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SBase_removeFromParentAndDelete(self)

    def matchesSBMLNamespaces(self, *args):
        """
        matchesSBMLNamespaces(self, SBase sb) -> bool
        matchesSBMLNamespaces(self, SBase sb) -> bool

        Returns @c True if this object's set of XML namespaces are the same
        as the given object's XML namespaces.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sb an object to compare with respect to namespaces

        @return boolean, @c True if this object's collection of namespaces is
        the same as @p sb's, @c False otherwise.

        """
        return _libsbml.SBase_matchesSBMLNamespaces(self, *args)

    def matchesRequiredSBMLNamespacesForAddition(self, *args):
        """
        matchesRequiredSBMLNamespacesForAddition(self, SBase sb) -> bool
        matchesRequiredSBMLNamespacesForAddition(self, SBase sb) -> bool

        Returns @c True if this object's set of XML namespaces are a subset
        of the given object's XML namespaces.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sb an object to compare with respect to namespaces

        @return boolean, @c True if this object's collection of namespaces is
        a subset of @p sb's, @c False otherwise.

        """
        return _libsbml.SBase_matchesRequiredSBMLNamespacesForAddition(self, *args)

    def getURI(self):
        """
        getURI(self) -> string

        Gets the namespace URI to which this element belongs to.

        For example, all elements that belong to SBML Level 3 Version 1 Core
        must would have the URI 'http://www.sbml.org/sbml/level3/version1/core';
        all elements that belong to Layout Extension Version 1 for SBML Level 3
        Version 1 Core must would have the URI
        'http://www.sbml.org/sbml/level3/version1/layout/version1/'

        This function first returns the URI for this element by looking into the
        SBMLNamespaces object of the document with the its package name.  If not
        found, it will @if clike return the result of getElementNamespace()@else
        return the XML namespace to which this element belongs@endif.

        @return the URI of this element

        @see getSBMLDocument()
        @see getPackageName()
        @if clike @see getElementNamespace() @endif

        """
        return _libsbml.SBase_getURI(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        Returns the namespace prefix of this element.

        """
        return _libsbml.SBase_getPrefix(self)

    __metaclass__ = AutoProperty

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    def getListOfAllElements(self, filter = None):
        """
        getListOfAllElements(self, ElementFilter filter = None) -> SBaseList
        getListOfAllElements(self) -> SBaseList

        @return an SBaseList of all child SBase objects, including those
        nested to an arbitrary depth.

        @return a list of all child objects.

        """
        return _libsbml.SBase_getListOfAllElements(self, filter)

    def getListOfAllElementsFromPlugins(self, filter = None):
        """
        getListOfAllElementsFromPlugins(self, ElementFilter filter = None) -> SBaseList
        getListOfAllElementsFromPlugins(self) -> SBaseList

        @return an SBaseList of all child SBase objects contained in SBML package
        plug-ins.

        This method walks down the list of all SBML Level 3 packages used by the
        model, and returns all objects contained in them.

        @return an SBaseList of all children objects from package plug-ins.

        """
        return _libsbml.SBase_getListOfAllElementsFromPlugins(self, filter)

SBase_swigregister = _libsbml.SBase_swigregister
SBase_swigregister(SBase)

class ListOf(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Parent class for libSBML's 'ListOfXYZ' classes.

    @htmlinclude not-sbml-warning.html

    The ListOf class in libSBML is a utility class that serves as the parent
    class for implementing the ListOf__ classes.  It provides methods for
    working generically with the various SBML lists of objects in a program.
    LibSBML uses this separate list class rather than ordinary
    @if conly C@endif@if cpp C++; @endif@if java Java@endif@if python Python@endif@~ lists,
    so that it can provide the methods and features associated with SBase.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOf, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOf, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ListOf
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level = SBML_DEFAULT_LEVEL, unsigned int version = SBML_DEFAULT_VERSION) -> ListOf
        __init__(self, unsigned int level = SBML_DEFAULT_LEVEL) -> ListOf
        __init__(self) -> ListOf
        __init__(self, SBMLNamespaces sbmlns) -> ListOf
        __init__(self, ListOf orig) -> ListOf

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOf(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOf with a given SBMLNamespaces object.

        @param sbmlns the set of SBML namespaces that this ListOf should
        contain.

        @note Bare ListOf @if conly structures @else objects@endif@~ are
        impossible to add to SBML models.  The ListOf
        @if conly structure type@else class@endif@~ is simply the base
        of <em>other</em> @if conly structure types @else classes@endif@~ in
        libSBML.  Calling programs are not intended to create bare ListOf
        @if conly structures @else objects@endif@~ themselves.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOf(long level   = SBML_DEFAULT_LEVEL, long version = SBML_DEFAULT_VERSION)</pre>

        Creates a new ListOf object.

        @param level the SBML Level; if not assigned, defaults to the
        value of SBMLDocument.getDefaultLevel().

        @param version the Version within the SBML Level; if not assigned,
        defaults to the value of SBMLDocument.getDefaultVersion().

        @note Bare ListOf @if conly structures @else objects@endif@~ are
        impossible to add to SBML models.  The ListOf
        @if conly structure type@else class@endif@~ is simply the base
        of <em>other</em> @if conly structure types @else classes@endif@~ in
        libSBML.  Calling programs are not intended to create bare ListOf
        @if conly structures @else objects@endif@~ themselves.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOf(ListOf orig)</pre>

        Copy constructor; creates a copy of this ListOf.

        @param orig the ListOf instance to copy.

        """
        this = _libsbml.new_ListOf(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOf

        Creates and returns a deep copy of this ListOf object.

        @return the (deep) copy of this ListOf object.

        """
        return _libsbml.ListOf_clone(self)

    def append(self, *args):
        """
        append(self, SBase item) -> int

        Adds an item to the end of this ListOf's list of items.

        This method makes a clone of the @p item handed to it.  This means that
        when the ListOf object is destroyed, the original items will not be
        destroyed.  For a method with an alternative ownership behavior, see the
        ListOf.appendAndOwn() method.

        @param item the item to be added to the list.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see appendAndOwn()
        @see appendFrom()

        """
        return _libsbml.ListOf_append(self, *args)

    def appendAndOwn(self, *args):
        """
        appendAndOwn(self, SBase item) -> int

        Adds an item to the end of this ListOf's list of items.

        This method does not clone the @p item handed to it; instead, it assumes
        ownership of it.  This means that when the ListOf is destroyed, the item
        will be destroyed along with it.  For a method with an alternative
        ownership behavior, see the ListOf.append() method.

        @param item the item to be added to the list.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see append()
        @see appendFrom()

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ListOf_appendAndOwn(self, *args)

    def appendFrom(self, *args):
        """
        appendFrom(self, ListOf list) -> int

        Adds a clone of a list of items to this ListOf's list.

        Note that because this clones the objects handed to it, the original
        items will not be destroyed when this ListOf object is destroyed.

        @param list a list of items to be added.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see append()
        @see appendAndOwn()

        """
        return _libsbml.ListOf_appendFrom(self, *args)

    def insert(self, *args):
        """
        insert(self, int location, SBase item) -> int

        Inserts an item at a given position in this ListOf's list of items.

        This variant of the method makes a clone of the @p item handed to it.
        This means that when the ListOf is destroyed, the original @p item will
        <em>not</em> be destroyed.

        @param location the location in the list where to insert the item.
        @param item the item to be inserted to the list.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see insertAndOwn()

        """
        return _libsbml.ListOf_insert(self, *args)

    def insertAndOwn(self, *args):
        """
        insertAndOwn(self, int location, SBase item) -> int

        Inserts an item at a given position in this ListOf's list of items.

        This variant of the method makes a clone of the @p item handed to it.
        This means that when the ListOf is destroyed, the original @p item
        <em>will</em> be destroyed.

        @param location the location where to insert the item
        @param item the item to be inserted to the list

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see insert()

        """
        return _libsbml.ListOf_insertAndOwn(self, *args)

    def get(self, *args):
        """
        get(self, unsigned int n) -> SBase
        get(self, unsigned int n) -> SBase

        Get an item from the list.

        @param n the index number of the item to get.

        @return the <em>n</em>th item in this ListOf items, or a null pointer if
        the index number @p n refers to a nonexistent position in this list.

        @see size()

        """
        return _libsbml.ListOf_get(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given identifier.

        This method searches this ListOf's list of items for SBML objects based
        on their 'id' attribute value in the model-wide <code>SId</code>
        identifier namespace.

        @param id string representing the id of the object to find.

        @return the first element found with the given @p id, or @c None if no
        such object is found.

        """
        return _libsbml.ListOf_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element found with the given meta-identifier.

        @param metaid string representing the 'metaid' attribute of the object
        to find.

        @return the first element found with the given @p metaid, or @c None if
        no such object is found.

        """
        return _libsbml.ListOf_getElementByMetaId(self, *args)

    def clear(self, doDelete = True):
        """
        clear(self, bool doDelete = True)
        clear(self)

        Removes all items in this ListOf object.

        If parameter @p doDelete is @c True (default), all items in this ListOf
        object are deleted and cleared, and thus the caller doesn't have to
        delete those items.  Otherwise, all items are cleared only from this
        ListOf object; the caller is still responsible for deleting the actual
        items.  (In the latter case, callers are advised to store pointers to
        all items elsewhere before calling this function.)

        @param doDelete if @c True (default), all items are deleted and cleared.
        Otherwise, all items are just cleared and not deleted.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.ListOf_clear(self, doDelete)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Removes all items in this ListOf object and deletes its properties too.

        This performs a call to clear() with an argument of @c True (thus removing
        all the child objects in the list), followed by calls to various libSBML
        <code>unset<em>Foo</em></code> methods to delete everything else: CVTerm
        objects, model history objects, etc.

        @if cpp Implementations of subclasses of ListOf may need to override
        this method if different handling of child objects is needed.@endif@~

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ListOf_removeFromParentAndDelete(self)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> SBase

        Removes the <em>n</em>th item from this ListOf list of items and returns
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()

        """
        return _libsbml.ListOf_remove(self, *args)

    def size(self):
        """
        size(self) -> unsigned int

        Returns number of items in this ListOf list.

        @return the number of items in this ListOf items.

        """
        return _libsbml.ListOf_size(self)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor and assignment operator.

        @if cpp
        @see setSBMLDocument()
        @see enablePackageInternal()
        @endif

        @internal

        """
        return _libsbml.ListOf_connectToChild(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this object, namely,
        @link libsbml#SBML_LIST_OF SBML_LIST_OF@endlink.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_LIST_OF SBML_LIST_OF@endlink (default).

        @note The various ListOf classes mostly differ from each other in what they
        contain.  Hence, one must call getItemTypeCode() to fully determine the
        class of this SBML object.

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getItemTypeCode()
        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOf_getTypeCode(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Get the type code of the objects contained in this ListOf.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        Classes that inherit from the ListOf class should override this method
        to return the SBML type code for the objects contained in this ListOf.
        If they do not, this method will return
        @link libsbml#SBML_UNKNOWN SBML_UNKNOWN@endlink

        @return The ListOf base class contains no SBML objects, and therefore
        this method returns @link libsbml#SBML_UNKNOWN SBML_UNKNOWN@endlink.

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOf_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for ListOf, is
        always @c 'listOf'.

        @return the XML name of this element.

        """
        return _libsbml.ListOf_getElementName(self)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.ListOf_enablePackageInternal(self, *args)

    def __len__(self):
        """__len__(self) -> int"""
        return _libsbml.ListOf___len__(self)

    def __getitem__(self, key):

      try:
         keyIsSlice = isinstance(key, slice)
      except:
         keyIsSlice = 0

      if keyIsSlice:
        start = key.start
        if start is None:
          start = 0
        stop = key.stop
        if stop is None:
          stop = self.size()
        return [self[i] for i in range(
          self._fixNegativeIndex(start), self._fixNegativeIndex(stop)
        )]

      key = self._fixNegativeIndex(key)
      if key < 0 or key >= self.size():
        raise IndexError(key)
      return self.get(key)


    def _fixNegativeIndex(self, index):
      if index < 0:
        return index + self.size()
      else:
        return index


    def __iter__(self):
      for i in range(self.size()):
        yield self[i]


    def __repr__(self):
      return "[" + ", ".join([repr(self[i]) for i in range(len(self))]) + "]"


    def __str__(self):
      return repr(self)

ListOf_swigregister = _libsbml.ListOf_swigregister
ListOf_swigregister(ListOf)

class Model(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML model.

    In an SBML model definition, a single object of class Model serves as
    the overall container for the lists of the various model components.
    All of the lists are optional, but if a given list container is present
    within the model, the list must not be empty; that is, it must have
    length one or more.  The following are the components and lists
    permitted in different Levels and Versions of SBML in
    version @htmlinclude libsbml-version.html
    of libSBML:
    <ul>
    <li> In SBML Level 1, the components are: UnitDefinition, Compartment,
    Species, Parameter, Rule, and Reaction.  Instances of the classes are
    placed inside instances of classes ListOfUnitDefinitions,
    ListOfCompartments, ListOfSpecies, ListOfParameters, ListOfRules, and
    ListOfReactions.

    <li> In SBML Level 2 Version 1, the components are: FunctionDefinition,
    UnitDefinition, Compartment, Species, Parameter, Rule, Reaction and
    Event.  Instances of the classes are placed inside instances of classes
    ListOfFunctionDefinitions, ListOfUnitDefinitions, ListOfCompartments,
    ListOfSpecies, ListOfParameters, ListOfRules, ListOfReactions, and
    ListOfEvents.

    <li> In SBML Level 2 Versions 2, 3 and 4, the components are:
    FunctionDefinition, UnitDefinition, CompartmentType, SpeciesType,
    Compartment, Species, Parameter, InitialAssignment, Rule, Constraint,
    Reaction and Event.  Instances of the classes are placed inside
    instances of classes ListOfFunctionDefinitions, ListOfUnitDefinitions,
    ListOfCompartmentTypes, ListOfSpeciesTypes, ListOfCompartments,
    ListOfSpecies, ListOfParameters, ListOfInitialAssignments, ListOfRules,
    ListOfConstraints, ListOfReactions, and ListOfEvents.

    <li> In SBML Level 3 Version 1, the components are: FunctionDefinition,
    UnitDefinition, Compartment, Species, Parameter, InitialAssignment,
    Rule, Constraint, Reaction and Event.  Instances of the classes are
    placed inside instances of classes ListOfFunctionDefinitions,
    ListOfUnitDefinitions, ListOfCompartments, ListOfSpecies,
    ListOfParameters, ListOfInitialAssignments, ListOfRules,
    ListOfConstraints, ListOfReactions, and ListOfEvents.  
    </ul>

    Although all the lists are optional, there are dependencies between SBML
    components such that defining some components requires defining others.
    An example is that defining a species requires defining a compartment,
    and defining a reaction requires defining a species.  The dependencies
    are explained in more detail in the SBML specifications.

    In addition to the above lists and attributes, the Model class in both
    SBML Level&nbsp;2 and Level&nbsp;3 has the usual two attributes of 'id'
    and 'name', and both are optional.  As is the case for other SBML
    components with 'id' and 'name' attributes, they must be used according
    to the guidelines described in the SBML specifications.  (Within the
    frameworks of SBML Level&nbsp;2 and Level&nbsp;3 Version&nbsp;1 Core, a
    Model object identifier has no assigned meaning, but extension packages
    planned for SBML Level&nbsp;3 are likely to make use of this
    identifier.)

    Finally, SBML Level&nbsp;3 has introduced a number of additional Model
    attributes.  They are discussed in a separate section below.


    @section approaches Approaches to creating objects using the libSBML API

    LibSBML provides two main mechanisms for creating objects: class
    constructors
    (e.g., @if java <a href='org/sbml/libsbml/Species.html'>Species()</a> @else Species.Species() @endif), 
    and <code>create<span class='placeholder-nospace'><em>Object</em></span>()</code>
    methods (such as Model.createSpecies()) provided by certain <span
    class='placeholder-nospace'><em>Object</em></span> classes such as Model.  These
    multiple mechanisms are provided by libSBML for flexibility and to
    support different use-cases, but they also have different implications
    for the overall model structure.

    In general, the recommended approach is to use the <code>create<span
    class='placeholder-nospace'><em>Object</em></span>()</code> methods.  These
    methods both create an object @em and link it to the parent in one step.
    Here is an example:@if clike
    @code{.cpp}
    // Create an SBMLDocument object in Level 3 Version 1 format:

    SBMLDocument sbmlDoc = new SBMLDocument(3, 1);

    // Create a Model object inside the SBMLDocument object and set
    // its identifier.  The call returns a pointer to the Model object
    // created, and methods called on that object affect the attributes
    // of the object attached to the model (as expected).

    Model model = sbmlDoc->createModel();
    model->setId('BestModelEver');

    // Create a Species object inside the Model and set its identifier.
    // Similar to the lines above, this call returns a pointer to the Species
    // object created, and methods called on that object affect the attributes
    // of the object attached to the model (as expected).

    Speciessp = model->createSpecies();
    sp->setId('MySpecies');
    @endcode
    @endif@if java
    @code{.java}
    // Create an SBMLDocument object in Level 3 Version 1 format:

    SBMLDocument sbmlDoc = new SBMLDocument(3, 1);

    // Create a Model object inside the SBMLDocument object and set
    // its identifier.  The call returns a pointer to the Model object
    // created, and methods called on that object affect the attributes
    // of the object attached to the model (as expected).  Note that
    // the call to setId() returns a status code, and a real program
    // should check this status code to make sure everything went okay.

    Model model = sbmlDoc.createModel();
    model.setId(&#34;BestModelEver&#34;);

    // Create a Species object inside the Model and set its identifier.
    // Similar to the lines above, this call returns a pointer to the Species
    // object created, and methods called on that object affect the attributes
    // of the object attached to the model (as expected).  Note that, like
    // with Model, the call to setId() returns a status code, and a real program
    // should check this status code to make sure everything went okay.

    Species sp = model.createSpecies();
    sp.setId(&#34;BestSpeciesEver&#34;);
    @endcode
    @endif@if python
    @code{.py}
    # Create an SBMLDocument object in Level 3 Version 1 format.
    # Make sure to check for possible failures.

    try:
      sbmlDoc = SBMLDocument(3, 1)
    except ValueError:
      print('Could not create SBMLDocument object')
      sys.exit(1)

    # Create a Model object inside the SBMLDocument object and set its
    # identifier, checking the returned values.  The call to setId() returns a
    # status code to indicate whether the assignment was successful.

    model = sbmlDoc.createModel()
    if model == None:
      # Do something to handle the error here.
      print('Unable to create Model object.')
      sys.exit(1)

    status = model.setId('BestModelEver')
    if status != LIBSBML_OPERATION_SUCCESS:
      # Do something to handle the error here.
      print('Unable to set identifier on the Model object')
      sys.exit(1)

    # Create a Species object inside the Model and set its identifier.
    # Again, the setId() returns a status code to indicate whether the
    # assignment was successful.

    sp = model.createSpecies()
    if sp == None:
      # Do something to handle the error here.
      print('Unable to create Species object.')
      sys.exit(1)

    status = sp.setId('BestSpeciesEver')
    if status != LIBSBML_OPERATION_SUCCESS:
      # Do something to handle the error here.
      print('Unable to set identifier on the Species object')
      sys.exit(1)
    @endcode
    @endif@if csharp
    @code
    // Create an SBMLDocument object in Level 3 Version 1 format:

    SBMLDocument sbmlDoc = new SBMLDocument(3, 1);

    // Create a Model object inside the SBMLDocument object and set
    // its identifier.  The call returns a pointer to the Model object
    // created, and methods called on that object affect the attributes
    // of the object attached to the model (as expected).

    Model model = sbmlDoc.createModel();
    model.setId('BestModelEver');

    // Create a Species object inside the Model and set its identifier.
    // Similar to the lines above, this call returns a pointer to the Species
    // object created, and methods called on that object affect the attributes
    // of the object attached to the model (as expected).

    Species sp = model.createSpecies();
    sp.setId('MySpecies');
    @endcode
    @endif@~

    The <code>create<span
    class='placeholder-nospace'><em>Object</em></span>()</code> methods return a
    pointer to the object created, but they also add the object to the
    relevant list of object instances contained in the parent.  (These lists
    become the <code>&lt;listOf<span
    class='placeholder-nospace'><em>Object</em></span>s&gt;</code> elements in the
    finished XML rendition of SBML.)  In the example above,
    Model.createSpecies() adds the created species directly to the
    <code>&lt;listOfSpeciesgt;</code> list in the model.  Subsequently,
    methods called on the species change the species in the model (which is
    what is expected in most situations).

    @section model-checking Consistency and adherence to SBML specifications

    To make it easier for applications to do whatever they need,
    libSBML version @htmlinclude libsbml-version.html
    is relatively lax when it comes to enforcing correctness and
    completeness of models @em during model construction and editing.
    Essentially, libSBML @em will @em not in most cases check automatically
    that a model's components have valid attribute values, or that the
    overall model is consistent and free of errors---even obvious errors
    such as duplication of identifiers.  This allows applications great
    leeway in how they build their models, but it means that software
    authors must take deliberate steps to ensure that the model will be, in
    the end, valid SBML.  These steps include such things as keeping track
    of the identifiers used in a model, manually performing updates in
    certain situations where an entity is referenced in more than one place
    (e.g., a species that is referenced by multiple SpeciesReference
    objects), and so on.

    That said, libSBML does provide powerful features for deliberately
    performing validation of SBML when an application decides it is time to
    do so.  The interfaces to these facilities are on the SBMLDocument
    class, in the form of SBMLDocument.checkInternalConsistency() and
    SBMLDocument.checkConsistency().  Please refer to the documentation for
    SBMLDocument for more information about this.

    While applications may play fast and loose and live like free spirits
    during the construction and editing of SBML models, they should always
    make sure to call SBMLDocument.checkInternalConsistency() and/or
    SBMLDocument.checkConsistency() before writing out the final version of
    an SBML model.


    @section model-l3-attrib Model attributes introduced in SBML Level&nbsp;3

    As mentioned above, the Model class has a number of optional attributes
    in SBML Level&nbsp;3 Version&nbsp;1 Core.  These are 'substanceUnits',
    'timeUnits', 'volumeUnits', 'areaUnits', 'lengthUnits', 'extentUnits',
    and 'conversionFactor.  The following provide more information about
    them.

    @subsection model-l3-substanceunits The 'substanceUnits' attribute

    The 'substanceUnits' attribute is used to specify the unit of
    measurement associated with substance quantities of Species objects that
    do not specify units explicitly.  If a given Species object definition
    does not specify its unit of substance quantity via the 'substanceUnits'
    attribute on the Species object instance, then that species inherits the
    value of the Model 'substanceUnits' attribute.  If the Model does not
    define a value for this attribute, then there is no unit to inherit, and
    all species that do not specify individual 'substanceUnits' attribute
    values then have <em>no</em> declared units for their quantities.  The
    SBML Level&nbsp;3 Version&nbsp;1 Core specification provides more
    details.

    Note that when the identifier of a species appears in a model's
    mathematical expressions, the unit of measurement associated with that
    identifier is <em>not solely determined</em> by setting 'substanceUnits'
    on Model or Species.  Please see the discussion about units given in
    the documentation for the Species class.


    @subsection model-l3-timeunits The 'timeUnits' attribute

    The 'timeUnits' attribute on SBML Level&nbsp;3's Model object is used to
    specify the unit in which time is measured in the model.  This attribute
    on Model is the <em>only</em> way to specify a unit for time in a model.
    It is a global attribute; time is measured in the model everywhere in
    the same way.  This is particularly relevant to Reaction and RateRule
    objects in a model: all Reaction and RateRule objects in SBML define
    per-time values, and the unit of time is given by the 'timeUnits'
    attribute on the Model object instance.  If the Model 'timeUnits'
    attribute has no value, it means that the unit of time is not defined
    for the model's reactions and rate rules.  Leaving it unspecified in an
    SBML model does not result in an invalid model in SBML Level&nbsp;3;
    however, as a matter of best practice, we strongly recommend that all
    models specify units of measurement for time.


    @subsection model-l3-voletc The 'volumeUnits', 'areaUnits', and 'lengthUnits' attributes

    The attributes 'volumeUnits', 'areaUnits' and 'lengthUnits' together are
    used to set the units of measurements for the sizes of Compartment
    objects in an SBML Level&nbsp;3 model when those objects do not
    otherwise specify units.  The three attributes correspond to the most
    common cases of compartment dimensions: 'volumeUnits' for compartments
    having a 'spatialDimensions' attribute value of @c '3', 'areaUnits' for
    compartments having a 'spatialDimensions' attribute value of @c '2', and
    'lengthUnits' for compartments having a 'spatialDimensions' attribute
    value of @c '1'.  The attributes are not applicable to compartments
    whose 'spatialDimensions' attribute values are @em not one of @c '1', @c
    '2' or @c '3'.

    If a given Compartment object instance does not provide a value for its
    'units' attribute, then the unit of measurement of that compartment's
    size is inherited from the value specified by the Model 'volumeUnits',
    'areaUnits' or 'lengthUnits' attribute, as appropriate based on the
    Compartment object's 'spatialDimensions' attribute value.  If the Model
    object does not define the relevant attribute, then there are no units
    to inherit, and all Compartment objects that do not set a value for
    their 'units' attribute then have <em>no</em> units associated with
    their compartment sizes.

    The use of three separate attributes is a carry-over from SBML
    Level&nbsp;2.  Note that it is entirely possible for a model to define a
    value for two or more of the attributes 'volumeUnits', 'areaUnits' and
    'lengthUnits' simultaneously, because SBML models may contain
    compartments with different numbers of dimensions.


    @subsection model-l3-extentunits The 'extentUnits' attribute

    Reactions are processes that occur over time.  These processes involve
    events of some sort, where a single ``reaction event'' is one in which
    some set of entities (known as reactants, products and modifiers in
    SBML) interact, once.  The <em>extent</em> of a reaction is a measure of
    how many times the reaction has occurred, while the time derivative of
    the extent gives the instantaneous rate at which the reaction is
    occurring.  Thus, what is colloquially referred to as the 'rate of the
    reaction' is in fact equal to the rate of change of reaction extent.

    In SBML Level&nbsp;3, the combination of 'extentUnits' and 'timeUnits'
    defines the units of kinetic laws in SBML and establishes how the
    numerical value of each KineticLaw object's mathematical formula is
    meant to be interpreted in a model.  The units of the kinetic laws are
    taken to be 'extentUnits' divided by 'timeUnits'.

    Note that this embodies an important principle in SBML Level&nbsp;3
    models: <em>all reactions in an SBML model must have the same units</em>
    for the rate of change of extent.  In other words, the units of all
    reaction rates in the model <em>must be the same</em>.  There is only
    one global value for 'extentUnits' and one global value for 'timeUnits'.


    @subsection model-l3-convfactor The 'conversionFactor' attribute

    The attribute 'conversionFactor' in SBML Level&nbsp;3's Model object
    defines a global value inherited by all Species object instances that do
    not define separate values for their 'conversionFactor' attributes.  The
    value of this attribute must refer to a Parameter object instance
    defined in the model.  The Parameter object in question must be a
    constant; ie it must have its 'constant' attribute value set to @c 'True'.

    If a given Species object definition does not specify a conversion
    factor via the 'conversionFactor' attribute on Species, then the species
    inherits the conversion factor specified by the Model 'conversionFactor'
    attribute.  If the Model does not define a value for this attribute,
    then there is no conversion factor to inherit.  More information about
    conversion factors is provided in the SBML Level&nbsp;3 Version&nbsp;1
    specification.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Model
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Model
        __init__(self, SBMLNamespaces sbmlns) -> Model
        __init__(self, Model orig) -> Model

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Model(SBMLNamespaces sbmlns)</pre>

        Creates a new Model using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Model(long level, long version)</pre>

        Creates a new Model using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Model

        @param version a long integer, the SBML Version to assign to this
        Model

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Model(Model orig)</pre>

        Copy constructor; creates a (deep) copy of the given Model object.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Model(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Model

        Creates and returns a deep copy of this Model object.

        @return the (deep) copy of this Model object.

        """
        return _libsbml.Model_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id.

        This operation searches the model-wide <code>SId</code> identifier
        type namespace

        @param id string representing the id of the object to find.

        @return pointer to the first element found with the given @p id, or @c
        None if no such object is found.

        """
        return _libsbml.Model_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid.

        @param metaid string representing the meta-identifier of the object to
        find.

        @return pointer to the first element found with the given @p metaid, or
        None if no such object is found.

        """
        return _libsbml.Model_getElementByMetaId(self, *args)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Model.

        @return the id of this Model.

        """
        return _libsbml.Model_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Model.

        @return the name of this Model.

        """
        return _libsbml.Model_getName(self)

    def getSubstanceUnits(self):
        """
        getSubstanceUnits(self) -> string

        Returns the value of the 'substanceUnits' attribute of this Model.

        @return the substanceUnits of this Model.

        @note The 'substanceUnits' attribute is available in
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getSubstanceUnits(self)

    def getTimeUnits(self):
        """
        getTimeUnits(self) -> string

        Returns the value of the 'timeUnits' attribute of this Model.

        @return the timeUnits of this Model.

        @note The 'timeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getTimeUnits(self)

    def getVolumeUnits(self):
        """
        getVolumeUnits(self) -> string

        Returns the value of the 'volumeUnits' attribute of this Model.

        @return the volumeUnits of this Model.

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getVolumeUnits(self)

    def getAreaUnits(self):
        """
        getAreaUnits(self) -> string

        Returns the value of the 'areaUnits' attribute of this Model.

        @return the areaUnits of this Model.

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getAreaUnits(self)

    def getLengthUnits(self):
        """
        getLengthUnits(self) -> string

        Returns the value of the 'lengthUnits' attribute of this Model.

        @return the lengthUnits of this Model.

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getLengthUnits(self)

    def getExtentUnits(self):
        """
        getExtentUnits(self) -> string

        Returns the value of the 'extentUnits' attribute of this Model.

        @return the extentUnits of this Model.

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getExtentUnits(self)

    def getConversionFactor(self):
        """
        getConversionFactor(self) -> string

        Returns the value of the 'conversionFactor' attribute of this Model.

        @return the conversionFactor of this Model.

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_getConversionFactor(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        Model's 'id' attribute is set.

        @return @c True if the 'id' attribute of this Model is
        set, @c False otherwise.

        """
        return _libsbml.Model_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        Model's 'name' attribute is set.

        @return @c True if the 'name' attribute of this Model is
        set, @c False otherwise.

        """
        return _libsbml.Model_isSetName(self)

    def isSetSubstanceUnits(self):
        """
        isSetSubstanceUnits(self) -> bool

        Predicate returning @c True if this
        Model's 'substanceUnits' attribute is set.

        @return @c True if the 'substanceUnits' attribute of this Model is
        set, @c False otherwise.

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetSubstanceUnits(self)

    def isSetTimeUnits(self):
        """
        isSetTimeUnits(self) -> bool

        Predicate returning @c True if this
        Model's 'timeUnits' attribute is set.

        @return @c True if the 'timeUnits' attribute of this Model is
        set, @c False otherwise.

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetTimeUnits(self)

    def isSetVolumeUnits(self):
        """
        isSetVolumeUnits(self) -> bool

        Predicate returning @c True if this
        Model's 'volumeUnits' attribute is set.

        @return @c True if the 'volumeUnits' attribute of this Model is
        set, @c False otherwise.

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetVolumeUnits(self)

    def isSetAreaUnits(self):
        """
        isSetAreaUnits(self) -> bool

        Predicate returning @c True if this
        Model's 'areaUnits' attribute is set.

        @return @c True if the 'areaUnits' attribute of this Model is
        set, @c False otherwise.

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetAreaUnits(self)

    def isSetLengthUnits(self):
        """
        isSetLengthUnits(self) -> bool

        Predicate returning @c True if this
        Model's 'lengthUnits' attribute is set.

        @return @c True if the 'lengthUnits' attribute of this Model is
        set, @c False otherwise.

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetLengthUnits(self)

    def isSetExtentUnits(self):
        """
        isSetExtentUnits(self) -> bool

        Predicate returning @c True if this
        Model's 'extentUnits' attribute is set.

        @return @c True if the 'extentUnits' attribute of this Model is
        set, @c False otherwise.

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetExtentUnits(self)

    def isSetConversionFactor(self):
        """
        isSetConversionFactor(self) -> bool

        Predicate returning @c True if this
        Model's 'conversionFactor' attribute is set.

        @return @c True if the 'conversionFactor' attribute of this Model is
        set, @c False otherwise.

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_isSetConversionFactor(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Model.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Model_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Model.

        The string in @p name is copied.

        @param name the new name for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Model_setName(self, *args)

    def setSubstanceUnits(self, *args):
        """
        setSubstanceUnits(self, string units) -> int

        Sets the value of the 'substanceUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new substanceUnits for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setSubstanceUnits(self, *args)

    def setTimeUnits(self, *args):
        """
        setTimeUnits(self, string units) -> int

        Sets the value of the 'timeUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new timeUnits for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'timeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setTimeUnits(self, *args)

    def setVolumeUnits(self, *args):
        """
        setVolumeUnits(self, string units) -> int

        Sets the value of the 'volumeUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new volumeUnits for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setVolumeUnits(self, *args)

    def setAreaUnits(self, *args):
        """
        setAreaUnits(self, string units) -> int

        Sets the value of the 'areaUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new areaUnits for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setAreaUnits(self, *args)

    def setLengthUnits(self, *args):
        """
        setLengthUnits(self, string units) -> int

        Sets the value of the 'lengthUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new lengthUnits for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setLengthUnits(self, *args)

    def setExtentUnits(self, *args):
        """
        setExtentUnits(self, string units) -> int

        Sets the value of the 'extentUnits' attribute of this Model.

        The string in @p units is copied.

        @param units the new extentUnits for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setExtentUnits(self, *args)

    def setConversionFactor(self, *args):
        """
        setConversionFactor(self, string units) -> int

        Sets the value of the 'conversionFactor' attribute of this Model.

        The string in @p units is copied.

        @param units the new conversionFactor for the Model

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_setConversionFactor(self, *args)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Model_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Model_unsetName(self)

    def unsetSubstanceUnits(self):
        """
        unsetSubstanceUnits(self) -> int

        Unsets the value of the 'substanceUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'substanceUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetSubstanceUnits(self)

    def unsetTimeUnits(self):
        """
        unsetTimeUnits(self) -> int

        Unsets the value of the 'timeUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'timeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetTimeUnits(self)

    def unsetVolumeUnits(self):
        """
        unsetVolumeUnits(self) -> int

        Unsets the value of the 'volumeUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'volumeUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetVolumeUnits(self)

    def unsetAreaUnits(self):
        """
        unsetAreaUnits(self) -> int

        Unsets the value of the 'areaUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'areaUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetAreaUnits(self)

    def unsetLengthUnits(self):
        """
        unsetLengthUnits(self) -> int

        Unsets the value of the 'lengthUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'lengthUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetLengthUnits(self)

    def unsetExtentUnits(self):
        """
        unsetExtentUnits(self) -> int

        Unsets the value of the 'extentUnits' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'extentUnits' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetExtentUnits(self)

    def unsetConversionFactor(self):
        """
        unsetConversionFactor(self) -> int

        Unsets the value of the 'conversionFactor' attribute of this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'conversionFactor' attribute is available in 
        SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.

        """
        return _libsbml.Model_unsetConversionFactor(self)

    def addFunctionDefinition(self, *args):
        """
        addFunctionDefinition(self, FunctionDefinition fd) -> int

        Adds a copy of the given FunctionDefinition object to this Model.

        @param fd the FunctionDefinition to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createFunctionDefinition()

        """
        return _libsbml.Model_addFunctionDefinition(self, *args)

    def addUnitDefinition(self, *args):
        """
        addUnitDefinition(self, UnitDefinition ud) -> int

        Adds a copy of the given UnitDefinition object to this Model.

        @param ud the UnitDefinition object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createUnitDefinition()

        """
        return _libsbml.Model_addUnitDefinition(self, *args)

    def addCompartmentType(self, *args):
        """
        addCompartmentType(self, CompartmentType ct) -> int

        Adds a copy of the given CompartmentType object to this Model.

        @param ct the CompartmentType object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        @see createCompartmentType()

        """
        return _libsbml.Model_addCompartmentType(self, *args)

    def addSpeciesType(self, *args):
        """
        addSpeciesType(self, SpeciesType st) -> int

        Adds a copy of the given SpeciesType object to this Model.

        @param st the SpeciesType object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        @see createSpeciesType()

        """
        return _libsbml.Model_addSpeciesType(self, *args)

    def addCompartment(self, *args):
        """
        addCompartment(self, Compartment c) -> int

        Adds a copy of the given Compartment object to this Model.

        @param c the Compartment object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createCompartment()

        """
        return _libsbml.Model_addCompartment(self, *args)

    def addSpecies(self, *args):
        """
        addSpecies(self, Species s) -> int

        Adds a copy of the given Species object to this Model.

        @param s the Species object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createSpecies()

        """
        return _libsbml.Model_addSpecies(self, *args)

    def addParameter(self, *args):
        """
        addParameter(self, Parameter p) -> int

        Adds a copy of the given Parameter object to this Model.

        @param p the Parameter object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createParameter()

        """
        return _libsbml.Model_addParameter(self, *args)

    def addInitialAssignment(self, *args):
        """
        addInitialAssignment(self, InitialAssignment ia) -> int

        Adds a copy of the given InitialAssignment object to this Model.

        @param ia the InitialAssignment object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createInitialAssignment()

        """
        return _libsbml.Model_addInitialAssignment(self, *args)

    def addRule(self, *args):
        """
        addRule(self, Rule r) -> int

        Adds a copy of the given Rule object to this Model.

        @param r the Rule object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createAlgebraicRule()
        @see createAssignmentRule()
        @see createRateRule()

        """
        return _libsbml.Model_addRule(self, *args)

    def addConstraint(self, *args):
        """
        addConstraint(self, Constraint c) -> int

        Adds a copy of the given Constraint object to this Model.

        @param c the Constraint object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createConstraint()

        """
        return _libsbml.Model_addConstraint(self, *args)

    def addReaction(self, *args):
        """
        addReaction(self, Reaction r) -> int

        Adds a copy of the given Reaction object to this Model.

        @param r the Reaction object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createReaction()

        """
        return _libsbml.Model_addReaction(self, *args)

    def addEvent(self, *args):
        """
        addEvent(self, Event e) -> int

        Adds a copy of the given Event object to this Model.

        @param e the Event object to add

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createEvent()

        """
        return _libsbml.Model_addEvent(self, *args)

    def createFunctionDefinition(self):
        """
        createFunctionDefinition(self) -> FunctionDefinition

        Creates a new FunctionDefinition inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the FunctionDefinition object created

        @see addFunctionDefinition()

        """
        return _libsbml.Model_createFunctionDefinition(self)

    def createUnitDefinition(self):
        """
        createUnitDefinition(self) -> UnitDefinition

        Creates a new UnitDefinition inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the UnitDefinition object created

        @see addUnitDefinition()

        """
        return _libsbml.Model_createUnitDefinition(self)

    def createUnit(self):
        """
        createUnit(self) -> Unit

        Creates a new Unit object within the last UnitDefinition object
        created in this model and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        The mechanism by which the UnitDefinition was created is not
        significant.  If a UnitDefinition object does not exist in this model,
        a new Unit is @em not created and @c None is returned instead.

        @return the Unit object created

        @see addUnitDefinition()

        """
        return _libsbml.Model_createUnit(self)

    def createCompartmentType(self):
        """
        createCompartmentType(self) -> CompartmentType

        Creates a new CompartmentType inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the CompartmentType object created

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        @see addCompartmentType()

        """
        return _libsbml.Model_createCompartmentType(self)

    def createSpeciesType(self):
        """
        createSpeciesType(self) -> SpeciesType

        Creates a new SpeciesType inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the SpeciesType object created

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        @see addSpeciesType()

        """
        return _libsbml.Model_createSpeciesType(self)

    def createCompartment(self):
        """
        createCompartment(self) -> Compartment

        Creates a new Compartment inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the Compartment object created

        @see addCompartment()

        """
        return _libsbml.Model_createCompartment(self)

    def createSpecies(self):
        """
        createSpecies(self) -> Species

        Creates a new Species inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the Species object created

        @see addSpecies()

        """
        return _libsbml.Model_createSpecies(self)

    def createParameter(self):
        """
        createParameter(self) -> Parameter

        Creates a new Parameter inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the Parameter object created

        @see addParameter()

        """
        return _libsbml.Model_createParameter(self)

    def createInitialAssignment(self):
        """
        createInitialAssignment(self) -> InitialAssignment

        Creates a new InitialAssignment inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the InitialAssignment object created

        @see addInitialAssignment()

        """
        return _libsbml.Model_createInitialAssignment(self)

    def createAlgebraicRule(self):
        """
        createAlgebraicRule(self) -> AlgebraicRule

        Creates a new AlgebraicRule inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the AlgebraicRule object created

        @see addRule()

        """
        return _libsbml.Model_createAlgebraicRule(self)

    def createAssignmentRule(self):
        """
        createAssignmentRule(self) -> AssignmentRule

        Creates a new AssignmentRule inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the AssignmentRule object created

        @see addRule()

        """
        return _libsbml.Model_createAssignmentRule(self)

    def createRateRule(self):
        """
        createRateRule(self) -> RateRule

        Creates a new RateRule inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the RateRule object created

        @see addRule()

        """
        return _libsbml.Model_createRateRule(self)

    def createConstraint(self):
        """
        createConstraint(self) -> Constraint

        Creates a new Constraint inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the Constraint object created

        @see addConstraint()

        """
        return _libsbml.Model_createConstraint(self)

    def createReaction(self):
        """
        createReaction(self) -> Reaction

        Creates a new Reaction inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the Reaction object created

        @see addReaction()

        """
        return _libsbml.Model_createReaction(self)

    def createReactant(self):
        """
        createReactant(self) -> SpeciesReference

        Creates a new SpeciesReference object for a reactant inside the last
        Reaction object in this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new SpeciesReference is @em not
        created and @c None is returned instead.

        @return the SpeciesReference object created.  If a Reaction does not
        exist for this model, a new SpeciesReference is @em not created and @c
        None is returned.

        """
        return _libsbml.Model_createReactant(self)

    def createProduct(self):
        """
        createProduct(self) -> SpeciesReference

        Creates a new SpeciesReference object for a product inside the last
        Reaction object in this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new SpeciesReference is @em not
        created and @c None is returned instead.

        @return the SpeciesReference object created. If a Reaction does not
        exist for this model, a new SpeciesReference is @em not created and @c
        None is returned.

        """
        return _libsbml.Model_createProduct(self)

    def createModifier(self):
        """
        createModifier(self) -> ModifierSpeciesReference

        Creates a new ModifierSpeciesReference object for a modifier species
        inside the last Reaction object in this Model, and returns a pointer
        to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new SpeciesReference is @em not
        created and @c None is returned instead.

        @return the SpeciesReference object created.  If a Reaction does not
        exist for this model, a new SpeciesReference is @em not created and @c
        None is returned.

        """
        return _libsbml.Model_createModifier(self)

    def createKineticLaw(self):
        """
        createKineticLaw(self) -> KineticLaw

        Creates a new KineticLaw inside the last Reaction object created in
        this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Reaction object was created and added
        to this Model is not significant.  It could have been created in a
        variety of ways, for example using createReaction().  If a Reaction
        does not exist for this model, a new SpeciesReference is @em not
        created and @c None is returned instead.

        @return the KineticLaw object created.  If a Reaction does not exist for
        this model, or a Reaction does exist but already has a KineticLaw, a new
        KineticLaw is @em not created and @c None is returned.

        """
        return _libsbml.Model_createKineticLaw(self)

    def createKineticLawParameter(self):
        """
        createKineticLawParameter(self) -> Parameter

        Creates a new local Parameter inside the KineticLaw object of the last
        Reaction created inside this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The last KineticLaw object in this Model could have been created in a
        variety of ways.  For example, it could have been added using
        createKineticLaw(), or it could be the result of using
        Reaction.createKineticLaw() on the Reaction object created by a
        createReaction().  If a Reaction does not exist for this model, or the
        last Reaction does not contain a KineticLaw object, a new Parameter is
        @em not created and @c None is returned instead.

        @return the Parameter object created.  If a Reaction does not exist for
        this model, or a KineticLaw for the Reaction does not exist, a new
        Parameter is @em not created and @c None is returned.

        """
        return _libsbml.Model_createKineticLawParameter(self)

    def createKineticLawLocalParameter(self):
        """
        createKineticLawLocalParameter(self) -> LocalParameter

        Creates a new LocalParameter inside the KineticLaw object of the last
        Reaction created inside this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The last KineticLaw object in this Model could have been created in a
        variety of ways.  For example, it could have been added using
        createKineticLaw(), or it could be the result of using
        Reaction.createKineticLaw() on the Reaction object created by a
        createReaction().  If a Reaction does not exist for this model, or the
        last Reaction does not contain a KineticLaw object, a new Parameter is
        @em not created and @c None is returned instead.

        @return the Parameter object created.  If a Reaction does not exist for
        this model, or a KineticLaw for the Reaction does not exist, a new
        Parameter is @em not created and @c None is returned.

        """
        return _libsbml.Model_createKineticLawLocalParameter(self)

    def createEvent(self):
        """
        createEvent(self) -> Event

        Creates a new Event inside this Model and returns it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @return the Event object created

        """
        return _libsbml.Model_createEvent(self)

    def createEventAssignment(self):
        """
        createEventAssignment(self) -> EventAssignment

        Creates a new EventAssignment inside the last Event object created in
        this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Event object in this model was created
        is not significant.  It could have been created in a variety of ways,
        for example by using createEvent().  If no Event object exists in this
        Model object, a new EventAssignment is @em not created and @c None is
        returned instead.

        @return the EventAssignment object created

        """
        return _libsbml.Model_createEventAssignment(self)

    def createTrigger(self):
        """
        createTrigger(self) -> Trigger

        Creates a new Trigger inside the last Event object created in
        this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Event object in this model was created
        is not significant.  It could have been created in a variety of ways,
        for example by using createEvent().  If no Event object exists in this
        Model object, a new EventAssignment is @em not created and @c None is
        returned instead.

        @return the Trigger object created

        """
        return _libsbml.Model_createTrigger(self)

    def createDelay(self):
        """
        createDelay(self) -> Delay

        Creates a new Delay inside the last Event object created in
        this Model, and returns a pointer to it.

        The SBML Level and Version of the enclosing Model object, as well as
        any SBML package namespaces, are used to initialize this
        object's corresponding attributes.

        @par
        The mechanism by which the last Event object in this model was created
        is not significant.  It could have been created in a variety of ways,
        for example by using createEvent().  If no Event object exists in this
        Model object, a new EventAssignment is @em not created and @c None is
        returned instead.

        @return the Delay object created

        """
        return _libsbml.Model_createDelay(self)

    def setAnnotation(self, *args):
        """
        setAnnotation(self, XMLNode annotation) -> int
        setAnnotation(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setAnnotation(XMLNode annotation)</pre>

        Sets the value of the 'annotation' subelement of this SBML object to a
        copy of @p annotation.

        Any existing content of the 'annotation' subelement is discarded.
        Unless you have taken steps to first copy and reconstitute any
        existing annotations into the @p annotation that is about to be
        assigned, it is likely that performing such wholesale replacement is
        unfriendly towards other software applications whose annotations are
        discarded.  An alternative may be to use appendAnnotation().

        @param annotation an XML structure that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see appendAnnotation()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setAnnotation(string annotation)</pre>

        Sets the value of the 'annotation' subelement of this SBML object to a
        copy of @p annotation.

        Any existing content of the 'annotation' subelement is discarded.
        Unless you have taken steps to first copy and reconstitute any
        existing annotations into the @p annotation that is about to be
        assigned, it is likely that performing such wholesale replacement is
        unfriendly towards other software applications whose annotations are
        discarded.  An alternative may be to use appendAnnotation().

        @param annotation an XML string that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see appendAnnotation()

        """
        return _libsbml.Model_setAnnotation(self, *args)

    def appendAnnotation(self, *args):
        """
        appendAnnotation(self, XMLNode annotation) -> int
        appendAnnotation(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendAnnotation(XMLNode annotation)</pre>

        Appends annotation content to any existing content in the 'annotation'
        subelement of this object.

        The content in @p annotation is copied.  Unlike setAnnotation(), this
        method allows other annotations to be preserved when an application
        adds its own data.

        @param annotation an XML structure that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see setAnnotation()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendAnnotation(string annotation)</pre>

        Appends annotation content to any existing content in the 'annotation'
        subelement of this object.

        The content in @p annotation is copied.  Unlike setAnnotation(), this 
        method allows other annotations to be preserved when an application
        adds its own data.

        @param annotation an XML string that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see setAnnotation()

        """
        return _libsbml.Model_appendAnnotation(self, *args)

    def getListOfFunctionDefinitions(self, *args):
        """
        getListOfFunctionDefinitions(self) -> ListOfFunctionDefinitions
        getListOfFunctionDefinitions(self) -> ListOfFunctionDefinitions

        Get the ListOfFunctionDefinitions object in this Model.

        @return the list of FunctionDefinitions for this Model.

        """
        return _libsbml.Model_getListOfFunctionDefinitions(self, *args)

    def getListOfUnitDefinitions(self, *args):
        """
        getListOfUnitDefinitions(self) -> ListOfUnitDefinitions
        getListOfUnitDefinitions(self) -> ListOfUnitDefinitions

        Get the ListOfUnitDefinitions object in this Model.

        @return the list of UnitDefinitions for this Model.

        """
        return _libsbml.Model_getListOfUnitDefinitions(self, *args)

    def getListOfCompartmentTypes(self, *args):
        """
        getListOfCompartmentTypes(self) -> ListOfCompartmentTypes
        getListOfCompartmentTypes(self) -> ListOfCompartmentTypes

        Get the ListOfCompartmentTypes object in this Model.

        @return the list of CompartmentTypes for this Model.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        """
        return _libsbml.Model_getListOfCompartmentTypes(self, *args)

    def getListOfSpeciesTypes(self, *args):
        """
        getListOfSpeciesTypes(self) -> ListOfSpeciesTypes
        getListOfSpeciesTypes(self) -> ListOfSpeciesTypes

        Get the ListOfSpeciesTypes object in this Model.

        @return the list of SpeciesTypes for this Model.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        """
        return _libsbml.Model_getListOfSpeciesTypes(self, *args)

    def getListOfCompartments(self, *args):
        """
        getListOfCompartments(self) -> ListOfCompartments
        getListOfCompartments(self) -> ListOfCompartments

        Get the ListOfCompartments object in this Model.

        @return the list of Compartments for this Model.

        """
        return _libsbml.Model_getListOfCompartments(self, *args)

    def getListOfSpecies(self, *args):
        """
        getListOfSpecies(self) -> ListOfSpecies
        getListOfSpecies(self) -> ListOfSpecies

        Get the ListOfSpecies object in this Model.

        @return the list of Species for this Model.

        """
        return _libsbml.Model_getListOfSpecies(self, *args)

    def getListOfParameters(self, *args):
        """
        getListOfParameters(self) -> ListOfParameters
        getListOfParameters(self) -> ListOfParameters

        Get the ListOfParameters object in this Model.

        @return the list of Parameters for this Model.

        """
        return _libsbml.Model_getListOfParameters(self, *args)

    def getListOfInitialAssignments(self, *args):
        """
        getListOfInitialAssignments(self) -> ListOfInitialAssignments
        getListOfInitialAssignments(self) -> ListOfInitialAssignments

        Get the ListOfInitialAssignments object in this Model.

        @return the list of InitialAssignments for this Model.

        """
        return _libsbml.Model_getListOfInitialAssignments(self, *args)

    def getListOfRules(self, *args):
        """
        getListOfRules(self) -> ListOfRules
        getListOfRules(self) -> ListOfRules

        Get the ListOfRules object in this Model.

        @return the list of Rules for this Model.

        """
        return _libsbml.Model_getListOfRules(self, *args)

    def getListOfConstraints(self, *args):
        """
        getListOfConstraints(self) -> ListOfConstraints
        getListOfConstraints(self) -> ListOfConstraints

        Get the ListOfConstraints object in this Model.

        @return the list of Constraints for this Model.

        """
        return _libsbml.Model_getListOfConstraints(self, *args)

    def getListOfReactions(self, *args):
        """
        getListOfReactions(self) -> ListOfReactions
        getListOfReactions(self) -> ListOfReactions

        Get the ListOfReactions object in this Model.

        @return the list of Reactions for this Model.

        """
        return _libsbml.Model_getListOfReactions(self, *args)

    def getListOfEvents(self, *args):
        """
        getListOfEvents(self) -> ListOfEvents
        getListOfEvents(self) -> ListOfEvents

        Get the ListOfEvents object in this Model.

        @return the list of Events for this Model.

        """
        return _libsbml.Model_getListOfEvents(self, *args)

    def getFunctionDefinition(self, *args):
        """
        getFunctionDefinition(self, unsigned int n) -> FunctionDefinition
        getFunctionDefinition(self, unsigned int n) -> FunctionDefinition
        getFunctionDefinition(self, string sid) -> FunctionDefinition
        getFunctionDefinition(self, string sid) -> FunctionDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getFunctionDefinition(long n)</pre>

        Get the nth FunctionDefinitions object in this Model.

        @param n the index of the object to return.

        @return the nth FunctionDefinition of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getFunctionDefinition(string sid)</pre>

        Get a FunctionDefinition object based on its identifier.

        @param sid the identifier to search for.

        @return the FunctionDefinition in this Model with the identifier
        @p sid or @c None if no such FunctionDefinition exists.

        """
        return _libsbml.Model_getFunctionDefinition(self, *args)

    def getUnitDefinition(self, *args):
        """
        getUnitDefinition(self, unsigned int n) -> UnitDefinition
        getUnitDefinition(self, unsigned int n) -> UnitDefinition
        getUnitDefinition(self, string sid) -> UnitDefinition
        getUnitDefinition(self, string sid) -> UnitDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getUnitDefinition(long n)</pre>

        Get the nth UnitDefinition object in this Model.

        @param n the index of the object to return.

        @return the nth UnitDefinition of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getUnitDefinition(string sid)</pre>

        Get a UnitDefinition based on its identifier.

        @param sid the identifier to search for.

        @return the UnitDefinition in this Model with the identifier @p sid or
        @c None if no such UnitDefinition exists.

        """
        return _libsbml.Model_getUnitDefinition(self, *args)

    def getCompartmentType(self, *args):
        """
        getCompartmentType(self, unsigned int n) -> CompartmentType
        getCompartmentType(self, unsigned int n) -> CompartmentType
        getCompartmentType(self, string sid) -> CompartmentType
        getCompartmentType(self, string sid) -> CompartmentType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getCompartmentType(long n)</pre>

        Get the nth CompartmentType object in this Model.

        @param n the index of the object to return.

        @return the nth CompartmentType of this Model.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getCompartmentType(string sid)</pre>

        Get a CompartmentType object based on its identifier.

        @param sid the identifier to search for.

        @return the CompartmentType in this Model with the identifier @p sid
        or @c None if no such CompartmentType exists.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        """
        return _libsbml.Model_getCompartmentType(self, *args)

    def getSpeciesType(self, *args):
        """
        getSpeciesType(self, unsigned int n) -> SpeciesType
        getSpeciesType(self, unsigned int n) -> SpeciesType
        getSpeciesType(self, string sid) -> SpeciesType
        getSpeciesType(self, string sid) -> SpeciesType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getSpeciesType(long n)</pre>

        Get the nth SpeciesType object in this Model.

        @param n the index of the object to return.

        @return the nth SpeciesType of this Model.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getSpeciesType(string sid)</pre>

        Get a SpeciesType object based on its identifier.

        @param sid the identifier to search for.

        @return the SpeciesType in this Model with the identifier @p sid or
        @c None if no such SpeciesType exists.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        """
        return _libsbml.Model_getSpeciesType(self, *args)

    def getCompartment(self, *args):
        """
        getCompartment(self, unsigned int n) -> Compartment
        getCompartment(self, unsigned int n) -> Compartment
        getCompartment(self, string sid) -> Compartment
        getCompartment(self, string sid) -> Compartment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getCompartment(long n)</pre>

        Get the nth Compartment object in this Model.

        @param n the index of the object to return.

        @return the nth Compartment of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getCompartment(string sid)</pre>

        Get a Compartment object based on its identifier.

        @param sid the identifier to search for.

        @return the Compartment in this Model with the identifier @p sid or
        @c None if no such Compartment exists.

        """
        return _libsbml.Model_getCompartment(self, *args)

    def getSpecies(self, *args):
        """
        getSpecies(self, unsigned int n) -> Species
        getSpecies(self, unsigned int n) -> Species
        getSpecies(self, string sid) -> Species
        getSpecies(self, string sid) -> Species

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getSpecies(long n)</pre>

        Get the nth Species object in this Model.

        @param n the index of the object to return.

        @return the nth Species of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getSpecies(string sid)</pre>

        Get a Species object based on its identifier.

        @param sid the identifier to search for.

        @return the Species in this Model with the identifier @p sid or @c None
        if no such Species exists.

        """
        return _libsbml.Model_getSpecies(self, *args)

    def getParameter(self, *args):
        """
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, string sid) -> Parameter
        getParameter(self, string sid) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getParameter(long n)</pre>

        Get the nth Parameter object in this Model.

        @param n the index of the object to return.

        @return the nth Parameter of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getParameter(string sid)</pre>

        Get a Parameter object based on its identifier.

        @param sid the identifier to search for.

        @return the Parameter in this Model with the identifier @p sid or @c None
        if no such Parameter exists.

        """
        return _libsbml.Model_getParameter(self, *args)

    def getInitialAssignment(self, *args):
        """
        getInitialAssignment(self, unsigned int n) -> InitialAssignment
        getInitialAssignment(self, unsigned int n) -> InitialAssignment
        getInitialAssignment(self, string symbol) -> InitialAssignment
        getInitialAssignment(self, string symbol) -> InitialAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getInitialAssignment(string symbol)</pre>

        Get an InitialAssignment object based on the symbol to which it
        assigns a value.

        @param symbol the symbol to search for.

        @return the InitialAssignment in this Model with the given 'symbol'
        attribute value or @c None if no such InitialAssignment exists.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getInitialAssignment(long n)</pre>

        Get the nth InitialAssignment object in this Model.

        @param n the index of the object to return.

        @return the nth InitialAssignment of this Model.

        """
        return _libsbml.Model_getInitialAssignment(self, *args)

    def getInitialAssignmentBySymbol(self, *args):
        """
        getInitialAssignmentBySymbol(self, string symbol) -> InitialAssignment
        getInitialAssignmentBySymbol(self, string symbol) -> InitialAssignment

        Get an InitialAssignment object based on the symbol to which it
        assigns a value.

        @param symbol the symbol to search for.

        @return the InitialAssignment in this Model with the given 'symbol'
        attribute value or @c None if no such InitialAssignment exists.

        """
        return _libsbml.Model_getInitialAssignmentBySymbol(self, *args)

    def getRule(self, *args):
        """
        getRule(self, unsigned int n) -> Rule
        getRule(self, unsigned int n) -> Rule
        getRule(self, string variable) -> Rule
        getRule(self, string variable) -> Rule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getRule(string variable)</pre>

        Get a Rule object based on the variable to which it assigns a value.

        @param variable the variable to search for.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c None if no such Rule exists.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getRule(long n)</pre>

        Get the nth Rule object in this Model.

        @param n the index of the object to return.

        @return the nth Rule of this Model.

        """
        return _libsbml.Model_getRule(self, *args)

    def getRuleByVariable(self, *args):
        """
        getRuleByVariable(self, string variable) -> Rule
        getRuleByVariable(self, string variable) -> Rule

        Get a Rule object based on the variable to which it assigns a value.

        @param variable the variable to search for.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c None if no such Rule exists.

        """
        return _libsbml.Model_getRuleByVariable(self, *args)

    def getAssignmentRule(self, *args):
        """
        getAssignmentRule(self, string variable) -> AssignmentRule
        getAssignmentRule(self, string variable) -> AssignmentRule

        Get a Rule object based on the variable to which it assigns a value.

        @param variable the variable to search for.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c None if no such Rule exists.

        """
        return _libsbml.Model_getAssignmentRule(self, *args)

    def getRateRule(self, *args):
        """
        getRateRule(self, string variable) -> RateRule
        getRateRule(self, string variable) -> RateRule

        Get a Rule object based on the variable to which it assigns a value.

        @param variable the symbol to search for.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c None if no such Rule exists.

        """
        return _libsbml.Model_getRateRule(self, *args)

    def getAssignmentRuleByVariable(self, *args):
        """
        getAssignmentRuleByVariable(self, string variable) -> AssignmentRule
        getAssignmentRuleByVariable(self, string variable) -> AssignmentRule

        Get a Rule object based on the variable to which it assigns a value.

        @param variable the variable to search for.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c None if no such Rule exists.

        """
        return _libsbml.Model_getAssignmentRuleByVariable(self, *args)

    def getRateRuleByVariable(self, *args):
        """
        getRateRuleByVariable(self, string variable) -> RateRule
        getRateRuleByVariable(self, string variable) -> RateRule

        Get a Rule object based on the variable to which it assigns a value.

        @param variable the variable to search for.

        @return the Rule in this Model with the given 'variable' attribute
        value or @c None if no such Rule exists.

        """
        return _libsbml.Model_getRateRuleByVariable(self, *args)

    def getConstraint(self, *args):
        """
        getConstraint(self, unsigned int n) -> Constraint
        getConstraint(self, unsigned int n) -> Constraint

        Get the nth Constraint object in this Model.

        @param n the index of the object to return.

        @return the nth Constraint of this Model.

        """
        return _libsbml.Model_getConstraint(self, *args)

    def getReaction(self, *args):
        """
        getReaction(self, unsigned int n) -> Reaction
        getReaction(self, unsigned int n) -> Reaction
        getReaction(self, string sid) -> Reaction
        getReaction(self, string sid) -> Reaction

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getReaction(long n)</pre>

        Get the nth Reaction object in this Model.

        @param n the index of the object to return.

        @return the nth Reaction of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getReaction(string sid)</pre>

        Get a Reaction object based on its identifier.

        @param sid the identifier to search for.

        @return the Reaction in this Model with the identifier @p sid or @c None
        if no such Reaction exists.

        """
        return _libsbml.Model_getReaction(self, *args)

    def getSpeciesReference(self, *args):
        """
        getSpeciesReference(self, string sid) -> SpeciesReference
        getSpeciesReference(self, string sid) -> SpeciesReference

        Get a SpeciesReference object based on its identifier.

        @param sid the identifier to search for.

        @return the SpeciesReference in this Model with the identifier @p sid or @c None
        if no such SpeciesReference exists.

        """
        return _libsbml.Model_getSpeciesReference(self, *args)

    def getModifierSpeciesReference(self, *args):
        """
        getModifierSpeciesReference(self, string sid) -> ModifierSpeciesReference
        getModifierSpeciesReference(self, string sid) -> ModifierSpeciesReference

        Get a ModifierSpeciesReference object based on its identifier.

        @param sid the identifier to search for.

        @return the ModifierSpeciesReference in this Model with the 
        identifier @p sid or @c None
        if no such ModifierSpeciesReference exists.

        """
        return _libsbml.Model_getModifierSpeciesReference(self, *args)

    def getEvent(self, *args):
        """
        getEvent(self, unsigned int n) -> Event
        getEvent(self, unsigned int n) -> Event
        getEvent(self, string sid) -> Event
        getEvent(self, string sid) -> Event

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getEvent(long n)</pre>

        Get the nth Event object in this Model.

        @param n the index of the object to return.

        @return the nth Event of this Model.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getEvent(string sid)</pre>

        Get an Event object based on its identifier.

        @param sid the identifier to search for.

        @return the Event in this Model with the identifier @p sid or @c None if
        no such Event exists.

        """
        return _libsbml.Model_getEvent(self, *args)

    def getNumFunctionDefinitions(self):
        """
        getNumFunctionDefinitions(self) -> unsigned int

        Get the number of FunctionDefinition objects in this Model.

        @return the number of FunctionDefinitions in this Model.

        """
        return _libsbml.Model_getNumFunctionDefinitions(self)

    def getNumUnitDefinitions(self):
        """
        getNumUnitDefinitions(self) -> unsigned int

        Get the number of UnitDefinition objects in this Model.

        @return the number of UnitDefinitions in this Model.

        """
        return _libsbml.Model_getNumUnitDefinitions(self)

    def getNumCompartmentTypes(self):
        """
        getNumCompartmentTypes(self) -> unsigned int

        Get the number of CompartmentType objects in this Model.

        @return the number of CompartmentTypes in this Model.

        @note The CompartmentType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        """
        return _libsbml.Model_getNumCompartmentTypes(self)

    def getNumSpeciesTypes(self):
        """
        getNumSpeciesTypes(self) -> unsigned int

        Get the number of SpeciesType objects in this Model.

        @return the number of SpeciesTypes in this Model.

        @note The SpeciesType object class is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in
        Level&nbsp;1 nor Level&nbsp;3.

        """
        return _libsbml.Model_getNumSpeciesTypes(self)

    def getNumCompartments(self):
        """
        getNumCompartments(self) -> unsigned int

        Get the number of Compartment objects in this Model.

        @return the number of Compartments in this Model.

        """
        return _libsbml.Model_getNumCompartments(self)

    def getNumSpecies(self):
        """
        getNumSpecies(self) -> unsigned int

        Get the number of Specie objects in this Model.

        @return the number of Species in this Model.

        """
        return _libsbml.Model_getNumSpecies(self)

    def getNumSpeciesWithBoundaryCondition(self):
        """
        getNumSpeciesWithBoundaryCondition(self) -> unsigned int

        Get the number of Species in this Model having their
        'boundaryCondition' attribute value set to @c True.

        @return the number of Species in this Model with boundaryCondition set
        to true.

        """
        return _libsbml.Model_getNumSpeciesWithBoundaryCondition(self)

    def getNumParameters(self):
        """
        getNumParameters(self) -> unsigned int

        Get the number of Parameter objects in this Model.

        @return the number of Parameters in this Model.  Parameters defined in
        KineticLaws are not included.

        """
        return _libsbml.Model_getNumParameters(self)

    def getNumInitialAssignments(self):
        """
        getNumInitialAssignments(self) -> unsigned int

        Get the number of InitialAssignment objects in this Model.

        @return the number of InitialAssignments in this Model.

        """
        return _libsbml.Model_getNumInitialAssignments(self)

    def getNumRules(self):
        """
        getNumRules(self) -> unsigned int

        Get the number of Rule objects in this Model.

        @return the number of Rules in this Model.

        """
        return _libsbml.Model_getNumRules(self)

    def getNumConstraints(self):
        """
        getNumConstraints(self) -> unsigned int

        Get the number of Constraint objects in this Model.

        @return the number of Constraints in this Model.

        """
        return _libsbml.Model_getNumConstraints(self)

    def getNumReactions(self):
        """
        getNumReactions(self) -> unsigned int

        Get the number of Reaction objects in this Model.

        @return the number of Reactions in this Model.

        """
        return _libsbml.Model_getNumReactions(self)

    def getNumEvents(self):
        """
        getNumEvents(self) -> unsigned int

        Get the number of Event objects in this Model.

        @return the number of Events in this Model.

        """
        return _libsbml.Model_getNumEvents(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Remove this Model from its parent SBMLDocument object.

        This works by finding this Model's parent SBMLDocument and then calling
        <code>setModel(None)</code> on it, indirectly deleting itself.
        Overridden from the SBase function since the parent is not a ListOf.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Model_removeFromParentAndDelete(self)

    def renameAllIds(self, *args):
        """
        renameAllIds(self, IdentifierTransformer idTransformer, ElementFilter filter = None) -> int
        renameAllIds(self, IdentifierTransformer idTransformer) -> int

        @internal

        @internal

        """
        return _libsbml.Model_renameAllIds(self, *args)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Model_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Model_renameUnitSIdRefs(self, *args)

    def convertL1ToL2(self):
        """
        convertL1ToL2(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertL1ToL2(self)

    def convertL1ToL3(self):
        """
        convertL1ToL3(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertL1ToL3(self)

    def convertL2ToL3(self):
        """
        convertL2ToL3(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertL2ToL3(self)

    def convertL2ToL1(self, strict = False):
        """
        convertL2ToL1(self, bool strict = False)
        convertL2ToL1(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertL2ToL1(self, strict)

    def convertL3ToL1(self):
        """
        convertL3ToL1(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertL3ToL1(self)

    def convertL3ToL2(self, strict = False):
        """
        convertL3ToL2(self, bool strict = False)
        convertL3ToL2(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertL3ToL2(self, strict)

    def addModifiers(self):
        """
        addModifiers(self)

        @internal

        @internal

        """
        return _libsbml.Model_addModifiers(self)

    def addConstantAttribute(self):
        """
        addConstantAttribute(self)

        @internal

        @internal

        """
        return _libsbml.Model_addConstantAttribute(self)

    def setSpatialDimensions(self, dims = 3.0):
        """
        setSpatialDimensions(self, double dims = 3.0)
        setSpatialDimensions(self)

        @internal

        @internal

        """
        return _libsbml.Model_setSpatialDimensions(self, dims)

    def addDefinitionsForDefaultUnits(self):
        """
        addDefinitionsForDefaultUnits(self)

        @internal

        @internal

        """
        return _libsbml.Model_addDefinitionsForDefaultUnits(self)

    def convertParametersToLocals(self, *args):
        """
        convertParametersToLocals(self, unsigned int level, unsigned int version)

        @internal

        @internal

        """
        return _libsbml.Model_convertParametersToLocals(self, *args)

    def setSpeciesReferenceConstantValueAndStoichiometry(self):
        """
        setSpeciesReferenceConstantValueAndStoichiometry(self)

        @internal

        @internal

        """
        return _libsbml.Model_setSpeciesReferenceConstantValueAndStoichiometry(self)

    def removeParameterRuleUnits(self, *args):
        """
        removeParameterRuleUnits(self, bool strict)

        @internal

        @internal

        """
        return _libsbml.Model_removeParameterRuleUnits(self, *args)

    def convertStoichiometryMath(self):
        """
        convertStoichiometryMath(self)

        @internal

        @internal

        """
        return _libsbml.Model_convertStoichiometryMath(self)

    def assignRequiredValues(self):
        """
        assignRequiredValues(self)

        @internal

        @internal

        """
        return _libsbml.Model_assignRequiredValues(self)

    def dealWithModelUnits(self):
        """
        dealWithModelUnits(self)

        @internal

        @internal

        """
        return _libsbml.Model_dealWithModelUnits(self)

    def dealWithStoichiometry(self):
        """
        dealWithStoichiometry(self)

        @internal

        @internal

        """
        return _libsbml.Model_dealWithStoichiometry(self)

    def dealWithEvents(self, *args):
        """
        dealWithEvents(self, bool strict)

        @internal

        @internal

        """
        return _libsbml.Model_dealWithEvents(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor and assignment operator.

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.Model_connectToChild(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_MODEL SBML_MODEL@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Model_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Model, is
        always @c 'model'.

        @return the name of this element, i.e., @c 'model'.

        """
        return _libsbml.Model_getElementName(self)

    def populateListFormulaUnitsData(self):
        """
        populateListFormulaUnitsData(self)

        Populates the internal list of derived units for this Model object.

        This method tells libSBML to (re)calculate all units for all components
        of the enclosing Model object.  The result is stored in an internal list
        of unit data.  Users can access the resulting data by calling the method
        SBase.getDerivedUnitDefinition() available on most objects.  (The name
        'formula units data' is drawn from the name of the internal objects
        libSBML uses to store the data; note that these internal objects are not
        exposed to callers, because callers can interact with the results using
        the ordinary SBML unit objects.)

        This method is used by libSBML itself in the validator concerned with
        unit consistency.  The unit consistency validator (like all other
        validators in libSBML) is invoked by using
        SBMLDocument.checkConsistency(), with the consistency checks for the
        category @link libsbml#LIBSBML_CAT_UNITS_CONSISTENCY LIBSBML_CAT_UNITS_CONSISTENCY@endlink turned on.  The method
        populateListFormulaUnitsData() does not need to be called prior to
        invoking the validator if unit consistency checking has not been turned
        off.  This method is only provided for cases when callers have a special
        need to force the unit data to be recalculated.  For instance, during
        construction of a model, a caller may want to interrogate libSBML's
        inferred units without invoking full-blown model validation; this is a
        scenario in which calling populateListFormulaUnitsData() may be useful.

        @warning Computing and inferring units is a time-consuming operation.
        Callers may want to call isPopulatedListFormulaUnitsData() to determine
        whether the units may already have been computed, to save themselves the
        need of invoking unit inference unnecessarily.

        @see isPopulatedListFormulaUnitsData()

        """
        return _libsbml.Model_populateListFormulaUnitsData(self)

    def isPopulatedListFormulaUnitsData(self):
        """
        isPopulatedListFormulaUnitsData(self) -> bool

        Predicate returning @c True if libSBML has derived units for the
        components of this model.

        LibSBML can infer the units of measurement associated with different
        elements of a model.  When libSBML does that, it builds a complex
        internal structure during a resource-intensive operation.  This is done
        automatically only when callers invoke validation (via
        SBMLDocument.checkConsistency()) and have not turned off the unit
        validation option.

        Callers can force units to be recalculated by calling
        populateListFormulaUnitsData().  To avoid calling that method
        unnecessarily, calling programs may first want to invoke this method
        (isPopulatedListFormulaUnitsData()) to determine whether it is even
        necessary.

        @return @c True if the units have already been computed, @c False
        otherwise.

        """
        return _libsbml.Model_isPopulatedListFormulaUnitsData(self)

    def getFormulaUnitsDataForVariable(self, *args):
        """
        getFormulaUnitsDataForVariable(self, string sid) -> FormulaUnitsData

        @internal
        Get a FormulaUnitsData variable object based on its unitReferenceId.

        @return the FormulaUnitsData in this Model with the unitReferenceId @p sid 
        that corrsponds to a variable object or @c None
        if no such FormulaUnitsData exists.

        @note  This function restricts the search to classes that can be varied
        Species, Compartment, Parameter, SpeciesReference.

        @internal

        """
        return _libsbml.Model_getFormulaUnitsDataForVariable(self, *args)

    def getFormulaUnitsDataForAssignment(self, *args):
        """
        getFormulaUnitsDataForAssignment(self, string sid) -> FormulaUnitsData

        @internal
        Get a FormulaUnitsData variable object based on its unitReferenceId.

        @return the FormulaUnitsData in this Model with the unitReferenceId @p sid 
        that corrsponds to a variable object or @c None
        if no such FormulaUnitsData exists.

        @note  This function restricts the search to classes that can be varied
        Species, Compartment, Parameter, SpeciesReference.

        @internal

        """
        return _libsbml.Model_getFormulaUnitsDataForAssignment(self, *args)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if all the required elements for this Model
        object have been set.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.Model_hasRequiredElements(self)

    def removeFunctionDefinition(self, *args):
        """
        removeFunctionDefinition(self, unsigned int n) -> FunctionDefinition
        removeFunctionDefinition(self, string sid) -> FunctionDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeFunctionDefinition(long n)</pre>

        Removes the nth FunctionDefinition object from this Model object and 
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the FunctionDefinition object to remove

        @return the FunctionDefinition object removed, or @c None if the given
        index is out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeFunctionDefinition(string sid)</pre>

        Removes the FunctionDefinition object with the given identifier from this Model 
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the FunctionDefinition object to remove

        @return the FunctionDefinition object removed, or @c None if no
        FunctionDefinition object with the identifier exists in this Model
        object.

        """
        return _libsbml.Model_removeFunctionDefinition(self, *args)

    def removeUnitDefinition(self, *args):
        """
        removeUnitDefinition(self, unsigned int n) -> UnitDefinition
        removeUnitDefinition(self, string sid) -> UnitDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeUnitDefinition(long n)</pre>

        Removes the nth UnitDefinition object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the UnitDefinition object to remove

        @return the UnitDefinition object removed., or @c None if the given
        index is out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeUnitDefinition(string sid)</pre>

        Removes the UnitDefinition object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the UnitDefinition object to remove

        @return the UnitDefinition object removed, or @c None if no
        UnitDefinition object with the identifier exists in this Model object.

        """
        return _libsbml.Model_removeUnitDefinition(self, *args)

    def removeCompartmentType(self, *args):
        """
        removeCompartmentType(self, unsigned int n) -> CompartmentType
        removeCompartmentType(self, string sid) -> CompartmentType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeCompartmentType(long n)</pre>

        Removes the nth CompartmentType object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the CompartmentType object to remove

        @return the ComapartmentType object removed, or @c None if the given
        index is out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeCompartmentType(string sid)</pre>

        Removes the CompartmentType object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the object to remove

        @return the CompartmentType object removed, or @c None if no
        CompartmentType object with the identifier exists in this Model object.

        """
        return _libsbml.Model_removeCompartmentType(self, *args)

    def removeSpeciesType(self, *args):
        """
        removeSpeciesType(self, unsigned int n) -> SpeciesType
        removeSpeciesType(self, string sid) -> SpeciesType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeSpeciesType(long n)</pre>

        Removes the nth SpeciesType object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the SpeciesType object to remove

        @return the SpeciesType object removed, or @c None if the given index is
        out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeSpeciesType(string sid)</pre>

        Removes the SpeciesType object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the SpeciesType object to remove

        @return the SpeciesType object removed, or @c None if no SpeciesType
        object with the identifier exists in this Model object.

        """
        return _libsbml.Model_removeSpeciesType(self, *args)

    def removeCompartment(self, *args):
        """
        removeCompartment(self, unsigned int n) -> Compartment
        removeCompartment(self, string sid) -> Compartment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeCompartment(long n)</pre>

        Removes the nth Compartment object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Compartment object to remove

        @return the Compartment object removed, or @c None if the given index is
        out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeCompartment(string sid)</pre>

        Removes the Compartment object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Compartment object to remove

        @return the Compartment object removed, or @c None if no Compartment
        object with the identifier exists in this Model object.

        """
        return _libsbml.Model_removeCompartment(self, *args)

    def removeSpecies(self, *args):
        """
        removeSpecies(self, unsigned int n) -> Species
        removeSpecies(self, string sid) -> Species

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeSpecies(long n)</pre>

        Removes the nth Species object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Species object to remove

        @return the Species object removed, or @c None if the given index is out
        of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeSpecies(string sid)</pre>

        Removes the Species object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Species object to remove

        @return the Species object removed, or @c None if no Species object with
        the identifier exists in this Model object.

        """
        return _libsbml.Model_removeSpecies(self, *args)

    def removeParameter(self, *args):
        """
        removeParameter(self, unsigned int n) -> Parameter
        removeParameter(self, string sid) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeParameter(long n)</pre>

        Removes the nth Parameter object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Parameter object to remove

        @return the Parameter object removed, or @c None if the given index is
        out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeParameter(string sid)</pre>

        Removes the Parameter object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Parameter object to remove

        @return the Parameter object removed, or @c None if no Parameter object
        with the identifier exists in this Model object.

        """
        return _libsbml.Model_removeParameter(self, *args)

    def removeInitialAssignment(self, *args):
        """
        removeInitialAssignment(self, unsigned int n) -> InitialAssignment
        removeInitialAssignment(self, string symbol) -> InitialAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeInitialAssignment(string symbol)</pre>

        Removes the InitialAssignment object with the given 'symbol' attribute 
        from this Model object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param symbol the 'symbol' attribute of the InitialAssignment object to remove

        @return the InitialAssignment object removed, or @c None if no
        InitialAssignment object with the 'symbol' attribute exists in this
        Model object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeInitialAssignment(long n)</pre>

        Removes the nth InitialAssignment object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the InitialAssignment object to remove

        @return the InitialAssignment object removed, or @c None if the given
        index is out of range.

        """
        return _libsbml.Model_removeInitialAssignment(self, *args)

    def removeRule(self, *args):
        """
        removeRule(self, unsigned int n) -> Rule
        removeRule(self, string variable) -> Rule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeRule(string variable)</pre>

        Removes the Rule object with the given 'variable' attribute from this Model 
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param variable the 'variable' attribute of the Rule object to remove

        @return the Rule object removed, or @c None if no Rule object with the
        'variable' attribute exists in this Model object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeRule(long n)</pre>

        Removes the nth Rule object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Rule object to remove

        @return the Rule object removed, or @c None if the given index is out of
        range.

        """
        return _libsbml.Model_removeRule(self, *args)

    def removeRuleByVariable(self, *args):
        """
        removeRuleByVariable(self, string variable) -> Rule

        Removes the Rule object with the given 'variable' attribute from this Model 
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param variable the 'variable' attribute of the Rule object to remove

        @return the Rule object removed, or @c None if no Rule object with the
        'variable' attribute exists in this Model object.

        """
        return _libsbml.Model_removeRuleByVariable(self, *args)

    def removeConstraint(self, *args):
        """
        removeConstraint(self, unsigned int n) -> Constraint

        Removes the nth Constraint object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Constraint object to remove

        @return the Constraint object removed, or @c None if the given index is
        out of range.

        """
        return _libsbml.Model_removeConstraint(self, *args)

    def removeReaction(self, *args):
        """
        removeReaction(self, unsigned int n) -> Reaction
        removeReaction(self, string sid) -> Reaction

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeReaction(long n)</pre>

        Removes the nth Reaction object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Reaction object to remove

        @return the Reaction object removed, or @c None if the given index is
        out of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeReaction(string sid)</pre>

        Removes the Reaction object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Reaction object to remove

        @return the Reaction object removed, or @c None if no Reaction object
        with the identifier exists in this Model object.

        """
        return _libsbml.Model_removeReaction(self, *args)

    def removeEvent(self, *args):
        """
        removeEvent(self, unsigned int n) -> Event
        removeEvent(self, string sid) -> Event

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeEvent(long n)</pre>

        Removes the nth Event object from this Model object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Event object to remove

        @return the Event object removed, or @c None if the given index is out
        of range.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeEvent(string sid)</pre>

        Removes the Event object with the given identifier from this Model
        object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Event object to remove

        @return the Event object removed, or @c None if no Event object with the
        identifier exists in this Model object.

        """
        return _libsbml.Model_removeEvent(self, *args)

    def appendFrom(self, *args):
        """
        appendFrom(self, Model model) -> int

        Copies a given Model object's subcomponents and appends the copies to
        the appropriate places in this Model.

        This method also calls the <code>appendFrom</code> method on all libSBML
        plug-in objects.

        @par
        SBML Level&nbsp;3 consists of a <em>Core</em> definition that can be extended
        via optional SBML Level&nbsp;3 <em>packages</em>.  A given model may indicate
        that it uses one or more SBML packages, and likewise, a software tool may be
        able to support one or more packages.  LibSBML does not come preconfigured
        with all possible packages included and enabled, in part because not all
        package specifications have been finalized.  To support the ability for
        software systems to enable support for the Level&nbsp;3 packages they choose,
        libSBML features a <em>plug-in</em> mechanism.  Each SBML Level&nbsp;3
        package is implemented in a separate code plug-in that can be enabled by the
        application to support working with that SBML package.  A given SBML model
        may thus contain not only objects defined by SBML Level&nbsp;3 Core, but also
        objects created by libSBML plug-ins supporting additional Level&nbsp;3
        packages.

        @param model the Model to merge with this one.

        """
        return _libsbml.Model_appendFrom(self, *args)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child elements
        (if any).  (This is an internal implementation for enablePackage
        function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.Model_enablePackageInternal(self, *args)

    def renameIDs(self, *args):
        """
        renameIDs(self, SBaseList elements, IdentifierTransformer idTransformer)

        """
        return _libsbml.Model_renameIDs(self, *args)

Model_swigregister = _libsbml.Model_swigregister
Model_swigregister(Model)

IdCheckON = _libsbml.IdCheckON
IdCheckOFF = _libsbml.IdCheckOFF
SBMLCheckON = _libsbml.SBMLCheckON
SBMLCheckOFF = _libsbml.SBMLCheckOFF
SBOCheckON = _libsbml.SBOCheckON
SBOCheckOFF = _libsbml.SBOCheckOFF
MathCheckON = _libsbml.MathCheckON
MathCheckOFF = _libsbml.MathCheckOFF
UnitsCheckON = _libsbml.UnitsCheckON
UnitsCheckOFF = _libsbml.UnitsCheckOFF
OverdeterCheckON = _libsbml.OverdeterCheckON
OverdeterCheckOFF = _libsbml.OverdeterCheckOFF
PracticeCheckON = _libsbml.PracticeCheckON
PracticeCheckOFF = _libsbml.PracticeCheckOFF
AllChecksON = _libsbml.AllChecksON
class SBMLDocument(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Overall SBML container object.

    @if clike LibSBML uses the class SBMLDocument as a
    top-level container for storing SBML content and data associated with it
    (such as warnings and error messages).  The two primary means of reading
    an SBML model, SBMLReader.readSBML() and
    SBMLReader.readSBMLFromString(), both return a pointer to an
    SBMLDocument object.  From there, callers can inquire about any errors
    encountered (e.g., using SBMLDocument.getNumErrors()), access the Model
    object, and perform other actions such as consistency-checking and model
    translation.
    @endif@if python LibSBML uses the class SBMLDocument as a
    top-level container for storing SBML content and data associated with it
    (such as warnings and error messages).  The two primary means of reading
    an SBML model, SBMLReader.readSBML() and
    SBMLReader.readSBMLFromString(), both return a pointer to an
    SBMLDocument object.  From there, callers can inquire about any errors
    encountered (e.g., using SBMLDocument.getNumErrors()), access the Model
    object, and perform other actions such as consistency-checking and model
    translation.
    @endif@if java LibSBML uses the class SBMLDocument as a top-level
    container for storing SBML content and data associated with it (such as
    warnings and error messages).  The two primary means of reading an SBML
    model, SBMLReader.readSBML() and
    SBMLReader.readSBMLFromString(), both return an SBMLDocument
    object.  From there, callers can inquire about any errors encountered
    (e.g., using SBMLDocument.getNumErrors()), access the Model object, and
    perform other actions such as consistency-checking and model
    translation.
    @endif@~

    When creating fresh models programmatically, the starting point is
    typically the creation of an SBMLDocument object instance.  The
    SBMLDocument constructor accepts arguments for the SBML Level and
    Version of the model to be created.  After creating the SBMLDocument
    object, calling programs then typically call SBMLDocument.createModel()
    almost immediately, and then proceed to call the methods on the Model
    object to fill out the model's contents.

    SBMLDocument corresponds roughly to the class <i>Sbml</i> defined in the
    SBML Level&nbsp;2 specification and <i>SBML</i> in the Level&nbsp;3
    specification.  It does not have a direct correspondence in SBML
    Level&nbsp;1.  (However, to make matters simpler for applications,
    libSBML creates an SBMLDocument no matter whether the model is
    Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)  In its barest form, when written out in
    XML format for (e.g.) SBML Level&nbsp;2 Version&nbsp;4, the corresponding
    structure is the following:
    @verbatim
    <sbml xmlns='http://www.sbml.org/sbml/level2/version4' level='2' version='4'>
      ...
    </sbml>@endverbatim

    SBMLDocument is derived from SBase, and therefore contains the usual SBase
    attributes (in SBML Level&nbsp;2 and Level&nbsp;3) of 'metaid' and 'sboTerm', as
    well as the subelements 'notes' and 'annotation'.  It also contains the
    attributes 'level' and 'version' indicating the Level and Version of the
    SBML data structure.  These can be accessed using the methods defined by
    the SBase class for that purpose.

    @section checking Checking consistency and adherence to SBML specifications

    One of the most important features of libSBML is its ability to perform
    SBML validation to ensure that a model adheres to the SBML specification
    for whatever Level+Version combination the model uses.  SBMLDocument
    provides the methods for running consistency-checking and validation
    rules on the SBML content.

    First, a brief explanation of the rationale is in order.  In libSBML
    versions up to and including the version&nbsp;3.3.x series, the
    individual methods for creating and setting attributes and other
    components were quite lenient, and allowed a caller to compose SBML
    entities that might not, in the end, represent valid SBML.  This allowed
    applications the freedom to do things such as save incomplete models
    (which is useful when models are being developed over long periods of
    time).  In the version&nbsp;4.x series, libSBML is somewhat stricter,
    but still permits structures to be created independently and the results
    to be combined in a separate step.  In all these cases, it means that a
    separate validation step is necessary when a calling program finally
    wants to finish a complete SBML document.

    The primary interface to this validation facility is SBMLDocument's
    SBMLDocument.checkInternalConsistency() and
    SBMLDocument.checkConsistency().  The former verifies the basic
    internal consistency and syntax of an SBML document, and the latter
    implements more elaborate validation rules (both those defined by the
    SBML specifications, as well as additional rules offered by libSBML).

    @if clike The checks performed by SBMLDocument.checkInternalConsistency() are
    hardwired and cannot be changed by calling programs, but the validation
    performed by SBMLDocument.checkConsistency() is under program control
    using the method SBMLDocument.setConsistencyChecks().  Applications can
    selectively disable specific kinds of checks that they may not be
    interested in, by calling SBMLDocument.setConsistencyChecks() with
    appropriate parameters.
    @endif@if python The checks performed by SBMLDocument.checkInternalConsistency() are
    hardwired and cannot be changed by calling programs, but the validation
    performed by SBMLDocument.checkConsistency() is under program control
    using the method SBMLDocument.setConsistencyChecks().  Applications can
    selectively disable specific kinds of checks that they may not be
    interested in, by calling SBMLDocument.setConsistencyChecks() with
    appropriate parameters.
    @endif@if java The checks performed by SBMLDocument.checkInternalConsistency() are
    hardwired and cannot be changed by calling programs, but the validation
    performed by SBMLDocument.checkConsistency() is under program control
    using the method SBMLDocument.setConsistencyChecks().  Applications can selectively disable specific kinds of checks
    that they may not be interested by calling
    SBMLDocument.setConsistencyChecks() with
    appropriate parameters.
    @endif@~

    These methods have slightly different relevance depending on whether a
    model is created programmaticaly from scratch, or whether it is read in
    from a file or data stream.  The following list summarizes the possible
    scenarios.

    <em>Scenario 1: Creating a model from scratch</em>.  Before writing out
    the model, 

    @li Call SBMLDocument.checkInternalConsistency(), then inquire about
    the results by calling SBMLDocument.getNumErrors()

    @li Call @if java SBMLDocument.setConsistencyChecks() @else SBMLDocument.setConsistencyChecks() @endif@~ to configure
    which checks will be performed by SBMLDocument.checkConsistency()

    @li Call SBMLDocument.checkConsistency(), then inquire about the results by
    calling SBMLDocument.getNumErrors()

    <em>Scenario 2: Reading a model from a file or data stream.</em> After
    reading the model,

    @li Basic consistency checks will have been performed automatically by
    libSBML upon reading the content, so you only need to inquire about the
    results by using SBMLDocument.getNumErrors()

    @li Call @if java SBMLDocument.setConsistencyChecks() @else SBMLDocument.setConsistencyChecks() @endif@~ to configure
    which checks are performed by SBMLDocument.checkConsistency()

    @li Call SBMLDocument.checkConsistency(), then inquire about the results
    by calling SBMLDocument.getNumErrors()

    @if clike An example of using the consistency-checking
    and validation facilities is provided in this manual in the
    section @ref libsbml-example. @endif@~

    @section converting Converting documents between Levels and Versions of SBML

    LibSBML provides facilities for limited translation of SBML between
    Levels and Versions of the SBML specifications.  The method for doing is
    is @if java SBMLDocument.setLevelAndVersion() @else setLevelAndVersion() @endif.  In 
    general, models can be converted upward without difficulty (e.g., from
    SBML Level&nbsp;1 to Level&nbsp;2, or from an earlier Version of
    Level&nbsp;2 to the latest Version of Level&nbsp;2).  Sometimes models
    can be translated downward as well, if they do not use constructs
    specific to more advanced Levels of SBML.

    Calling @if java SBMLDocument.setLevelAndVersion() @else SBMLDocument.setLevelAndVersion() @endif@~ will not @em necessarily lead
    to a successful conversion.  The method will return a boolean value
    to indicate success or failure.  Callers must check the error log (see 
    next section) attached to the SBMLDocument object after calling
    @if java SBMLDocument.setLevelAndVersion() @else SBMLDocument.setLevelAndVersion() @endif@~ in order to assess whether any
    problems arose.

    If an application is interested in translating to a lower Level and/or
    Version of SBML within a Level, the following methods allow for prior
    assessment of whether there is sufficient compatibility to make a
    translation possible:

    @li SBMLDocument.checkL1Compatibility(),
    @li SBMLDocument.checkL2v1Compatibility(),
    @li SBMLDocument.checkL2v2Compatibility(),
    @li SBMLDocument.checkL2v3Compatibility(), 
    @li SBMLDocument.checkL2v4Compatibility(), and
    @li SBMLDocument.checkL3v1Compatibility().

    Some changes between Versions of SBML Level&nbsp;2 may lead to
    unexpected behaviors when attempting conversions in either direction.
    For example, SBML Level&nbsp;2 Version&nbsp;4 relaxed the requirement
    for consistency in units of measurement between expressions annd
    quantities in a model.  As a result, a model written in Version&nbsp;4,
    if converted to Version&nbsp;3 with no other changes, may fail
    validation as a Version&nbsp;3 model because Version&nbsp;3 imposed
    stricter requirements on unit consistency.

    Other changes between SBML Level 2 and Level 3 make downward conversions
    challenging.  In some cases, it means that a model converted to
    Level&nbsp;2 from Level&nbsp;3 will contain attributes that were not
    explicitly given in the Level&nbsp;3 model, because in Level&nbsp;2
    these attributes may have been optional or have default values.

    @section errors Error handling

    Upon reading a model, SBMLDocument logs any problems encountered while
    reading the model from the file or data stream.  The log contains
    objects that record diagnostic information about any notable issues that
    arose.  Whether the problems are warnings or errors, they are both
    reported through a single common interface involving the object class
    SBMLError.

    The methods SBMLDocument.getNumErrors(), @if java SBMLDocument.getError() @else SBMLDocument.getError() @endif@~ and
    SBMLDocument.printErrors() allow callers to interact with the warnings
    or errors logged.  Alternatively, callers may retrieve the entire log as
    an SBMLErrorLog object using the method SBMLDocument.getErrorLog().
    The SBMLErrorLog object provides some alternative methods for
    interacting with the set of errors and warnings.  In either case,
    applications typically should first call SBMLDocument.getNumErrors() to
    find out if any issues have been logged after specific libSBML
    operations such as the ones discussed in the sections above.  If they
    have, then an application will should proceed to inspect the individual
    reports using either the direct interfaces on SBMLDocument or using the
    methods on the SBMLErrorLog object.

    @if clike An example of using the error facility is
    provided in this manual in the
    section @ref libsbml-example. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLDocument, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLDocument, name)
    __repr__ = _swig_repr
    def getDefaultLevel():
        """
        getDefaultLevel() -> unsigned int

        The default SBML Level of new SBMLDocument objects.

        @par
        This 'default Level' corresponds to the most recent SBML specification
        Level available at the time libSBML version @htmlinclude
        libsbml-version.html was released.  The default Level is used by
        SBMLDocument if no Level is explicitly specified at the time of the
        construction of an SBMLDocument instance.

        @return an integer indicating the most recent SBML specification Level

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike getDefaultVersion() @else SBMLDocument.getDefaultVersion() @endif@~

        """
        return _libsbml.SBMLDocument_getDefaultLevel()

    if _newclass:getDefaultLevel = staticmethod(getDefaultLevel)
    __swig_getmethods__["getDefaultLevel"] = lambda x: getDefaultLevel
    def getDefaultVersion():
        """
        getDefaultVersion() -> unsigned int

        The default Version of new SBMLDocument objects.

        @par
        This 'default Version' corresponds to the most recent Version within the
        most recent Level of SBML available at the time libSBML version
        @htmlinclude libsbml-version.html was released.  The default Version is
        used by SBMLDocument if no Version is explicitly specified at the time of
        the construction of an SBMLDocument instance. 

        @return an integer indicating the most recent SBML specification
        Version

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike getDefaultLevel() @else SBMLDocument.getDefaultLevel() @endif@~

        """
        return _libsbml.SBMLDocument_getDefaultVersion()

    if _newclass:getDefaultVersion = staticmethod(getDefaultVersion)
    __swig_getmethods__["getDefaultVersion"] = lambda x: getDefaultVersion
    __swig_destroy__ = _libsbml.delete_SBMLDocument
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level = 0, unsigned int version = 0) -> SBMLDocument
        __init__(self, unsigned int level = 0) -> SBMLDocument
        __init__(self) -> SBMLDocument
        __init__(self, SBMLNamespaces sbmlns) -> SBMLDocument
        __init__(self, SBMLDocument orig) -> SBMLDocument

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLDocument(SBMLNamespaces sbmlns)</pre>

        Creates a new SBMLDocument using the given SBMLNamespaces object 
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLDocument(long level = 0, long version = 0)</pre>

        Creates a new SBMLDocument, optionally with given values for the SBML
        Level and Version.

        If <em>both</em> the SBML Level and Version attributes are not
        specified, the SBML document is treated as having the latest Level and
        Version of SBML as determined by SBMLDocument.getDefaultLevel() and
        SBMLDocument.getDefaultVersion(); <em>however</em>, the SBMLDocument
        object is otherwise left blank.  In particular, the blank SBMLDocument
        object has no associated XML attributes, including (but not limited
        to) an XML namespace declaration.  The XML namespace declaration is
        not added until the model is written out, <em>or</em> the method
        SBMLDocument.setLevelAndVersion()
        is called.  This may be important to keep in mind
        if an application needs to add additional XML namespace declarations
        on the <code>&lt;sbml&gt;</code> element.  Application writers should
        either provide values for @p level and @p version on the call to this
        constructor, or else call
        SBMLDocument.setLevelAndVersion()
        shortly after creating the SBMLDocument object.

        @param level an integer for the SBML Level

        @param version an integer for the Version within the SBML Level

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see SBMLDocument.setLevelAndVersion()
        @see getDefaultLevel()
        @see getDefaultVersion()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLDocument(SBMLDocument orig)</pre>

        Copy constructor; creates a copy of this SBMLDocument.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_SBMLDocument(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLDocument

        Creates and returns a deep copy of this SBMLDocument object.

        @return the (deep) copy of this SBMLDocument object.

        """
        return _libsbml.SBMLDocument_clone(self)

    def getModel(self, *args):
        """
        getModel(self) -> Model
        getModel(self) -> Model

        Returns the Model object stored in this SBMLDocument.

        It is important to note that this method <em>does not create</em> a
        Model instance.  The model in the SBMLDocument must have been created
        at some prior time, for example using SBMLDocument.createModel() 
        or SBMLDocument.setModel().
        This method returns @c None if a model does not yet exist.

        @return the Model contained in this SBMLDocument.

        @see createModel()

        """
        return _libsbml.SBMLDocument_getModel(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.SBMLDocument_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid, or
        itself if it has the given @p metaid, or @c None if no such object is
        found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        """
        return _libsbml.SBMLDocument_getElementByMetaId(self, *args)

    def expandFunctionDefinitions(self):
        """
        expandFunctionDefinitions(self) -> bool

        Removes FunctionDefinition constructs from the document and expands
        any instances of their use within <code>&lt;math&gt;</code> elements.

        For example, suppose a Model contains a FunctionDefinition with
        identifier @c 'f' representing the math expression: <em>f(x, y) = x *
        y</em>.  Suppose further that there is a reaction in which the
        <code>&lt;math&gt;</code> element of the KineticLaw object contains
        <code>f(s, p)</code>, where @c s and @c p are other identifiers
        defined in the model.  The outcome of invoking this method is that the
        <code>&lt;math&gt;</code> of the KineticLaw now represents the
        expression <em>s * p</em> and the model no longer contains any
        FunctionDefinition objects.

        @return bool @c True if the transformation was successful, 
        @c False, otherwise.

        @note This function will check the consistency of a model before
        attemptimg the transformation.  If the model is not valid SBML, the
        transformation will not be performed and the function will return @c False.

        """
        return _libsbml.SBMLDocument_expandFunctionDefinitions(self)

    def expandInitialAssignments(self):
        """
        expandInitialAssignments(self) -> bool

        Removes InitialAssignment constructs from the document and
        replaces them with appropriate values.

        For example, suppose a Model contains a InitialAssignment to a symbol
        @c 'k' where @c 'k' is the identifier of a Parameter.  The outcome of
        invoking this method is that the 'value' attribute of the Parameter
        definition is set to the result calculated using the InitialAssignment
        object's <code>&lt;math&gt;</code> formula, and the corresponding
        InitialAssignment is then removed from the Model.

        @return bool @c True if the transformation was successful, 
        @c False, otherwise.

        @note This function will check the consistency of a model before
        attemptimg the transformation.  If the model is not valid SBML, the
        transformation will not be performed and the function will return @c False.  As part of that process, this method will check that it has
        values for any components referred to by the <code>&lt;math&gt;</code>
        elements of InitialAssignment objects.  In cases where not all of the
        values have been declared (e.g., if the mathematical expression refers
        to model entities that have no declared values), the InitialAssignment
        in question will @em not be removed and this method will return @c False.

        """
        return _libsbml.SBMLDocument_expandInitialAssignments(self)

    def setLevelAndVersion(self, *args):
        """
        setLevelAndVersion(self, unsigned int level, unsigned int version, bool strict = True, 
            bool ignorePackages = False) -> bool
        setLevelAndVersion(self, unsigned int level, unsigned int version, bool strict = True) -> bool
        setLevelAndVersion(self, unsigned int level, unsigned int version) -> bool

        Sets the SBML Level and Version of this SBMLDocument instance,
        attempting to convert the model as needed.

        This method is the principal way in libSBML to convert models between
        Levels and Versions of SBML.  Generally, models can be converted
        upward without difficulty (e.g., from SBML Level&nbsp;1 to
        Level&nbsp;2, or from an earlier Version of Level&nbsp;2 to the latest
        Version of Level&nbsp;2).  Sometimes models can be translated downward
        as well, if they do not use constructs specific to more advanced
        Levels of SBML.

        Before calling this method, callers may check compatibility directly
        using the methods SBMLDocument.checkL1Compatibility(),
        SBMLDocument.checkL2v1Compatibility(),
        SBMLDocument.checkL2v2Compatibility(),
        SBMLDocument.checkL2v3Compatibility(),
        SBMLDocument.checkL2v4Compatibility(), and
        SBMLDocument.checkL3v1Compatibility().

        The valid combinations of SBML Level and Version as of this release
        of libSBML are the following: 
        <ul>
        <li> Level&nbsp;1 Version&nbsp;2
        <li> Level&nbsp;2 Version&nbsp;1
        <li> Level&nbsp;2 Version&nbsp;2
        <li> Level&nbsp;2 Version&nbsp;3
        <li> Level&nbsp;2 Version&nbsp;4
        <li> Level&nbsp;3 Version&nbsp;1
        </ul>

        Strict conversion applies the additional criteria that both the
        source and the target model must be consistent SBML.  Users can
        control the consistency checks that are applied using the
        SBMLDocument.setConsistencyChecksForConversion() method.  If either
        the source or the potential target model have validation errors, the
        conversion is not performed.  When a strict conversion is successful,
        the underlying SBML object model is altered to reflect the new level
        and version.  Thus, information that cannot be converted
        (e.g. sboTerms) will be lost.

        @param level the desired SBML Level

        @param version the desired Version within the SBML Level

        @param strict boolean indicating whether to check consistency
        of both the source and target model when performing
        conversion (defaults to <code> true </code>)

        @param ignorePackages boolean indicating whether the presence of
        packages should be ignored by the conversion routine 
        (defaults to <code> false </code>)

        @return @c True if the level and version of the document were
        successfully set to the requested values (which may have required
        conversion of the model), @c False otherwise.

        @note Calling this method will not @em necessarily lead to a successful
        conversion.  If the conversion fails, it will be logged in the error
        list associated with this SBMLDocument.  Callers should consult
        getNumErrors() to find out if the conversion succeeded without
        problems.  For conversions from Level&nbsp;2 to Level&nbsp;1, callers
        can also check the Level of the model after calling this method to
        find out whether it is Level&nbsp;1.  (If the conversion to
        Level&nbsp;1 failed, the Level of this model will be left unchanged.)

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see checkL1Compatibility()
        @see checkL2v1Compatibility()
        @see checkL2v2Compatibility()
        @see checkL2v3Compatibility()
        @see checkL2v4Compatibility()
        @see checkL3v1Compatibility()
        @see checkL3v1Compatibility()

        """
        return _libsbml.SBMLDocument_setLevelAndVersion(self, *args)

    def updateSBMLNamespace(self, *args):
        """
        updateSBMLNamespace(self, string package, unsigned int level, unsigned int version)

        @internal
        @param package
        @param level
        @param version

        @internal

        """
        return _libsbml.SBMLDocument_updateSBMLNamespace(self, *args)

    def setModel(self, *args):
        """
        setModel(self, Model m) -> int

        Sets the Model for this SBMLDocument to a copy of the given Model.

        @param m the new Model to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink

        @see createModel()
        @see getModel()

        """
        return _libsbml.SBMLDocument_setModel(self, *args)

    def createModel(self, sid = ""):
        """
        createModel(self, string sid = "") -> Model
        createModel(self) -> Model

        Creates a new Model inside this SBMLDocument, and returns a pointer to
        it.

        In SBML Level&nbsp;2, the use of an identifier on a Model object is
        optional.  This method takes an optional argument, @p sid, for setting
        the identifier.  If not supplied, the identifier attribute on the
        Model instance is not set.

        @param sid the identifier of the new Model to create.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see getModel()
        @see SBMLDocument.setModel()

        """
        return _libsbml.SBMLDocument_createModel(self, sid)

    def setLocationURI(self, *args):
        """
        setLocationURI(self, string uri)

        Sets the location of this SBMLDocument.

        Called automatically when readSBMLFromFile is used, but may be set
        manually as well.

        """
        return _libsbml.SBMLDocument_setLocationURI(self, *args)

    def getLocationURI(self, *args):
        """
        getLocationURI(self) -> string
        getLocationURI(self) -> string

        Get the location of this SBMLDocument.

        If this document was read from a file or had its location set manually,
        that filename or set location will be returned, otherwise, an empty
        string is returned.

        """
        return _libsbml.SBMLDocument_getLocationURI(self, *args)

    def setConsistencyChecks(self, *args):
        """
        setConsistencyChecks(self, SBMLErrorCategory_t category, bool apply)

        Controls the consistency checks that are performed when
        SBMLDocument.checkConsistency() is called.

        This method works by adding or subtracting consistency checks from the
        set of all possible checks that SBMLDocument.checkConsistency() knows
        how to perform.  This method may need to be called multiple times in
        order to achieve the desired combination of checks.  The first
        argument (@p category) in a call to this method indicates the category
        of consistency/error checks that are to be turned on or off, and the
        second argument (@p apply, a boolean) indicates whether to turn it on
        (value of @c True) or off (value of @c False).

        @if clike
        The possible categories (values to the argument @p category) are the
        set of values from the enumeration #SBMLErrorCategory_t.
        The following are the possible choices:
        @endif@if java
        The possible categories (values to the argument @p category) are the
        set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>
        in the interface class {@link libsbmlConstants}.
        The following are the possible choices:
        @endif@if python 
        The possible categories (values to the argument @p category) are the
        set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>
        in the interface class @link libsbml libsbml@endlink.
        The following are the possible choices:
        @endif@~
        <ul>
        <li> @link libsbml#LIBSBML_CAT_GENERAL_CONSISTENCY LIBSBML_CAT_GENERAL_CONSISTENCY@endlink:
        Correctness and consistency of specific SBML language constructs.
        Performing this set of checks is highly recommended.  With respect to
        the SBML specification, these concern failures in applying the
        validation rules numbered 2xxxx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_IDENTIFIER_CONSISTENCY LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink:
        Correctness and consistency of identifiers used for model entities.  An
        example of inconsistency would be using a species identifier in a
        reaction rate formula without first having declared the species.  With
        respect to the SBML specification, these concern failures in applying
        the validation rules numbered 103xx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_UNITS_CONSISTENCY LIBSBML_CAT_UNITS_CONSISTENCY@endlink:
        Consistency of measurement units associated with quantities in a model.
        With respect to the SBML specification, these concern failures in
        applying the validation rules numbered 105xx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_MATHML_CONSISTENCY LIBSBML_CAT_MATHML_CONSISTENCY@endlink:
        Syntax of MathML constructs.  With respect to the SBML specification,
        these concern failures in applying the validation rules numbered 102xx
        in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3
        Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_SBO_CONSISTENCY LIBSBML_CAT_SBO_CONSISTENCY@endlink:
        Consistency and validity of %SBO identifiers (if any) used in the model.
        With respect to the SBML specification, these concern failures in
        applying the validation rules numbered 107xx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_OVERDETERMINED_MODEL LIBSBML_CAT_OVERDETERMINED_MODEL@endlink:
        Static analysis of whether the system of equations implied by a model is
        mathematically overdetermined.  With respect to the SBML specification,
        this is validation rule #10601 in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_MODELING_PRACTICE LIBSBML_CAT_MODELING_PRACTICE@endlink:
        Additional checks for recommended good modeling practice. (These are
        tests performed by libSBML and do not have equivalent SBML validation
        rules.)  </ul>

        <em>By default, all validation checks are applied</em> to the model in
        an SBMLDocument object @em unless
        SBMLDocument.setConsistencyChecks()
        is called to indicate that only a subset should be applied.  Further,
        this default (i.e., performing all checks) applies separately to
        <em>each new SBMLDocument object</em> created.  In other words, each
        time a model is read using SBMLReader.readSBML(),
        SBMLReader.readSBMLFromString(),
        or the global functions readSBML() and readSBMLFromString(), a new
        SBMLDocument is created and for that document, a call to
        SBMLDocument.checkConsistency() will default to applying all possible checks.
        Calling programs must invoke
        SBMLDocument.setConsistencyChecks()
        for each such new model if they wish to change the consistency checks
        applied.

        @param category a value drawn from @if clike #SBMLErrorCategory_t@else
        the set of SBML error categories@endif@~ indicating the
        consistency checking/validation to be turned on or off.

        @param apply a boolean indicating whether the checks indicated by
        @p category should be applied or not.

        @see SBMLDocument.checkConsistency()

        """
        return _libsbml.SBMLDocument_setConsistencyChecks(self, *args)

    def setConsistencyChecksForConversion(self, *args):
        """
        setConsistencyChecksForConversion(self, SBMLErrorCategory_t category, bool apply)

        Controls the consistency checks that are performed when
        SBMLDocument.setLevelAndVersion() is called.

        This method works by adding or subtracting consistency checks from the
        set of all possible checks that may be performed to avoid conversion
        to or from an invalid document.  This method may need to be called 
        multiple times in
        order to achieve the desired combination of checks.  The first
        argument (@p category) in a call to this method indicates the category
        of consistency/error checks that are to be turned on or off, and the
        second argument (@p apply, a boolean) indicates whether to turn it on
        (value of @c True) or off (value of @c False).

        @if clike
        The possible categories (values to the argument @p category) are the
        set of values from the enumeration #SBMLErrorCategory_t.
        The following are the possible choices:
        @endif@if java
        The possible categories (values to the argument @p category) are the
        set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>
        in the interface class {@link libsbmlConstants}.
        The following are the possible choices:
        @endif@if python 
        The possible categories (values to the argument @p category) are the
        set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>
        in the interface class @link libsbml libsbml@endlink.
        The following are the possible choices:
        @endif@~
        <ul>
        <li> @link libsbml#LIBSBML_CAT_GENERAL_CONSISTENCY LIBSBML_CAT_GENERAL_CONSISTENCY@endlink:
        Correctness and consistency of specific SBML language constructs.
        Performing this set of checks is highly recommended.  With respect to
        the SBML specification, these concern failures in applying the
        validation rules numbered 2xxxx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_IDENTIFIER_CONSISTENCY LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink:
        Correctness and consistency of identifiers used for model entities.  An
        example of inconsistency would be using a species identifier in a
        reaction rate formula without first having declared the species.  With
        respect to the SBML specification, these concern failures in applying
        the validation rules numbered 103xx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_UNITS_CONSISTENCY LIBSBML_CAT_UNITS_CONSISTENCY@endlink:
        Consistency of measurement units associated with quantities in a model.
        With respect to the SBML specification, these concern failures in
        applying the validation rules numbered 105xx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_MATHML_CONSISTENCY LIBSBML_CAT_MATHML_CONSISTENCY@endlink:
        Syntax of MathML constructs.  With respect to the SBML specification,
        these concern failures in applying the validation rules numbered 102xx
        in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3
        Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_SBO_CONSISTENCY LIBSBML_CAT_SBO_CONSISTENCY@endlink:
        Consistency and validity of %SBO identifiers (if any) used in the model.
        With respect to the SBML specification, these concern failures in
        applying the validation rules numbered 107xx in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_OVERDETERMINED_MODEL LIBSBML_CAT_OVERDETERMINED_MODEL@endlink:
        Static analysis of whether the system of equations implied by a model is
        mathematically overdetermined.  With respect to the SBML specification,
        this is validation rule #10601 in the Level&nbsp;2
        Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.

        <li> @link libsbml#LIBSBML_CAT_MODELING_PRACTICE LIBSBML_CAT_MODELING_PRACTICE@endlink:
        Additional checks for recommended good modeling practice. (These are
        tests performed by libSBML and do not have equivalent SBML validation
        rules.)
        </ul>

        <em>By default, all validation checks are applied</em> to the model in
        an SBMLDocument object @em unless
        SBMLDocument.setConsistencyChecks()
        is called to indicate that only a subset should be applied.  Further,
        this default (i.e., performing all checks) applies separately to
        <em>each new SBMLDocument object</em> created.  In other words, each
        time a model is read using SBMLReader.readSBML(),
        SBMLReader.readSBMLFromString(),
        or the global functions readSBML() and readSBMLFromString(), a new
        SBMLDocument is created and for that document, a call to
        SBMLDocument.checkConsistency() will default to applying all possible checks.
        Calling programs must invoke
        SBMLDocument.setConsistencyChecks()
        for each such new model if they wish to change the consistency checks
        applied.

        @param category a value drawn from @if clike #SBMLErrorCategory_t@else
        the set of SBML error categories@endif@~ indicating the consistency
        checking/validation to be turned on or off.

        @param apply a boolean indicating whether the checks indicated by
        @p category should be applied or not.

        @see SBMLDocument.setLevelAndVersion()

        """
        return _libsbml.SBMLDocument_setConsistencyChecksForConversion(self, *args)

    def checkConsistency(self):
        """
        checkConsistency(self) -> unsigned int

        Performs consistency checking and validation on this SBML document.

        If this method returns a nonzero value (meaning, one or more
        consistency checks have failed for SBML document), the failures may be
        due to warnings @em or errors.  Callers should inspect the severity
        flag in the individual SBMLError objects returned by
        SBMLDocument.getError() to determine the nature of the failures.

        @return the number of failed checks (errors) encountered.

        @see SBMLDocument.checkInternalConsistency()

        """
        return _libsbml.SBMLDocument_checkConsistency(self)

    def validateSBML(self):
        """
        validateSBML(self) -> unsigned int

        Performs consistency checking and validation on this SBML document.

        If this method returns a nonzero value (meaning, one or more
        consistency checks have failed for SBML document), the failures may be
        due to warnings @em or errors.  Callers should inspect the severity
        flag in the individual SBMLError objects returned by
        SBMLDocument.getError() to determine the nature of the failures.

        @note unlike checkConsistency this method will write the document
        in order to determine all errors for the document. This will 
        also clear the error log. 

        @return the number of failed checks (errors) encountered.

        @see SBMLDocument.checkConsistency()

        """
        return _libsbml.SBMLDocument_validateSBML(self)

    def checkInternalConsistency(self):
        """
        checkInternalConsistency(self) -> unsigned int

        Performs consistency checking on libSBML's internal representation of 
        an SBML Model.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        The distinction between this method and
        SBMLDocument.checkConsistency() is that this method reports on
        fundamental syntactic and structural errors that violate the XML
        Schema for SBML; by contrast, SBMLDocument.checkConsistency()
        performs more elaborate model verifications and also validation
        according to the validation rules written in the appendices of the
        SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 specification documents.

        @see SBMLDocument.checkConsistency()

        """
        return _libsbml.SBMLDocument_checkInternalConsistency(self)

    def checkL1Compatibility(self):
        """
        checkL1Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;1 and can be converted
        to Level&nbsp;1.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        """
        return _libsbml.SBMLDocument_checkL1Compatibility(self)

    def checkL2v1Compatibility(self):
        """
        checkL2v1Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;1 and can
        be converted to Level&nbsp;2 Version&nbsp;1.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        """
        return _libsbml.SBMLDocument_checkL2v1Compatibility(self)

    def checkL2v2Compatibility(self):
        """
        checkL2v2Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;2 and can
        be converted to Level&nbsp;2 Version&nbsp;2.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        """
        return _libsbml.SBMLDocument_checkL2v2Compatibility(self)

    def checkL2v3Compatibility(self):
        """
        checkL2v3Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;3 and can
        be converted to Level&nbsp;2 Version&nbsp;3.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        """
        return _libsbml.SBMLDocument_checkL2v3Compatibility(self)

    def checkL2v4Compatibility(self):
        """
        checkL2v4Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;2 Version&nbsp;4 and can
        be converted to Level&nbsp;2 Version&nbsp;4.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        """
        return _libsbml.SBMLDocument_checkL2v4Compatibility(self)

    def checkL3v1Compatibility(self):
        """
        checkL3v1Compatibility(self) -> unsigned int

        Performs a set of consistency checks on the document to establish
        whether it is compatible with SBML Level&nbsp;3 Version&nbsp;1 and can
        be converted to Level&nbsp;3 Version&nbsp;1.

        Callers should query the results of the consistency check by calling
        SBMLDocument.getError().

        @return the number of failed checks (errors) encountered.

        """
        return _libsbml.SBMLDocument_checkL3v1Compatibility(self)

    def getError(self, *args):
        """
        getError(self, unsigned int n) -> SBMLError

        Returns the nth error or warning encountered during parsing,
        consistency checking, or attempted translation of this model.

        Callers can use method XMLError.getSeverity() on the result to assess
        the severity of the problem.  The possible severity levels range from
        informational messages to fatal errors.

        @return the error or warning indexed by integer @p n, or return @c
        None if <code>n &gt; (getNumErrors() - 1)</code>.

        @param n the integer index of the error sought.

        @see SBMLDocument.getNumErrors()

        """
        return _libsbml.SBMLDocument_getError(self, *args)

    def getNumErrors(self, *args):
        """
        getNumErrors(self) -> unsigned int
        getNumErrors(self, unsigned int severity) -> unsigned int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getNumErrors(long severity)</pre>

        Returns the number of errors or warnings encountered with the given 
        severity during parsing,
        consistency checking, or attempted translation of this model.

        @param severity the severity of the error sought. 

        @return the number of errors or warnings encountered

        @see SBMLDocument.getError()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getNumErrors()</pre>

        Returns the number of errors or warnings encountered during parsing,
        consistency checking, or attempted translation of this model.

        @return the number of errors or warnings encountered

        @see SBMLDocument.getError()

        """
        return _libsbml.SBMLDocument_getNumErrors(self, *args)

    def printErrors(self, *args):
        """
        printErrors(self, ostream stream = cerr)
        printErrors(self)

        Prints all the errors or warnings encountered trying to parse,
        check, or translate this SBML document.

        It prints the text to the stream given by the optional parameter @p
        stream.  If no parameter is given, it prints the output to the
        standard error stream.

        If no errors have occurred, i.e., <code>getNumErrors() == 0</code>, no
        output will be sent to the stream.

        The format of the output is:
        @verbatim
           N error(s):
             line NNN: (id) message
         @endverbatim

        @param stream the ostream or ostringstream object indicating where
        the output should be printed.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see getNumErrors()
        @see getErrorLog()
        @see SBMLDocument.getError()

        """
        return _libsbml.SBMLDocument_printErrors(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor and assignment operator.

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.SBMLDocument_connectToChild(self)

    def convert(self, *args):
        """
        convert(self, ConversionProperties props) -> int

        Converts this document using the converter that best matches
        the given conversion properties. 

        @param props the conversion properties to use

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_CONV_CONVERSION_NOT_AVAILABLE LIBSBML_CONV_CONVERSION_NOT_AVAILABLE@endlink

        """
        return _libsbml.SBMLDocument_convert(self, *args)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.SBMLDocument_enablePackageInternal(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_DOCUMENT SBML_DOCUMENT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see SBMLDocument.getElementName()
        @see getPackageName()

        """
        return _libsbml.SBMLDocument_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for SBMLDocument,
        is always @c 'sbml'.

        @return the name of this element, i.e., @c 'sbml'.

        """
        return _libsbml.SBMLDocument_getElementName(self)

    def getErrorLog(self, *args):
        """
        getErrorLog(self) -> SBMLErrorLog
        getErrorLog(self) -> SBMLErrorLog

        Returns the list of errors or warnings logged during parsing, 
        consistency checking, or attempted translation of this model.

        @return the SBMLErrorLog used for this SBMLDocument

        @see SBMLDocument.getNumErrors()

        """
        return _libsbml.SBMLDocument_getErrorLog(self, *args)

    def getNamespaces(self):
        """
        getNamespaces(self) -> XMLNamespaces

        Returns a list of XML Namespaces associated with the XML content
        of this SBML document.

        @return the XML Namespaces associated with this SBML object

        """
        return _libsbml.SBMLDocument_getNamespaces(self)

    def enableDefaultNS(self, *args):
        """
        enableDefaultNS(self, string package, bool flag) -> int

        Set/unset default namespace to each top-level element defined in the
        given package extension.

        This works by adding a <code>xmlns=&quot;...&quot;</code> attribute.  No
        prefix will be written when writing elements defined in the given
        package extension if @c True is given as second argument.

        @param package the name or URI of the package extension.
        @param flag boolean value to indicate whether to write a namespace
        prefix.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_PKG_UNKNOWN_VERSION LIBSBML_PKG_UNKNOWN_VERSION@endlink

        """
        return _libsbml.SBMLDocument_enableDefaultNS(self, *args)

    def isEnabledDefaultNS(self, *args):
        """
        isEnabledDefaultNS(self, string package) -> bool

        Returns @c True if a default namespace is added to each top-level
        element defined in the given package extension, otherwise returns
        @c False.

        This basically checks if the attribute
        <code>xmlns=&quot;...&quot;</code> is present.

        @param package the name or URI of the package extension.

        @return a boolean

        """
        return _libsbml.SBMLDocument_isEnabledDefaultNS(self, *args)

    def setPackageRequired(self, *args):
        """
        setPackageRequired(self, string package, bool flag) -> int

        Sets the <code>required</code> attribute value of the given package
        extension.

        @note The name of package must not be given if the package is not
        enabled.

        @param package the name or URI of the package extension.
        @param flag Boolean value indicating whether the package is required.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_PKG_UNKNOWN_VERSION LIBSBML_PKG_UNKNOWN_VERSION@endlink

        """
        return _libsbml.SBMLDocument_setPackageRequired(self, *args)

    def getPackageRequired(self, *args):
        """
        getPackageRequired(self, string package) -> bool

        Returns the <code>required</code> attribute of the given package
        extension.

        @note The name of package must not be given if the package is not
        enabled.

        @param package the name or URI of the package extension.

        @return Boolean flag indicating whether the package is flagged as
        being required.

        """
        return _libsbml.SBMLDocument_getPackageRequired(self, *args)

    def isSetPackageRequired(self, *args):
        """
        isSetPackageRequired(self, string package) -> bool

        Returns @c True if the required attribute of the given package extension
        is defined, otherwise returns @c False.

        @note The name of package must not be given if the package is not
        enabled.

        @param package the name or URI of the package extension.

        @return a Boolean

        """
        return _libsbml.SBMLDocument_isSetPackageRequired(self, *args)

    def isIgnoredPackage(self, *args):
        """
        isIgnoredPackage(self, string pkgURI) -> bool

        Returns @c True if the given package extension is one of an ignored
        packages, otherwise returns @c False.

        An ignored package is one that is defined to be used in this SBML
        document, but the package is not enabled in this copy of libSBML.

        @param pkgURI the URI of the package extension.

        @return a Boolean, @c True if the package is being ignored and
        @c False otherwise.

        """
        return _libsbml.SBMLDocument_isIgnoredPackage(self, *args)

    def isDisabledIgnoredPackage(self, *args):
        """
        isDisabledIgnoredPackage(self, string pkgURI) -> bool

        Returns @c True if the given package extension is one of an ignored
        packages that has been disabled, otherwise returns @c False.

        An ignored package is one that is defined to be used in this SBML
        document, but the package is not enabled in this copy of libSBML.
        It may have been disabled to avoid reproducing the package
        information when writing out the file.

        @param pkgURI the URI of the package extension.

        @return a Boolean, @c True if the package is being ignored and
        @c False otherwise.

        """
        return _libsbml.SBMLDocument_isDisabledIgnoredPackage(self, *args)

    def setPkgRequired(self, *args):
        """
        setPkgRequired(self, string package, bool flag) -> int

        Sets the value of the <code>required</code> attribute for the given
        package.

        @note The name of package must not be given if the package is not
        enabled.

        @param package the name or URI of the package extension.
        @param flag a Boolean value.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_PKG_UNKNOWN_VERSION LIBSBML_PKG_UNKNOWN_VERSION@endlink

        @deprecated Replaced in libSBML 5.2.0 by
        setPackageRequired(@if java String, boolean@endif)

        """
        return _libsbml.SBMLDocument_setPkgRequired(self, *args)

    def getPkgRequired(self, *args):
        """
        getPkgRequired(self, string package) -> bool

        Returns the <code>required</code> attribute of the given package
        extension.

        @note The name of package must not be given if the package is not
        enabled.

        @param package the name or URI of the package extension.

        @return a Boolean value indicating whether the package is flagged as
        being required in this SBML document.

        @deprecated Replaced in libSBML 5.2.0 by
        getPackageRequired(@if java String@endif)

        """
        return _libsbml.SBMLDocument_getPkgRequired(self, *args)

    def isSetPkgRequired(self, *args):
        """
        isSetPkgRequired(self, string package) -> bool

        Returns @c True if the required attribute of the given package extension
        is defined, otherwise returns @c False.

        @note The name of package must not be given if the package is not
        enabled.

        @param package the name or URI of the package extension.

        @return a Boolean value.

        @deprecated Replaced in libSBML 5.2.0 by
        isSetPackageRequired(@if java String@endif)

        """
        return _libsbml.SBMLDocument_isSetPkgRequired(self, *args)

    def isIgnoredPkg(self, *args):
        """
        isIgnoredPkg(self, string pkgURI) -> bool

        Returns @c True if the given package extension is one of ignored
        packages, otherwise returns @c False.

        An ignored package is one that is defined to be used in this SBML
        document, but the package is not enabled in this copy of libSBML.

        @param pkgURI the URI of the package extension.

        @return a boolean

        @deprecated Replaced in libSBML 5.2.0 by
        isIgnoredPackage(@if java String@endif)

        """
        return _libsbml.SBMLDocument_isIgnoredPkg(self, *args)

    def getApplicableValidators(self):
        """
        getApplicableValidators(self) -> unsigned char

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_getApplicableValidators(self)

    def getConversionValidators(self):
        """
        getConversionValidators(self) -> unsigned char

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_getConversionValidators(self)

    def setApplicableValidators(self, *args):
        """
        setApplicableValidators(self, unsigned char appl)

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_setApplicableValidators(self, *args)

    def setConversionValidators(self, *args):
        """
        setConversionValidators(self, unsigned char appl)

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_setConversionValidators(self, *args)

    def getNumValidators(self):
        """
        getNumValidators(self) -> unsigned int

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_getNumValidators(self)

    def clearValidators(self):
        """
        clearValidators(self) -> int

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_clearValidators(self)

    def addValidator(self, *args):
        """
        addValidator(self, SBMLValidator validator) -> int

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_addValidator(self, *args)

    def getValidator(self, *args):
        """
        getValidator(self, unsigned int index) -> SBMLValidator

        @internal
        Validation system.

        @internal

        """
        return _libsbml.SBMLDocument_getValidator(self, *args)

SBMLDocument_swigregister = _libsbml.SBMLDocument_swigregister
SBMLDocument_swigregister(SBMLDocument)

def SBMLDocument_getDefaultLevel():
  """
    SBMLDocument_getDefaultLevel() -> unsigned int

    The default SBML Level of new SBMLDocument objects.

    @par
    This 'default Level' corresponds to the most recent SBML specification
    Level available at the time libSBML version @htmlinclude
    libsbml-version.html was released.  The default Level is used by
    SBMLDocument if no Level is explicitly specified at the time of the
    construction of an SBMLDocument instance.

    @return an integer indicating the most recent SBML specification Level

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike getDefaultVersion() @else SBMLDocument.getDefaultVersion() @endif@~

    """
  return _libsbml.SBMLDocument_getDefaultLevel()

def SBMLDocument_getDefaultVersion():
  """
    SBMLDocument_getDefaultVersion() -> unsigned int

    The default Version of new SBMLDocument objects.

    @par
    This 'default Version' corresponds to the most recent Version within the
    most recent Level of SBML available at the time libSBML version
    @htmlinclude libsbml-version.html was released.  The default Version is
    used by SBMLDocument if no Version is explicitly specified at the time of
    the construction of an SBMLDocument instance. 

    @return an integer indicating the most recent SBML specification
    Version

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike getDefaultLevel() @else SBMLDocument.getDefaultLevel() @endif@~

    """
  return _libsbml.SBMLDocument_getDefaultVersion()

class FunctionDefinition(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A user-defined function in an SBML model.

    The FunctionDefinition structure associates an identifier with a
    function definition.  This identifier can then be used as the function
    called in subsequent MathML content elsewhere in an SBML model.

    FunctionDefinition has one required attribute, 'id', to give the
    function a unique identifier by which other parts of an SBML model
    definition can refer to it.  A FunctionDefinition instance can also have
    an optional 'name' attribute of type @c string.  Identifiers and names
    must be used according to the guidelines described in the %SBML
    specification (e.g., Section 3.3 in the Level 2 Version 4
    specification).

    FunctionDefinition has a required 'math' subelement containing a MathML
    expression defining the function body.  The content of this element can
    only be a MathML 'lambda' element.  The 'lambda' element must begin with
    zero or more 'bvar' elements, followed by any other of the elements in
    the MathML subset allowed in SBML Level 2 @em except 'lambda' (i.e., a
    'lambda' element cannot contain another 'lambda' element).  This is the
    only place in SBML where a 'lambda' element can be used.  The function
    defined by a FunctionDefinition is only available for use in other
    MathML elements that @em follow the FunctionDefinition definition in the
    model.  (These restrictions prevent recursive and mutually-recursive
    functions from being expressed.)

    A further restriction on the content of 'math' is that it cannot contain
    references to variables other than the variables declared to the
    'lambda' itself.  That is, the contents of MathML 'ci' elements inside
    the body of the 'lambda' can only be the variables declared by its
    'bvar' elements, or the identifiers of other FunctionDefinition
    instances in the model.  This means must be written so that all
    variables or parameters used in the MathML content are passed to them
    via their function parameters.  In SBML Level&nbsp;2, this restriction
    applies also to the MathML @c csymbol elements for @em time and @em
    delay; in SBML Level&nbsp;3, it additionally applies to the @c csymbol
    element for @em avogadro.

    @note Function definitions (also informally known as user-defined
    functions) were introduced in SBML Level 2.  They have purposefully
    limited capabilities.  A function cannot reference parameters or other
    model quantities outside of itself; values must be passed as parameters
    to the function.  Moreover, recursive and mutually-recursive functions
    are not permitted.  The purpose of these limitations is to balance power
    against complexity of implementation.  With the restrictions as they
    are, function definitions could be implemented as textual
    substitutions---they are simply macros.  Software implementations
    therefore do not need the full function-definition machinery typically
    associated with programming languages.
    <br><br>
    Another important point to note is FunctionDefinition does not
    have a separate attribute for defining the units of the value returned
    by the function.  The units associated with the function's return value,
    when the function is called from within MathML expressions elsewhere in
    SBML, are simply the overall units of the expression in
    FunctionDefinition's 'math' subelement when applied to the arguments
    supplied in the call to the function.  Ascertaining these units requires
    performing dimensional analysis on the expression.  (Readers may wonder
    why there is no attribute.  The reason is that having a separate
    attribute for declaring the units would not only be redundant, but also
    lead to the potential for having conflicting information.  In the case
    of a conflict between the declared units and those of the value actually
    returned by the function, the only logical resolution rule would be to
    assume that the correct units are those of the expression anyway.)

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionDefinition, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_FunctionDefinition
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> FunctionDefinition
        __init__(self, SBMLNamespaces sbmlns) -> FunctionDefinition
        __init__(self, FunctionDefinition orig) -> FunctionDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>FunctionDefinition(SBMLNamespaces sbmlns)</pre>

        Creates a new FunctionDefinition using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>FunctionDefinition(long level, long version)</pre>

        Creates a new FunctionDefinition using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this FunctionDefinition

        @param version a long integer, the SBML Version to assign to this
        FunctionDefinition

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>FunctionDefinition(FunctionDefinition orig)</pre>

        Copy constructor; creates a copy of this FunctionDefinition.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_FunctionDefinition(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> FunctionDefinition

        Creates and returns a deep copy of this FunctionDefinition object.

        @return the (deep) copy of this FunctionDefinition object.

        """
        return _libsbml.FunctionDefinition_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this FunctionDefinition.

        @return the id of this FunctionDefinition.

        """
        return _libsbml.FunctionDefinition_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this FunctionDefinition.

        @return the name of this FunctionDefinition.

        """
        return _libsbml.FunctionDefinition_getName(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula of this FunctionDefinition.

        @return an ASTNode, the value of the 'math' subelement of this
        FunctionDefinition

        """
        return _libsbml.FunctionDefinition_getMath(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        FunctionDefinition's 'id' attribute is set.

        @return @c True if the 'id' attribute of this FunctionDefinition is
        set, @c False otherwise.

        """
        return _libsbml.FunctionDefinition_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        FunctionDefinition's 'name' attribute is set.

        @return @c True if the 'name' attribute of this FunctionDefinition is
        set, @c False otherwise.

        """
        return _libsbml.FunctionDefinition_isSetName(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c True if this
        FunctionDefinition's 'math' subelement contains a value.

        @return @c True if the 'math' for this FunctionDefinition is set,
        @c False otherwise.

        """
        return _libsbml.FunctionDefinition_isSetMath(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this FunctionDefinition.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this FunctionDefinition

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.FunctionDefinition_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this FunctionDefinition.

        The string in @p name is copied.

        @param name the new name for the FunctionDefinition

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.FunctionDefinition_setName(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this FunctionDefinition to the Abstract
        Syntax Tree given in @p math.

        @param math an AST containing the mathematical expression to
        be used as the formula for this FunctionDefinition.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.FunctionDefinition_setMath(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this FunctionDefinition.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.FunctionDefinition_unsetName(self)

    def getArgument(self, *args):
        """
        getArgument(self, unsigned int n) -> ASTNode
        getArgument(self, string name) -> ASTNode

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getArgument(long n)</pre>

        Get the <code>n</code>th argument to this function.

        Callers should first find out the number of arguments to the function
        by calling getNumArguments().

        @param n an integer index for the argument sought.

        @return the nth argument (bound variable) passed to this
        FunctionDefinition.

        @see getNumArguments()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getArgument(string name)</pre>

        Get the argument named @p name to this FunctionDefinition.

        @param name the exact name (case-sensitive) of the sought-after
        argument

        @return the argument (bound variable) having the given name, or @c None if
        no such argument exists.

        """
        return _libsbml.FunctionDefinition_getArgument(self, *args)

    def getBody(self, *args):
        """
        getBody(self) -> ASTNode
        getBody(self) -> ASTNode

        Get the mathematical expression that is the body of this
        FunctionDefinition object.

        @return the body of this FunctionDefinition as an Abstract Syntax
        Tree, or @c None if no body is defined.

        """
        return _libsbml.FunctionDefinition_getBody(self, *args)

    def isSetBody(self):
        """
        isSetBody(self) -> bool

        Predicate returning @c True if the body of this
        FunctionDefinition has set.

        @return @c True if the body of this FunctionDefinition is 
        set, @c False otherwise.

        """
        return _libsbml.FunctionDefinition_isSetBody(self)

    def getNumArguments(self):
        """
        getNumArguments(self) -> unsigned int

        Get the number of arguments (bound variables) taken by this
        FunctionDefinition.

        @return the number of arguments (bound variables) that must be passed
        to this FunctionDefinition.

        """
        return _libsbml.FunctionDefinition_getNumArguments(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_FUNCTION_DEFINITION SBML_FUNCTION_DEFINITION@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.FunctionDefinition_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        FunctionDefinition, is always @c 'functionDefinition'.

        @return the name of this element, i.e., @c 'functionDefinition'.

        """
        return _libsbml.FunctionDefinition_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this FunctionDefinition object
        have been set.

        The required attributes for a FunctionDefinition object are:
        @li 'id'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.FunctionDefinition_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for this FunctionDefinition object
        have been set.

        @note The required elements for a FunctionDefinition object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.FunctionDefinition_hasRequiredElements(self)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Renames all the @c UnitSIdRef attributes on this element.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        unit identifiers to the value of @p oldid.  If any matches are found,
        the matching identifiers are replaced with @p newid.  The method does
        @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.FunctionDefinition_renameUnitSIdRefs(self, *args)

FunctionDefinition_swigregister = _libsbml.FunctionDefinition_swigregister
FunctionDefinition_swigregister(FunctionDefinition)

class ListOfFunctionDefinitions(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of FunctionDefinition objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfFunctionDefinitions, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfFunctionDefinitions, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfFunctionDefinitions
        __init__(self, SBMLNamespaces sbmlns) -> ListOfFunctionDefinitions

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfFunctionDefinitions(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfFunctionDefinitions object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfFunctionDefinitions object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfFunctionDefinitions(long level, long version)</pre>

        Creates a new ListOfFunctionDefinitions object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfFunctionDefinitions(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfFunctionDefinitions

        Creates and returns a deep copy of this ListOfFunctionDefinitions object.

        @return the (deep) copy of this ListOfFunctionDefinitions object.

        """
        return _libsbml.ListOfFunctionDefinitions_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., FunctionDefinition objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf:
        @link libsbml#SBML_FUNCTION_DEFINITION SBML_FUNCTION_DEFINITION@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfFunctionDefinitions_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfFunctionDefinitions, the XML element name is @c
        'listOfFunctionDefinitions'.

        @return the name of this element, i.e., @c 'listOfFunctionDefinitions'.

        """
        return _libsbml.ListOfFunctionDefinitions_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> FunctionDefinition
        get(self, unsigned int n) -> FunctionDefinition
        get(self, string sid) -> FunctionDefinition
        get(self, string sid) -> FunctionDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a FunctionDefinition from the ListOfFunctionDefinitions.

        @param n the index number of the FunctionDefinition to get.

        @return the nth FunctionDefinition in this ListOfFunctionDefinitions.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a FunctionDefinition from the ListOfFunctionDefinitions
        based on its identifier.

        @param sid a string representing the identifier 
        of the FunctionDefinition to get.

        @return FunctionDefinition in this ListOfFunctionDefinitions
        with the given @p sid or @c None if no such
        FunctionDefinition exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfFunctionDefinitions_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> FunctionDefinition
        remove(self, string sid) -> FunctionDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfFunctionDefinitions items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfFunctionDefinitions items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfFunctionDefinitions_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfFunctionDefinitions
    __del__ = lambda self : None;
ListOfFunctionDefinitions_swigregister = _libsbml.ListOfFunctionDefinitions_swigregister
ListOfFunctionDefinitions_swigregister(ListOfFunctionDefinitions)

UNIT_KIND_AMPERE = _libsbml.UNIT_KIND_AMPERE
UNIT_KIND_AVOGADRO = _libsbml.UNIT_KIND_AVOGADRO
UNIT_KIND_BECQUEREL = _libsbml.UNIT_KIND_BECQUEREL
UNIT_KIND_CANDELA = _libsbml.UNIT_KIND_CANDELA
UNIT_KIND_CELSIUS = _libsbml.UNIT_KIND_CELSIUS
UNIT_KIND_COULOMB = _libsbml.UNIT_KIND_COULOMB
UNIT_KIND_DIMENSIONLESS = _libsbml.UNIT_KIND_DIMENSIONLESS
UNIT_KIND_FARAD = _libsbml.UNIT_KIND_FARAD
UNIT_KIND_GRAM = _libsbml.UNIT_KIND_GRAM
UNIT_KIND_GRAY = _libsbml.UNIT_KIND_GRAY
UNIT_KIND_HENRY = _libsbml.UNIT_KIND_HENRY
UNIT_KIND_HERTZ = _libsbml.UNIT_KIND_HERTZ
UNIT_KIND_ITEM = _libsbml.UNIT_KIND_ITEM
UNIT_KIND_JOULE = _libsbml.UNIT_KIND_JOULE
UNIT_KIND_KATAL = _libsbml.UNIT_KIND_KATAL
UNIT_KIND_KELVIN = _libsbml.UNIT_KIND_KELVIN
UNIT_KIND_KILOGRAM = _libsbml.UNIT_KIND_KILOGRAM
UNIT_KIND_LITER = _libsbml.UNIT_KIND_LITER
UNIT_KIND_LITRE = _libsbml.UNIT_KIND_LITRE
UNIT_KIND_LUMEN = _libsbml.UNIT_KIND_LUMEN
UNIT_KIND_LUX = _libsbml.UNIT_KIND_LUX
UNIT_KIND_METER = _libsbml.UNIT_KIND_METER
UNIT_KIND_METRE = _libsbml.UNIT_KIND_METRE
UNIT_KIND_MOLE = _libsbml.UNIT_KIND_MOLE
UNIT_KIND_NEWTON = _libsbml.UNIT_KIND_NEWTON
UNIT_KIND_OHM = _libsbml.UNIT_KIND_OHM
UNIT_KIND_PASCAL = _libsbml.UNIT_KIND_PASCAL
UNIT_KIND_RADIAN = _libsbml.UNIT_KIND_RADIAN
UNIT_KIND_SECOND = _libsbml.UNIT_KIND_SECOND
UNIT_KIND_SIEMENS = _libsbml.UNIT_KIND_SIEMENS
UNIT_KIND_SIEVERT = _libsbml.UNIT_KIND_SIEVERT
UNIT_KIND_STERADIAN = _libsbml.UNIT_KIND_STERADIAN
UNIT_KIND_TESLA = _libsbml.UNIT_KIND_TESLA
UNIT_KIND_VOLT = _libsbml.UNIT_KIND_VOLT
UNIT_KIND_WATT = _libsbml.UNIT_KIND_WATT
UNIT_KIND_WEBER = _libsbml.UNIT_KIND_WEBER
UNIT_KIND_INVALID = _libsbml.UNIT_KIND_INVALID

def UnitKind_equals(*args):
  """
    UnitKind_equals(UnitKind_t uk1, UnitKind_t uk2) -> int

    Tests for logical equality between two given <code>UNIT_KIND_</code>
    code values.

    This function behaves exactly like C's <code>==</code> operator, except
    for the following two cases:
    <ul>
    <li>@link libsbml#UNIT_KIND_LITER UNIT_KIND_LITER@endlink <code>==</code> @link libsbml#UNIT_KIND_LITRE UNIT_KIND_LITRE@endlink
    <li>@link libsbml#UNIT_KIND_METER UNIT_KIND_METER@endlink <code>==</code> @link libsbml#UNIT_KIND_METRE UNIT_KIND_METRE@endlink
    </ul>

    In the two cases above, C equality comparison would yield @c False
    (because each of the above is a distinct enumeration value), but
    this function returns @c True.

    @param uk1 a <code>UNIT_KIND_</code> value 
    @param uk2 a second <code>UNIT_KIND_</code> value to compare to @p uk1

    @return nonzero (for @c True) if @p uk1 is logically equivalent to @p
    uk2, zero (for @c False) otherwise.

    @note For more information about the libSBML unit codes, please refer to
    the class documentation for Unit.

    @if conly
    @memberof Unit_t
    @endif

    """
  return _libsbml.UnitKind_equals(*args)

def UnitKind_forName(*args):
  """
    UnitKind_forName(char name) -> UnitKind_t

    Converts a text string naming a kind of unit to its corresponding
    libSBML <code>UNIT_KIND_</code> constant/enumeration value.

    @param name a string, the name of a predefined base unit in SBML

    @return @if clike a value from UnitKind_t corresponding to the given
    string @p name (determined in a case-insensitive manner).
    @endif@if python a value the set of <code>UNIT_KIND_</code> codes
    defined in class @link libsbml libsbml@endlink, corresponding to the
    string @p name (determined in a case-insensitive
    manner).@endif@if java a value the set of <code>UNIT_KIND_</code> codes
    defined in class {@link libsbmlConstants}, corresponding to the string
    @p name (determined in a case-insensitive manner).@endif@~

    @note For more information about the libSBML unit codes, please refer to
    the class documentation for Unit.

    @if conly
    @memberof Unit_t
    @endif

    """
  return _libsbml.UnitKind_forName(*args)

def UnitKind_toString(*args):
  """
    UnitKind_toString(UnitKind_t uk) -> char

    Converts a unit code to a text string equivalent.

    @param uk @if clike a value from the UnitKind_t enumeration
    @endif@if python a value from the set of <code>UNIT_KIND_</code> codes
    defined in the class @link libsbml libsbml@endlink
    @endif@if java a value from the set of <code>UNIT_KIND_</code> codes
    defined in the class {@link libsbmlConstants}
    @endif@~

    @return the name corresponding to the given unit code.

    @note For more information about the libSBML unit codes, please refer to
    the class documentation for Unit.

    @warning The string returned is a static data value.  The caller does not
    own the returned string and is therefore not allowed to modify it.

    @if conly
    @memberof Unit_t
    @endif

    """
  return _libsbml.UnitKind_toString(*args)

def UnitKind_isValidUnitKindString(*args):
  """
    UnitKind_isValidUnitKindString(char str, unsigned int level, unsigned int version) -> int

    Predicate for testing whether a given string corresponds to a
    predefined libSBML unit code.

    @param str a text string naming a base unit defined by SBML
    @param level the Level of SBML
    @param version the Version within the Level of SBML

    @return nonzero (for @c True) if string is the name of a valid
    <code>UNIT_KIND_</code> value, zero (for @c False) otherwise.

    @note For more information about the libSBML unit codes, please refer to
    the class documentation for Unit.

    @if conly
    @memberof Unit_t
    @endif

    """
  return _libsbml.UnitKind_isValidUnitKindString(*args)
class Unit(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A single unit referenced in an SBML <em>unit definition</em>.

    The SBML unit definition facility uses two classes of objects,
    UnitDefinition and Unit.  The approach to defining units in %SBML is
    compositional; for example, <em>meter second<sup> &ndash;2</sup></em> is
    constructed by combining a Unit object representing <em>meter</em> with
    another Unit object representing <em>second<sup> &ndash;2</sup></em>.
    The combination is wrapped inside a UnitDefinition, which provides for
    assigning an identifier and optional name to the combination.  The
    identifier can then be referenced from elsewhere in a model.  Thus, the
    UnitDefinition class is the container, and Unit instances are placed
    inside UnitDefinition instances.

    A Unit has four attributes named 'kind', 'exponent', 'scale'
    and 'multiplier'.  It represents a (possibly transformed) reference to a
    base unit.  The attribute 'kind' on Unit indicates the chosen base unit.
    Its value must be one of the text strings listed below; this list
    corresponds to SBML Level&nbsp;3 Version&nbsp;1 Core:

    @par
    <table border='0' class='centered text-table width80 normal-font code'
           style='border: none !important'>
    <tr>
    <td>ampere</td><td>farad</td><td>joule</td><td>lux</td><td>radian</td><td>volt</td>
    </tr>
    <tr>
    <td>avogadro</td><td>gram</td><td>katal</td><td>metre</td><td>second</td><td>watt</td>
    </tr>
    <tr>
    <td>becquerel</td><td>gray</td><td>kelvin</td><td>mole</td><td>siemens</td><td>weber</td>
    </tr>
    <tr>
    <td>candela</td><td>henry</td><td>kilogram</td><td>newton</td><td>sievert</td>
    </tr>
    <tr>
    <td>coulomb</td><td>hertz</td><td>litre</td><td>ohm</td><td>steradian</td>
    </tr>
    <tr>
    <td>dimensionless</td><td>item</td><td>lumen</td><td>pascal</td><td>tesla</td>
    </tr>
    </table>

    A few small differences exist between the Level&nbsp;3 list of base
    units and the list defined in other Level/Version combinations of SBML.
    Specifically, Levels of SBML before Level&nbsp;3 do not define @c
    avogadro; conversely, Level&nbsp;2 Version&nbsp;1 defines @c Celsius,
    and Level&nbsp;1 defines @c celsius, @c meter, and @c liter, none of
    which are available in Level&nbsp;3.  In libSBML, each of the predefined
    base unit names is represented by an enumeration value @if clike in
    #UnitKind_t@else whose name begins with the characters
    <code>UNIT_KIND_</code>@endif, discussed in a separate section below.

    The attribute named 'exponent' on Unit represents an exponent on the
    unit.  In SBML Level&nbsp;2, the attribute is optional and has a default
    value of @c 1 (one); in SBML Level&nbsp;3, the attribute is mandatory
    and there is no default value.  A Unit also has an attribute
    called 'scale'; its value must be an integer exponent for a power-of-ten
    multiplier used to set the scale of the unit.  For example, a unit
    having a 'kind' value of @c gram and a 'scale' value of @c -3 signifies
    10<sup>&nbsp;&ndash;3</sup> * gram, or milligrams.  In SBML
    Level&nbsp;2, the attribute is optional and has a default value of @c 0
    (zero), because 10<sup> 0</sup> = 1; in SBML Level&nbsp;3, the attribute
    is mandatory and has no default value.  Lastly, the attribute named
    'multiplier' can be used to multiply the unit by a real-numbered factor;
    this enables the definition of units that are not power-of-ten multiples
    of SI units.  For instance, a multiplier of 0.3048 could be used to
    define @c foot as a measure of length in terms of a @c metre.  The
    'multiplier' attribute is optional in SBML Level&nbsp;2, where it has a
    default value of @c 1 (one); in SBML Level&nbsp;3, the attribute is
    mandatory and has not default value.

    @if clike
    <h3><a class='anchor' name='UnitKind_t'>UnitKind_t</a></h3>
    @else
    <h3><a class='anchor' name='UnitKind_t'>%Unit identification codes</a></h3>
    @endif@~

    As discussed above, SBML defines a set of base units which serves as the
    starting point for new unit definitions.  This set of base units
    consists of the SI units and a small number of additional convenience
    units.

    @if clike Until SBML Level&nbsp;2 Version&nbsp;3, there
    existed a data type in the SBML specifications called @c UnitKind,
    enumerating the possible SBML base units.  Although SBML Level&nbsp;2
    Version&nbsp;3 removed this type from the language specification,
    libSBML maintains the corresponding enumeration type #UnitKind_t as a
    convenience and as a way to provide backward compatibility to previous
    SBML Level/Version specifications.  (The removal in SBML Level&nbsp;2
    Version&nbsp;3 of the enumeration @c UnitKind was also accompanied by
    the redefinition of the data type @c UnitSId to include the previous @c
    UnitKind values as reserved symbols in the @c UnitSId space.  This
    change has no net effect on permissible models, their representation or
    their syntax.  The purpose of the change in the SBML specification was
    simply to clean up an inconsistency about the contexts in which these
    values were usable.)
    @endif@if java In SBML Level&nbsp;2 Versions before
    Version&nbsp;3, there existed an enumeration of units called @c
    UnitKind.  In Version&nbsp;3, this enumeration was removed and the
    identifier class @c UnitSId redefined to include the previous @c
    UnitKind values as reserved symbols.  This change has no net effect on
    permissible models, their representation or their syntax.  The purpose
    of the change in the SBML specification was simply to clean up an
    inconsistency about the contexts in which these values were usable.
    However, libSBML maintains UnitKind in the form of of a set of static
    integer constants whose names begin with the characters
    <code>UNIT_KIND_</code>.  These constants are defined in the class
    <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>.
    @endif@if python In SBML Level&nbsp;2 Versions before
    Version&nbsp;3, there existed an enumeration of units called @c
    UnitKind.  In Version&nbsp;3, this enumeration was removed and the
    identifier class @c UnitSId redefined to include the previous @c
    UnitKind values as reserved symbols.  This change has no net effect on
    permissible models, their representation or their syntax.  The purpose
    of the change in the SBML specification was simply to clean up an
    inconsistency about the contexts in which these values were usable.
    However, libSBML maintains UnitKind in the form of of a set of static
    integer constants whose names begin with the characters
    <code>UNIT_KIND_</code>.  These constants are defined in the class
    @link libsbml libsbml@endlink.
    @endif@~

    As a consequence of the fact that libSBML supports models in all Levels
    and Versions of SBML, libSBML's set of @c UNIT_KIND_ values is a union
    of all the possible base unit names defined in the different SBML
    specifications.  However, not every base unit is allowed in every
    Level+Version combination of SBML.  Note in particular the following
    exceptions:
    <ul>
    <li> The alternate spelling @c 'meter' is included in
    addition to the official SI spelling @c 'metre'.  This spelling is only
    permitted in SBML Level&nbsp;1 models.

    <li> The alternate spelling @c 'liter' is included in addition to the
    official SI spelling @c 'litre'.  This spelling is only permitted in
    SBML Level&nbsp;1 models.

    <li> The unit @c 'Celsius' is included because of its presence in
    specifications of SBML prior to SBML Level&nbsp;2 Version&nbsp;3.

    <li> The unit @c avogadro was introduced in SBML Level&nbsp;3, and
    is only permitted for use in SBML Level&nbsp;3 models.
    </ul>

    @if clike The table below lists the symbols defined in the
    @c UnitKind_t enumeration, and their
    meanings. @else The table below lists the unit
    constants defined in libSBML, and their meanings. @endif@~

    @htmlinclude unitkind-table.html

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Unit, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Unit, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Unit
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Unit
        __init__(self, SBMLNamespaces sbmlns) -> Unit
        __init__(self, Unit orig) -> Unit

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Unit(SBMLNamespaces sbmlns)</pre>

        Creates a new Unit using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Unit(long level, long version)</pre>

        Creates a new Unit using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Unit

        @param version a long integer, the SBML Version to assign to this
        Unit

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Unit(Unit orig)</pre>

        Copy constructor; creates a copy of this Unit.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Unit(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Unit

        Creates and returns a deep copy of this Unit object.

        @return the (deep) copy of this Unit object.

        """
        return _libsbml.Unit_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Unit object to 'typical' default
        values.

        The SBML Unit component has slightly different aspects and default
        attribute values in different SBML Levels and Versions.  This method
        sets the values to certain common defaults, based mostly on what they
        are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets attribute 'exponent' to @c 1
        <li> Sets attribute 'scale' to @c 0
        <li> Sets attribute 'multiplier' to @c 1.0
        </ul>

        The 'kind' attribute is left unchanged.

        """
        return _libsbml.Unit_initDefaults(self)

    def getKind(self):
        """
        getKind(self) -> UnitKind_t

        Returns the 'kind' of Unit this is.

        @if clike
        @return the value of the 'kind' attribute of this Unit as a
        value from the <a class='el' href='#UnitKind_t'>UnitKind_t</a> enumeration.
        @endif@if java
        @return the value of the 'kind' attribute of this Unit as a
        value from the set of constants whose names begin
        with <code>UNIT_KIND_</code> defined in the class
        <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>.
        @endif@if python
        @return the value of the 'kind' attribute of this Unit as a
        value from the set of constants whose names begin
        with <code>UNIT_KIND_</code> defined in the class
        @link libsbml libsbml@endlink.
        @endif@~

        """
        return _libsbml.Unit_getKind(self)

    def getExponent(self):
        """
        getExponent(self) -> int

        Returns the value of the 'exponent' attribute of this unit.

        @return the 'exponent' value of this Unit, as an integer.

        """
        return _libsbml.Unit_getExponent(self)

    def getExponentAsDouble(self):
        """
        getExponentAsDouble(self) -> double

        Returns the value of the 'exponent' attribute of this unit.

        @return the 'exponent' value of this Unit, as a double.

        """
        return _libsbml.Unit_getExponentAsDouble(self)

    def getScale(self):
        """
        getScale(self) -> int

        Returns the value of the 'scale' attribute of this unit.

        @return the 'scale' value of this Unit, as an integer.

        """
        return _libsbml.Unit_getScale(self)

    def getMultiplier(self):
        """
        getMultiplier(self) -> double

        Returns the value of the 'multiplier' attribute of this Unit.

        @return the 'multiplier' value of this Unit, as a double.

        """
        return _libsbml.Unit_getMultiplier(self)

    def getOffset(self):
        """
        getOffset(self) -> double

        Returns the value of the 'offset' attribute of this Unit.

        @return the 'offset' value of this Unit, as a double.

        @warning <span class='warning'>The 'offset' attribute is only available in
        SBML Level&nbsp;2 Version&nbsp;1.  This attribute is not present in SBML
        Level&nbsp;2 Version&nbsp;2 or above.  When producing SBML models using
        these later specifications, modelers and software tools need to account
        for units with offsets explicitly.  The %SBML specification document
        offers a number of suggestions for how to achieve this.  LibSBML methods
        such as this one related to 'offset' are retained for compatibility with
        earlier versions of SBML Level&nbsp;2, but their use is strongly
        discouraged.</span>

        """
        return _libsbml.Unit_getOffset(self)

    def isAmpere(self):
        """
        isAmpere(self) -> bool

        Predicate for testing whether this Unit is of the kind @c ampere.

        @return @c True if the kind of this Unit is @c ampere, @c False
        otherwise.

        """
        return _libsbml.Unit_isAmpere(self)

    def isAvogadro(self):
        """
        isAvogadro(self) -> bool

        Predicate for testing whether this Unit is of the kind @c avogadro.

        @return @c True if the kind of this Unit is @c avogadro, @c False
        otherwise.

        @note The unit @c avogadro was introduced in SBML Level&nbsp;3, and
        is only permitted for use in SBML Level&nbsp;3 models.

        """
        return _libsbml.Unit_isAvogadro(self)

    def isBecquerel(self):
        """
        isBecquerel(self) -> bool

        Predicate for testing whether this Unit is of the kind @c becquerel

        @return @c True if the kind of this Unit is @c becquerel, @c False
        otherwise.

        """
        return _libsbml.Unit_isBecquerel(self)

    def isCandela(self):
        """
        isCandela(self) -> bool

        Predicate for testing whether this Unit is of the kind @c candela

        @return @c True if the kind of this Unit is @c candela, @c False
        otherwise.

        """
        return _libsbml.Unit_isCandela(self)

    def isCelsius(self):
        """
        isCelsius(self) -> bool

        Predicate for testing whether this Unit is of the kind @c Celsius

        @return @c True if the kind of this Unit is @c Celsius, @c False
        otherwise. 

        @warning <span class='warning'>The predefined unit @c Celsius was
        removed from the list of predefined units in SBML Level&nbsp;2
        Version&nbsp;2 at the same time that the 'offset' attribute was removed
        from Unit definitions.  LibSBML methods such as this one related to @c
        Celsius are retained in order to support SBML Level&nbsp;2
        Version&nbsp;1, but their use is strongly discouraged.</span>

        """
        return _libsbml.Unit_isCelsius(self)

    def isCoulomb(self):
        """
        isCoulomb(self) -> bool

        Predicate for testing whether this Unit is of the kind @c coulomb

        @return @c True if the kind of this Unit is @c coulomb, @c False
        otherwise.

        """
        return _libsbml.Unit_isCoulomb(self)

    def isDimensionless(self):
        """
        isDimensionless(self) -> bool

        Predicate for testing whether this Unit is of the kind @c
        dimensionless.

        @return @c True if the kind of this Unit is @c dimensionless, @c False

        otherwise.

        """
        return _libsbml.Unit_isDimensionless(self)

    def isFarad(self):
        """
        isFarad(self) -> bool

        Predicate for testing whether this Unit is of the kind @c farad

        @return @c True if the kind of this Unit is @c farad, @c False
        otherwise.

        """
        return _libsbml.Unit_isFarad(self)

    def isGram(self):
        """
        isGram(self) -> bool

        Predicate for testing whether this Unit is of the kind @c gram

        @return @c True if the kind of this Unit is @c gram, @c False
        otherwise.

        """
        return _libsbml.Unit_isGram(self)

    def isGray(self):
        """
        isGray(self) -> bool

        Predicate for testing whether this Unit is of the kind @c gray

        @return @c True if the kind of this Unit is @c gray, @c False
        otherwise.

        """
        return _libsbml.Unit_isGray(self)

    def isHenry(self):
        """
        isHenry(self) -> bool

        Predicate for testing whether this Unit is of the kind @c henry

        @return @c True if the kind of this Unit is @c henry, @c False
        otherwise.

        """
        return _libsbml.Unit_isHenry(self)

    def isHertz(self):
        """
        isHertz(self) -> bool

        Predicate for testing whether this Unit is of the kind @c hertz

        @return @c True if the kind of this Unit is @c hertz, @c False
        otherwise.

        """
        return _libsbml.Unit_isHertz(self)

    def isItem(self):
        """
        isItem(self) -> bool

        Predicate for testing whether this Unit is of the kind @c item

        @return @c True if the kind of this Unit is @c item, @c False
        otherwise.

        """
        return _libsbml.Unit_isItem(self)

    def isJoule(self):
        """
        isJoule(self) -> bool

        Predicate for testing whether this Unit is of the kind @c joule

        @return @c True if the kind of this Unit is @c joule, @c False
        otherwise.

        """
        return _libsbml.Unit_isJoule(self)

    def isKatal(self):
        """
        isKatal(self) -> bool

        Predicate for testing whether this Unit is of the kind @c katal

        @return @c True if the kind of this Unit is @c katal, @c False
        otherwise.

        """
        return _libsbml.Unit_isKatal(self)

    def isKelvin(self):
        """
        isKelvin(self) -> bool

        Predicate for testing whether this Unit is of the kind @c kelvin

        @return @c True if the kind of this Unit is @c kelvin, @c False
        otherwise.

        """
        return _libsbml.Unit_isKelvin(self)

    def isKilogram(self):
        """
        isKilogram(self) -> bool

        Predicate for testing whether this Unit is of the kind @c kilogram

        @return @c True if the kind of this Unit is @c kilogram, @c False
        otherwise.

        """
        return _libsbml.Unit_isKilogram(self)

    def isLitre(self):
        """
        isLitre(self) -> bool

        Predicate for testing whether this Unit is of the kind @c litre

        @return @c True if the kind of this Unit is @c litre or 'liter', @c False 
        otherwise.

        """
        return _libsbml.Unit_isLitre(self)

    def isLumen(self):
        """
        isLumen(self) -> bool

        Predicate for testing whether this Unit is of the kind @c lumen

        @return @c True if the kind of this Unit is @c lumen, @c False
        otherwise.

        """
        return _libsbml.Unit_isLumen(self)

    def isLux(self):
        """
        isLux(self) -> bool

        Predicate for testing whether this Unit is of the kind @c lux

        @return @c True if the kind of this Unit is @c lux, @c False
        otherwise.

        """
        return _libsbml.Unit_isLux(self)

    def isMetre(self):
        """
        isMetre(self) -> bool

        Predicate for testing whether this Unit is of the kind @c metre

        @return @c True if the kind of this Unit is @c metre or 'meter', @c False 
        otherwise.

        """
        return _libsbml.Unit_isMetre(self)

    def isMole(self):
        """
        isMole(self) -> bool

        Predicate for testing whether this Unit is of the kind @c mole

        @return @c True if the kind of this Unit is @c mole, @c False
        otherwise.

        """
        return _libsbml.Unit_isMole(self)

    def isNewton(self):
        """
        isNewton(self) -> bool

        Predicate for testing whether this Unit is of the kind @c newton

        @return @c True if the kind of this Unit is @c newton, @c False
        otherwise.

        """
        return _libsbml.Unit_isNewton(self)

    def isOhm(self):
        """
        isOhm(self) -> bool

        Predicate for testing whether this Unit is of the kind @c ohm

        @return @c True if the kind of this Unit is @c ohm, @c False
        otherwise.

        """
        return _libsbml.Unit_isOhm(self)

    def isPascal(self):
        """
        isPascal(self) -> bool

        Predicate for testing whether this Unit is of the kind @c pascal

        @return @c True if the kind of this Unit is @c pascal, @c False
        otherwise.

        """
        return _libsbml.Unit_isPascal(self)

    def isRadian(self):
        """
        isRadian(self) -> bool

        Predicate for testing whether this Unit is of the kind @c radian

        @return @c True if the kind of this Unit is @c radian, @c False
        otherwise.

        """
        return _libsbml.Unit_isRadian(self)

    def isSecond(self):
        """
        isSecond(self) -> bool

        Predicate for testing whether this Unit is of the kind @c second

        @return @c True if the kind of this Unit is @c second, @c False
        otherwise.

        """
        return _libsbml.Unit_isSecond(self)

    def isSiemens(self):
        """
        isSiemens(self) -> bool

        Predicate for testing whether this Unit is of the kind @c siemens

        @return @c True if the kind of this Unit is @c siemens, @c False
        otherwise.

        """
        return _libsbml.Unit_isSiemens(self)

    def isSievert(self):
        """
        isSievert(self) -> bool

        Predicate for testing whether this Unit is of the kind @c sievert

        @return @c True if the kind of this Unit is @c sievert, @c False
        otherwise.

        """
        return _libsbml.Unit_isSievert(self)

    def isSteradian(self):
        """
        isSteradian(self) -> bool

        Predicate for testing whether this Unit is of the kind @c steradian

        @return @c True if the kind of this Unit is @c steradian, @c False
        otherwise.

        """
        return _libsbml.Unit_isSteradian(self)

    def isTesla(self):
        """
        isTesla(self) -> bool

        Predicate for testing whether this Unit is of the kind @c tesla

        @return @c True if the kind of this Unit is @c tesla, @c False
        otherwise.

        """
        return _libsbml.Unit_isTesla(self)

    def isVolt(self):
        """
        isVolt(self) -> bool

        Predicate for testing whether this Unit is of the kind @c volt

        @return @c True if the kind of this Unit is @c volt, @c False
        otherwise.

        """
        return _libsbml.Unit_isVolt(self)

    def isWatt(self):
        """
        isWatt(self) -> bool

        Predicate for testing whether this Unit is of the kind @c watt

        @return @c True if the kind of this Unit is @c watt, @c False
        otherwise.

        """
        return _libsbml.Unit_isWatt(self)

    def isWeber(self):
        """
        isWeber(self) -> bool

        Predicate for testing whether this Unit is of the kind @c weber

        @return @c True if the kind of this Unit is @c weber, @c False
        otherwise.

        """
        return _libsbml.Unit_isWeber(self)

    def isSetKind(self):
        """
        isSetKind(self) -> bool

        Predicate to test whether the 'kind' attribute of this Unit is set.

        @return @c True if the 'kind' attribute of this Unit is set, @c False otherwise.

        """
        return _libsbml.Unit_isSetKind(self)

    def isSetExponent(self):
        """
        isSetExponent(self) -> bool

        Predicate to test whether the 'exponent' attribute of this Unit 
        is set.

        @return @c True if the 'exponent' attribute of this Unit is set, 
        @c False otherwise.

        """
        return _libsbml.Unit_isSetExponent(self)

    def isSetScale(self):
        """
        isSetScale(self) -> bool

        Predicate to test whether the 'scale' attribute of this Unit 
        is set.

        @return @c True if the 'scale' attribute of this Unit is set, 
        @c False otherwise.

        """
        return _libsbml.Unit_isSetScale(self)

    def isSetMultiplier(self):
        """
        isSetMultiplier(self) -> bool

        Predicate to test whether the 'multiplier' attribute of this Unit 
        is set.

        @return @c True if the 'multiplier' attribute of this Unit is set, 
        @c False otherwise.

        """
        return _libsbml.Unit_isSetMultiplier(self)

    def setKind(self, *args):
        """
        setKind(self, UnitKind_t kind) -> int

        Sets the 'kind' attribute value of this Unit.

        @if clike
        @param kind a value from the <a class='el'
        href='#UnitKind_t'>UnitKind_t</a> enumeration.
        @endif@if java
        @param kind a unit identifier chosen from the set of constants whose
        names begin with <code>UNIT_KIND_</code> in <code><a
        href='libsbmlConstants.html'>libsbmlConstants</a></code>.
        @endif@if python
        @param kind a unit identifier chosen from the set of constants whose
        names begin with <code>UNIT_KIND_</code> in @link libsbml libsbml@endlink.
        @endif@~

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Unit_setKind(self, *args)

    def setExponent(self, *args):
        """
        setExponent(self, int value) -> int
        setExponent(self, double value) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setExponent(int value)</pre>

        Sets the 'exponent' attribute value of this Unit.

        @param value the integer to which the attribute 'exponent' should be set

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setExponent(double value)</pre>

        Sets the 'exponent' attribute value of this Unit.

        @param value the double to which the attribute 'exponent' should be set

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.Unit_setExponent(self, *args)

    def setScale(self, *args):
        """
        setScale(self, int value) -> int

        Sets the 'scale' attribute value of this Unit.

        @param value the integer to which the attribute 'scale' should be set

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.Unit_setScale(self, *args)

    def setMultiplier(self, *args):
        """
        setMultiplier(self, double value) -> int

        Sets the 'multipler' attribute value of this Unit.

        @param value the floating-point value to which the attribute
        'multiplier' should be set

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.Unit_setMultiplier(self, *args)

    def setOffset(self, *args):
        """
        setOffset(self, double value) -> int

        Sets the 'offset' attribute value of this Unit.

        @param value the float-point value to which the attribute 'offset'
        should set

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @warning <span class='warning'>The 'offset' attribute is only available in
        SBML Level&nbsp;2 Version&nbsp;1.  This attribute is not present in SBML
        Level&nbsp;2 Version&nbsp;2 or above.  When producing SBML models using
        these later specifications, modelers and software tools need to account
        for units with offsets explicitly.  The %SBML specification document
        offers a number of suggestions for how to achieve this.  LibSBML methods
        such as this one related to 'offset' are retained for compatibility with
        earlier versions of SBML Level&nbsp;2, but their use is strongly
        discouraged.</span>

        """
        return _libsbml.Unit_setOffset(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_UNIT SBML_UNIT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getPackageName()
        @see getElementName()

        """
        return _libsbml.Unit_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Unit, is
        always @c 'unit'.

        @return the name of this element, i.e., @c 'unit'.

        """
        return _libsbml.Unit_getElementName(self)

    def isBuiltIn(*args):
        """
        isBuiltIn(string name, unsigned int level) -> bool

        Predicate to test whether a given string is the name of a
        predefined SBML unit.

        @param name a string to be tested against the predefined unit names

        @param level the Level of SBML for which the determination should be
        made.  This is necessary because there are a few small differences
        in allowed units between SBML Level&nbsp;1 and Level&nbsp;2.

        @return @c True if @p name is one of the five SBML predefined unit
        identifiers (@c 'substance', @c 'volume', @c 'area', @c 'length' or @c
        'time'), @c False otherwise.

        @note The predefined unit identifiers @c 'length' and @c 'area' were
        added in Level&nbsp;2 Version&nbsp;1.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.Unit_isBuiltIn(*args)

    if _newclass:isBuiltIn = staticmethod(isBuiltIn)
    __swig_getmethods__["isBuiltIn"] = lambda x: isBuiltIn
    def isUnitKind(*args):
        """
        isUnitKind(string name, unsigned int level, unsigned int version) -> bool

        Predicate to test whether a given string is the name of a valid
        base unit in SBML (such as @c 'gram' or @c 'mole').

        This method exists because prior to SBML Level&nbsp;2 Version&nbsp;3,
        an enumeration called @c UnitKind was defined by SBML.  This enumeration
        was removed in SBML Level&nbsp;2 Version&nbsp;3 and its values were
        folded into the space of values of a type called @c UnitSId.  This method
        therefore has less significance in SBML Level&nbsp;2 Version&nbsp;3
        and Level&nbsp;2 Version&nbsp;4, but remains for backward
        compatibility and support for reading models in older Versions of
        Level&nbsp;2.

        @param name a string to be tested

        @param level a long integer representing the SBML specification
        Level 

        @param version a long integer representing the SBML specification
        Version

        @return @c True if name is a valid SBML UnitKind, @c False otherwise

        @note The allowed unit names differ between SBML Levels&nbsp;1
        and&nbsp;2 and again slightly between Level&nbsp;2 Versions&nbsp;1
        and&nbsp;2.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.Unit_isUnitKind(*args)

    if _newclass:isUnitKind = staticmethod(isUnitKind)
    __swig_getmethods__["isUnitKind"] = lambda x: isUnitKind
    def areIdentical(*args):
        """
        areIdentical(Unit unit1, Unit unit2) -> bool

        Predicate returning @c True if two
        Unit objects are identical.

        Two Unit objects are considered to be @em identical if they match in
        all attributes.  (Contrast this to the method areEquivalent(@if java
        Unit u1, %Unit u2@endif), which compares Unit objects only with respect
        to certain attributes.)

        @param unit1 the first Unit object to compare
        @param unit2 the second Unit object to compare

        @return @c True if all the attributes of unit1 are identical
        to the attributes of unit2, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike areEquivalent() @else Unit.areEquivalent() @endif@~

        """
        return _libsbml.Unit_areIdentical(*args)

    if _newclass:areIdentical = staticmethod(areIdentical)
    __swig_getmethods__["areIdentical"] = lambda x: areIdentical
    def areEquivalent(*args):
        """
        areEquivalent(Unit unit1, Unit unit2) -> bool

        Predicate returning @c True if 
        Unit objects are equivalent.

        Two Unit objects are considered to be @em equivalent either if (1) both
        have a 'kind' attribute value of @c dimensionless, or (2) their 'kind',
        'exponent' and (for SBML Level&nbsp;2 Version&nbsp;1) 'offset'
        attribute values are equal. (Contrast this to the method
        areIdentical(@if java Unit, %Unit@endif), which compares Unit objects with respect to all
        attributes, not just the 'kind' and 'exponent'.)

        @param unit1 the first Unit object to compare
        @param unit2 the second Unit object to compare

        @return @c True if the 'kind' and 'exponent' attributes of unit1 are
        identical to the kind and exponent attributes of unit2, @c False
        otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike areIdentical() @else Unit.areIdentical() @endif@~

        """
        return _libsbml.Unit_areEquivalent(*args)

    if _newclass:areEquivalent = staticmethod(areEquivalent)
    __swig_getmethods__["areEquivalent"] = lambda x: areEquivalent
    def removeScale(*args):
        """
        removeScale(Unit unit) -> int

        Manipulates the attributes of the Unit to express the unit with the 
        value of the scale attribute reduced to zero.

        For example, 1 millimetre can be expressed as a Unit with kind=@c
        'metre' multiplier=@c '1' scale=@c '-3' exponent=@c '1'. It can also be
        expressed as a Unit with kind=@c 'metre'
        multiplier=<code>'0.001'</code> scale=@c '0' exponent=@c '1'.

        @param unit the Unit object to manipulate.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike convertToSI() @else Unit.convertToSI() @endif@~
        @see @if clike merge() @else Unit.merge() @endif@~

        """
        return _libsbml.Unit_removeScale(*args)

    if _newclass:removeScale = staticmethod(removeScale)
    __swig_getmethods__["removeScale"] = lambda x: removeScale
    def merge(*args):
        """
        merge(Unit unit1, Unit unit2)

        Merges two Unit objects with the same 'kind' attribute value into a
        single Unit.

        For example, the following,
        @verbatim
         <unit kind='metre' exponent='2'/>
         <unit kind='metre' exponent='1'/>
         @endverbatim
        would be merged to become
        @verbatim
         <unit kind='metre' exponent='3'/>
         @endverbatim

        @param unit1 the first Unit object; the result of the operation is
        left as a new version of this unit, modified in-place.  Not modified if
        the two units have different kinds.

        @param unit2 the second Unit object to merge with the first

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike convertToSI() @else Unit.convertToSI() @endif@~
        @see @if clike removeScale() @else Unit.removeScale() @endif@~

        """
        return _libsbml.Unit_merge(*args)

    if _newclass:merge = staticmethod(merge)
    __swig_getmethods__["merge"] = lambda x: merge
    def convertToSI(*args):
        """
        convertToSI(Unit unit) -> UnitDefinition

        Returns a UnitDefinition object containing the given @p unit converted
        to the appropriate SI unit.

        This method exists because some units can be expressed in terms of
        others when the same physical dimension is involved.  For example, one
        hertz is identical to 1&nbsp;sec<sup>-1</sup>, one litre is equivalent
        to 1 cubic decametre, and so on.

        @param unit the Unit object to convert to SI

        @return a UnitDefinition object containing the SI unit.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike merge() @else Unit.merge() @endif@~

        """
        return _libsbml.Unit_convertToSI(*args)

    if _newclass:convertToSI = staticmethod(convertToSI)
    __swig_getmethods__["convertToSI"] = lambda x: convertToSI
    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this Unit object
        have been set.

        The required attributes for a Unit object are:
        @li 'kind'
        @li 'exponent' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)
        @li 'multiplier' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)
        @li 'scale' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Unit_hasRequiredAttributes(self)

Unit_swigregister = _libsbml.Unit_swigregister
Unit_swigregister(Unit)

def Unit_isBuiltIn(*args):
  """
    Unit_isBuiltIn(string name, unsigned int level) -> bool

    Predicate to test whether a given string is the name of a
    predefined SBML unit.

    @param name a string to be tested against the predefined unit names

    @param level the Level of SBML for which the determination should be
    made.  This is necessary because there are a few small differences
    in allowed units between SBML Level&nbsp;1 and Level&nbsp;2.

    @return @c True if @p name is one of the five SBML predefined unit
    identifiers (@c 'substance', @c 'volume', @c 'area', @c 'length' or @c
    'time'), @c False otherwise.

    @note The predefined unit identifiers @c 'length' and @c 'area' were
    added in Level&nbsp;2 Version&nbsp;1.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.Unit_isBuiltIn(*args)

def Unit_isUnitKind(*args):
  """
    Unit_isUnitKind(string name, unsigned int level, unsigned int version) -> bool

    Predicate to test whether a given string is the name of a valid
    base unit in SBML (such as @c 'gram' or @c 'mole').

    This method exists because prior to SBML Level&nbsp;2 Version&nbsp;3,
    an enumeration called @c UnitKind was defined by SBML.  This enumeration
    was removed in SBML Level&nbsp;2 Version&nbsp;3 and its values were
    folded into the space of values of a type called @c UnitSId.  This method
    therefore has less significance in SBML Level&nbsp;2 Version&nbsp;3
    and Level&nbsp;2 Version&nbsp;4, but remains for backward
    compatibility and support for reading models in older Versions of
    Level&nbsp;2.

    @param name a string to be tested

    @param level a long integer representing the SBML specification
    Level 

    @param version a long integer representing the SBML specification
    Version

    @return @c True if name is a valid SBML UnitKind, @c False otherwise

    @note The allowed unit names differ between SBML Levels&nbsp;1
    and&nbsp;2 and again slightly between Level&nbsp;2 Versions&nbsp;1
    and&nbsp;2.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.Unit_isUnitKind(*args)

def Unit_areIdentical(*args):
  """
    Unit_areIdentical(Unit unit1, Unit unit2) -> bool

    Predicate returning @c True if two
    Unit objects are identical.

    Two Unit objects are considered to be @em identical if they match in
    all attributes.  (Contrast this to the method areEquivalent(@if java
    Unit u1, %Unit u2@endif), which compares Unit objects only with respect
    to certain attributes.)

    @param unit1 the first Unit object to compare
    @param unit2 the second Unit object to compare

    @return @c True if all the attributes of unit1 are identical
    to the attributes of unit2, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike areEquivalent() @else Unit.areEquivalent() @endif@~

    """
  return _libsbml.Unit_areIdentical(*args)

def Unit_areEquivalent(*args):
  """
    Unit_areEquivalent(Unit unit1, Unit unit2) -> bool

    Predicate returning @c True if 
    Unit objects are equivalent.

    Two Unit objects are considered to be @em equivalent either if (1) both
    have a 'kind' attribute value of @c dimensionless, or (2) their 'kind',
    'exponent' and (for SBML Level&nbsp;2 Version&nbsp;1) 'offset'
    attribute values are equal. (Contrast this to the method
    areIdentical(@if java Unit, %Unit@endif), which compares Unit objects with respect to all
    attributes, not just the 'kind' and 'exponent'.)

    @param unit1 the first Unit object to compare
    @param unit2 the second Unit object to compare

    @return @c True if the 'kind' and 'exponent' attributes of unit1 are
    identical to the kind and exponent attributes of unit2, @c False
    otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike areIdentical() @else Unit.areIdentical() @endif@~

    """
  return _libsbml.Unit_areEquivalent(*args)

def Unit_removeScale(*args):
  """
    Unit_removeScale(Unit unit) -> int

    Manipulates the attributes of the Unit to express the unit with the 
    value of the scale attribute reduced to zero.

    For example, 1 millimetre can be expressed as a Unit with kind=@c
    'metre' multiplier=@c '1' scale=@c '-3' exponent=@c '1'. It can also be
    expressed as a Unit with kind=@c 'metre'
    multiplier=<code>'0.001'</code> scale=@c '0' exponent=@c '1'.

    @param unit the Unit object to manipulate.

    @return integer value indicating success/failure of the function.  The
    possible values returned by this function are:
    @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike convertToSI() @else Unit.convertToSI() @endif@~
    @see @if clike merge() @else Unit.merge() @endif@~

    """
  return _libsbml.Unit_removeScale(*args)

def Unit_merge(*args):
  """
    Unit_merge(Unit unit1, Unit unit2)

    Merges two Unit objects with the same 'kind' attribute value into a
    single Unit.

    For example, the following,
    @verbatim
     <unit kind='metre' exponent='2'/>
     <unit kind='metre' exponent='1'/>
     @endverbatim
    would be merged to become
    @verbatim
     <unit kind='metre' exponent='3'/>
     @endverbatim

    @param unit1 the first Unit object; the result of the operation is
    left as a new version of this unit, modified in-place.  Not modified if
    the two units have different kinds.

    @param unit2 the second Unit object to merge with the first

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike convertToSI() @else Unit.convertToSI() @endif@~
    @see @if clike removeScale() @else Unit.removeScale() @endif@~

    """
  return _libsbml.Unit_merge(*args)

def Unit_convertToSI(*args):
  """
    Unit_convertToSI(Unit unit) -> UnitDefinition

    Returns a UnitDefinition object containing the given @p unit converted
    to the appropriate SI unit.

    This method exists because some units can be expressed in terms of
    others when the same physical dimension is involved.  For example, one
    hertz is identical to 1&nbsp;sec<sup>-1</sup>, one litre is equivalent
    to 1 cubic decametre, and so on.

    @param unit the Unit object to convert to SI

    @return a UnitDefinition object containing the SI unit.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike merge() @else Unit.merge() @endif@~

    """
  return _libsbml.Unit_convertToSI(*args)

class ListOfUnits(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Unit objects.

    ListOfUnits is entirely contained within UnitDefinition.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfUnits, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfUnits, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfUnits
        __init__(self, SBMLNamespaces sbmlns) -> ListOfUnits

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfUnits(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfUnits object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfUnits object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfUnits(long level, long version)</pre>

        Creates a new ListOfUnits object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfUnits(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfUnits

        Creates and returns a deep copy of this ListOfUnits object.

        @return the (deep) copy of this ListOfUnits object.

        """
        return _libsbml.ListOfUnits_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Unit objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_UNIT SBML_UNIT@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfUnits_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfUnits, the XML element name is @c 'listOfUnits'.

        @return the name of this element, i.e., @c 'listOfUnits'.

        """
        return _libsbml.ListOfUnits_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Unit
        get(self, unsigned int n) -> Unit

        Get a Unit from the ListOfUnits.

        @param n the index number of the Unit to get.

        @return the nth Unit in this ListOfUnits.

        @see size()

        """
        return _libsbml.ListOfUnits_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Unit

        Removes the nth item from this ListOfUnits items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()

        """
        return _libsbml.ListOfUnits_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfUnits
    __del__ = lambda self : None;
ListOfUnits_swigregister = _libsbml.ListOfUnits_swigregister
ListOfUnits_swigregister(ListOfUnits)

class UnitDefinition(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A definition of a unit used in an SBML model.

    Units of measurement may be supplied in a number of contexts in an SBML
    model.  The SBML unit definition facility uses two classes of objects,
    UnitDefinition and Unit.  The approach to defining units in SBML is
    compositional; for example, <em>meter second<sup> &ndash;2</sup></em> is
    constructed by combining a Unit object representing <em>meter</em> with
    another Unit object representing <em>second<sup> &ndash;2</sup></em>.
    The combination is wrapped inside a UnitDefinition, which provides for
    assigning an identifier and optional name to the combination.  The
    identifier can then be referenced from elsewhere in a model.  Thus, the
    UnitDefinition class is the container, and Unit instances are placed
    inside UnitDefinition instances.

    Two points are worth discussing in the context of SBML units.  First,
    unit declarations in SBML models are @em optional.  The consequence of
    this is that a model must be numerically self-consistent independently
    of unit declarations, for the benefit of software tools that cannot
    interpret or manipulate units.  Unit declarations in SBML are thus more
    akin to a type of annotation; they can indicate intentions, and can be
    used by model readers for checking the consistency of the model,
    labeling simulation output, etc., but any transformations of values
    implied by different units must be incorporated @em explicitly into a
    model.

    Second, the vast majority of situations that require new SBML unit
    definitions involve simple multiplicative combinations of base units and
    factors.  An example is <em>moles per litre per second</em>.  What
    distinguishes these sorts of unit definitions from more complex ones is
    that they may be expressed without the use of an additive offset from a
    zero point.  The use of offsets complicates all unit definition systems,
    yet in the domain of SBML, the real-life cases requiring offsets are few
    (and in fact, to the best of our knowledge, only involve temperature).
    Consequently, the SBML unit system has been consciously designed to
    simplify implementation of unit support for the most common cases in
    systems biology.  The cost of this simplification is to require units
    with offsets to be handled explicitly by the modeler.

    @section unitdef-summary Summary of the UnitDefinition construct

    UnitDefinition has two attributes and one subelement.  The two
    attributes are 'id' and 'name', and the subelement is ListOfUnits.

    The required attribute 'id' and optional attribute 'name' are both
    strings.  The 'id' attribute is used to give the defined unit a unique
    identifier by which other parts of an SBML model definition can refer to
    it.  The 'name' attribute is intended to be used for giving the unit
    definition an optional human-readable name.  Please see the <a
    href='#unitdef-id'>next section</a> for information about the values
    permitted for 'id'.

    A UnitDefinition must contain exactly one ListOfUnits, and this list
    must contain one or more Unit definitions; see the definitions of these
    other object classes for more information about them.  The following
    example illustrates a complete unit definition (when written in XML)
    when they all the pieces are combined together.  This defines 'mmls'
    to be millimoles per litre per second.
    @verbatim
     <listOfUnitDefinitions>
         <unitDefinition id='mmls'>
             <listOfUnits>
                 <unit kind='mole'   scale='-3'/>
                 <unit kind='litre'  exponent='-1'/>
                 <unit kind='second' exponent='-1'/>
             </listOfUnits>
         </unitDefinition>
     </listOfUnitDefinitions>
     @endverbatim

    @section unitdef-id Special considerations for Unit object identifiers

    The attribute 'id' in UnitDefinition cannot be given simply any value,
    and the precise details of the values permitted differ slightly between
    Levels of SBML:
    <ul>

    <li> The 'id' of a UnitDefinition must @em not contain a value from the
    list of SBML's predefined base unit names (i.e., the strings @c gram, @c
    litre, etc.).  In SBML Level&nbsp;3, this list consists of the
    following:

    @par
    <table border='0' class='centered text-table width80 normal-font code'
           style='border: none !important'>
    <tr>
    <td>ampere</td><td>farad</td><td>joule</td><td>lux</td><td>radian</td><td>volt</td>
    </tr>
    <tr>
    <td>avogadro</td><td>gram</td><td>katal</td><td>metre</td><td>second</td><td>watt</td>
    </tr>
    <tr>
    <td>becquerel</td><td>gray</td><td>kelvin</td><td>mole</td><td>siemens</td><td>weber</td>
    </tr>
    <tr>
    <td>candela</td><td>henry</td><td>kilogram</td><td>newton</td><td>sievert</td>
    </tr>
    <tr>
    <td>coulomb</td><td>hertz</td><td>litre</td><td>ohm</td><td>steradian</td>
    </tr>
    <tr>
    <td>dimensionless</td><td>item</td><td>lumen</td><td>pascal</td><td>tesla</td>
    </tr>
    </table>

    This list of predefined base units is nearly identical in SBML
    Level&nbsp;2 Version&nbsp;4, the exception being that Level&nbsp;2 does
    not define @c avogadro.  SBML Level&nbsp;2 Version&nbsp;1 (and @em only
    this Level+Version combination) provides an additional predefined unit
    name, @c Celsius, not available in Level&nbsp;3.  Finally, SBML
    Level&nbsp;1 Versions&nbsp;2&ndash;3 provide two more additional
    predefined unit names, @c meter and @c liter.  This is explained in
    somewhat greater detail in the description of the Unit class.

    <ul>
    <li> In SBML Level&nbsp;2 (all Versions), there is an additional set of
    reserved identifiers: @c substance, @c volume, @c area, @c length, and
    @c time.  Using one of these values for the attribute 'id' of a
    UnitDefinition has the effect of redefining the model-wide default units
    for the corresponding quantities.  The list of special unit names in
    SBML Level&nbsp;2 is given in the table below:
    </ul>

    @htmlinclude predefined-units.html

    Also, SBML Level&nbsp;2 imposes two limitations on redefining the
    predefined unit @c substance, @c volume, @c area, @c length, and @c
    time: (1) The UnitDefinition of a predefined SBML unit can only contain
    a single Unit object within it.  (2) The value of the 'kind' attribute
    in a Unit instance must be drawn from one of the values in the second
    column of the table above.

    The special unit names @c substance, @c volume, @c area, @c length, and
    @c time are not defined by SBML Level&nbsp;3, which uses a different
    approach to setting model-wide inherited units.


    @section sbml-units-limits Further comments about SBML's unit definition system

    The vast majority of modeling situations requiring new SBML unit
    definitions involve simple multiplicative combinations of base units and
    factors.  An example of this might be <em>moles per litre per
    second</em>.  What distinguishes these sorts of simpler unit definitions
    from more complex ones is that they may be expressed without the use of
    an additive offset from a zero point.  The use of offsets complicates
    all unit definition systems, yet in the domain of SBML the real-life
    cases requiring offsets are few (and in fact, to the best of our
    knowledge, only involve temperature).  Consequently, the SBML unit
    system has been consciously designed in a way that attempts to simplify
    implementation of unit support for the most common cases in systems
    biology.

    As of SBML Level&nbsp;2 Version&nbsp;2, Unit no longer has the
    attribute called 'offset' introduced in SBML Level&nbsp;2
    Version&nbsp;1.  It turned out that the general case involving units
    with offsets was incorrectly defined, and few (if any) developers even
    attempted to support offset-based units in their software.  In the
    development of Level&nbsp;2 Version&nbsp;2, a consensus among SBML
    developers emerged that a fully generalized unit scheme is @em so
    confusing and complicated that it actually @em impedes interoperability.
    SBML Level&nbsp;2 Version&nbsp;2, Version&nbsp;3 and Version&nbsp;4 acknowledge this
    reality by reducing and simplifying the unit system, specifically by
    removing the 'offset' attribute on Unit and @c Celsius as a pre-defined
    unit.

    The following guidelines suggest methods for handling units that do
    require the use of zero offsets for their definitions:
    <ul>
    <li> <em>Handling Celsius</em>.  A model in which certain quantities are
    temperatures measured in degrees Celsius can be converted
    straightforwardly to a model in which those temperatures are in
    kelvin.  A software tool could do this by performing a straightforward
    substitution using the following relationship: <em>T<sub> kelvin</sub> =
    T<sub>Celsius</sub> + 273.15</em>.  In every mathematical formula of the
    model where a quantity (call it @em x) in degrees Celsius appears,
    replace @em x with <em>x<sub>k</sub>+ 273.15</em>, where
    <em>x<sub>k</sub></em> is now in kelvin.  An alternative approach would 
    be to use a FunctionDefinition object to define a function encapsulating this
    relationship above and then using that in the rest of the model as
    needed.  Since Celsius is a commonly-used unit, software tools could
    help users by providing users with the ability to express temperatures
    in Celsius in the tools' interfaces, and making substitutions
    automatically when writing out the SBML.

    <li> <em>Other units requiring offsets</em>.  One approach to handling
    other kinds of units is to use a FunctionDefinition to define a function
    encapsulating the necessary mathematical relationship, then
    substituting a call to this function wherever the original quantity
    appeared in the model.  For example, here is a possible definition for
    converting Fahrenheit to Celsius degrees:
    @verbatim
     <functionDefinition id='Fahrenheit_to_kelvin'>
         <math xmlns='http://www.w3.org/1998/Math/MathML'>
             <lambda>
                 <bvar><ci> temp_in_fahrenheit </ci></bvar>
                 <apply>
                     <divide/>
                     <apply>
                         <plus/>
                         <ci> temp_in_fahrenheit </ci>
                         <cn> 459.67 </cn>
                     </apply>
                     <cn> 1.8 </cn>
                 </apply>
             </lambda>
         </math>
     </functionDefinition>
     @endverbatim

    <li> An alternative approach not requiring the use of function definitions
    is to use an AssignmentRule for each variable in Fahrenheit units.
    The AssignmentRule could compute the conversion from Fahrenheit to
    (say) kelvin, assign its value to a variable (in Kelvin units), and
    then that variable could be used elsewhere in the model.

    <li> Still another approach is to rewrite the mathematical formulas of a
    model to directly incorporate the conversion formula wherever the
    original quantity appeared.
    </ul>

    Please consult the SBML specifications for more information about this
    and other issues involving units.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnitDefinition, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnitDefinition, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_UnitDefinition
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> UnitDefinition
        __init__(self, SBMLNamespaces sbmlns) -> UnitDefinition
        __init__(self, UnitDefinition orig) -> UnitDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>UnitDefinition(SBMLNamespaces sbmlns)</pre>

        Creates a new UnitDefinition using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>UnitDefinition(long level, long version)</pre>

        Creates a new UnitDefinition using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this UnitDefinition

        @param version a long integer, the SBML Version to assign to this
        UnitDefinition

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>UnitDefinition(UnitDefinition orig)</pre>

        Copy constructor; creates a copy of this UnitDefinition.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_UnitDefinition(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> UnitDefinition

        Creates and returns a deep copy of this UnitDefinition object.

        @return the (deep) copy of this UnitDefinition object.

        """
        return _libsbml.UnitDefinition_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        @param id string representing the id of objects to find.

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.UnitDefinition_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid, or
        @c None if no such object is found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        """
        return _libsbml.UnitDefinition_getElementByMetaId(self, *args)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this UnitDefinition.

        @return the id of this UnitDefinition.

        """
        return _libsbml.UnitDefinition_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this UnitDefinition.

        @return the name of this UnitDefinition.

        """
        return _libsbml.UnitDefinition_getName(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        UnitDefinition's 'id' attribute is set.

        @return @c True if the 'id' attribute of this UnitDefinition is
        set, @c False otherwise.

        """
        return _libsbml.UnitDefinition_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        UnitDefinition's 'name' attribute is set.

        @return @c True if the 'name' attribute of this UnitDefinition is
        set, @c False otherwise.

        """
        return _libsbml.UnitDefinition_isSetName(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this UnitDefinition.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this UnitDefinition

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.UnitDefinition_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this UnitDefinition.

        The string in @p name is copied.

        @param name the new name for the UnitDefinition

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.UnitDefinition_setName(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this UnitDefinition.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.UnitDefinition_unsetName(self)

    def isVariantOfArea(self):
        """
        isVariantOfArea(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'area'.

        @return @c True if this UnitDefinition is a variant of the predefined
        unit @c area, meaning square metres with only abritrary variations
        in scale or multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfArea(self)

    def isVariantOfLength(self):
        """
        isVariantOfLength(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'length'.

        @return @c True if this UnitDefinition is a variant of the predefined
        unit @c length, meaning metres with only abritrary variations in scale
        or multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfLength(self)

    def isVariantOfSubstance(self):
        """
        isVariantOfSubstance(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'substance'.

        @return @c True if this UnitDefinition is a variant of the predefined
        unit @c substance, meaning moles or items (and grams or kilograms from
        SBML Level&nbsp;2 Version&nbsp;2 onwards) with only abritrary variations
        in scale or multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfSubstance(self)

    def isVariantOfTime(self):
        """
        isVariantOfTime(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'time'.

        @return @c True if this UnitDefinition is a variant of the predefined
        unit @c time, meaning seconds with only abritrary variations in scale or
        multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfTime(self)

    def isVariantOfVolume(self):
        """
        isVariantOfVolume(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'volume'.

        @return @c True if this UnitDefinition is a variant of the predefined
        unit @c volume, meaning litre or cubic metre with only abritrary
        variations in scale or multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfVolume(self)

    def isVariantOfDimensionless(self):
        """
        isVariantOfDimensionless(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the unit @c 'dimensionless'.

        @return @c True if this UnitDefinition is a variant of @c
        dimensionless, meaning dimensionless with only abritrary variations in
        scale or multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfDimensionless(self)

    def isVariantOfMass(self):
        """
        isVariantOfMass(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit identifier @c 'mass'.

        @return @c True if this UnitDefinition is a variant of mass units,
        meaning gram or kilogram with only abritrary variations in scale or
        multiplier values; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfMass(self)

    def isVariantOfSubstancePerTime(self):
        """
        isVariantOfSubstancePerTime(self) -> bool

        Convenience function for testing if a given unit definition is a
        variant of the predefined unit @c 'substance' divided by the predefined
        unit @c 'time'.

        @return @c True if this UnitDefinition is a variant of the predefined
        unit @c substance per predefined unit @c time, meaning it contains two
        units one of which is a variant of substance and the other is a
        variant of time which an exponent of -1; @c False otherwise.

        """
        return _libsbml.UnitDefinition_isVariantOfSubstancePerTime(self)

    def addUnit(self, *args):
        """
        addUnit(self, Unit u) -> int

        Adds a copy of the given Unit to this UnitDefinition.

        @param u the Unit instance to add to this UnitDefinition.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createUnit()

        """
        return _libsbml.UnitDefinition_addUnit(self, *args)

    def createUnit(self):
        """
        createUnit(self) -> Unit

        Creates a new and empty Unit, adds it to this UnitDefinition's list of
        units, and returns it.

        @return a newly constructed (and empty) Unit instance.

        @note It is worth emphasizing that the attribute 'kind' value of a
        Unit is a required attribute for a valid Unit definition.  The
        createUnit() method does not assign a valid kind to the constructed
        unit (instead, it sets the 'kind' to @link libsbml#UNIT_KIND_INVALID UNIT_KIND_INVALID@endlink).
        Callers are cautioned to set the newly-constructed Unit's kind using
        Unit.setKind() soon after calling this method.

        @see addUnit()

        """
        return _libsbml.UnitDefinition_createUnit(self)

    def getListOfUnits(self, *args):
        """
        getListOfUnits(self) -> ListOfUnits
        getListOfUnits(self) -> ListOfUnits

        Returns the list of Units for this UnitDefinition instance.
        @return the ListOfUnits value for this UnitDefinition.

        """
        return _libsbml.UnitDefinition_getListOfUnits(self, *args)

    def getUnit(self, *args):
        """
        getUnit(self, unsigned int n) -> Unit
        getUnit(self, unsigned int n) -> Unit

        Returns a specific Unit instance belonging to this UnitDefinition.

        @param n an integer, the index of the Unit to be returned.

        @return the nth Unit of this UnitDefinition.

        @see getNumUnits()

        """
        return _libsbml.UnitDefinition_getUnit(self, *args)

    def getNumUnits(self):
        """
        getNumUnits(self) -> unsigned int

        Returns the number of Unit objects contained within this
        UnitDefinition.

        @return an integer representing the number of Units in this
        UnitDefinition.

        """
        return _libsbml.UnitDefinition_getNumUnits(self)

    def removeUnit(self, *args):
        """
        removeUnit(self, unsigned int n) -> Unit

        Removes the nth Unit object from this UnitDefinition object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Unit object to remove

        @return the Unit object removed, or @c None if the given index 
        is out of range.

        """
        return _libsbml.UnitDefinition_removeUnit(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor and assignment operator.

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.UnitDefinition_connectToChild(self)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.UnitDefinition_enablePackageInternal(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_UNIT_DEFINITION SBML_UNIT_DEFINITION@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getPackageName()
        @see getElementName()

        """
        return _libsbml.UnitDefinition_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for UnitDefinition,
        is always @c 'unitDefinition'.

        @return the name of this element, i.e., @c 'unitDefinition'.

        """
        return _libsbml.UnitDefinition_getElementName(self)

    def simplify(*args):
        """
        simplify(UnitDefinition ud)

        Simplifies the UnitDefinition such that any given kind of Unit object
        occurs only once in the ListOfUnits.

        For example, the following definition,
        @verbatim
         <unitDefinition>
          <listOfUnits>
            <unit kind='metre' exponent='1'/>
            <unit kind='metre' exponent='2'/>
          </listOfUnits>
         <unitDefinition>
         @endverbatim
        will be simplified to 
        @verbatim
         <unitDefinition>
           <listOfUnits>
             <unit kind='metre' exponent='3'/>
           </listOfUnits>
         <unitDefinition>
         @endverbatim

        @param ud the UnitDefinition object to be simplified.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.UnitDefinition_simplify(*args)

    if _newclass:simplify = staticmethod(simplify)
    __swig_getmethods__["simplify"] = lambda x: simplify
    def reorder(*args):
        """
        reorder(UnitDefinition ud)

        Alphabetically orders the Unit objects within the ListOfUnits of a
        UnitDefinition.

        @param ud the UnitDefinition object whose units are to be reordered.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.UnitDefinition_reorder(*args)

    if _newclass:reorder = staticmethod(reorder)
    __swig_getmethods__["reorder"] = lambda x: reorder
    def convertToSI(*args):
        """
        convertToSI(UnitDefinition ud) -> UnitDefinition

        Convert a given UnitDefinition into a new UnitDefinition object
        that uses SI units.

        @param ud the UnitDefinition object to convert to SI

        @return a new UnitDefinition object representing the results of the
        conversion.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.UnitDefinition_convertToSI(*args)

    if _newclass:convertToSI = staticmethod(convertToSI)
    __swig_getmethods__["convertToSI"] = lambda x: convertToSI
    def areIdentical(*args):
        """
        areIdentical(UnitDefinition ud1, UnitDefinition ud2) -> bool

        Predicate returning @c True if two
        UnitDefinition objects are identical.

        For the purposes of performing this comparison, two UnitDefinition
        objects are considered identical when they contain identical lists of
        Unit objects.  Pairs of Unit objects in the lists are in turn
        considered identical if they satisfy the predicate
        Unit.areIdentical().
        The predicate compares every attribute of the
        Unit objects.

        @param ud1 the first UnitDefinition object to compare
        @param ud2 the second UnitDefinition object to compare

        @return @c True if all the Unit objects in ud1 are identical to the
        Unit objects of ud2, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see UnitDefinition.areEquivalent()
        @see Unit.areIdentical()

        """
        return _libsbml.UnitDefinition_areIdentical(*args)

    if _newclass:areIdentical = staticmethod(areIdentical)
    __swig_getmethods__["areIdentical"] = lambda x: areIdentical
    def areEquivalent(*args):
        """
        areEquivalent(UnitDefinition ud1, UnitDefinition ud2) -> bool

        Predicate returning @c True if two
        UnitDefinition objects are equivalent.

        For the purposes of performing this comparison, two UnitDefinition
        objects are considered equivalent when they contain @em equivalent
        list of Unit objects.  Unit objects are in turn considered equivalent
        if they satisfy the predicate
        Unit.areEquivalent().
        The predicate tests a subset of the objects's attributes.

        @param ud1 the first UnitDefinition object to compare

        @param ud2 the second UnitDefinition object to compare

        @return @c True if all the Unit objects in ud1 are equivalent
        to the Unit objects in ud2, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see UnitDefinition.areIdentical()
        @see Unit.areEquivalent()

        """
        return _libsbml.UnitDefinition_areEquivalent(*args)

    if _newclass:areEquivalent = staticmethod(areEquivalent)
    __swig_getmethods__["areEquivalent"] = lambda x: areEquivalent
    def combine(*args):
        """
        combine(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition

        Combines two UnitDefinition objects into a single UnitDefinition.

        This takes UnitDefinition objects @p ud1 and @p ud2, and creates a
        UnitDefinition object that expresses the product of the units of @p
        ud1 and @p ud2.

        @param ud1 the first UnitDefinition object 
        @param ud2 the second UnitDefinition object

        @return a UnitDefinition which represents the product of the 
        units of the two argument UnitDefinitions.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.UnitDefinition_combine(*args)

    if _newclass:combine = staticmethod(combine)
    __swig_getmethods__["combine"] = lambda x: combine
    def divide(*args):
        """
        divide(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition

        Combines two UnitDefinition objects into a single UnitDefinition as
        a division.

        This takes UnitDefinition objects @p ud1 and @p ud2, and creates a
        UnitDefinition object that expresses the division of the units of @p
        ud1 and @p ud2.

        @param ud1 the first UnitDefinition object 
        @param ud2 the second UnitDefinition object

        @return a UnitDefinition which represents the division of the 
        units of the two argument UnitDefinitions.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.UnitDefinition_divide(*args)

    if _newclass:divide = staticmethod(divide)
    __swig_getmethods__["divide"] = lambda x: divide
    def printUnits(*args):
        """
        printUnits(UnitDefinition ud, bool compact = False) -> string
        printUnits(UnitDefinition ud) -> string

        Expresses the given definition in a plain-text form.

        For example,
        UnitDefinition.printUnits()
        applied to
        @verbatim
         <unitDefinition>
          <listOfUnits>
            <unit kind='metre' exponent='1'/>
            <unit kind='second' exponent='-2'/>
          </listOfUnits>
         <unitDefinition>
         @endverbatim
        will return the string <code>'metre (exponent = 1, multiplier = 1,
        scale = 0) second (exponent = -2, multiplier = 1, scale = 0)'</code>
        or, if the optional parameter @p compact is given the value @c True,
        the string <code>'(1 metre)^1 (1 second)^-2'</code>.  This method may
        be useful for printing unit information to human users, or in
        debugging software, or other situations.

        @param ud the UnitDefinition object
        @param compact boolean indicating whether the compact form
        should be used (defaults to false)

        @return a string expressing the unit definition defined by the given
        UnitDefinition object @p ud.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.UnitDefinition_printUnits(*args)

    if _newclass:printUnits = staticmethod(printUnits)
    __swig_getmethods__["printUnits"] = lambda x: printUnits
    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this UnitDefinition object
        have been set.

        The required attributes for a UnitDefinition object are:
        @li 'id'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.UnitDefinition_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for this UnitDefinition object
        have been set.

        @note The required elements for a Constraint object are:
        @li 'listOfUnits' (required in SBML Level&nbsp;2 only, optional in Level&nbsp;3)

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.UnitDefinition_hasRequiredElements(self)

UnitDefinition_swigregister = _libsbml.UnitDefinition_swigregister
UnitDefinition_swigregister(UnitDefinition)

def UnitDefinition_simplify(*args):
  """
    UnitDefinition_simplify(UnitDefinition ud)

    Simplifies the UnitDefinition such that any given kind of Unit object
    occurs only once in the ListOfUnits.

    For example, the following definition,
    @verbatim
     <unitDefinition>
      <listOfUnits>
        <unit kind='metre' exponent='1'/>
        <unit kind='metre' exponent='2'/>
      </listOfUnits>
     <unitDefinition>
     @endverbatim
    will be simplified to 
    @verbatim
     <unitDefinition>
       <listOfUnits>
         <unit kind='metre' exponent='3'/>
       </listOfUnits>
     <unitDefinition>
     @endverbatim

    @param ud the UnitDefinition object to be simplified.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.UnitDefinition_simplify(*args)

def UnitDefinition_reorder(*args):
  """
    UnitDefinition_reorder(UnitDefinition ud)

    Alphabetically orders the Unit objects within the ListOfUnits of a
    UnitDefinition.

    @param ud the UnitDefinition object whose units are to be reordered.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.UnitDefinition_reorder(*args)

def UnitDefinition_convertToSI(*args):
  """
    UnitDefinition_convertToSI(UnitDefinition ud) -> UnitDefinition

    Convert a given UnitDefinition into a new UnitDefinition object
    that uses SI units.

    @param ud the UnitDefinition object to convert to SI

    @return a new UnitDefinition object representing the results of the
    conversion.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.UnitDefinition_convertToSI(*args)

def UnitDefinition_areIdentical(*args):
  """
    UnitDefinition_areIdentical(UnitDefinition ud1, UnitDefinition ud2) -> bool

    Predicate returning @c True if two
    UnitDefinition objects are identical.

    For the purposes of performing this comparison, two UnitDefinition
    objects are considered identical when they contain identical lists of
    Unit objects.  Pairs of Unit objects in the lists are in turn
    considered identical if they satisfy the predicate
    Unit.areIdentical().
    The predicate compares every attribute of the
    Unit objects.

    @param ud1 the first UnitDefinition object to compare
    @param ud2 the second UnitDefinition object to compare

    @return @c True if all the Unit objects in ud1 are identical to the
    Unit objects of ud2, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see UnitDefinition.areEquivalent()
    @see Unit.areIdentical()

    """
  return _libsbml.UnitDefinition_areIdentical(*args)

def UnitDefinition_areEquivalent(*args):
  """
    UnitDefinition_areEquivalent(UnitDefinition ud1, UnitDefinition ud2) -> bool

    Predicate returning @c True if two
    UnitDefinition objects are equivalent.

    For the purposes of performing this comparison, two UnitDefinition
    objects are considered equivalent when they contain @em equivalent
    list of Unit objects.  Unit objects are in turn considered equivalent
    if they satisfy the predicate
    Unit.areEquivalent().
    The predicate tests a subset of the objects's attributes.

    @param ud1 the first UnitDefinition object to compare

    @param ud2 the second UnitDefinition object to compare

    @return @c True if all the Unit objects in ud1 are equivalent
    to the Unit objects in ud2, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see UnitDefinition.areIdentical()
    @see Unit.areEquivalent()

    """
  return _libsbml.UnitDefinition_areEquivalent(*args)

def UnitDefinition_combine(*args):
  """
    UnitDefinition_combine(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition

    Combines two UnitDefinition objects into a single UnitDefinition.

    This takes UnitDefinition objects @p ud1 and @p ud2, and creates a
    UnitDefinition object that expresses the product of the units of @p
    ud1 and @p ud2.

    @param ud1 the first UnitDefinition object 
    @param ud2 the second UnitDefinition object

    @return a UnitDefinition which represents the product of the 
    units of the two argument UnitDefinitions.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.UnitDefinition_combine(*args)

def UnitDefinition_divide(*args):
  """
    UnitDefinition_divide(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition

    Combines two UnitDefinition objects into a single UnitDefinition as
    a division.

    This takes UnitDefinition objects @p ud1 and @p ud2, and creates a
    UnitDefinition object that expresses the division of the units of @p
    ud1 and @p ud2.

    @param ud1 the first UnitDefinition object 
    @param ud2 the second UnitDefinition object

    @return a UnitDefinition which represents the division of the 
    units of the two argument UnitDefinitions.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.UnitDefinition_divide(*args)

def UnitDefinition_printUnits(*args):
  """
    printUnits(UnitDefinition ud, bool compact = False) -> string
    UnitDefinition_printUnits(UnitDefinition ud) -> string

    Expresses the given definition in a plain-text form.

    For example,
    UnitDefinition.printUnits()
    applied to
    @verbatim
     <unitDefinition>
      <listOfUnits>
        <unit kind='metre' exponent='1'/>
        <unit kind='second' exponent='-2'/>
      </listOfUnits>
     <unitDefinition>
     @endverbatim
    will return the string <code>'metre (exponent = 1, multiplier = 1,
    scale = 0) second (exponent = -2, multiplier = 1, scale = 0)'</code>
    or, if the optional parameter @p compact is given the value @c True,
    the string <code>'(1 metre)^1 (1 second)^-2'</code>.  This method may
    be useful for printing unit information to human users, or in
    debugging software, or other situations.

    @param ud the UnitDefinition object
    @param compact boolean indicating whether the compact form
    should be used (defaults to false)

    @return a string expressing the unit definition defined by the given
    UnitDefinition object @p ud.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.UnitDefinition_printUnits(*args)

class ListOfUnitDefinitions(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of UnitDefinition objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfUnitDefinitions, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfUnitDefinitions, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfUnitDefinitions
        __init__(self, SBMLNamespaces sbmlns) -> ListOfUnitDefinitions

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfUnitDefinitions(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfUnitDefinitions object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfUnitDefinitions object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfUnitDefinitions(long level, long version)</pre>

        Creates a new ListOfUnitDefinitions object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfUnitDefinitions(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfUnitDefinitions

        Creates and returns a deep copy of this ListOfUnitDefinitions object.

        @return the (deep) copy of this ListOfUnitDefinitions object.

        """
        return _libsbml.ListOfUnitDefinitions_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., UnitDefinition objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_UNIT_DEFINITION SBML_UNIT_DEFINITION@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfUnitDefinitions_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfUnitDefinitions, the XML element name is @c
        'listOfUnitDefinitions'.

        @return the name of this element, i.e., @c 'listOfUnitDefinitions'.

        """
        return _libsbml.ListOfUnitDefinitions_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> UnitDefinition
        get(self, unsigned int n) -> UnitDefinition
        get(self, string sid) -> UnitDefinition
        get(self, string sid) -> UnitDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a UnitDefinition from the ListOfUnitDefinitions.

        @param n the index number of the UnitDefinition to get.

        @return the nth UnitDefinition in this ListOfUnitDefinitions.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a UnitDefinition from the ListOfUnitDefinitions
        based on its identifier.

        @param sid a string representing the identifier 
        of the UnitDefinition to get.

        @return UnitDefinition in this ListOfUnitDefinitions
        with the given @p sid or @c None if no such
        UnitDefinition exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfUnitDefinitions_get(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        Note that UnitDefinitions themselves are in the UnitId namespace, not
        the SId namespace, so no UnitDefinition object will be returned from
        this function (and is the reason we override the base
        ListOf::getElementBySId function here).

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.ListOfUnitDefinitions_getElementBySId(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> UnitDefinition
        remove(self, string sid) -> UnitDefinition

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfUnitDefinitions items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfUnitDefinitions items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfUnitDefinitions_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfUnitDefinitions
    __del__ = lambda self : None;
ListOfUnitDefinitions_swigregister = _libsbml.ListOfUnitDefinitions_swigregister
ListOfUnitDefinitions_swigregister(ListOfUnitDefinitions)

class CompartmentType(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A <em>compartment type</em> in SBML Level&nbsp;2.

    SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 provide the <em>compartment
    type</em> as a grouping construct that can be used to establish a
    relationship between multiple Compartment objects.  A CompartmentType
    object only has an identity, and this identity can only be used to
    indicate that particular Compartment objects in the model belong to this
    type.  This may be useful for conveying a modeling intention, such as
    when a model contains many similar compartments, either by their
    biological function or the reactions they carry.  Without a compartment
    type construct, it would be impossible within SBML itself to indicate
    that all of the compartments share an underlying conceptual relationship
    because each SBML compartment must be given a unique and separate
    identity.  Compartment types have no mathematical meaning in
    SBML---they have no effect on a model's mathematical interpretation.
    Simulators and other numerical analysis software may ignore
    CompartmentType definitions and references to them in a model.

    There is no mechanism in SBML Level 2 for representing hierarchies of
    compartment types.  One CompartmentType instance cannot be the subtype
    of another CompartmentType instance; SBML provides no means of defining
    such relationships.

    As with other major structures in SBML, CompartmentType has a mandatory
    attribute, 'id', used to give the compartment type an identifier.  The
    identifier must be a text %string conforming to the identifer syntax
    permitted in SBML.  CompartmentType also has an optional 'name'
    attribute, of type @c string.  The 'id' and 'name' must be used
    according to the guidelines described in the SBML specification (e.g.,
    Section 3.3 in the Level 2 Version 4 specification).

    CompartmentType was introduced in SBML Level 2 Version 2.  It is not
    available in SBML Level&nbsp;1 nor in Level&nbsp;3.

    @see Compartment
    @see ListOfCompartmentTypes
    @see SpeciesType
    @see ListOfSpeciesTypes

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompartmentType, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CompartmentType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_CompartmentType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> CompartmentType
        __init__(self, SBMLNamespaces sbmlns) -> CompartmentType
        __init__(self, CompartmentType orig) -> CompartmentType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>CompartmentType(SBMLNamespaces sbmlns)</pre>

        Creates a new CompartmentType object using the given SBMLNamespaces
        object @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        It is worth emphasizing that although this constructor does not take an
        identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'
        (identifier) attribute of a CompartmentType object is required to have a
        value.  Thus, callers are cautioned to assign a value after calling this
        constructor.  Setting the identifier can be accomplished using the
        method setId(@if java String@endif).

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>CompartmentType(long level, long version)</pre>

        Creates a new CompartmentType object using the given SBML @p level and
        @p version values.

        @param level a long integer, the SBML Level to assign to this
        CompartmentType

        @param version a long integer, the SBML Version to assign to this
        CompartmentType

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>CompartmentType(CompartmentType orig)</pre>

        Copy constructor; creates a copy of this CompartmentType object.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_CompartmentType(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> CompartmentType

        Creates and returns a deep copy of this CompartmentType object.

        @return the (deep) copy of this CompartmentType object.

        """
        return _libsbml.CompartmentType_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this CompartmentType object.

        @return the identifier of this CompartmentType object.

        @see getName()
        @see setId()
        @see unsetId()
        @see isSetId()

        """
        return _libsbml.CompartmentType_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this CompartmentType
        object.

        @return the name of this CompartmentType object.

        @see getId()
        @see isSetName()
        @see setName()
        @see unsetName()

        """
        return _libsbml.CompartmentType_getName(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this CompartmentType object's 'id'
        attribute is set.

        @return @c True if the 'id' attribute of this CompartmentType object is
        set, @c False otherwise.

        @see getId()
        @see unsetId()
        @see setId()

        """
        return _libsbml.CompartmentType_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this CompartmentType object's 'name'
        attribute is set.

        @return @c True if the 'name' attribute of this CompartmentType object
        is set, @c False otherwise.

        @see getName()
        @see setName()
        @see unsetName()

        """
        return _libsbml.CompartmentType_isSetName(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this CompartmentType object.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this CompartmentType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @see getId()
        @see unsetId()
        @see isSetId()

        """
        return _libsbml.CompartmentType_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this CompartmentType object.

        The string in @p name is copied.

        @param name the new name for the CompartmentType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @see getName()
        @see isSetName()
        @see unsetName()

        """
        return _libsbml.CompartmentType_setName(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this CompartmentType object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getName()
        @see setName()
        @see isSetName()

        """
        return _libsbml.CompartmentType_unsetName(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_COMPARTMENT_TYPE SBML_COMPARTMENT_TYPE@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.CompartmentType_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object

        For CompartmentType, the element name is always @c 'compartmentType'.

        @return the name of this element.

        @see getTypeCode()
        @see getPackageName()

        """
        return _libsbml.CompartmentType_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        CompartmentType object have been set.

        The required attributes for a CompartmentType object are:
        @li 'id'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.CompartmentType_hasRequiredAttributes(self)

CompartmentType_swigregister = _libsbml.CompartmentType_swigregister
CompartmentType_swigregister(CompartmentType)

class ListOfCompartmentTypes(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of CompartmentType objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfCompartmentTypes, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfCompartmentTypes, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfCompartmentTypes
        __init__(self, SBMLNamespaces sbmlns) -> ListOfCompartmentTypes

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfCompartmentTypes(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfCompartmentTypes object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfCompartmentTypes object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfCompartmentTypes(long level, long version)</pre>

        Creates a new ListOfCompartmentTypes object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfCompartmentTypes(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfCompartmentTypes

        Creates and returns a deep copy of this ListOfCompartmentTypes object.

        @return the (deep) copy of this ListOfCompartmentTypes object.

        """
        return _libsbml.ListOfCompartmentTypes_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., CompartmentType objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf
        instance: @link libsbml#SBML_COMPARTMENT_TYPE SBML_COMPARTMENT_TYPE@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfCompartmentTypes_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfCompartmentTypes, the XML element name is @c
        'listOfCompartmentTypes'.

        @return the name of this element, i.e., @c 'listOfCompartmentTypes'.

        """
        return _libsbml.ListOfCompartmentTypes_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> CompartmentType
        get(self, unsigned int n) -> CompartmentType
        get(self, string sid) -> CompartmentType
        get(self, string sid) -> CompartmentType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a CompartmentType object from the ListOfCompartmentTypes.

        @param n the index number of the CompartmentType object to get.

        @return the nth CompartmentType object in this ListOfCompartmentTypes.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a CompartmentType object from the ListOfCompartmentTypes
        based on its identifier.

        @param sid a string representing the identifier
        of the CompartmentType object to get.

        @return CompartmentType object in this ListOfCompartmentTypes
        with the given @p sid or @c None if no such
        CompartmentType object exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfCompartmentTypes_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> CompartmentType
        remove(self, string sid) -> CompartmentType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfCompartmentTypes items
        and returns a pointer to it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfCompartmentTypes items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfCompartmentTypes_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfCompartmentTypes
    __del__ = lambda self : None;
ListOfCompartmentTypes_swigregister = _libsbml.ListOfCompartmentTypes_swigregister
ListOfCompartmentTypes_swigregister(ListOfCompartmentTypes)

class SpeciesType(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A <em>species type</em> in SBML Level 2.

    The term @em species @em type refers to reacting entities independent of
    location.  These include simple ions (e.g., protons, calcium), simple
    molecules (e.g., glucose, ATP), large molecules (e.g., RNA,
    polysaccharides, and proteins), and others.

    SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 provide an explicit
    SpeciesType class of object to enable Species objects of the same type
    to be related together.  SpeciesType is a conceptual construct; the
    existence of SpeciesType objects in a model has no effect on the model's
    numerical interpretation.  Except for the requirement for uniqueness of
    species/species type combinations located in compartments, simulators
    and other numerical analysis software may ignore SpeciesType definitions
    and references to them in a model.

    There is no mechanism in SBML Level 2 for representing hierarchies of
    species types.  One SpeciesType object cannot be the subtype of another
    SpeciesType object; SBML provides no means of defining such
    relationships.

    As with other major structures in SBML, SpeciesType has a mandatory
    attribute, 'id', used to give the species type an identifier.  The
    identifier must be a text string conforming to the identifer syntax
    permitted in SBML.  SpeciesType also has an optional 'name' attribute,
    of type @c string.  The 'id' and 'name' must be used according to the
    guidelines described in the SBML specification (e.g., Section 3.3 in
    the Level&nbsp;2 Version&nbsp;4 specification).

    SpeciesType was introduced in SBML Level 2 Version 2.  It is not
    available in SBML Level&nbsp;1 nor in Level&nbsp;3.

    @see Species
    @see ListOfSpeciesTypes
    @see CompartmentType
    @see ListOfCompartmentTypes

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeciesType, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeciesType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SpeciesType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> SpeciesType
        __init__(self, SBMLNamespaces sbmlns) -> SpeciesType
        __init__(self, SpeciesType orig) -> SpeciesType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SpeciesType(SBMLNamespaces sbmlns)</pre>

        Creates a new SpeciesType using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        It is worth emphasizing that although this constructor does not take
        an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'
        (identifier) attribute of a SpeciesType object is required to have a value.
        Thus, callers are cautioned to assign a value after calling this
        constructor.  Setting the identifier can be accomplished using the
        method SBase.setId().

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SpeciesType(long level, long version)</pre>

        Creates a new SpeciesType using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this SpeciesType

        @param version a long integer, the SBML Version to assign to this
        SpeciesType

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SpeciesType(SpeciesType orig)</pre>

        Copy constructor; creates a copy of this SpeciesType.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_SpeciesType(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SpeciesType

        Creates and returns a deep copy of this SpeciesType object.

        @return the (deep) copy of this SpeciesType object.

        """
        return _libsbml.SpeciesType_clone(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this SpeciesType.

        @return the id of this SpeciesType.

        """
        return _libsbml.SpeciesType_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this SpeciesType.

        @return the name of this SpeciesType.

        """
        return _libsbml.SpeciesType_getName(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        SpeciesType's 'id' attribute is set.

        @return @c True if the 'id' attribute of this SpeciesType is
        set, @c False otherwise.

        """
        return _libsbml.SpeciesType_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        SpeciesType's 'name' attribute is set.

        @return @c True if the 'name' attribute of this SpeciesType is
        set, @c False otherwise.

        """
        return _libsbml.SpeciesType_isSetName(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this SpeciesType.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this SpeciesType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.SpeciesType_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this SpeciesType.

        The string in @p name is copied.

        @param name the new name for the SpeciesType

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.SpeciesType_setName(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this SpeciesType.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SpeciesType_unsetName(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_SPECIES_TYPE SBML_SPECIES_TYPE@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.SpeciesType_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        SpeciesType, is always @c 'compartmentType'.

        @return the name of this element, i.e., @c 'compartmentType'.

        """
        return _libsbml.SpeciesType_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this SpeciesType object
        have been set.

        The required attributes for a SpeciesType object are:
        @li 'id'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.SpeciesType_hasRequiredAttributes(self)

SpeciesType_swigregister = _libsbml.SpeciesType_swigregister
SpeciesType_swigregister(SpeciesType)

class ListOfSpeciesTypes(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of SpeciesType objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfSpeciesTypes, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfSpeciesTypes, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfSpeciesTypes
        __init__(self, SBMLNamespaces sbmlns) -> ListOfSpeciesTypes

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfSpeciesTypes(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfSpeciesTypes object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfSpeciesTypes object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfSpeciesTypes(long level, long version)</pre>

        Creates a new ListOfSpeciesTypes object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfSpeciesTypes(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfSpeciesTypes

        Creates and returns a deep copy of this ListOfSpeciesTypes object.

        @return the (deep) copy of this ListOfSpeciesTypes object.

        """
        return _libsbml.ListOfSpeciesTypes_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., SpeciesType objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_SPECIES_TYPE SBML_SPECIES_TYPE@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfSpeciesTypes_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfSpeciesTypes, the XML element name is @c
        'listOfSpeciesTypes'.

        @return the name of this element, i.e., @c 'listOfSpeciesTypes'.

        """
        return _libsbml.ListOfSpeciesTypes_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> SpeciesType
        get(self, unsigned int n) -> SpeciesType
        get(self, string sid) -> SpeciesType
        get(self, string sid) -> SpeciesType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a SpeciesType from the ListOfSpeciesTypes.

        @param n the index number of the SpeciesType to get.

        @return the nth SpeciesType in this ListOfSpeciesTypes.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a SpeciesType from the ListOfSpeciesTypes
        based on its identifier.

        @param sid a string representing the identifier 
        of the SpeciesType to get.

        @return SpeciesType in this ListOfSpeciesTypes
        with the given @p sid or @c None if no such
        SpeciesType exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfSpeciesTypes_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> SpeciesType
        remove(self, string sid) -> SpeciesType

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfSpeciesTypes items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfSpeciesTypes items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfSpeciesTypes_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfSpeciesTypes
    __del__ = lambda self : None;
ListOfSpeciesTypes_swigregister = _libsbml.ListOfSpeciesTypes_swigregister
ListOfSpeciesTypes_swigregister(ListOfSpeciesTypes)

class Compartment(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML compartment, where species are located.

    A compartment in SBML represents a bounded space in which species are
    located.  Compartments do not necessarily have to correspond to actual
    structures inside or outside of a biological cell.

    It is important to note that although compartments are optional in the
    overall definition of Model, every species in an SBML model must be
    located in a compartment.  This in turn means that if a model defines
    any species, the model must also define at least one compartment.  The
    reason is simply that species represent physical things, and therefore
    must exist @em somewhere.  Compartments represent the @em somewhere.

    Compartment has one required attribute, 'id', to give the compartment a
    unique identifier by which other parts of an SBML model definition can
    refer to it.  A compartment can also have an optional 'name' attribute
    of type @c string.  Identifiers and names must be used according to the
    guidelines described in the SBML specifications.

    Compartment also has an optional attribute 'spatialDimensions' that is
    used to indicate the number of spatial dimensions possessed by the
    compartment.  Most modeling scenarios involve compartments with integer
    values of 'spatialDimensions' of @c 3 (i.e., a three-dimensional
    compartment, which is to say, a volume), or 2 (a two-dimensional
    compartment, a surface), or @c 1 (a one-dimensional compartment, a
    line).  In SBML Level&nbsp;3, the type of this attribute is @c float,
    there are no restrictions on the permitted values of the
    'spatialDimensions' attribute, and there are no default values.  In SBML
    Level&nbsp;2, the value must be a positive @c integer, and the default
    value is @c 3; the permissible values in SBML Level&nbsp;2 are @c 3, @c
    2, @c 1, and @c 0 (for a point).

    Another optional attribute on Compartment is 'size', representing the @em
    initial total size of that compartment in the model.  The 'size' attribute
    must be a floating-point value and may represent a volume (if the
    compartment is a three-dimensional one), or an area (if the compartment is
    two-dimensional), or a length (if the compartment is one-dimensional).
    There is no default value of compartment size in SBML Level&nbsp;2 or
    Level&nbsp;3.  In particular, a missing 'size' value <em>does not imply
    that the compartment size is 1</em>.  (This is unlike the definition of
    compartment 'volume' in SBML Level&nbsp;1.)  When the compartment's
    'spatialDimensions' attribute does not have a value of @c 0, a missing
    value of 'size' for a given compartment signifies that the value either is
    unknown, or to be obtained from an external source, or determined by an
    InitialAssignment, AssignmentRule, AlgebraicRule or RateRule
    @if conly structure @else object@endif@~ elsewhere in the model.  In SBML
    Level&nbsp;2, there are additional special requirements on the values of
    'size'; we discuss them in a <a href='#comp-l2'>separate section
    below</a>.

    The units associated with a compartment's 'size' attribute value may be
    set using the optional attribute 'units'.  The rules for setting and
    using compartment size units differ between SBML Level&nbsp;2 and
    Level&nbsp;3, and are discussed separately below.

    Finally, the optional Compartment attribute named 'constant' is used to
    indicate whether the compartment's size stays constant after simulation
    begins.  A value of @c True indicates the compartment's 'size' cannot be
    changed by any other construct except InitialAssignment; a value of @c False indicates the compartment's 'size' can be changed by other
    constructs in SBML.  In SBML Level&nbsp;2, there is an additional
    explicit restriction that if 'spatialDimensions'=@c '0', the value
    cannot be changed by InitialAssignment either.  Further, in
    Level&nbsp;2, 'constant' has a default value of @c True.  In SBML
    Level&nbsp;3, there is no default value for the 'constant' attribute.


    @section comp-l2 Additional considerations in SBML Level&nbsp;2

    In SBML Level&nbsp;2, the default units of compartment size, and the kinds
    of units allowed as values of the attribute 'units', interact with the
    number of spatial dimensions of the compartment.  The value of the 'units'
    attribute of a Compartment @if conly structure @else object@endif@~ must
    be one of the base units (see Unit), or the predefined unit identifiers @c
    volume, @c area, @c length or @c dimensionless, or a new unit defined by a
    UnitDefinition @if conly structure @else object@endif@~ in the enclosing
    Model, subject to the restrictions detailed in the following table:

    <table border='0' class='centered text-table width80 normal-font alt-row-colors'
    style='padding-bottom: 0.5em'>
    <caption class='top-caption'>Restrictions on values permitted for
    compartment <code>size</code> and <code>units</code> attributes.</caption>
    <tr>
    <th align='left' valign='bottom'>
    Value of<br><code>spatialDimensions</code>
    </th>
    <th align='left' valign='bottom'>
    <code>size</code><br>allowed?
    </th>
    <th align='left' valign='bottom'>
    <code>units</code><br>allowed?
    </th>
    <th align='left' valign='bottom'>
    Allowable kinds of units
    </th>
    <th align='left' valign='bottom'>
    Default value of attribute <code>units</code>
    </th>
    </tr>
    <tr>
    <td><code>3</code></td>
    <td>yes</td>
    <td>yes</td>
    <td>units of volume, or <code>dimensionless</code></td>
    <td><code>volume</code></td>
    </tr>
    <tr>
    <td><code>2</code></td>
    <td>yes</td>
    <td>yes</td>
    <td>units of area, or <code>dimensionless</code></td>
    <td><code>area</code></td>
    </tr>
    <tr>
    <td><code>1</code></td>
    <td>yes</td>
    <td>yes</td>
    <td>units of length, or <code>dimensionless</code></td>
    <td><code>length</code></td>
    </tr>
    <tr>
    <td><code>0</code></td>
    <td>no</td>
    <td>no</td>
    <td>(no units allowed)</td>
    <td></td>
    </tr>
    </tr>
    </table>

    In SBML Level&nbsp;2, the units of the compartment size, as defined by the
    'units' attribute or (if 'units' is not set) the default value listed in
    the table above, are used in the following ways when the compartment has
    a 'spatialDimensions' value greater than @c 0:
    <ul>
    <li> The value of the 'units' attribute is used as the units of the
    compartment identifier when the identifier appears as a numerical
    quantity in a mathematical formula expressed in MathML.

    <li> The @c math element of an AssignmentRule or InitialAssignment
    referring to this compartment must have identical units.

    <li> In RateRule objects that set the rate of change of the compartment's
    size, the units of the rule's @c math element must be identical to the
    compartment's 'units' attribute divided by the default @em time units.
    (In other words, the units for the rate of change of compartment size
    are <em>compartment size</em>/<em>time</em> units.

    <li> When a Species is to be treated in terms of concentrations or
    density, the units of the spatial size portion of the concentration
    value (i.e., the denominator in the units formula @em substance/@em
    size) are those indicated by the value of the 'units' attribute on the
    compartment in which the species is located.
    </ul>

    Compartments with 'spatialDimensions'=@c 0 require special treatment in
    this framework.  As implied above, the 'size' attribute must not have a
    value on an SBML Level&nbsp;2 Compartment
    @if conly structure @else object@endif@~ if the 'spatialDimensions'
    attribute has a value of @c 0.  An additional related restriction is that
    the 'constant' attribute must default to or be set to @c True if the value
    of the 'spatialDimensions' attribute is @c 0, because a zero-dimensional
    compartment cannot ever have a size.

    If a compartment has no size or dimensional units, how should such a
    compartment's identifier be interpreted when it appears in mathematical
    formulas?  The answer is that such a compartment's identifier should not
    appear in mathematical formulas in the first place---it has no
    value, and its value cannot change.  Note also that a zero-dimensional
    compartment is a point, and species located at points can only be
    described in terms of amounts, not spatially-dependent measures such as
    concentration.  Since SBML KineticLaw formulas are already in terms of
    @em substance/@em time and not (say) @em concentration/@em time, volume
    or other factors in principle are not needed for species located in
    zero-dimensional compartments.

    Finally, in SBML Level&nbsp;2 Versions 2&ndash;4, each compartment in a
    model may optionally be designated as belonging to a particular
    compartment @em type.  The optional attribute 'compartmentType' is used
    identify the compartment type represented by the Compartment structure.
    The 'compartmentType' attribute's value must be the identifier of a
    CompartmentType instance defined in the model.  If the 'compartmentType'
    attribute is not present on a particular compartment definition, a
    unique virtual compartment type is assumed for that compartment, and no
    other compartment can belong to that compartment type.  The values of
    'compartmentType' attributes on compartments have no effect on the
    numerical interpretation of a model.  Simulators and other numerical
    analysis software may ignore 'compartmentType' attributes.  The
    'compartmentType' attribute and the CompartmentType
    @if conly structures @else class of objects@endif@~ are
    not present in SBML Level&nbsp;3 Core nor in SBML Level&nbsp;1.


    @section comp-l3 Additional considerations in SBML Level&nbsp;3

    One difference between SBML Level&nbsp;3 and lower Levels of SBML is
    that there are no restrictions on the permissible values of the
    'spatialDimensions' attribute, and there is no default value defined for
    the attribute.  The value of 'spatialDimensions' does not have to be an
    integer, either; this is to allow for the possibility of representing
    structures with fractal dimensions.

    The number of spatial dimensions possessed by a compartment cannot enter
    into mathematical formulas, and therefore cannot directly alter the
    numerical interpretation of a model.  However, the value of
    'spatialDimensions' @em does affect the interpretation of the units
    associated with a compartment's size.  Specifically, the value of
    'spatialDimensions' is used to select among the Model attributes
    'volumeUnits', 'areaUnits' and 'lengthUnits' when a Compartment
    @if conly object @else structure@endif@~ does not define a value for its
    'units' attribute.

    The 'units' attribute may be left unspecified for a given compartment in a
    model; in that case, the compartment inherits the unit of measurement
    specified by one of the attributes on the enclosing Model
    @if conly structure @else object@endif@~ instance.  The applicable
    attribute on Model depends on the value of the compartment's
    'spatialDimensions' attribute; the relationship is shown in the table
    below.  If the Model @if conly structure @else object@endif@~ does not
    define the relevant attribute ('volumeUnits', 'areaUnits' or
    'lengthUnits') for a given 'spatialDimensions' value, the unit associated
    with that Compartment @if conly structure @else object@endif's size is
    undefined.  If @em both 'spatialDimensions' and 'units' are left unset on
    a given Compartment @if conly structure @else object@endif@~ instance,
    then no unit can be chosen from among the Model's 'volumeUnits',
    'areaUnits' or 'lengthUnits' attributes (even if the Model instance
    provides values for those attributes), because there is no basis to select
    between them and there is no default value of 'spatialDimensions'.
    Leaving the units of compartments' sizes undefined in an SBML model does
    not render the model invalid; however, as a matter of best practice, we
    strongly recommend that all models specify the units of measurement for
    all compartment sizes.

    <table border='0' class='centered text-table width80 normal-font alt-row-colors'
    style='padding-bottom: 0.5em'>
    <caption class='top-caption'>Interpretation of the Compartment 'units' attribute.</caption>
    <tr>
    <th align='left' valign='bottom'>
    Value of attribute<br>'spatialDimensions'
    </th>
    <th align='left' valign='bottom'>
    Attribute of Model used<br>for inheriting the unit
    </th>
    <th align='left' valign='bottom'>
    Recommended candidate units
    </th>
    </tr>
    <tr>
    <td><code>3</code></td>
    <td>&quot;volumeUnits&quot;</td>
    <td>units of volume, or <code>dimensionless</code></td>
    </tr>
    <tr>
    <td><code>2</code></td>
    <td>&quot;areaUnits&quot;</td>
    <td>units of area, or <code>dimensionless</code></td>
    </tr>
    <tr>
    <td><code>1</code></td>
    <td>&quot;lengthUnits&quot;</td>
    <td>units of length, or <code>dimensionless</code></td>
    </tr>
    <tr>
    <td><em>other</em></td>
    <td><em>no units inherited</em></td>
    <td><em>no specific recommendations</em></td>
    </tr>
    </tr>
    </table>

    The unit of measurement associated with a compartment's size, as defined
    by the 'units' attribute or (if 'units' is not set) the inherited value
    from Model according to the table above, is used in the following ways:

    <ul>

    <li> When the identifier of the compartment appears as a numerical
    quantity in a mathematical formula expressed in MathML, it represents
    the size of the compartment, and the unit associated with the size is
    the value of the 'units' attribute.

    <li> When a Species is to be treated in terms of concentrations or
    density, the unit associated with the spatial size portion of the
    concentration value (i.e., the denominator in the formula
    <em>amount</em>/<em>size</em>) is specified by the value of the 'units'
    attribute on the compartment in which the species is located.

    <li> The 'math' elements of AssignmentRule, InitialAssignment and
    EventAssignment @if conly structures @else objects@endif@~ setting the
    value of the compartment size should all have the same units as the unit
    associated with the compartment's size.

    <li> In a RateRule @if conly structure @else object@endif@~ that defines a
    rate of change for a compartment's size, the unit of the rule's 'math'
    element should be identical to the compartment's 'units' attribute divided
    by the model-wide unit of <em>time</em>.  (In other words, {<em>unit of
    compartment size</em>}/{<em>unit of time</em>}.)

    </ul>


    @section comp-other Other aspects of Compartment

    In SBML Level&nbsp;1 and Level&nbsp;2, Compartment has an optional
    attribute named 'outside', whose value can be the identifier of another
    Compartment @if conly structure @else object@endif@~ defined in the
    enclosing Model @if conly structure @else object@endif@~.  Doing so means
    that the other compartment contains it or is outside of it.  This enables
    the representation of simple topological relationships between
    compartments, for those simulation systems that can make use of the
    information (e.g., for drawing simple diagrams of compartments).  It is
    worth noting that in SBML, there is no relationship between compartment
    sizes when compartment positioning is expressed using the 'outside'
    attribute.  The size of a given compartment does not in any sense include
    the sizes of other compartments having it as the value of their 'outside'
    attributes.  In other words, if a compartment @em B has the identifier of
    compartment @em A as its 'outside' attribute value, the size of @em A does
    not include the size of @em B.  The compartment sizes are separate.

    In Level&nbsp;2, there are two restrictions on the 'outside' attribute.
    First, because a compartment with 'spatialDimensions' of @c 0 has no
    size, such a compartment cannot act as the container of any other
    compartment @em except compartments that @em also have
    'spatialDimensions' values of @c 0.  Second, the directed graph formed
    by representing Compartment structures as vertexes and the 'outside'
    attribute values as edges must be acyclic.  The latter condition is
    imposed to prevent a compartment from being contained inside itself.  In
    the absence of a value for 'outside', compartment definitions in SBML
    Level&nbsp;2 do not have any implied spatial relationships between each
    other.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Compartment, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Compartment, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Compartment
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Compartment
        __init__(self, SBMLNamespaces sbmlns) -> Compartment
        __init__(self, Compartment orig) -> Compartment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Compartment(SBMLNamespaces sbmlns)</pre>

        Creates a new Compartment object using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        It is worth emphasizing that although this constructor does not take an
        identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'
        (identifier) attribute of a Compartment object is required to have a
        value.  Thus, callers are cautioned to assign a value after calling this
        constructor.  Setting the identifier can be accomplished using the
        method @if java Compartment.setId()@else setId()@endif.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Compartment(long level, long version)</pre>

        Creates a new Compartment object using the given SBML @p level and @p
        version values.

        @param level a long integer, the SBML Level to assign to this Compartment

        @param version a long integer, the SBML Version to assign to this
        Compartment

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Compartment(Compartment orig)</pre>

        Copy constructor; creates a copy of a Compartment.

        @param orig the Compartment instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Compartment(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Compartment

        Creates and returns a deep copy of this Compartment object.

        @return the (deep) copy of this Compartment object.

        """
        return _libsbml.Compartment_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Compartment object to 'typical' default
        values.

        The SBML Compartment component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:

        @li Sets attribute 'spatialDimensions' to @c 3
        @li Sets attribute 'constant' to @c True
        @li (Applies to Level&nbsp;1 models only) Sets attribute 'volume' to @c 1.0
        @li (Applies to Level&nbsp;3 models only) Sets attribute 'units' to @c litre

        """
        return _libsbml.Compartment_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Compartment object.

        @return the identifier of this Compartment object.

        @see getName()
        @see setId()
        @see unsetId()
        @see isSetId()

        """
        return _libsbml.Compartment_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Compartment object.

        @return the name of this Compartment object.

        @see getId()
        @see isSetName()
        @see setName()
        @see unsetName()

        """
        return _libsbml.Compartment_getName(self)

    def getCompartmentType(self):
        """
        getCompartmentType(self) -> string

        Get the value of the 'compartmentType' attribute of this Compartment
        object.

        @return the value of the 'compartmentType' attribute of this
        Compartment object as a string.

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        @see isSetCompartmentType()
        @see setCompartmentType()
        @see unsetCompartmentType()

        """
        return _libsbml.Compartment_getCompartmentType(self)

    def getSpatialDimensions(self):
        """
        getSpatialDimensions(self) -> unsigned int

        Get the number of spatial dimensions of this Compartment object.

        @return the value of the 'spatialDimensions' attribute of this
        Compartment object as a long integereger

        @note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'
        attribute is @c float, whereas in Level&nbsp;2, it is @c integer.  To
        avoid backward compatibility issues, libSBML provides two separate methods
        for obtaining the value as either an integer or a type @c float, for
        models where it is relevant.

        @see getSpatialDimensionsAsDouble()
        @see setSpatialDimensions()
        @see isSetSpatialDimensions()
        @see unsetSpatialDimensions()

        """
        return _libsbml.Compartment_getSpatialDimensions(self)

    def getSpatialDimensionsAsDouble(self):
        """
        getSpatialDimensionsAsDouble(self) -> double

        Get the number of spatial dimensions of this Compartment object,
        as a double.

        @return the value of the 'spatialDimensions' attribute of this
        Compartment object as a double, or @c NaN if this model is not in SBML
        Level&nbsp;3 format.

        @note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'
        attribute is @c float, whereas in Level&nbsp;2, it is @c integer.  To
        avoid backward compatibility issues, libSBML provides two separate methods
        for obtaining the value as either an integer or a type @c float, for
        models where it is relevant.

        @see getSpatialDimensions()
        @see setSpatialDimensions()
        @see isSetSpatialDimensions()
        @see unsetSpatialDimensions()

        """
        return _libsbml.Compartment_getSpatialDimensionsAsDouble(self)

    def getSize(self):
        """
        getSize(self) -> double

        Get the size of this Compartment object.

        @par
        In SBML Level&nbsp;1, compartments are always three-dimensional
        constructs and only have volumes, whereas in SBML Level&nbsp;2 and higher,
        compartments may be other than three-dimensional, and therefore the
        'volume' attribute is named 'size' in Level&nbsp;2 and above.  LibSBML
        provides both @if conly Compartment_getSize() and Compartment_getVolume()
        @else Compartment.getSize() and Compartment.getVolume()@endif@~
        for easier support of different SBML Levels.

        @return the value of the 'size' attribute ('volume' in Level&nbsp;1) of
        this Compartment object as a floating-point number.

        @note This method is identical to
        @if java Compartment.getVolume()@else getVolume()@endif.

        @see getVolume()
        @see isSetSize()
        @see setSize()
        @see unsetSize()

        """
        return _libsbml.Compartment_getSize(self)

    def getVolume(self):
        """
        getVolume(self) -> double

        Get the volume of this Compartment object.

        @par
        In SBML Level&nbsp;1, compartments are always three-dimensional
        constructs and only have volumes, whereas in SBML Level&nbsp;2 and higher,
        compartments may be other than three-dimensional, and therefore the
        'volume' attribute is named 'size' in Level&nbsp;2 and above.  LibSBML
        provides both @if conly Compartment_getSize() and Compartment_getVolume()
        @else Compartment.getSize() and Compartment.getVolume()@endif@~
        for easier support of different SBML Levels.

        @return the value of the 'volume' attribute ('size' in Level&nbsp;2) of
        this Compartment object, as a floating-point number.

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a default
        value (@c 1.0) and therefore methods such as
        @if conly Compartment_isSetVolume() @else Compartment.isSetVolume()@endif@~
        will always return @c True for a Level&nbsp;1 model.  In Level&nbsp;2, a
        compartment's size (the equivalent of SBML Level&nbsp;1's 'volume') is
        optional and has no default value, and therefore may or may not be set.

        @note This method is identical to
        @if java Compartment.getSize()@else getSize()@endif.

        @see getSize()
        @see isSetVolume()
        @see setVolume()
        @see unsetVolume()

        """
        return _libsbml.Compartment_getVolume(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Get the units of this Compartment object's size.

        The value of an SBML compartment's 'units' attribute establishes the
        unit of measurement associated with the compartment's size.

        @return the value of the 'units' attribute of this Compartment object,
        as a string.  An empty string indicates that no units have been assigned
        to the value of the size.

        @note There is an important distinction to be made between <em>no units
        assigned</em>, and assuming a value without units has any specific unit
        such as <code>dimensionless</code>.  In SBML, default units are never
        attributed to numbers, and numbers without units are not automatically
        assumed to have the unit <code>dimensionless</code>.  Please consult the
        relevant SBML specification document for a more in-depth explanation of
        this topic and the SBML unit system.

        @see isSetUnits()
        @see setUnits()
        @see unsetUnits()

        """
        return _libsbml.Compartment_getUnits(self)

    def getOutside(self):
        """
        getOutside(self) -> string

        Get the identifier, if any, of the Compartment object that is designated
        as being outside of @em this one.

        @return the value of the 'outside' attribute of this Compartment object.

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.

        @see isSetOutside()
        @see setOutside()
        @see unsetOutside()

        """
        return _libsbml.Compartment_getOutside(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Get the value of the 'constant' attribute of this Compartment object.

        @return @c True if this Compartment object's size is flagged as being
        constant, @c False otherwise.

        @see isSetConstant()
        @see setConstant()

        """
        return _libsbml.Compartment_getConstant(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this Compartment object's 'id' attribute
        is set.

        @return @c True if the 'id' attribute of this Compartment object is
        set, @c False otherwise.

        @see getId()
        @see unsetId()
        @see setId()

        """
        return _libsbml.Compartment_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this Compartment object's 'name'
        attribute is set.

        @return @c True if the 'name' attribute of this Compartment object is
        set, @c False otherwise.

        @see getName()
        @see setName()
        @see unsetName()

        """
        return _libsbml.Compartment_isSetName(self)

    def isSetCompartmentType(self):
        """
        isSetCompartmentType(self) -> bool

        Predicate returning @c True if this Compartment object's
        'compartmentType' attribute is set.

        @return @c True if the 'compartmentType' attribute of this Compartment
        is set, @c False otherwise.

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        @see setCompartmentType()
        @see getCompartmentType()
        @see unsetCompartmentType()

        """
        return _libsbml.Compartment_isSetCompartmentType(self)

    def isSetSize(self):
        """
        isSetSize(self) -> bool

        Predicate returning @c True if this Compartment object's 'size'
        attribute is set.

        This method is similar but not identical to
        @if java Compartment.isSetVolume()@else isSetVolume()@endif.  The latter
        should be used in the context of SBML Level&nbsp;1 models instead of
        @if java Compartment.isSetSize()@else isSetSize()@endif@~
        because @if java Compartment.isSetVolume()@else isSetVolume()@endif@~
        performs extra processing to take into account the difference in
        default values between SBML Levels&nbsp;1 and&nbsp;2.

        @return @c True if the 'size' attribute ('volume' in Level&nbsp;2) of
        this Compartment object is set, @c False otherwise.

        @see isSetVolume()
        @see setSize()
        @see getSize()
        @see unsetSize()

        """
        return _libsbml.Compartment_isSetSize(self)

    def isSetVolume(self):
        """
        isSetVolume(self) -> bool

        Predicate returning @c True if this Compartment object's 'volume'
        attribute is set.

        This method is similar but not identical to
        @if java Compartment.isSetSize()@else isSetSize()@endif.  The latter
        should not be used in the context of SBML Level&nbsp;1 models because the
        present method performs extra processing to take into account
        the difference in default values between SBML Levels&nbsp;1 and&nbsp;2.

        @return @c True if the 'volume' attribute ('size' in Level&nbsp;2 and
        above) of this Compartment object is set, @c False otherwise.

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a default
        value (@c 1.0) and therefore methods such as
        @if conly Compartment_isSetVolume() @else Compartment.isSetVolume()@endif@~
        will always return @c True for a Level&nbsp;1 model.  In Level&nbsp;2, a
        compartment's size (the equivalent of SBML Level&nbsp;1's 'volume') is
        optional and has no default value, and therefore may or may not be set.

        @see isSetSize()
        @see getVolume()
        @see setVolume()
        @see unsetVolume()

        """
        return _libsbml.Compartment_isSetVolume(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c True if this Compartment object's 'units'
        attribute is set.

        @return @c True if the 'units' attribute of this Compartment object is
        set, @c False otherwise.

        @note There is an important distinction to be made between <em>no units
        assigned</em>, and assuming a value without units has any specific unit
        such as <code>dimensionless</code>.  In SBML, default units are never
        attributed to numbers, and numbers without units are not automatically
        assumed to have the unit <code>dimensionless</code>.  Please consult the
        relevant SBML specification document for a more in-depth explanation of
        this topic and the SBML unit system.

        @see setUnits()
        @see getUnits()
        @see unsetUnits()

        """
        return _libsbml.Compartment_isSetUnits(self)

    def isSetOutside(self):
        """
        isSetOutside(self) -> bool

        Predicate returning @c True if this Compartment object's 'outside'
        attribute is set.

        @return @c True if the 'outside' attribute of this Compartment object is
        set, @c False otherwise.

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.

        @see getOutside()
        @see setOutside()
        @see unsetOutside()

        """
        return _libsbml.Compartment_isSetOutside(self)

    def isSetSpatialDimensions(self):
        """
        isSetSpatialDimensions(self) -> bool

        Predicate returning @c True if this Compartment object's
        'spatialDimensions' attribute is set.

        @return @c True if the 'spatialDimensions' attribute of this
        Compartment object is set, @c False otherwise.

        @see getSpatialDimensions()
        @see setSpatialDimensions()
        @see unsetSpatialDimensions()

        """
        return _libsbml.Compartment_isSetSpatialDimensions(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c True if this Compartment object's 'constant'
        attribute is set.

        @return @c True if the 'constant' attribute of this Compartment object is
        set, @c False otherwise.

        @see getConstant()
        @see setConstant()

        """
        return _libsbml.Compartment_isSetConstant(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Compartment object.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this Compartment object. If
        the string is @c None, this method will return
        @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @see getId()
        @see unsetId()
        @see isSetId()

        """
        return _libsbml.Compartment_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Compartment object.

        The string in @p name is copied.

        @param name the new name for the Compartment object. If the string is @c
        None, this method will return
        @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @see getName()
        @see isSetName()
        @see unsetName()

        """
        return _libsbml.Compartment_setName(self, *args)

    def setCompartmentType(self, *args):
        """
        setCompartmentType(self, string sid) -> int

        Sets the 'compartmentType' attribute of this Compartment object.

        @param sid the identifier of a CompartmentType object defined elsewhere
        in this Model. If the string is @c None, this method will return
        @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        @see isSetCompartmentType()
        @see getCompartmentType()
        @see unsetCompartmentType()

        """
        return _libsbml.Compartment_setCompartmentType(self, *args)

    def setSpatialDimensions(self, *args):
        """
        setSpatialDimensions(self, unsigned int value) -> int
        setSpatialDimensions(self, double value) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setSpatialDimensions(double value)</pre>

        Sets the 'spatialDimensions' attribute of this Compartment object as a double.

        @param value a double indicating the number of dimensions
        of this compartment.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @see getSpatialDimensions()
        @see isSetSpatialDimensions()
        @see unsetSpatialDimensions()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setSpatialDimensions(long value)</pre>

        Sets the 'spatialDimensions' attribute of this Compartment object.

        @param value a long integereger indicating the number of dimensions
        of this compartment.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @see getSpatialDimensions()
        @see isSetSpatialDimensions()
        @see unsetSpatialDimensions()

        """
        return _libsbml.Compartment_setSpatialDimensions(self, *args)

    def setSize(self, *args):
        """
        setSize(self, double value) -> int

        Sets the 'size' attribute (or 'volume' in SBML Level&nbsp;1) of this
        Compartment object.

        @param value a @c float representing the size of this compartment
        instance in whatever units are in effect for the compartment.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @note This method is identical to
        @if java Compartment.setVolume()@else setVolume()@endif.

        @see setVolume()
        @see getSize()
        @see isSetSize()
        @see unsetSize()

        """
        return _libsbml.Compartment_setSize(self, *args)

    def setVolume(self, *args):
        """
        setVolume(self, double value) -> int

        Sets the 'volume' attribute (or 'size' in SBML Level&nbsp;2) of this
        Compartment object.

        This method is identical to
        @if java Compartment.setSize()@else setSize()@endif@~
        and is provided for compatibility between SBML Level&nbsp;1 and
        higher Levels of SBML.

        @param value a @c float representing the volume of this compartment
        instance in whatever units are in effect for the compartment.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a default
        value (@c 1.0) and therefore methods such as
        @if conly Compartment_isSetVolume() @else Compartment.isSetVolume()@endif@~
        will always return @c True for a Level&nbsp;1 model.  In Level&nbsp;2, a
        compartment's size (the equivalent of SBML Level&nbsp;1's 'volume') is
        optional and has no default value, and therefore may or may not be set.

        @see setSize()
        @see getVolume()
        @see isSetVolume()
        @see unsetVolume()

        """
        return _libsbml.Compartment_setVolume(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string sid) -> int

        Sets the 'units' attribute of this Compartment object.

        @param sid the identifier of the defined units to use.  If @p sid is @c
        None, then this method will return
        @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @see isSetUnits()
        @see getUnits()
        @see unsetUnits()

        """
        return _libsbml.Compartment_setUnits(self, *args)

    def setOutside(self, *args):
        """
        setOutside(self, string sid) -> int

        Sets the 'outside' attribute of this Compartment object.

        @param sid the identifier of a compartment that encloses this one. If @p
        sid is @c None, then this method will return
        @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.

        @see isSetOutside()
        @see getOutside()
        @see unsetOutside()

        """
        return _libsbml.Compartment_setOutside(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool value) -> int

        Sets the value of the 'constant' attribute of this Compartment object.

        @param value a boolean indicating whether the size/volume of this
        compartment should be considered constant (@c True) or variable
        (@c False).

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @see isSetConstant()
        @see getConstant()

        """
        return _libsbml.Compartment_setConstant(self, *args)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Compartment_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Compartment_renameUnitSIdRefs(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Compartment object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getName()
        @see setName()
        @see isSetName()

        """
        return _libsbml.Compartment_unsetName(self)

    def unsetCompartmentType(self):
        """
        unsetCompartmentType(self) -> int

        Unsets the value of the 'compartmentType' attribute of this Compartment object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The 'compartmentType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        @see setCompartmentType()
        @see isSetCompartmentType()
        @see getCompartmentType()

        """
        return _libsbml.Compartment_unsetCompartmentType(self)

    def unsetSize(self):
        """
        unsetSize(self) -> int

        Unsets the value of the 'size' attribute of this Compartment object.

        In SBML Level&nbsp;1, a compartment's volume has a default value (@c
        1.0) and therefore <em>should always be set</em>.  Calling this method
        on a Level&nbsp;1 model resets the value to @c 1.0 rather than actually
        unsetting it.  In Level&nbsp;2, a compartment's 'size' is optional with
        no default value, and unsetting it will result in the compartment having
        no defined size.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method is identical to
        @if java Compartment.unsetVolume()@else unsetVolume()@endif.

        @see unsetVolume()
        @see getSize()
        @see isSetSize()
        @see setSize()

        """
        return _libsbml.Compartment_unsetSize(self)

    def unsetVolume(self):
        """
        unsetVolume(self) -> int

        Unsets the value of the 'volume' attribute of this Compartment object.

        This method is identical to
        @if java Compartment.unsetSize()@else unsetSize()@endif.  Please refer
        to that method's documentation for more information about its behavior.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The attribute 'volume' only exists by that name in SBML
        Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is
        named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a default
        value (@c 1.0) and therefore methods such as
        @if conly Compartment_isSetVolume() @else Compartment.isSetVolume()@endif@~
        will always return @c True for a Level&nbsp;1 model.  In Level&nbsp;2, a
        compartment's size (the equivalent of SBML Level&nbsp;1's 'volume') is
        optional and has no default value, and therefore may or may not be set.

        @see unsetSize()
        @see getVolume()
        @see setVolume()
        @see isSetVolume()

        """
        return _libsbml.Compartment_unsetVolume(self)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the value of the 'units' attribute of this Compartment object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see isSetUnits()
        @see setUnits()
        @see getUnits()

        """
        return _libsbml.Compartment_unsetUnits(self)

    def unsetOutside(self):
        """
        unsetOutside(self) -> int

        Unsets the value of the 'outside' attribute of this Compartment object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'outside' attribute is defined in SBML Level&nbsp;1 and
        Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1
        Core.

        @see isSetOutside()
        @see getOutside()
        @see setOutside()

        """
        return _libsbml.Compartment_unsetOutside(self)

    def unsetSpatialDimensions(self):
        """
        unsetSpatialDimensions(self) -> int

        Unsets the value of the 'spatialDimensions' attribute of this
        Compartment object.

        In SBML Levels prior to Level&nbsp;3, compartments must always have a
        value for the number of dimensions.  Consequently, calling this method
        on a model of SBML Level 1&ndash;2 will result in a return value of
        @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note This function is only valid for SBML Level&nbsp;3.

        @see getSpatialDimensions()
        @see isSetSpatialDimensions()
        @see setSpatialDimensions()

        """
        return _libsbml.Compartment_unsetSpatialDimensions(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this Compartment object's designated size.

        @par
        Compartments in SBML have an attribute ('units') for declaring the
        units of measurement intended for the value of the compartment's size.  In
        the absence of a value given for this attribute, the units are inherited
        from values either defined on the enclosing Model (in SBML Level&nbsp;3)
        or in defaults (in SBML Level&nbsp;2).  This method returns a
        @if conly UnitDefinition_t structure @else UnitDefinition object@endif@~
        based on how this compartment's units are interpreted according to the
        relevant SBML guidelines, or it returns @c None if no units have been
        declared and no defaults are defined by the relevant SBML specification.

        Note that unit declarations for
        @if conly Compartment_t structures @else Compartment objects @endif@~
        are specified in terms of the @em identifier of a unit,
        but @em this method returns @if conly a structure @else an object @endif,
        not a unit identifier.  It does this by constructing an appropriate
        @if conly UnitDefinition_t structure @else UnitDefinition object@endif.  For
        SBML Level&nbsp;2 models, it will do this even when the value of the
        'units' attribute is one of the special SBML Level&nbsp;2 unit identifiers
        @c 'substance', @c 'volume', @c 'area', @c 'length' or @c 'time'.  Callers
        may find this useful in conjunction with the helper methods provided by
        the @if conly UnitDefinition_t structure @else UnitDefinition
        class@endif@~ for comparing different UnitDefinition objects.

        @return a UnitDefinition that expresses the units of this
        Compartment object, or @c None if one cannot be constructed.

        @note The libSBML system for unit analysis depends on the model as a
        whole.  In cases where the
        @if conly Compartment_t structure @else Compartment object@endif@~ has not
        yet been added to a model, or the model itself is incomplete, unit
        analysis is not possible, and consequently this method will return @c
        None.

        @see isSetUnits()
        @see getUnits()

        """
        return _libsbml.Compartment_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_COMPARTMENT SBML_COMPARTMENT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Compartment_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object

        For Compartment, the XML element name is always @c 'compartment'.

        @return the name of this element.

        """
        return _libsbml.Compartment_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        Compartment object have been set.

        The required attributes for a Compartment object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'constant' (in SBML Level&nbsp;3 only)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Compartment_hasRequiredAttributes(self)

Compartment_swigregister = _libsbml.Compartment_swigregister
Compartment_swigregister(Compartment)

class ListOfCompartments(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Compartment objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfCompartments, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfCompartments, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfCompartments
        __init__(self, SBMLNamespaces sbmlns) -> ListOfCompartments

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfCompartments(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfCompartments object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfCompartments object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfCompartments(long level, long version)</pre>

        Creates a new ListOfCompartments object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfCompartments(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfCompartments

        Creates and returns a deep copy of this ListOfCompartments object.

        @return the (deep) copy of this ListOfCompartments object.

        """
        return _libsbml.ListOfCompartments_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Compartment objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf
        instance: @link libsbml#SBML_COMPARTMENT SBML_COMPARTMENT@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfCompartments_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfCompartments, the XML element name is always
        @c 'listOfCompartments'.

        @return the name of this element.

        """
        return _libsbml.ListOfCompartments_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Compartment
        get(self, unsigned int n) -> Compartment
        get(self, string sid) -> Compartment
        get(self, string sid) -> Compartment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a Compartment object from the ListOfCompartments.

        @param n the index number of the Compartment object to get.

        @return the nth Compartment object in this ListOfCompartments.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a Compartment object from the ListOfCompartments
        based on its identifier.

        @param sid a string representing the identifier
        of the Compartment object to get.

        @return Compartment object in this ListOfCompartments
        with the given @p sid or @c None if no such
        Compartment object exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfCompartments_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Compartment
        remove(self, string sid) -> Compartment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfCompartments items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfCompartments items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then
        @c None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfCompartments_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfCompartments
    __del__ = lambda self : None;
ListOfCompartments_swigregister = _libsbml.ListOfCompartments_swigregister
ListOfCompartments_swigregister(ListOfCompartments)

class Species(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML <em>species</em> &ndash; a pool of entities.

    A @em species in SBML refers to a pool of entities that (a) are
    considered indistinguishable from each other for the purposes of the
    model, (b) participate in reactions, and (c) are located in a specific
    @em compartment.  The SBML Species object class is intended to represent
    these pools.

    As with other major constructs in SBML, Species has a mandatory
    attribute, 'id', used to give the species type an identifier in the
    model.  The identifier must be a text string conforming to the identifer
    syntax permitted in SBML.  Species also has an optional 'name'
    attribute, of type @c string.  The 'id' and 'name' must be used
    according to the guidelines described in the SBML specifications.

    The required attribute 'compartment' is used to identify the compartment
    in which the species is located.  The attribute's value must be the
    identifier of an existing Compartment object.  It is important to note
    that there is no default value for the 'compartment' attribute on
    Species; every species in an SBML model must be assigned a compartment
    @em explicitly.  (This also implies that every model with one or more
    Species objects must define at least one Compartment object.)


    @section species-amounts The initial amount and concentration of a species

    The optional attributes 'initialAmount' and 'initialConcentration', both
    having a data type of @c float, can be used to set the @em initial
    quantity of the species in the compartment where the species is located.
    These attributes are mutually exclusive; i.e., <em>only one</em> can
    have a value on any given instance of a Species object.  Missing
    'initialAmount' and 'initialConcentration' values implies that their
    values either are unknown, or to be obtained from an external source, or
    determined by an InitialAssignment or other SBML construct elsewhere in
    the model.

    A species' initial quantity in SBML is set by the 'initialAmount' or
    'initialConcentration' attribute exactly once.  If the 'constant'
    attribute is @c True, then the value of the species' quantity is fixed
    and cannot be changed except by an InitialAssignment.  These methods
    differ in that the 'initialAmount' and 'initialConcentration' attributes
    can only be used to set the species quantity to a literal floating-point
    number, whereas the use of an InitialAssignment object allows the value
    to be set using an arbitrary mathematical expression (which, thanks to
    MathML's expressiveness, may evaluate to a rational number).  If the
    species' 'constant' attribute is @c False, the species' quantity value
    may be overridden by an InitialAssignment or changed by AssignmentRule
    or AlgebraicRule, and in addition, for <em>t &gt; 0</em>, it may also be
    changed by a RateRule, Event objects, and as a result of being a
    reactant or product in one or more Reaction objects.  (However, some
    constructs are mutually exclusive; see the SBML specifications for the
    precise details.)  It is not an error to define 'initialAmount' or
    'initialConcentration' on a species and also redefine the value using an
    InitialAssignment, but the 'initialAmount' or 'initialConcentration'
    setting in that case is ignored.  The SBML specifications provide
    additional information about the semantics of assignments, rules and
    values for simulation time <em>t</em> <= <em>0</em>.

    SBML Level&nbsp;2 additionally stipulates that in cases where a species'
    compartment has a 'spatialDimensions' value of @c 0 (zero), the species
    cannot have a value for 'initialConcentration' because the concepts of
    concentration and density break down when a container has zero
    dimensions.

    @section species-units The units of a species' amount or concentration

    When the attribute 'initialAmount' is set, the unit of measurement
    associated with the value of 'initialAmount' is specified by the Species
    attribute 'substanceUnits'.  When the 'initialConcentration' attribute
    is set, the unit of measurement associated with this concentration value
    is {<em>unit of amount</em>} divided by {<em>unit of size</em>}, where
    the {<em>unit of amount</em>} is specified by the Species
    'substanceUnits' attribute, and the {<em>unit of size</em>} is specified
    by the 'units' attribute of the Compartment object in which the species
    is located.  Note that in either case, a unit of <em>amount</em> is
    involved and determined by the 'substanceUnits' attribute.  Note
    <strong>these two attributes alone do not determine the units of the
    species when the species identifier appears in a mathematical
    expression</strong>; <em>that</em> aspect is determined by the attribute
    'hasOnlySubstanceUnits' discussed below.

    In SBML Level&nbsp;3, if the 'substanceUnits' attribute is not set on a
    given Species object instance, then the unit of <em>amount</em> for that
    species is inherited from the 'substanceUnits' attribute on the
    enclosing Model object instance.  If that attribute on Model is not set
    either, then the unit associated with the species' quantity is
    undefined.

    In SBML Level&nbsp;2, if the 'substanceUnits' attribute is not set on a
    given Species object instance, then the unit of <em>amount</em> for that
    species is taken from the predefined SBML unit identifier @c
    'substance'.  The value assigned to 'substanceUnits' must be chosen from
    one of the following possibilities: one of the base unit identifiers
    defined in SBML, the built-in unit identifier @c 'substance', or the
    identifier of a new unit defined in the list of unit definitions in the
    enclosing Model object.  The chosen units for 'substanceUnits' must be
    be @c 'dimensionless', @c 'mole', @c 'item', @c 'kilogram', @c 'gram',
    or units derived from these.

    As noted at the beginning of this section, simply setting
    'initialAmount' or 'initialConcentration' alone does @em not determine
    whether a species identifier represents an amount or a concentration
    when it appears elsewhere in an SBML model.  The role of the attribute
    'hasOnlySubstanceUnits' is to indicate whether the units of the species,
    when the species identifier appears in mathematical formulas, are
    intended to be concentration or amount.  The attribute takes on a
    boolean value.  In SBML Level&nbsp;3, the attribute has no default value
    and must always be set in a model; in SBML Level&nbsp;2, it has a
    default value of @c False.

    The <em>units of the species</em> are used in the following ways:
    <ul>
    <li> When the species' identifier appears in a MathML formula, it
    represents the species' quantity, and the unit of measurement associated
    with the quantity is as described above.

    <li> The 'math' elements of AssignmentRule, InitialAssignment and
    EventAssignment objects referring to this species should all have the
    same units as the unit of measurement associated with the species
    quantity.

    <li> In a RateRule object that defines the rate of change of the
    species' quantity, the unit associated with the rule's 'math' element
    should be equal to the unit of the species' quantity divided by the
    model-wide unit of <em>time</em>; in other words, {<em>unit of species
    quantity</em>}/{<em>unit of time</em>}.

    </ul>


    @section species-constant The 'constant' and 'boundaryCondition' attributes

    The Species object class has two boolean attributes named 'constant' and
    'boundaryCondition', used to indicate whether and how the quantity of
    that species can vary during a simulation.  In SBML Level&nbsp;2 they
    are optional; in SBML Level&nbsp;3 they are mandatory.  The following
    table shows how to interpret the combined values of these attributes.

    @htmlinclude species-boundarycondition.html

    By default, when a species is a product or reactant of one or more
    reactions, its quantity is determined by those reactions.  In SBML, it
    is possible to indicate that a given species' quantity is <em>not</em>
    determined by the set of reactions even when that species occurs as a
    product or reactant; i.e., the species is on the <em>boundary</em> of
    the reaction system, and its quantity is not determined by the
    reactions.  The boolean attribute 'boundaryCondition' can be used to
    indicate this.  A value of @c False indicates that the species @em is
    part of the reaction system.  In SBML Level&nbsp;2, the attribute has a
    default value of @c False, while in SBML Level&nbsp;3, it has no
    default.

    The 'constant' attribute indicates whether the species' quantity can be
    changed at all, regardless of whether by reactions, rules, or constructs
    other than InitialAssignment.  A value of @c False indicates that the
    species' quantity can be changed.  (This is also a common value because
    the purpose of most simulations is precisely to calculate changes in
    species quantities.)  In SBML Level&nbsp;2, the attribute has a default
    value of @c False, while in SBML Level&nbsp;3, it has no default.  Note
    that the initial quantity of a species can be set by an
    InitialAssignment irrespective of the value of the 'constant' attribute.

    In practice, a 'boundaryCondition' value of @c True means a differential
    equation derived from the reaction definitions should not be generated
    for the species.  However, the species' quantity may still be changed by
    AssignmentRule, RateRule, AlgebraicRule, Event, and InitialAssignment
    constructs if its 'constant' attribute is @c False.  Conversely, if the
    species' 'constant' attribute is @c True, then its value cannot be
    changed by anything except InitialAssignment.

    A species having 'boundaryCondition'=@c False and 'constant'=@c False
    can appear as a product and/or reactant of one or more reactions in the
    model.  If the species is a reactant or product of a reaction, it must
    @em not also appear as the target of any AssignmentRule or RateRule
    object in the model.  If instead the species has 'boundaryCondition'=@c False and 'constant'=@c True, then it cannot appear as a reactant or
    product, or as the target of any AssignmentRule, RateRule or
    EventAssignment object in the model.


    @section species-l2-convfactor The conversionFactor attribute in SBML Level&nbsp;3

    In SBML Level&nbsp;3, Species has an additional optional attribute,
    'conversionFactor', that defines a conversion factor that applies to a
    particular species.  The value must be the identifier of a Parameter
    object instance defined in the model.  That Parameter object must be a
    constant, meaning its 'constant' attribute must be set to @c True.
    If a given Species object definition defines a value for its
    'conversionFactor' attribute, it takes precedence over any factor
    defined by the Model object's 'conversionFactor' attribute.

    The unit of measurement associated with a species' quantity can be
    different from the unit of extent of reactions in the model.  SBML
    Level&nbsp;3 avoids implicit unit conversions by providing an explicit
    way to indicate any unit conversion that might be required.  The use of
    a conversion factor in computing the effects of reactions on a species'
    quantity is explained in detail in the SBML Level&nbsp;3 specification
    document.  Because the value of the 'conversionFactor' attribute is the
    identifier of a Parameter object, and because parameters can have units
    attached to them, the transformation from reaction extent units to
    species units can be completely specified using this approach.

    Note that the unit conversion factor is <strong>only applied when
    calculating the effect of a reaction on a species</strong>.  It is not
    used in any rules or other SBML constructs that affect the species, and
    it is also not used when the value of the species is referenced in a
    mathematical expression.


    @section species-l2-type The speciesType attribute in SBML Level&nbsp;2 Versions&nbsp;2&ndash;4

    In SBML Level&nbsp;2 Versions&nbsp;2&ndash;4, each species in a model
    may optionally be designated as belonging to a particular species type.
    The optional attribute 'speciesType' is used to identify the species
    type of the chemical entities that make up the pool represented by the
    Species objects.  The attribute's value must be the identifier of an
    existing SpeciesType object in the model.  If the 'speciesType'
    attribute is not present on a particular species definition, it means
    the pool contains chemical entities of a type unique to that pool; in
    effect, a virtual species type is assumed for that species, and no other
    species can belong to that species type.  The value of 'speciesType'
    attributes on species have no effect on the numerical interpretation of
    a model; simulators and other numerical analysis software may ignore
    'speciesType' attributes.

    There can be only one species of a given species type in any given
    compartment of a model.  More specifically, for all Species objects
    having a value for the 'speciesType' attribute, the pair
    <center>
    ('speciesType' attribute value, 'compartment' attribute value)
    </center>

    must be unique across the set of all Species object in a model.


    @section species-other The spatialSizeUnits attribute in SBML Level&nbsp;2 Versions&nbsp;1&ndash;2

    In versions of SBML Level&nbsp;2 before Version&nbsp;3, the class
    Species included an attribute called 'spatialSizeUnits', which allowed
    explicitly setting the units of size for initial concentration.  LibSBML
    retains this attribute for compatibility with older definitions of
    Level&nbsp;2, but its use is strongly discouraged because many software
    tools do no properly interpret this unit declaration and it is
    incompatible with all SBML specifications after Level&nbsp;2
    Version&nbsp;3.


    @section species-math Additional considerations for interpreting the numerical value of a species

    Species are unique in SBML in that they have a kind of duality: a
    species identifier may stand for either substance amount (meaning, a
    count of the number of individual entities) or a concentration or
    density (meaning, amount divided by a compartment size).  The previous
    sections explain the meaning of a species identifier when it is
    referenced in a mathematical formula or in rules or other SBML
    constructs; however, it remains to specify what happens to a species
    when the compartment in which it is located changes in size.

    When a species definition has a 'hasOnlySubstanceUnits' attribute value
    of @c False and the size of the compartment in which the species is
    located changes, the default in SBML is to assume that it is the
    concentration that must be updated to account for the size change.  This
    follows from the principle that, all other things held constant, if a
    compartment simply changes in size, the size change does not in itself
    cause an increase or decrease in the number of entities of any species
    in that compartment.  In a sense, the default is that the @em amount of
    a species is preserved across compartment size changes.  Upon such size
    changes, the value of the concentration or density must be recalculated
    from the simple relationship <em>concentration = amount / size</em> if
    the value of the concentration is needed (for example, if the species
    identifier appears in a mathematical formula or is otherwise referenced
    in an SBML construct).  There is one exception: if the species' quantity
    is determined by an AssignmentRule, RateRule, AlgebraicRule, or an
    EventAssignment and the species has a 'hasOnlySubstanceUnits' attribute
    value of @c False, it means that the <em>concentration</em> is assigned
    by the rule or event; in that case, the <em>amount</em> must be
    calculated when the compartment size changes.  (Events also require
    additional care in this situation, because an event with multiple
    assignments could conceivably reassign both a species quantity and a
    compartment size simultaneously.  Please refer to the SBML
    specifications for the details.)

    Note that the above only matters if a species has a
    'hasOnlySubstanceUnits' attribute value of @c False, meaning that the
    species identifier refers to a concentration wherever the identifier
    appears in a mathematical formula.  If instead the attribute's value is
    @c True, then the identifier of the species <em>always</em> stands for
    an amount wherever it appears in a mathematical formula or is referenced
    by an SBML construct.  In that case, there is never a question about
    whether an assignment or event is meant to affect the amount or
    concentration: it is always the amount.

    A particularly confusing situation can occur when the species has
    'constant' attribute value of @c True in combination with a
    'hasOnlySubstanceUnits' attribute value of @c False.  Suppose this
    species is given a value for 'initialConcentration'.  Does a 'constant'
    value of @c True mean that the concentration is held constant if the
    compartment size changes?  No; it is still the amount that is kept
    constant across a compartment size change.  The fact that the species
    was initialized using a concentration value is irrelevant.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Species, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Species, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Species
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Species
        __init__(self, SBMLNamespaces sbmlns) -> Species
        __init__(self, Species orig) -> Species

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Species(SBMLNamespaces sbmlns)</pre>

        Creates a new Species using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        It is worth emphasizing that although this constructor does not take
        an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'
        (identifier) attribute of a Species is required to have a value.
        Thus, callers are cautioned to assign a value after calling this
        constructor.  Setting the identifier can be accomplished using the
        method Species.setId().

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Species(long level, long version)</pre>

        Creates a new Species using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Species

        @param version a long integer, the SBML Version to assign to this
        Species

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Species(Species orig)</pre>

        Copy constructor; creates a copy of this Species object.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Species(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Species

        Creates and returns a deep copy of this Species object.

        @return the (deep) copy of this Species object.

        """
        return _libsbml.Species_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Species object to 'typical' defaults
        values.

        The SBML Species component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets 'boundaryCondition' to @c False
        <li> Sets 'constant' to @c False
        <li> sets 'hasOnlySubstanceUnits' to @c False
        <li> (Applies to Level&nbsp;3 models only) Sets attribute 'substanceUnits' to @c mole
        </ul>

        """
        return _libsbml.Species_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Species object.

        @return the id of this Species object.

        """
        return _libsbml.Species_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Species object.

        @return the name of this Species object.

        """
        return _libsbml.Species_getName(self)

    def getSpeciesType(self):
        """
        getSpeciesType(self) -> string

        Get the type of this Species object object.

        @return the value of the 'speciesType' attribute of this
        Species as a string.

        @note The 'speciesType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        """
        return _libsbml.Species_getSpeciesType(self)

    def getCompartment(self):
        """
        getCompartment(self) -> string

        Get the compartment in which this species is located.

        The compartment is designated by its identifier.

        @return the value of the 'compartment' attribute of this Species
        object, as a string.

        """
        return _libsbml.Species_getCompartment(self)

    def getInitialAmount(self):
        """
        getInitialAmount(self) -> double

        Get the value of the 'initialAmount' attribute.

        @return the initialAmount of this Species, as a float-point number.

        """
        return _libsbml.Species_getInitialAmount(self)

    def getInitialConcentration(self):
        """
        getInitialConcentration(self) -> double

        Get the value of the 'initialConcentration' attribute.

        @return the initialConcentration of this Species,, as a float-point
        number.

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_getInitialConcentration(self)

    def getSubstanceUnits(self):
        """
        getSubstanceUnits(self) -> string

        Get the value of the 'substanceUnits' attribute.

        @return the value of the 'substanceUnits' attribute of this Species,
        as a string.  An empty string indicates that no units have been
        assigned.

        @note There is an important distinction to be made between <em>no units
        assigned</em>, and assuming a value without units has any specific unit
        such as <code>dimensionless</code>.  In SBML, default units are never
        attributed to numbers, and numbers without units are not automatically
        assumed to have the unit <code>dimensionless</code>.  Please consult the
        relevant SBML specification document for a more in-depth explanation of
        this topic and the SBML unit system.

        @see isSetSubstanceUnits()
        @see setSubstanceUnits()

        """
        return _libsbml.Species_getSubstanceUnits(self)

    def getSpatialSizeUnits(self):
        """
        getSpatialSizeUnits(self) -> string

        Get the value of the 'spatialSizeUnits' attribute.

        @return the value of the 'spatialSizeUnits' attribute of this Species
        object, as a string.

        @warning <span class='warning'>In versions of SBML Level&nbsp;2 before
        Version&nbsp;3, the class Species included an attribute called
        'spatialSizeUnits', which allowed explicitly setting the units of size for
        initial concentration.  This attribute was removed in SBML Level&nbsp;2
        Version&nbsp;3.  LibSBML retains this attribute for compatibility with
        older definitions of Level&nbsp;2, but its use is strongly discouraged
        because it is incompatible with Level&nbsp;2 Version&nbsp;3 and
        Level&nbsp;2 Version&nbsp;4.</span>

        """
        return _libsbml.Species_getSpatialSizeUnits(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Get the value of the 'units' attribute.

        @return the units of this Species (L1 only).

        @note The 'units' attribute is defined only in SBML Level&nbsp;1.  In
        SBML Level&nbsp;2 and Level&nbsp;3, it has been replaced by a
        combination of 'substanceUnits' and the units of the Compartment
        object in which a species is located.  In SBML Level&nbsp;2
        Versions&nbsp;1&ndash;2, an additional attribute 'spatialSizeUnits'
        helps determine the units of the species quantity, but this attribute
        was removed in later versions of SBML Level&nbsp;2.

        """
        return _libsbml.Species_getUnits(self)

    def getHasOnlySubstanceUnits(self):
        """
        getHasOnlySubstanceUnits(self) -> bool

        Get the value of the 'hasOnlySubstanceUnits' attribute.

        @return @c True if this Species' 'hasOnlySubstanceUnits' attribute
        value is nonzero, @c False otherwise.

        @note The 'hasOnlySubstanceUnits' attribute does not exist in SBML
        Level&nbsp;1.

        """
        return _libsbml.Species_getHasOnlySubstanceUnits(self)

    def getBoundaryCondition(self):
        """
        getBoundaryCondition(self) -> bool

        Get the value of the 'boundaryCondition' attribute.

        @return @c True if this Species' 'boundaryCondition' attribute value
        is nonzero, @c False otherwise.

        """
        return _libsbml.Species_getBoundaryCondition(self)

    def getCharge(self):
        """
        getCharge(self) -> int

        Get the value of the 'charge' attribute.

        @return the charge of this Species object.

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species is deprecated and in SBML Level&nbsp;3 it does
        not exist at all.  Its use strongly discouraged.  Its presence is
        considered a misfeature in earlier definitions of SBML because its
        implications for the mathematics of a model were never defined, and in
        any case, no known modeling system ever used it.  Instead, models take
        account of charge values directly in their definitions of species by
        (for example) having separate species identities for the charged and
        uncharged versions of the same species.  This allows the condition to
        affect model mathematics directly.  LibSBML retains this method for
        easier compatibility with SBML Level&nbsp;1.

        """
        return _libsbml.Species_getCharge(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Get the value of the 'constant' attribute.

        @return @c True if this Species's 'constant' attribute value is
        nonzero, @c False otherwise.

        @note The attribute 'constant' is only available in SBML Levels&nbsp;2
        and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_getConstant(self)

    def getConversionFactor(self):
        """
        getConversionFactor(self) -> string

        Get the value of the 'conversionFactor' attribute.

        @return the conversionFactor of this Species, as a string.

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.

        """
        return _libsbml.Species_getConversionFactor(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        Species object's 'id' attribute is set.

        @return @c True if the 'id' attribute of this Species is
        set, @c False otherwise.

        """
        return _libsbml.Species_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        Species object's 'name' attribute is set.

        @return @c True if the 'name' attribute of this Species is
        set, @c False otherwise.

        """
        return _libsbml.Species_isSetName(self)

    def isSetSpeciesType(self):
        """
        isSetSpeciesType(self) -> bool

        Predicate returning @c True if this Species object's
        'speciesType' attribute is set.

        @return @c True if the 'speciesType' attribute of this Species is
        set, @c False otherwise.

        @note The 'speciesType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        """
        return _libsbml.Species_isSetSpeciesType(self)

    def isSetCompartment(self):
        """
        isSetCompartment(self) -> bool

        Predicate returning @c True if this
        Species object's 'compartment' attribute is set.

        @return @c True if the 'compartment' attribute of this Species is
        set, @c False otherwise.

        """
        return _libsbml.Species_isSetCompartment(self)

    def isSetInitialAmount(self):
        """
        isSetInitialAmount(self) -> bool

        Predicate returning @c True if this
        Species object's 'initialAmount' attribute is set.

        @return @c True if the 'initialAmount' attribute of this Species is
        set, @c False otherwise.

        @note In SBML Level&nbsp;1, Species' 'initialAmount' is required and
        therefore <em>should always be set</em>.  (However, in Level&nbsp;1, the
        attribute has no default value either, so this method will not return
        @c True until a value has been assigned.)  In SBML Level&nbsp;2,
        'initialAmount' is optional and as such may or may not be set.

        """
        return _libsbml.Species_isSetInitialAmount(self)

    def isSetInitialConcentration(self):
        """
        isSetInitialConcentration(self) -> bool

        Predicate returning @c True if this
        Species object's 'initialConcentration' attribute is set.

        @return @c True if the 'initialConcentration' attribute of this Species is
        set, @c False otherwise.

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_isSetInitialConcentration(self)

    def isSetSubstanceUnits(self):
        """
        isSetSubstanceUnits(self) -> bool

        Predicate returning @c True if this
        Species object's 'substanceUnits' attribute is set.

        @return @c True if the 'substanceUnits' attribute of this Species is
        set, @c False otherwise.

        """
        return _libsbml.Species_isSetSubstanceUnits(self)

    def isSetSpatialSizeUnits(self):
        """
        isSetSpatialSizeUnits(self) -> bool

        Predicate returning @c True if this
        Species object's 'spatialSizeUnits' attribute is set.

        @return @c True if the 'spatialSizeUnits' attribute of this Species is
        set, @c False otherwise.

        @warning <span class='warning'>In versions of SBML Level&nbsp;2 before
        Version&nbsp;3, the class Species included an attribute called
        'spatialSizeUnits', which allowed explicitly setting the units of size for
        initial concentration.  This attribute was removed in SBML Level&nbsp;2
        Version&nbsp;3.  LibSBML retains this attribute for compatibility with
        older definitions of Level&nbsp;2, but its use is strongly discouraged
        because it is incompatible with Level&nbsp;2 Version&nbsp;3 and
        Level&nbsp;2 Version&nbsp;4.</span>

        """
        return _libsbml.Species_isSetSpatialSizeUnits(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c True if
        this Species object's 'units' attribute is set.

        @return @c True if the 'units' attribute of this Species is
        set, @c False otherwise.

        """
        return _libsbml.Species_isSetUnits(self)

    def isSetCharge(self):
        """
        isSetCharge(self) -> bool

        Predicate returning @c True if this
        Species object's 'charge' attribute is set.

        @return @c True if the 'charge' attribute of this Species is
        set, @c False otherwise.

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species is deprecated and in SBML Level&nbsp;3 it does
        not exist at all.  Its use strongly discouraged.  Its presence is
        considered a misfeature in earlier definitions of SBML because its
        implications for the mathematics of a model were never defined, and in
        any case, no known modeling system ever used it.  Instead, models take
        account of charge values directly in their definitions of species by
        (for example) having separate species identities for the charged and
        uncharged versions of the same species.  This allows the condition to
        affect model mathematics directly.  LibSBML retains this method for
        easier compatibility with SBML Level&nbsp;1.

        """
        return _libsbml.Species_isSetCharge(self)

    def isSetConversionFactor(self):
        """
        isSetConversionFactor(self) -> bool

        Predicate returning @c True if this
        Species object's 'conversionFactor' attribute is set.

        @return @c True if the 'conversionFactor' attribute of this Species is
        set, @c False otherwise.

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.

        """
        return _libsbml.Species_isSetConversionFactor(self)

    def isSetBoundaryCondition(self):
        """
        isSetBoundaryCondition(self) -> bool

        Predicate returning @c True if this
        Species object's 'boundaryCondition' attribute is set.

        @return @c True if the 'boundaryCondition' attribute of this Species is
        set, @c False otherwise.

        """
        return _libsbml.Species_isSetBoundaryCondition(self)

    def isSetHasOnlySubstanceUnits(self):
        """
        isSetHasOnlySubstanceUnits(self) -> bool

        Predicate returning @c True if this
        Species object's 'hasOnlySubstanceUnits' attribute is set.

        @return @c True if the 'hasOnlySubstanceUnits' attribute of this Species is
        set, @c False otherwise.

        @note The 'hasOnlySubstanceUnits' attribute does not exist in SBML
        Level&nbsp;1.

        """
        return _libsbml.Species_isSetHasOnlySubstanceUnits(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c True if this
        Species object's 'constant' attribute is set.

        @return @c True if the 'constant' attribute of this Species is
        set, @c False otherwise.

        @note The attribute 'constant' is only available in SBML Levels&nbsp;2
        and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_isSetConstant(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Species object.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this Species

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Species_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Species object.

        The string in @p name is copied.

        @param name the new name for the Species

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Species_setName(self, *args)

    def setSpeciesType(self, *args):
        """
        setSpeciesType(self, string sid) -> int

        Sets the 'speciesType' attribute of this Species object.

        @param sid the identifier of a SpeciesType object defined elsewhere
        in this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The 'speciesType' attribute is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        """
        return _libsbml.Species_setSpeciesType(self, *args)

    def setCompartment(self, *args):
        """
        setCompartment(self, string sid) -> int

        Sets the 'compartment' attribute of this Species object.

        @param sid the identifier of a Compartment object defined elsewhere
        in this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Species_setCompartment(self, *args)

    def setInitialAmount(self, *args):
        """
        setInitialAmount(self, double value) -> int

        Sets the 'initialAmount' attribute of this Species and marks the field
        as set.

        This method also unsets the 'initialConcentration' attribute.

        @param value the value to which the 'initialAmount' attribute should
        be set.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.Species_setInitialAmount(self, *args)

    def setInitialConcentration(self, *args):
        """
        setInitialConcentration(self, double value) -> int

        Sets the 'initialConcentration' attribute of this Species and marks
        the field as set.

        This method also unsets the 'initialAmount' attribute.

        @param value the value to which the 'initialConcentration' attribute
        should be set.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_setInitialConcentration(self, *args)

    def setSubstanceUnits(self, *args):
        """
        setSubstanceUnits(self, string sid) -> int

        Sets the 'substanceUnits' attribute of this Species object.

        @param sid the identifier of the unit to use.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Species_setSubstanceUnits(self, *args)

    def setSpatialSizeUnits(self, *args):
        """
        setSpatialSizeUnits(self, string sid) -> int

        (SBML Level&nbsp;2 Versions&nbsp;1&ndash;2) Sets the 'spatialSizeUnits' attribute of this Species object.

        @param sid the identifier of the unit to use.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @warning <span class='warning'>In versions of SBML Level&nbsp;2 before
        Version&nbsp;3, the class Species included an attribute called
        'spatialSizeUnits', which allowed explicitly setting the units of size for
        initial concentration.  This attribute was removed in SBML Level&nbsp;2
        Version&nbsp;3.  LibSBML retains this attribute for compatibility with
        older definitions of Level&nbsp;2, but its use is strongly discouraged
        because it is incompatible with Level&nbsp;2 Version&nbsp;3 and
        Level&nbsp;2 Version&nbsp;4.</span>

        """
        return _libsbml.Species_setSpatialSizeUnits(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string sname) -> int

        (SBML Level&nbsp;1 only) Sets the units of this Species object.

        @param sname the identifier of the unit to use.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Species_setUnits(self, *args)

    def setHasOnlySubstanceUnits(self, *args):
        """
        setHasOnlySubstanceUnits(self, bool value) -> int

        Sets the 'hasOnlySubstanceUnits' attribute of this Species object.

        @param value boolean value for the 'hasOnlySubstanceUnits' attribute.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The 'hasOnlySubstanceUnits' attribute does not exist in SBML
        Level&nbsp;1.

        """
        return _libsbml.Species_setHasOnlySubstanceUnits(self, *args)

    def setBoundaryCondition(self, *args):
        """
        setBoundaryCondition(self, bool value) -> int

        Sets the 'boundaryCondition' attribute of this Species object.

        @param value boolean value for the 'boundaryCondition' attribute.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.Species_setBoundaryCondition(self, *args)

    def setCharge(self, *args):
        """
        setCharge(self, int value) -> int

        Sets the 'charge' attribute of this Species object.

        @param value an integer to which to set the 'charge' to.

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species is deprecated and in SBML Level&nbsp;3 it does
        not exist at all.  Its use strongly discouraged.  Its presence is
        considered a misfeature in earlier definitions of SBML because its
        implications for the mathematics of a model were never defined, and in
        any case, no known modeling system ever used it.  Instead, models take
        account of charge values directly in their definitions of species by
        (for example) having separate species identities for the charged and
        uncharged versions of the same species.  This allows the condition to
        affect model mathematics directly.  LibSBML retains this method for
        easier compatibility with SBML Level&nbsp;1. 

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.Species_setCharge(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool value) -> int

        Sets the 'constant' attribute of this Species object.

        @param value a boolean value for the 'constant' attribute

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attribute 'constant' is only available in SBML Levels&nbsp;2
        and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_setConstant(self, *args)

    def setConversionFactor(self, *args):
        """
        setConversionFactor(self, string sid) -> int

        Sets the value of the 'conversionFactor' attribute of this Species object.

        The string in @p sid is copied.

        @param sid the new conversionFactor for the Species

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.

        """
        return _libsbml.Species_setConversionFactor(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Species_unsetName(self)

    def unsetSpeciesType(self):
        """
        unsetSpeciesType(self) -> int

        Unsets the 'speciesType' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The attribute 'speciesType' is only available in SBML
        Level&nbsp;2 Versions&nbsp;2&ndash;4.

        """
        return _libsbml.Species_unsetSpeciesType(self)

    def unsetInitialAmount(self):
        """
        unsetInitialAmount(self) -> int

        Unsets the 'initialAmount' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Species_unsetInitialAmount(self)

    def unsetInitialConcentration(self):
        """
        unsetInitialConcentration(self) -> int

        Unsets the 'initialConcentration' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The attribute 'initialConcentration' is only available in SBML
        Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.

        """
        return _libsbml.Species_unsetInitialConcentration(self)

    def unsetSubstanceUnits(self):
        """
        unsetSubstanceUnits(self) -> int

        Unsets the 'substanceUnits' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Species_unsetSubstanceUnits(self)

    def unsetSpatialSizeUnits(self):
        """
        unsetSpatialSizeUnits(self) -> int

        Unsets the 'spatialSizeUnits' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @warning <span class='warning'>In versions of SBML Level&nbsp;2 before
        Version&nbsp;3, the class Species included an attribute called
        'spatialSizeUnits', which allowed explicitly setting the units of size for
        initial concentration.  This attribute was removed in SBML Level&nbsp;2
        Version&nbsp;3.  LibSBML retains this attribute for compatibility with
        older definitions of Level&nbsp;2, but its use is strongly discouraged
        because it is incompatible with Level&nbsp;2 Version&nbsp;3 and
        Level&nbsp;2 Version&nbsp;4.</span>

        """
        return _libsbml.Species_unsetSpatialSizeUnits(self)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the 'units' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Species_unsetUnits(self)

    def unsetCharge(self):
        """
        unsetCharge(self) -> int

        Unsets the 'charge' attribute
        value of this Species object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'
        attribute on Species is deprecated and in SBML Level&nbsp;3 it does
        not exist at all.  Its use strongly discouraged.  Its presence is
        considered a misfeature in earlier definitions of SBML because its
        implications for the mathematics of a model were never defined, and in
        any case, no known modeling system ever used it.  Instead, models take
        account of charge values directly in their definitions of species by
        (for example) having separate species identities for the charged and
        uncharged versions of the same species.  This allows the condition to
        affect model mathematics directly.  LibSBML retains this method for
        easier compatibility with SBML Level&nbsp;1.

        """
        return _libsbml.Species_unsetCharge(self)

    def unsetConversionFactor(self):
        """
        unsetConversionFactor(self) -> int

        Unsets the 'conversionFactor' attribute value of this Species object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'conversionFactor' attribute was introduced in SBML
        Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1
        and&nbsp;2.

        """
        return _libsbml.Species_unsetConversionFactor(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this Species' amount or concentration.

        Species in SBML have an attribute ('substanceUnits') for declaring the
        units of measurement intended for the species' amount or concentration
        (depending on which one applies).  In the absence of a value given for
        'substanceUnits', the units are taken from the enclosing Model's
        definition of @c 'substance' or @c 'substance'/<em>(size of the
        compartment)</em> in which the species is located, or finally, if
        these are not redefined by the Model, the relevant SBML default units
        for those quantities.  Following that procedure, the method
        @if java Species.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif@~
        returns a UnitDefinition based on the
        interpreted units of this species's amount or concentration.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c None.

        Note also that unit declarations for Species are in terms of the @em
        identifier of a unit, but this method returns a UnitDefinition object,
        not a unit identifier.  It does this by constructing an appropriate
        UnitDefinition.  Callers may find this particularly useful when used
        in conjunction with the helper methods on UnitDefinition for comparing
        different UnitDefinition objects.

        In SBML Level&nbsp;2 specifications prior to Version&nbsp;3, Species
        includes an additional attribute named 'spatialSizeUnits', which
        allows explicitly setting the units of size for initial concentration.
        The @if java Species.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif@~
        takes this into account for models
        expressed in SBML Level&nbsp;2 Versions&nbsp;1 and&nbsp;2.

        @return a UnitDefinition that expresses the units of this 
        Species, or @c None if one cannot be constructed.

        @see getSubstanceUnits()

        """
        return _libsbml.Species_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_SPECIES SBML_SPECIES@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Species_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Species, is
        always @c 'species'.

        @return the name of this element, i.e., @c 'species'.

        """
        return _libsbml.Species_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this Species object
        have been set.

        The required attributes for a Species object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'compartment'
        @li 'initialAmount' (required in SBML Level&nbsp;1 only; optional otherwise)
        @li 'hasOnlySubstanceUnits' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)
        @li 'boundaryCondition' (required in SBML Level&nbsp;3; optional in Levels&nbsp;1 and&nbsp;2)
        @li 'constant' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Species_hasRequiredAttributes(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Species_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Species_renameUnitSIdRefs(self, *args)

Species_swigregister = _libsbml.Species_swigregister
Species_swigregister(Species)

class ListOfSpecies(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Species objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfSpecies, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfSpecies, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfSpecies
        __init__(self, SBMLNamespaces sbmlns) -> ListOfSpecies

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfSpecies(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfSpecies object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfSpecies object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfSpecies(long level, long version)</pre>

        Creates a new ListOfSpecies object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfSpecies(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfSpecies

        Creates and returns a deep copy of this ListOfSpecies object.

        @return the (deep) copy of this ListOfSpecies object.

        """
        return _libsbml.ListOfSpecies_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Species objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_SPECIES SBML_SPECIES@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfSpecies_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfSpeciess, the XML element name is @c 'listOfSpeciess'.

        @return the name of this element, i.e., @c 'listOfSpeciess'.

        """
        return _libsbml.ListOfSpecies_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Species
        get(self, unsigned int n) -> Species
        get(self, string sid) -> Species
        get(self, string sid) -> Species

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a Species from the ListOfSpecies.

        @param n the index number of the Species to get.

        @return the nth Species in this ListOfSpecies.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a Species from the ListOfSpecies
        based on its identifier.

        @param sid a string representing the identifier 
        of the Species to get.

        @return Species in this ListOfSpecies
        with the given @p sid or @c None if no such
        Species exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfSpecies_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Species
        remove(self, string sid) -> Species

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfSpeciess items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfSpeciess items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfSpecies_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfSpecies
    __del__ = lambda self : None;
ListOfSpecies_swigregister = _libsbml.ListOfSpecies_swigregister
ListOfSpecies_swigregister(ListOfSpecies)

class Parameter(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML parameter: a named symbol with a value.

    A Parameter is used in SBML to define a symbol associated with a value;
    this symbol can then be used in mathematical formulas in a model.  By
    default, parameters have constant value for the duration of a
    simulation, and for this reason are called @em parameters instead of @em
    variables in SBML, although it is crucial to understand that <em>SBML
    parameters represent both concepts</em>.  Whether a given SBML
    parameter is intended to be constant or variable is indicated by the
    value of its 'constant' attribute.

    SBML's Parameter has a required attribute, 'id', that gives the
    parameter a unique identifier by which other parts of an SBML model
    definition can refer to it.  A parameter can also have an optional
    'name' attribute of type @c string.  Identifiers and names must be used
    according to the guidelines described in the SBML specifications.

    The optional attribute 'value' determines the value (of type @c float)
    assigned to the parameter.  A missing value for 'value' implies that
    the value either is unknown, or to be obtained from an external source,
    or determined by an initial assignment.  The unit of measurement
    associated with the value of the parameter can be specified using the
    optional attribute 'units'.  Here we only mention briefly some notable
    points about the possible unit choices, but readers are urged to consult
    the SBML specification documents for more information:
    <ul>

    <li> In SBML Level&nbsp;3, there are no constraints on the units that
    can be assigned to parameters in a model; there are also no units to
    inherit from the enclosing Model object (unlike the case for, e.g.,
    Species and Compartment).

    <li> In SBML Level&nbsp;2, the value assigned to the parameter's 'units'
    attribute must be chosen from one of the following possibilities: one of
    the base unit identifiers defined in SBML; one of the built-in unit
    identifiers @c 'substance', @c 'time', @c 'volume', @c 'area' or @c
    'length'; or the identifier of a new unit defined in the list of unit
    definitions in the enclosing Model structure.  There are no constraints
    on the units that can be chosen from these sets.  There are no default
    units for parameters.
    </ul>

    The Parameter structure has another boolean attribute named 'constant'
    that is used to indicate whether the parameter's value can vary during a
    simulation.  (In SBML Level&nbsp;3, the attribute is mandatory and must
    be given a value; in SBML Levels below Level&nbsp;3, the attribute is
    optional.)  A value of @c True indicates the parameter's value cannot be
    changed by any construct except InitialAssignment.  Conversely, if the
    value of 'constant' is @c False, other constructs in SBML, such as rules
    and events, can change the value of the parameter.

    SBML Level&nbsp;3 uses a separate object class, LocalParameter, for
    parameters that are local to a Reaction's KineticLaw.  In Levels prior
    to SBML Level&nbsp;3, the Parameter class is used both for definitions
    of global parameters, as well as reaction-local parameters stored in a
    list within KineticLaw objects.  Parameter objects that are local to a
    reaction (that is, those defined within the KineticLaw structure of a
    Reaction) cannot be changed by rules and therefore are <em>implicitly
    always constant</em>; consequently, in SBML Level&nbsp;2, parameter
    definitions within Reaction structures should @em not have their
    'constant' attribute set to @c False.

    What if a global parameter has its 'constant' attribute set to @c False,
    but the model does not contain any rules, events or other constructs
    that ever change its value over time?  Although the model may be
    suspect, this situation is not strictly an error.  A value of @c False
    for 'constant' only indicates that a parameter @em can change value, not
    that it @em must.

    As with all other major SBML components, Parameter is derived from
    SBase, and the methods defined on SBase are available on Parameter.

    @note The use of the term @em parameter in SBML sometimes leads to
    confusion among readers who have a particular notion of what something
    called 'parameter' should be.  It has been the source of heated debate,
    but despite this, no one has yet found an adequate replacement term that
    does not have different connotations to different people and hence leads
    to confusion among @em some subset of users.  Perhaps it would have been
    better to have two constructs, one called @em constants and the other
    called @em variables.  The current approach in SBML is simply more
    parsimonious, using a single Parameter construct with the boolean flag
    'constant' indicating which flavor it is.  In any case, readers are
    implored to look past their particular definition of a @em parameter and
    simply view SBML's Parameter as a single mechanism for defining both
    constants and (additional) variables in a model.  (We write @em
    additional because the species in a model are usually considered to be
    the central variables.)  After all, software tools are not required to
    expose to users the actual names of particular SBML constructs, and
    thus tools can present to their users whatever terms their designers
    feel best matches their target audience.

    @see ListOfParameters

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parameter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Parameter, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Parameter
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Parameter
        __init__(self, SBMLNamespaces sbmlns) -> Parameter
        __init__(self, Parameter orig) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Parameter(SBMLNamespaces sbmlns)</pre>

        Creates a new Parameter using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        It is worth emphasizing that although this constructor does not take
        an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'
        (identifier) attribute of a Parameter is required to have a value.
        Thus, callers are cautioned to assign a value after calling this
        constructor if no identifier is provided as an argument.  Setting the
        identifier can be accomplished using the method
        @if java setId(String id)@else setId()@endif.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Parameter(long level, long version)</pre>

        Creates a new Parameter using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Parameter

        @param version a long integer, the SBML Version to assign to this
        Parameter

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Parameter(Parameter orig)</pre>

        Copy constructor; creates a copy of a Parameter.

        @param orig the Parameter instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Parameter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Parameter

        Creates and returns a deep copy of this Parameter object.

        @return the (deep) copy of this Parameter object.

        """
        return _libsbml.Parameter_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Parameter object to 'typical' defaults
        values.

        The SBML Parameter component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.  Many
        SBML object classes defined by libSBML have an initDefaults() method
        to set the values to certain common defaults, based mostly on what
        they are in SBML Level&nbsp;2.  In the case of Parameter, this method
        only sets the value of the 'constant' attribute to @c True.

        @see getConstant()
        @see isSetConstant()
        @see setConstant()

        """
        return _libsbml.Parameter_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Parameter.

        @return the id of this Parameter.

        """
        return _libsbml.Parameter_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Parameter.

        @return the name of this Parameter.

        """
        return _libsbml.Parameter_getName(self)

    def getValue(self):
        """
        getValue(self) -> double

        Gets the numerical value of this Parameter.

        @return the value of the 'value' attribute of this Parameter, as a
        number of type @c float.

        @note <b>It is crucial</b> that callers not blindly call
        Parameter.getValue() without first using Parameter.isSetValue() to
        determine whether a value has ever been set.  Otherwise, the value
        return by Parameter.getValue() may not actually represent a value
        assigned to the parameter.  The reason is simply that the data type
        @c float in a program always has @em some value.  A separate test is
        needed to determine whether the value is a true model value, or
        uninitialized data in a computer's memory location.

        @see isSetValue()
        @see setValue()
        @see getUnits()

        """
        return _libsbml.Parameter_getValue(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Gets the units defined for this Parameter.

        The value of an SBML parameter's 'units' attribute establishes the
        unit of measurement associated with the parameter's value.

        @return the value of the 'units' attribute of this Parameter, as a
        string.  An empty string indicates that no units have been assigned.

        @note There is an important distinction to be made between <em>no units
        assigned</em>, and assuming a value without units has any specific unit
        such as <code>dimensionless</code>.  In SBML, default units are never
        attributed to numbers, and numbers without units are not automatically
        assumed to have the unit <code>dimensionless</code>.  Please consult the
        relevant SBML specification document for a more in-depth explanation of
        this topic and the SBML unit system.

        @see isSetUnits()
        @see setUnits()
        @see getValue()

        """
        return _libsbml.Parameter_getUnits(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Gets the value of the 'constant' attribute of this Parameter instance.

        @return @c True if this Parameter is declared as being constant,
        @c False otherwise.

        @note Readers who view the documentation for LocalParameter may be
        confused about the presence of this method.  LibSBML derives
        LocalParameter from Parameter; however, this does not precisely match
        the object hierarchy defined by SBML Level&nbsp;3, where
        LocalParameter is derived directly from SBase and not Parameter.  We
        believe this arrangement makes it easier for libSBML users to program
        applications that work with both SBML Level&nbsp;2 and SBML
        Level&nbsp;3, but programmers should also keep in mind this difference
        exists.  A side-effect of libSBML's scheme is that certain methods on
        LocalParameter that are inherited from Parameter do not actually have
        relevance to LocalParameter objects.  An example of this is the
        methods pertaining to Parameter's attribute 'constant' (i.e.,
        isSetConstant(), setConstant(), and getConstant()).

        @see isSetConstant()
        @see setConstant()

        """
        return _libsbml.Parameter_getConstant(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        Parameter's 'id' attribute is set.

        @return @c True if the 'id' attribute of this Parameter is
        set, @c False otherwise.

        """
        return _libsbml.Parameter_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        Parameter's 'name' attribute is set.

        @return @c True if the 'name' attribute of this Parameter is
        set, @c False otherwise.

        """
        return _libsbml.Parameter_isSetName(self)

    def isSetValue(self):
        """
        isSetValue(self) -> bool

        Predicate returning @c True if the
        'value' attribute of this Parameter is set.

        In SBML definitions after SBML Level&nbsp;1 Version&nbsp;1,
        parameter values are optional and have no defaults.  If a model read
        from a file does not contain a setting for the 'value' attribute of a
        parameter, its value is considered unset; it does not default to any
        particular value.  Similarly, when a Parameter object is created in
        libSBML, it has no value until given a value.  The
        Parameter.isSetValue() method allows calling applications to
        determine whether a given parameter's value has ever been set.

        In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have
        values and therefore, the value of a Parameter <b>should always be
        set</b>.  In Level&nbsp;1 Version&nbsp;2 and beyond, the value is
        optional and as such, the 'value' attribute may or may not be set.

        @return @c True if the value of this Parameter is set,
        @c False otherwise.

        @see getValue()
        @see setValue()

        """
        return _libsbml.Parameter_isSetValue(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c True if the
        'units' attribute of this Parameter is set.

        @return @c True if the 'units' attribute of this Parameter is
        set, @c False otherwise.

        @note There is an important distinction to be made between <em>no units
        assigned</em>, and assuming a value without units has any specific unit
        such as <code>dimensionless</code>.  In SBML, default units are never
        attributed to numbers, and numbers without units are not automatically
        assumed to have the unit <code>dimensionless</code>.  Please consult the
        relevant SBML specification document for a more in-depth explanation of
        this topic and the SBML unit system.

        """
        return _libsbml.Parameter_isSetUnits(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c True if the
        'constant' attribute of this Parameter is set.

        @return @c True if the 'constant' attribute of this Parameter is
        set, @c False otherwise.

        @note Readers who view the documentation for LocalParameter may be
        confused about the presence of this method.  LibSBML derives
        LocalParameter from Parameter; however, this does not precisely match
        the object hierarchy defined by SBML Level&nbsp;3, where
        LocalParameter is derived directly from SBase and not Parameter.  We
        believe this arrangement makes it easier for libSBML users to program
        applications that work with both SBML Level&nbsp;2 and SBML
        Level&nbsp;3, but programmers should also keep in mind this difference
        exists.  A side-effect of libSBML's scheme is that certain methods on
        LocalParameter that are inherited from Parameter do not actually have
        relevance to LocalParameter objects.  An example of this is the
        methods pertaining to Parameter's attribute 'constant' (i.e.,
        isSetConstant(), setConstant(), and getConstant()).

        @see getConstant()
        @see setConstant()

        """
        return _libsbml.Parameter_isSetConstant(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Parameter.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this Parameter

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Parameter_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Parameter.

        The string in @p name is copied.

        @param name the new name for the Parameter

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Parameter_setName(self, *args)

    def setValue(self, *args):
        """
        setValue(self, double value) -> int

        Sets the 'value' attribute of this Parameter to the given @c float
        value and marks the attribute as set.

        @param value a @c float, the value to assign

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.Parameter_setValue(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string units) -> int

        Sets the 'units' attribute of this Parameter to a copy of the given
        units identifier @p units.

        @param units a string, the identifier of the units to assign to this
        Parameter instance

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Parameter_setUnits(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool flag) -> int

        Sets the 'constant' attribute of this Parameter to the given boolean
        @p flag.

        @param flag a boolean, the value for the 'constant' attribute of this
        Parameter instance

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note Readers who view the documentation for LocalParameter may be
        confused about the presence of this method.  LibSBML derives
        LocalParameter from Parameter; however, this does not precisely match
        the object hierarchy defined by SBML Level&nbsp;3, where
        LocalParameter is derived directly from SBase and not Parameter.  We
        believe this arrangement makes it easier for libSBML users to program
        applications that work with both SBML Level&nbsp;2 and SBML
        Level&nbsp;3, but programmers should also keep in mind this difference
        exists.  A side-effect of libSBML's scheme is that certain methods on
        LocalParameter that are inherited from Parameter do not actually have
        relevance to LocalParameter objects.  An example of this is the
        methods pertaining to Parameter's attribute 'constant' (i.e.,
        isSetConstant(), setConstant(), and getConstant()).

        @see getConstant()
        @see isSetConstant()

        """
        return _libsbml.Parameter_setConstant(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Parameter.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Parameter_unsetName(self)

    def unsetValue(self):
        """
        unsetValue(self) -> int

        Unsets the 'value' attribute of this Parameter instance.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have
        values and therefore, the value of a Parameter <b>should always be
        set</b>.  In SBML Level&nbsp;1 Version&nbsp;2 and beyond, the value
        is optional and as such, the 'value' attribute may or may not be set.

        """
        return _libsbml.Parameter_unsetValue(self)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the 'units' attribute of this Parameter instance.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Parameter_unsetUnits(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this Parameter's value.

        Parameters in SBML have an attribute ('units') for declaring the units
        of measurement intended for the parameter's value.  <b>No defaults are
        defined</b> by SBML in the absence of a definition for 'units'.  This
        method returns a UnitDefinition object based on the units declared for
        this Parameter using its 'units' attribute, or it returns @c None if
        no units have been declared.

        Note that unit declarations for Parameter objects are specified in
        terms of the @em identifier of a unit (e.g., using setUnits()), but
        @em this method returns a UnitDefinition object, not a unit
        identifier.  It does this by constructing an appropriate
        UnitDefinition.For SBML Level&nbsp;2 models, it will do this even when
        the value of the 'units' attribute is one of the special SBML
        Level&nbsp;2 unit identifiers @c 'substance', @c 'volume', @c 'area',
        @c 'length' or @c 'time'.  Callers may find this useful in conjunction
        with the helper methods provided by the UnitDefinition class for
        comparing different UnitDefinition objects.

        @return a UnitDefinition that expresses the units of this 
        Parameter, or @c None if one cannot be constructed.

        @note The libSBML system for unit analysis depends on the model as a
        whole.  In cases where the Parameter object has not yet been added to
        a model, or the model itself is incomplete, unit analysis is not
        possible, and consequently this method will return @c None.

        @see isSetUnits()

        """
        return _libsbml.Parameter_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_PARAMETER SBML_PARAMETER@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Parameter_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Parameter, is
        always @c 'parameter'.

        @return the name of this element, i.e., @c 'parameter'.

        """
        return _libsbml.Parameter_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this Parameter object
        have been set.

        The required attributes for a Parameter object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'value' (required in Level&nbsp;1, optional otherwise)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Parameter_hasRequiredAttributes(self)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Renames all the @c UnitSIdRef attributes on this element.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        unit identifiers to the value of @p oldid.  If any matches are found,
        the matching identifiers are replaced with @p newid.  The method does
        @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Parameter_renameUnitSIdRefs(self, *args)

    def setCalculatingUnits(self, *args):
        """
        setCalculatingUnits(self, bool calculatingUnits)

        @internal

        @internal

        """
        return _libsbml.Parameter_setCalculatingUnits(self, *args)

Parameter_swigregister = _libsbml.Parameter_swigregister
Parameter_swigregister(Parameter)

class ListOfParameters(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Parameter objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfParameters, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfParameters, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfParameters
        __init__(self, SBMLNamespaces sbmlns) -> ListOfParameters

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfParameters(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfParameters object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfParameters object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfParameters(long level, long version)</pre>

        Creates a new ListOfParameters object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfParameters(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfParameters

        Creates and returns a deep copy of this ListOfParameters object.

        @return the (deep) copy of this ListOfParameters object.

        """
        return _libsbml.ListOfParameters_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Parameter objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this objects contained in this list:
        @link libsbml#SBML_PARAMETER SBML_PARAMETER@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfParameters_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfParameters, the XML element name is @c 'listOfParameters'.

        @return the name of this element, i.e., @c 'listOfParameters'.

        """
        return _libsbml.ListOfParameters_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Parameter
        get(self, unsigned int n) -> Parameter
        get(self, string sid) -> Parameter
        get(self, string sid) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Returns the Parameter object located at position @p n within this
        ListOfParameters instance.

        @param n the index number of the Parameter to get.

        @return the nth Parameter in this ListOfParameters.  If the index @p n
        is out of bounds for the length of the list, then @c None is returned.

        @see size()
        @see get()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Returns the first Parameter object matching the given identifier.

        @param sid a string representing the identifier of the Parameter to
        get.

        @return the Parameter object found.  The caller owns the returned
        object and is responsible for deleting it.  If none of the items have
        an identifier matching @p sid, then @c None is returned.

        @see get()
        @see size()

        """
        return _libsbml.ListOfParameters_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Parameter
        remove(self, string sid) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfParameters, and returns a pointer
        to it.

        @param n the index of the item to remove

        @return the item removed.  The caller owns the returned object and is
        responsible for deleting it.  If the index number @p n is out of
        bounds for the length of the list, then @c None is returned.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes the first Parameter object in this ListOfParameters
        matching the given identifier, and returns a pointer to it.

        @param sid the identifier of the item to remove.

        @return the item removed.  The caller owns the returned object and is
        responsible for deleting it.  If none of the items have an identifier
        matching @p sid, then @c None is returned.

        """
        return _libsbml.ListOfParameters_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfParameters
    __del__ = lambda self : None;
ListOfParameters_swigregister = _libsbml.ListOfParameters_swigregister
ListOfParameters_swigregister(ListOfParameters)

class LocalParameter(Parameter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A parameter inside an SBML <em>reaction</em> definition.

    LocalParameter has been introduced in SBML Level&nbsp;3 to serve as the
    object class for parameter definitions that are intended to be local to
    a Reaction.  Objects of class LocalParameter never appear at the Model
    level; they are always contained within ListOfLocalParameters lists
    which are in turn contained within KineticLaw objects.

    Like its global Parameter counterpart, the LocalParameter object class
    is used to define a symbol associated with a value; this symbol can then
    be used in a model's mathematical formulas (and specifically, for
    LocalParameter, reaction rate formulas).  Unlike Parameter, the
    LocalParameter class does not have a 'constant' attribute: local
    parameters within reactions are @em always constant.

    LocalParameter has one required attribute, 'id', to give the
    parameter a unique identifier by which other parts of an SBML model
    definition can refer to it.  A parameter can also have an optional
    'name' attribute of type @c string.  Identifiers and names must be used
    according to the guidelines described in the SBML specifications.

    The optional attribute 'value' determines the value (of type @c float)
    assigned to the parameter.  A missing value for 'value' implies that
    the value either is unknown, or to be obtained from an external source,
    or determined by an initial assignment.  The unit of measurement
    associated with the value of the parameter can be specified using the
    optional attribute 'units'.  Here we only mention briefly some notable
    points about the possible unit choices, but readers are urged to consult
    the SBML specification documents for more information:
    <ul>

    <li> In SBML Level&nbsp;3, there are no constraints on the units that
    can be assigned to parameters in a model; there are also no units to
    inherit from the enclosing Model object.

    <li> In SBML Level&nbsp;2, the value assigned to the parameter's 'units'
    attribute must be chosen from one of the following possibilities: one of
    the base unit identifiers defined in SBML; one of the built-in unit
    identifiers @c 'substance', @c 'time', @c 'volume', @c 'area' or @c
    'length'; or the identifier of a new unit defined in the list of unit
    definitions in the enclosing Model structure.  There are no constraints
    on the units that can be chosen from these sets.  There are no default
    units for local parameters.
    </ul>

    As with all other major SBML components, LocalParameter is derived from
    SBase, and the methods defined on SBase are available on LocalParameter.

    @warning <span class='warning'>LibSBML derives LocalParameter from
    Parameter; however, this does not precisely match the object hierarchy
    defined by SBML Level&nbsp;3, where LocalParameter is derived directly
    from SBase and not Parameter.  We believe this arrangement makes it easier
    for libSBML users to program applications that work with both SBML
    Level&nbsp;2 and SBML Level&nbsp;3, but programmers should also keep in
    mind this difference exists.  A side-effect of libSBML's scheme is that
    certain methods on LocalParameter that are inherited from Parameter do not
    actually have relevance to LocalParameter objects.  An example of this is
    the methods pertaining to Parameter's attribute 'constant' (i.e.,
    isSetConstant(), setConstant(), and getConstant()).</span>

    @see ListOfLocalParameters
    @see KineticLaw

    """
    __swig_setmethods__ = {}
    for _s in [Parameter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalParameter, name, value)
    __swig_getmethods__ = {}
    for _s in [Parameter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalParameter, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_LocalParameter
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> LocalParameter
        __init__(self, SBMLNamespaces sbmlns) -> LocalParameter
        __init__(self, LocalParameter orig) -> LocalParameter
        __init__(self, Parameter orig) -> LocalParameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>LocalParameter(SBMLNamespaces sbmlns)</pre>

        Creates a new LocalParameter object with the given SBMLNamespaces
        object @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        It is worth emphasizing that although this constructor does not take
        an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'
        (identifier) attribute of a LocalParameter is required to have a value.
        Thus, callers are cautioned to assign a value after calling this
        constructor if no identifier is provided as an argument.  Setting the
        identifier can be accomplished using the method
        @if java setId(String id)@else setId()@endif.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>LocalParameter(long level, long version)</pre>

        Creates a new LocalParameter object with the given SBML @p level and
        @p version values.

        @param level a long integer, the SBML Level to assign to this
        LocalParameter.

        @param version a long integer, the SBML Version to assign to this
        LocalParameter.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>LocalParameter(LocalParameter orig)</pre>

        Copy constructor; creates a copy of a given LocalParameter object.

        @param orig the LocalParameter instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>LocalParameter(Parameter orig)</pre>

        Copy constructor; creates a LocalParameter object by copying
        the attributes of a given Parameter object.

        @param orig the Parameter instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_LocalParameter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> LocalParameter

        Creates and returns a deep copy of this LocalParameter object.

        @return the (deep) copy of this LocalParameter object.

        """
        return _libsbml.LocalParameter_clone(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Constructs and returns a UnitDefinition that corresponds to the units
        of this LocalParameter's value.

        @par
        LocalParameters in SBML have an attribute ('units') for declaring the
        units of measurement intended for the parameter's value.  <b>No
        defaults are defined</b> by SBML in the absence of a definition for
        'units'.  This method returns a UnitDefinition object based on the
        units declared for this LocalParameter using its 'units' attribute, or
        it returns @c None if no units have been declared.

        Note that unit declarations for LocalParameter objects are specified
        in terms of the @em identifier of a unit (e.g., using setUnits()), but
        @em this method returns a UnitDefinition object, not a unit
        identifier.  It does this by constructing an appropriate
        UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even
        when the value of the 'units' attribute is one of the predefined SBML
        units @c 'substance', @c 'volume', @c 'area', @c 'length' or @c
        'time'.  Callers may find this useful in conjunction with the helper
        methods provided by the UnitDefinition class for comparing different
        UnitDefinition objects.

        @return a UnitDefinition that expresses the units of this 
        LocalParameter, or @c None if one cannot be constructed.

        @note The libSBML system for unit analysis depends on the model as a
        whole.  In cases where the LocalParameter object has not yet been
        added to a model, or the model itself is incomplete, unit analysis is
        not possible, and consequently this method will return @c None.

        @see isSetUnits()

        """
        return _libsbml.LocalParameter_getDerivedUnitDefinition(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_LOCAL_PARAMETER SBML_LOCAL_PARAMETER@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.LocalParameter_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for LocalParameter,
        is always @c 'localParameter'.

        @return the name of this element, i.e., @c 'localParameter'.

        """
        return _libsbml.LocalParameter_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        LocalParameter object have been set.

        The required attributes for a LocalParameter object are:
        @li 'id'
        @li 'value'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.LocalParameter_hasRequiredAttributes(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        @internal

        @internal

        """
        return _libsbml.LocalParameter_getConstant(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        @internal

        @internal

        """
        return _libsbml.LocalParameter_isSetConstant(self)

    def setConstant(self, *args):
        """
        setConstant(self, bool flag) -> int

        @internal

        @internal

        """
        return _libsbml.LocalParameter_setConstant(self, *args)

LocalParameter_swigregister = _libsbml.LocalParameter_swigregister
LocalParameter_swigregister(LocalParameter)

class ListOfLocalParameters(ListOfParameters):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of LocalParameter objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOfParameters]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfLocalParameters, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOfParameters]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfLocalParameters, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfLocalParameters
        __init__(self, SBMLNamespaces sbmlns) -> ListOfLocalParameters

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfLocalParameters(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfLocalParameters object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfLocalParameters object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfLocalParameters(long level, long version)</pre>

        Creates a new ListOfLocalParameters object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfLocalParameters(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfLocalParameters

        Creates and returns a deep copy of this ListOfLocalParameters object.

        @return the (deep) copy of this ListOfLocalParameters object.

        """
        return _libsbml.ListOfLocalParameters_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., LocalParameter objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf:
        @link libsbml#SBML_LOCAL_PARAMETER SBML_LOCAL_PARAMETER@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfLocalParameters_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfLocalParameters, the XML element name is @c 'listOfLocalParameters'.

        @return the name of this element, i.e., @c 'listOfLocalParameters'.

        """
        return _libsbml.ListOfLocalParameters_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> LocalParameter
        get(self, unsigned int n) -> LocalParameter
        get(self, string sid) -> LocalParameter
        get(self, string sid) -> LocalParameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Returns the LocalParameter object located at position @p n within this
        ListOfLocalParameters instance.

        @param n the index number of the LocalParameter to get.

        @return the item at position @p n.  The caller owns the returned
        object and is responsible for deleting it.  If the index number @p n
        is out of bounds for the length of the list, then @c None is returned.

        @see size()
        @see get()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Returns the first LocalParameter object matching the given identifier.

        @param sid a string representing the identifier of the LocalParameter
        to get.

        @return the LocalParameter object found.  The caller owns the returned
        object and is responsible for deleting it.  If none of the items have
        an identifier matching @p sid, then @c None is returned.

        @see get()
        @see size()

        """
        return _libsbml.ListOfLocalParameters_get(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        Note that LocalParameters, while they use the SId namespace, are not in
        the model-wide SId namespace, so no LocalParameter object will be
        returned from this function (and is the reason we override the base
        ListOf::getElementBySId function here).

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.ListOfLocalParameters_getElementBySId(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> LocalParameter
        remove(self, string sid) -> LocalParameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfLocalParameters, and returns a
        pointer to it.

        @param n the index of the item to remove.  

        @return the item removed.  The caller owns the returned object and is
        responsible for deleting it.  If the index number @p n is out of
        bounds for the length of the list, then @c None is returned.

        @see size()
        @see remove()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes the first LocalParameter object in this ListOfLocalParameters
        matching the given identifier, and returns a pointer to it.

        @param sid the identifier of the item to remove.

        @return the item removed.  The caller owns the returned object and is
        responsible for deleting it.  If none of the items have an identifier
        matching @p sid, then @c None is returned.

        """
        return _libsbml.ListOfLocalParameters_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfLocalParameters
    __del__ = lambda self : None;
ListOfLocalParameters_swigregister = _libsbml.ListOfLocalParameters_swigregister
ListOfLocalParameters_swigregister(ListOfLocalParameters)

class InitialAssignment(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML <em>initial assignment</em>, evaluated once only.

    SBML Level 2 Versions 2&ndash;4 and SBML Level&nbsp;3 provide two ways of assigning initial
    values to entities in a model.  The simplest and most basic is to set
    the values of the appropriate attributes in the relevant components; for
    example, the initial value of a model parameter (whether it is a
    constant or a variable) can be assigned by setting its 'value' attribute
    directly in the model definition.  However, this approach is not
    suitable when the value must be calculated, because the initial value
    attributes on different components such as species, compartments, and
    parameters are single values and not mathematical expressions.  In those
    situations, the InitialAssignment construct can be used; it permits the
    calculation of the value of a constant or the initial value of a
    variable from the values of @em other quantities in a model.

    As explained below, the provision of InitialAssignment does not mean
    that models necessarily must use this construct when defining initial
    values of quantities in a model.  If a value can be set directly using
    the relevant attribute of a component in a model, then that
    approach may be more efficient and more portable to other software
    tools.  InitialAssignment should be used when the other mechanism is
    insufficient for the needs of a particular model.

    The InitialAssignment construct has some similarities to AssignmentRule.
    The main differences are: (a) an InitialAssignment can set the value of
    a constant whereas an AssignmentRule cannot, and (b) unlike
    AssignmentRule, an InitialAssignment definition only applies up to and
    including the beginning of simulation time, i.e., <em>t <= 0</em>,
    while an AssignmentRule applies at all times.

    InitialAssignment has a required attribute, 'symbol', whose value must
    follow the guidelines for identifiers described in the %SBML
    specification (e.g., Section 3.3 in the Level 2 Version 4
    specification).  The value of this attribute in an InitialAssignment
    object can be the identifier of a Compartment, Species or global
    Parameter elsewhere in the model.  The InitialAssignment defines the
    initial value of the constant or variable referred to by the 'symbol'
    attribute.  (The attribute's name is 'symbol' rather than 'variable'
    because it may assign values to constants as well as variables in a
    model.)  Note that an initial assignment cannot be made to reaction
    identifiers, that is, the 'symbol' attribute value of an
    InitialAssignment cannot be an identifier that is the 'id' attribute
    value of a Reaction object in the model.  This is identical to a
    restriction placed on rules.

    InitialAssignment also has a required 'math' subelement that contains a
    MathML expression used to calculate the value of the constant or the
    initial value of the variable.  The units of the value computed by the
    formula in the 'math' subelement should (in SBML Level&nbsp;2
    Version&nbsp;4 and in SBML Level&nbsp;3) or must (in previous Versions) be identical to be the
    units associated with the identifier given in the 'symbol' attribute.
    (That is, the units are the units of the species, compartment, or
    parameter, as appropriate for the kind of object identified by the value
    of 'symbol'.)

    InitialAssignment was introduced in SBML Level 2 Version 2.  It is not
    available in SBML Level&nbsp;2 Version&nbsp;1 nor in any version of Level 1.

    @section initassign-semantics Semantics of Initial Assignments

    The value calculated by an InitialAssignment object overrides the value
    assigned to the given symbol by the object defining that symbol.  For
    example, if a compartment's 'size' attribute is set in its definition,
    and the model also contains an InitialAssignment having that
    compartment's identifier as its 'symbol' attribute value, then the
    interpretation is that the 'size' assigned in the Compartment object
    should be ignored and the value assigned based on the computation
    defined in the InitialAssignment.  Initial assignments can take place
    for Compartment, Species and global Parameter objects regardless of the
    value of their 'constant' attribute.

    The actions of all InitialAssignment objects are in general terms
    the same, but differ in the precise details depending on the type
    of variable being set:
    <ul>
    <li> <em>In the case of a species</em>, an InitialAssignment sets the
    referenced species' initial quantity (concentration or amount of
    substance) to the value determined by the formula in the 'math'
    subelement.    The overall units of the formula should (in SBML
    Level&nbsp;2 Version&nbsp;4 and in SBML Level&nbsp;3) or must (in previous Versions) be the same
    as the units specified for the species.

    <li> <em>In the case of a compartment</em>, an InitialAssignment sets
    the referenced compartment's initial size to the size determined by the
    formula in 'math'.  The overall units of the formula should (in SBML
    Level&nbsp;2 Version&nbsp;4 and in SBML Level&nbsp;3) or must (in previous Versions) be the same
    as the units specified for the size of the compartment.

    <li> <em>In the case of a parameter</em>, an InitialAssignment sets the
    referenced parameter's initial value to that determined by the formula
    in 'math'.  The overall units of the formula should (in SBML
    Level&nbsp;2 Version&nbsp;4 and SBML Level&nbsp;3) or must (in previous Versions) be the same
    as the units defined for the parameter.  </ul>

    In the context of a simulation, initial assignments establish values
    that are in effect prior to and including the start of simulation time,
    i.e., <em>t <= 0</em>.  Section 3.4.8 in the SBML Level 2
    Version 4  and SBML Level&nbsp;3 Version&nbsp;1 Core specifications provides information about the interpretation of
    assignments, rules, and entity values for simulation time up to and
    including the start time <em>t = 0</em>; this is important for
    establishing the initial conditions of a simulation if the model
    involves expressions containing the <em>delay</em> 'csymbol'.

    There cannot be two initial assignments for the same symbol in a model;
    that is, a model must not contain two or more InitialAssignment objects
    that both have the same identifier as their 'symbol' attribute value.  A
    model must also not define initial assignments <em>and</em> assignment
    rules for the same entity.  That is, there cannot be <em>both</em> an
    InitialAssignment and an AssignmentRule for the same symbol in a model,
    because both kinds of constructs apply prior to and at the start of
    simulated time---allowing both to exist for a given symbol would
    result in indeterminism).

    The ordering of InitialAssignment objects is not significant.  The
    combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects form a set of assignment statements that must be considered as a
    whole.  The combined set of assignment statements should not contain
    algebraic loops: a chain of dependency between these statements should
    terminate.  (More formally, consider the directed graph of assignment
    statements where nodes are a model's assignment statements and directed
    arcs exist for each occurrence of a symbol in an assignment statement
    'math' attribute.  The directed arcs in this graph start from the
    statement assigning the symbol and end at the statement that contains
    the symbol in their math elements.  Such a graph must be acyclic.)

    Finally, it is worth being explicit about the expected behavior in the
    following situation.  Suppose (1) a given symbol has a value <em>x</em>
    assigned to it in its definition, and (2) there is an initial assignment
    having the identifier as its 'symbol' value and reassigning the value to
    <em>y</em>, <em>and</em> (3) the identifier is also used in the
    mathematical formula of a second initial assignment.  What value should
    the second initial assignment use?  It is <em>y</em>, the value assigned
    to the symbol by the first initial assignment, not whatever value was
    given in the symbol's definition.  This follows directly from the
    behavior described above: if an InitialAssignment object exists for a
    given symbol, then the symbol's value is overridden by that initial
    assignment.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitialAssignment, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitialAssignment, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_InitialAssignment
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> InitialAssignment
        __init__(self, SBMLNamespaces sbmlns) -> InitialAssignment
        __init__(self, InitialAssignment orig) -> InitialAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>InitialAssignment(SBMLNamespaces sbmlns)</pre>

        Creates a new InitialAssignment using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute. 
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>InitialAssignment(long level, long version)</pre>

        Creates a new InitialAssignment using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this InitialAssignment

        @param version a long integer, the SBML Version to assign to this
        InitialAssignment

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>InitialAssignment(InitialAssignment orig)</pre>

        Copy constructor; creates a copy of this InitialAssignment.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_InitialAssignment(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> InitialAssignment

        Creates and returns a deep copy of this InitialAssignment object.

        @return the (deep) copy of this InitialAssignment object.

        """
        return _libsbml.InitialAssignment_clone(self)

    def getSymbol(self):
        """
        getSymbol(self) -> string

        Get the value of the 'symbol' attribute of this InitialAssignment.

        @return the identifier string stored as the 'symbol' attribute value
        in this InitialAssignment.

        """
        return _libsbml.InitialAssignment_getSymbol(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula of this InitialAssignment.

        @return an ASTNode, the value of the 'math' subelement of this
        InitialAssignment

        """
        return _libsbml.InitialAssignment_getMath(self)

    def isSetSymbol(self):
        """
        isSetSymbol(self) -> bool

        Predicate returning @c True if this
        InitialAssignment's 'symbol' attribute is set.

        @return @c True if the 'symbol' attribute of this InitialAssignment
        is set, @c False otherwise.

        """
        return _libsbml.InitialAssignment_isSetSymbol(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c True if this
        InitialAssignment's 'math' subelement contains a value.

        @return @c True if the 'math' for this InitialAssignment is set,
        @c False otherwise.

        """
        return _libsbml.InitialAssignment_isSetMath(self)

    def setSymbol(self, *args):
        """
        setSymbol(self, string sid) -> int

        Sets the 'symbol' attribute value of this InitialAssignment.

        @param sid the identifier of a Species, Compartment or Parameter
        object defined elsewhere in this Model.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.InitialAssignment_setSymbol(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this InitialAssignment.

        The AST passed in @p math is copied.

        @param math an AST containing the mathematical expression to
        be used as the formula for this InitialAssignment.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.InitialAssignment_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units
        of measurement assumed for the 'math' expression of this
        InitialAssignment.

        @par
        The units are calculated based on the mathematical expression in the
        InitialAssignment and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The method
        InitialAssignment.getDerivedUnitDefinition() returns the calculated
        units, to the extent that libSBML can compute them.

        @note The functionality that facilitates unit analysis depends on the
        model as a whole.  Thus, in cases where the object has not been added to
        a model or the model itself is incomplete, unit analysis is not possible
        and this method will return @c None. 

        @warning <span class='warning'>Note that it is possible the 'math'
        expression in the InitialAssignment contains literal numbers or parameters
        with undeclared units.  In those cases, it is not possible to calculate
        the units of the overall expression without making assumptions.  LibSBML
        does not make assumptions about the units, and
        InitialAssignment.getDerivedUnitDefinition() only returns the units as
        far as it is able to determine them.  For example, in an expression <em>X
        + Y</em>, if <em>X</em> has unambiguously-defined units and <em>Y</em>
        does not, it will return the units of <em>X</em>.  When using this method,
        <strong>it is critical that callers also invoke the method</strong>
        InitialAssignment.containsUndeclaredUnits() <strong>to determine whether
        this situation holds</strong>.  Callers should take suitable action in
        those situations.</span>

        @return a UnitDefinition that expresses the units of the math 
        expression of this InitialAssignment, or @c None if one cannot be constructed.

        @see containsUndeclaredUnits()

        """
        return _libsbml.InitialAssignment_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c True if the math expression of this
        InitialAssignment contains parameters/numbers with undeclared units.

        @return @c True if the math expression of this InitialAssignment
        includes parameters/numbers 
        with undeclared units, @c False otherwise.

        @note A return value of @c True indicates that the UnitDefinition
        returned by InitialAssignment::getDerivedUnitDefinition may not
        accurately represent the units of the expression.

        @see getDerivedUnitDefinition()

        """
        return _libsbml.InitialAssignment_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_INITIAL_ASSIGNMENT SBML_INITIAL_ASSIGNMENT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.InitialAssignment_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        InitialAssignment, is always @c 'initialAssignment'.

        @return the name of this element, i.e., @c 'initialAssignment'.

        """
        return _libsbml.InitialAssignment_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        InitialAssignment object have been set.

        The required attributes for an InitialAssignment object are:
        @li 'symbol'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.InitialAssignment_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if all the required elements for this
        InitialAssignment object have been set.

        @note The required elements for a InitialAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.InitialAssignment_hasRequiredElements(self)

    def getId(self):
        """
        getId(self) -> string

        @internal

        @internal

        """
        return _libsbml.InitialAssignment_getId(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.InitialAssignment_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.InitialAssignment_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.InitialAssignment_replaceSIDWithFunction(self, *args)

    def divideAssignmentsToSIdByFunction(self, *args):
        """
        divideAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing/function).

        @internal

        """
        return _libsbml.InitialAssignment_divideAssignmentsToSIdByFunction(self, *args)

    def multiplyAssignmentsToSIdByFunction(self, *args):
        """
        multiplyAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing*function).

        @internal

        """
        return _libsbml.InitialAssignment_multiplyAssignmentsToSIdByFunction(self, *args)

InitialAssignment_swigregister = _libsbml.InitialAssignment_swigregister
InitialAssignment_swigregister(InitialAssignment)

class ListOfInitialAssignments(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of InitialAssignment objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfInitialAssignments, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfInitialAssignments, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfInitialAssignments
        __init__(self, SBMLNamespaces sbmlns) -> ListOfInitialAssignments

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfInitialAssignments(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfInitialAssignments object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfInitialAssignments object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfInitialAssignments(long level, long version)</pre>

        Creates a new ListOfInitialAssignments object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfInitialAssignments(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfInitialAssignments

        Creates and returns a deep copy of this ListOfInitialAssignments object.

        @return the (deep) copy of this ListOfInitialAssignments object.

        """
        return _libsbml.ListOfInitialAssignments_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., InitialAssignment objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf:
        @link libsbml#SBML_INITIAL_ASSIGNMENT SBML_INITIAL_ASSIGNMENT@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfInitialAssignments_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfInitialAssignments, the XML element name is @c
        'listOfInitialAssignments'.

        @return the name of this element, i.e., @c 'listOfInitialAssignments'.

        """
        return _libsbml.ListOfInitialAssignments_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> InitialAssignment
        get(self, unsigned int n) -> InitialAssignment
        get(self, string sid) -> InitialAssignment
        get(self, string sid) -> InitialAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a InitialAssignment from the ListOfInitialAssignments.

        @param n the index number of the InitialAssignment to get.

        @return the nth InitialAssignment in this ListOfInitialAssignments.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a InitialAssignment from the ListOfInitialAssignments
        based on its identifier.

        @param sid a string representing the identifier 
        of the InitialAssignment to get.

        @return InitialAssignment in this ListOfInitialAssignments
        with the given @p sid or @c None if no such
        InitialAssignment exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfInitialAssignments_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> InitialAssignment
        remove(self, string sid) -> InitialAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfInitialAssignments items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfInitialAssignments items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfInitialAssignments_remove(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        Note that InitialAssignments do not actually have IDs, though the
        libsbml interface pretends that they do: no initial assignment is
        returned by this function.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.ListOfInitialAssignments_getElementBySId(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfInitialAssignments
    __del__ = lambda self : None;
ListOfInitialAssignments_swigregister = _libsbml.ListOfInitialAssignments_swigregister
ListOfInitialAssignments_swigregister(ListOfInitialAssignments)

RULE_TYPE_RATE = _libsbml.RULE_TYPE_RATE
RULE_TYPE_SCALAR = _libsbml.RULE_TYPE_SCALAR
RULE_TYPE_INVALID = _libsbml.RULE_TYPE_INVALID
class Rule(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Parent class for SBML <em>rules</em> in libSBML.

    In SBML, @em rules provide additional ways to define the values of
    variables in a model, their relationships, and the dynamical behaviors
    of those variables.  They enable encoding relationships that cannot be
    expressed using Reaction nor InitialAssignment objects alone.

    The libSBML implementation of rules mirrors the SBML Level&nbsp;3
    Version&nbsp;1 Core definition (which is in turn is very similar to the
    Level&nbsp;2 Version&nbsp;4 definition), with Rule being the parent
    class of three subclasses as explained below.  The Rule class itself
    cannot be instantiated by user programs and has no constructor; only the
    subclasses AssignmentRule, AlgebraicRule and RateRule can be
    instantiated directly.

    @section rules-general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into three
    subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible functional
    forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary
    function returning a numerical result, <b><em>V</em></b> is a vector of
    variables that does not include <em>x</em>, and <b><em>W</em></b> is a
    vector of variables that may include <em>x</em>):

    <table border='0' cellpadding='0' class='centered' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    @li <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)
    @li SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.

    @li Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;

    @li Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and

    @li Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section rules-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection rules-no-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops---dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection rules-not-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in
    Appendix&nbsp;B of the SBML Level&nbsp;3 Version&nbsp;1 Core
    specification for assessing whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)

    @section RuleType_t Rule types for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for
    distinguishing rules; specifically, it uses an attribute whose value is
    drawn from an enumeration of 3 values.  LibSBML supports this using methods
    that work @if clike a libSBML enumeration type, RuleType_t, whose values
    are @else with the enumeration values @endif@~ listed below.

    @li @link libsbml#RULE_TYPE_RATE RULE_TYPE_RATE@endlink: Indicates
    the rule is a 'rate' rule.
    @li @link libsbml#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink:
    Indicates the rule is a 'scalar' rule.
    @li @link libsbml#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink:
    Indicates the rule type is unknown or not yet set.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rule, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Rule, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Rule
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, Rule orig) -> Rule

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html Parent class for SBML <em>rules</em> in libSBML.

        In SBML, @em rules provide additional ways to define the values of
        variables in a model, their relationships, and the dynamical behaviors
        of those variables.  They enable encoding relationships that cannot be
        expressed using Reaction nor InitialAssignment objects alone.

        The libSBML implementation of rules mirrors the SBML Level&nbsp;3
        Version&nbsp;1 Core definition (which is in turn is very similar to the
        Level&nbsp;2 Version&nbsp;4 definition), with Rule being the parent
        class of three subclasses as explained below.  The Rule class itself
        cannot be instantiated by user programs and has no constructor; only the
        subclasses AssignmentRule, AlgebraicRule and RateRule can be
        instantiated directly.

        @section rules-general General summary of SBML rules

        In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into three
        subclasses for the benefit of model analysis software.  The three
        subclasses are based on the following three different possible functional
        forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary
        function returning a numerical result, <b><em>V</em></b> is a vector of
        variables that does not include <em>x</em>, and <b><em>W</em></b> is a
        vector of variables that may include <em>x</em>):

        <table border='0' cellpadding='0' class='centered' style='font-size: small'>
        <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
        <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
        <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
        </table>

        In their general form given above, there is little to distinguish
        between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
        separate cases for the following reasons:

        @li <em>Assignment</em> rules can simply be evaluated to calculate
        intermediate values for use in numerical methods.  They are statements
        of equality that hold at all times.  (For assignments that are only
        performed once, see InitialAssignment.)
        @li SBML needs to place restrictions on assignment rules, for example
        the restriction that assignment rules cannot contain algebraic loops.

        @li Some simulators do not contain numerical solvers capable of solving
        unconstrained algebraic equations, and providing more direct forms such
        as assignment rules may enable those simulators to process models they
        could not process if the same assignments were put in the form of
        general algebraic equations;

        @li Those simulators that <em>can</em> solve these algebraic equations make a
        distinction between the different categories listed above; and

        @li Some specialized numerical analyses of models may only be applicable
        to models that do not contain <em>algebraic</em> rules.

        The approach taken to covering these cases in SBML is to define an
        abstract Rule structure containing a subelement, 'math', to hold the
        right-hand side expression, then to derive subtypes of Rule that add
        attributes to distinguish the cases of algebraic, assignment and rate
        rules.  The 'math' subelement must contain a MathML expression defining the
        mathematical formula of the rule.  This MathML formula must return a
        numerical value.  The formula can be an arbitrary expression referencing
        the variables and other entities in an SBML model.

        Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
        RateRule) inherit the the 'math' subelement and other fields from SBase.
        The AssignmentRule and RateRule classes add an additional attribute,
        'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
        RateRule for details about the structure and interpretation of each one.

        @section rules-restrictions Additional restrictions on SBML rules

        An important design goal of SBML rule semantics is to ensure that a
        model's simulation and analysis results will not be dependent on when or
        how often rules are evaluated.  To achieve this, SBML needs to place two
        restrictions on rule use.  The first concerns algebraic loops in the system
        of assignments in a model, and the second concerns overdetermined systems.

        @subsection rules-no-loops A model must not contain algebraic loops

        The combined set of InitialAssignment, AssignmentRule and KineticLaw
        objects in a model constitute a set of assignment statements that should be
        considered as a whole.  (A KineticLaw object is counted as an assignment
        because it assigns a value to the symbol contained in the 'id' attribute of
        the Reaction object in which it is defined.)  This combined set of
        assignment statements must not contain algebraic loops---dependency
        chains between these statements must terminate.  To put this more formally,
        consider a directed graph in which nodes are assignment statements and
        directed arcs exist for each occurrence of an SBML species, compartment or
        parameter symbol in an assignment statement's 'math' subelement.  Let the
        directed arcs point from the statement assigning the symbol to the
        statements that contain the symbol in their 'math' subelement expressions.
        This graph must be acyclic.

        SBML does not specify when or how often rules should be evaluated.
        Eliminating algebraic loops ensures that assignment statements can be
        evaluated any number of times without the result of those evaluations
        changing.  As an example, consider the set of equations <em>x = x + 1</em>,
        <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
        were interpreted as a set of assignment statements, it would be invalid
        because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
        of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
        for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
        Conversely, the following set of equations would constitute a valid set of
        assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
        + 100</em>.

        @subsection rules-not-overdetermined A model must not be overdetermined

        An SBML model must not be overdetermined; that is, a model must not
        define more equations than there are unknowns in a model.  An SBML model
        that does not contain AlgebraicRule structures cannot be overdetermined.

        LibSBML implements the static analysis procedure described in
        Appendix&nbsp;B of the SBML Level&nbsp;3 Version&nbsp;1 Core
        specification for assessing whether a model is overdetermined.

        (In summary, assessing whether a given continuous, deterministic,
        mathematical model is overdetermined does not require dynamic analysis; it
        can be done by analyzing the system of equations created from the model.
        One approach is to construct a bipartite graph in which one set of vertices
        represents the variables and the other the set of vertices represents the
        equations.  Place edges between vertices such that variables in the system
        are linked to the equations that determine them.  For algebraic equations,
        there will be edges between the equation and each variable occurring in the
        equation.  For ordinary differential equations (such as those defined by
        rate rules or implied by the reaction rate definitions), there will be a
        single edge between the equation and the variable determined by that
        differential equation.  A mathematical model is overdetermined if the
        maximal matchings of the bipartite graph contain disconnected vertexes
        representing equations.  If one maximal matching has this property, then
        all the maximal matchings will have this property; i.e., it is only
        necessary to find one maximal matching.)

        @section RuleType_t Rule types for SBML Level 1

        SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for
        distinguishing rules; specifically, it uses an attribute whose value is
        drawn from an enumeration of 3 values.  LibSBML supports this using methods
        that work @if clike a libSBML enumeration type, RuleType_t, whose values
        are @else with the enumeration values @endif@~ listed below.

        @li @link libsbml#RULE_TYPE_RATE RULE_TYPE_RATE@endlink: Indicates
        the rule is a 'rate' rule.
        @li @link libsbml#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink:
        Indicates the rule is a 'scalar' rule.
        @li @link libsbml#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink:
        Indicates the rule type is unknown or not yet set.

        """
        this = _libsbml.new_Rule(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Rule

        Creates and returns a deep copy of this Rule object.

        @return the (deep) copy of this Rule object.

        """
        return _libsbml.Rule_clone(self)

    def getFormula(self):
        """
        getFormula(self) -> string

        Returns the mathematical expression of this Rule in text-string form.

        The text string is produced by
        @if java <code><a href='libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)'>libsbml.formulaToString()</a></code>@else SBML_formulaToString()@endif; please consult
        the documentation for that function to find out more about the format
        of the text-string formula.

        @return the formula text string for this Rule.

        @note The attribute 'formula' is specific to SBML Level&nbsp;1; in
        higher Levels of SBML, it has been replaced with a subelement named
        'math'.  However, libSBML provides a unified interface to the
        underlying math expression and this method can be used for models
        of all Levels of SBML.

        @see getMath()

        """
        return _libsbml.Rule_getFormula(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula of this Rule as an ASTNode tree.

        @return an ASTNode, the value of the 'math' subelement of this Rule.

        @note The subelement 'math' is present in SBML Levels&nbsp;2
        and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the
        attribute named 'formula'.  LibSBML provides a unified interface to
        the underlying math expression and this method can be used for models
        of all Levels of SBML.

        @see getFormula()

        """
        return _libsbml.Rule_getMath(self)

    def getVariable(self):
        """
        getVariable(self) -> string

        Get the value of the 'variable' attribute of this Rule object.

        @par
        In SBML Level&nbsp;1, the different rule types each have a different
        name for the attribute holding the reference to the object constituting
        the left-hand side of the rule.  (E.g., for SBML Level&nbsp;1's
        SpeciesConcentrationRule the attribute is 'species', for
        CompartmentVolumeRule it is 'compartment', etc.)  In SBML Levels&nbsp;2
        and&nbsp;3, the only two types of Rule objects with a left-hand side
        object reference are AssignmentRule and RateRule, and both of them use the
        same name for attribute: 'variable'.  In order to make it easier for
        application developers to work with all Levels of SBML, libSBML uses a
        uniform name for all such attributes, and it is 'variable', regardless of
        whether Level&nbsp;1 rules or Level&nbsp;2&ndash;3 rules are being used.

        @return the identifier string stored as the 'variable' attribute value
        in this Rule, or @c None if this object is an AlgebraicRule object.

        """
        return _libsbml.Rule_getVariable(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Returns the units for the
        mathematical formula of this Rule.

        @return the identifier of the units for the expression of this Rule.

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.

        """
        return _libsbml.Rule_getUnits(self)

    def isSetFormula(self):
        """
        isSetFormula(self) -> bool

        Predicate returning @c True if this Rule's mathematical expression is
        set.

        This method is equivalent to isSetMath().  This version is present for
        easier compatibility with SBML Level&nbsp;1, in which mathematical
        formulas were written in text-string form.

        @return @c True if the mathematical formula for this Rule is
        set, @c False otherwise.

        @note The attribute 'formula' is specific to SBML Level&nbsp;1; in
        higher Levels of SBML, it has been replaced with a subelement named
        'math'.  However, libSBML provides a unified interface to the
        underlying math expression and this method can be used for models
        of all Levels of SBML.

        @see isSetMath()

        """
        return _libsbml.Rule_isSetFormula(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c True if this Rule's mathematical expression is
        set.

        This method is equivalent to isSetFormula().

        @return @c True if the formula (or equivalently the math) for this
        Rule is set, @c False otherwise.

        @note The subelement 'math' is present in SBML Levels&nbsp;2
        and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the
        attribute named 'formula'.  LibSBML provides a unified interface to
        the underlying math expression and this method can be used for models
        of all Levels of SBML.

        @see isSetFormula()

        """
        return _libsbml.Rule_isSetMath(self)

    def isSetVariable(self):
        """
        isSetVariable(self) -> bool

        Predicate returning @c True if this Rule's 'variable' attribute is set.

        @par
        In SBML Level&nbsp;1, the different rule types each have a different
        name for the attribute holding the reference to the object constituting
        the left-hand side of the rule.  (E.g., for SBML Level&nbsp;1's
        SpeciesConcentrationRule the attribute is 'species', for
        CompartmentVolumeRule it is 'compartment', etc.)  In SBML Levels&nbsp;2
        and&nbsp;3, the only two types of Rule objects with a left-hand side
        object reference are AssignmentRule and RateRule, and both of them use the
        same name for attribute: 'variable'.  In order to make it easier for
        application developers to work with all Levels of SBML, libSBML uses a
        uniform name for all such attributes, and it is 'variable', regardless of
        whether Level&nbsp;1 rules or Level&nbsp;2&ndash;3 rules are being used.

        @return @c True if the 'variable' attribute value of this Rule is
        set, @c False otherwise.

        """
        return _libsbml.Rule_isSetVariable(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Predicate returning @c True if this Rule's 'units' attribute is set.

        @return @c True if the units for this Rule is set, @c False
        otherwise

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.

        """
        return _libsbml.Rule_isSetUnits(self)

    def setFormula(self, *args):
        """
        setFormula(self, string formula) -> int

        Sets the 'math' subelement of this Rule to an expression in text-string
        form.

        This is equivalent to setMath(ASTNode math).  The provision of
        using text-string formulas is retained for easier SBML Level&nbsp;1
        compatibility.  The formula is converted to an ASTNode internally.

        @param formula a mathematical formula in text-string form.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note The attribute 'formula' is specific to SBML Level&nbsp;1; in
        higher Levels of SBML, it has been replaced with a subelement named
        'math'.  However, libSBML provides a unified interface to the
        underlying math expression and this method can be used for models
        of all Levels of SBML.

        @see setMath()

        """
        return _libsbml.Rule_setFormula(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this Rule to a copy of the given
        ASTNode.

        @param math the ASTNode_t structure of the mathematical formula.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note The subelement 'math' is present in SBML Levels&nbsp;2
        and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the
        attribute named 'formula'.  LibSBML provides a unified interface to
        the underlying math expression and this method can be used for models
        of all Levels of SBML.

        @see setFormula()

        """
        return _libsbml.Rule_setMath(self, *args)

    def setVariable(self, *args):
        """
        setVariable(self, string sid) -> int

        Sets the 'variable' attribute value of this Rule object.

        @par
        In SBML Level&nbsp;1, the different rule types each have a different
        name for the attribute holding the reference to the object constituting
        the left-hand side of the rule.  (E.g., for SBML Level&nbsp;1's
        SpeciesConcentrationRule the attribute is 'species', for
        CompartmentVolumeRule it is 'compartment', etc.)  In SBML Levels&nbsp;2
        and&nbsp;3, the only two types of Rule objects with a left-hand side
        object reference are AssignmentRule and RateRule, and both of them use the
        same name for attribute: 'variable'.  In order to make it easier for
        application developers to work with all Levels of SBML, libSBML uses a
        uniform name for all such attributes, and it is 'variable', regardless of
        whether Level&nbsp;1 rules or Level&nbsp;2&ndash;3 rules are being used.

        @param sid the identifier of a Compartment, Species or Parameter
        elsewhere in the enclosing Model object.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.Rule_setVariable(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string sname) -> int

        Sets the units for this Rule.

        @param sname the identifier of the units

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.

        """
        return _libsbml.Rule_setUnits(self, *args)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the 'units' for this Rule.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule
        objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.

        """
        return _libsbml.Rule_unsetUnits(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units of
        measurement assumed for the 'math' expression of this Rule.

        @par
        The units are calculated based on the mathematical expression in the
        Rule and the model quantities referenced by <code>&lt;ci&gt;</code>
        elements used within that expression.  The method
        Rule.getDerivedUnitDefinition() returns the calculated units, to the
        extent that libSBML can compute them. 

        @note The functionality that facilitates unit analysis depends on the
        model as a whole.  Thus, in cases where the object has not been added to
        a model or the model itself is incomplete, unit analysis is not possible
        and this method will return @c None. 

        @warning <span class='warning'>Note that it is possible the 'math'
        expression in the Rule contains pure numbers or parameters with undeclared
        units.  In those cases, it is not possible to calculate the units of the
        overall expression without making assumptions.  LibSBML does not make
        assumptions about the units, and Rule.getDerivedUnitDefinition() only
        returns the units as far as it is able to determine them.  For example, in
        an expression <em>X + Y</em>, if <em>X</em> has unambiguously-defined
        units and <em>Y</em> does not, it will return the units of <em>X</em>.
        <strong>It is important that callers also invoke the method</strong>
        Rule.containsUndeclaredUnits() <strong>to determine whether this
        situation holds</strong>.  Callers may wish to take suitable actions in
        those scenarios.</span>

        @return a UnitDefinition that expresses the units of the math 
        expression of this Rule, or @c None if one cannot be constructed.

        @see containsUndeclaredUnits()

        """
        return _libsbml.Rule_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c True if the math expression of this Rule contains
        parameters/numbers with undeclared units.

        @return @c True if the math expression of this Rule includes
        parameters/numbers with undeclared units, @c False otherwise.

        @note A return value of @c True indicates that the UnitDefinition
        returned by getDerivedUnitDefinition() may not accurately represent
        the units of the expression.

        @see getDerivedUnitDefinition()

        """
        return _libsbml.Rule_containsUndeclaredUnits(self, *args)

    def getType(self):
        """
        getType(self) -> RuleType_t

        Returns a code representing the type of rule this is.

        @return the rule type, which will be one of the following three possible
        values:
        @li @link libsbml#RULE_TYPE_RATE RULE_TYPE_RATE@endlink
        @li @link libsbml#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink
        @li @link libsbml#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink

        @note The attribute 'type' on Rule objects is present only in SBML
        Level&nbsp;1.  In SBML Level&nbsp;2 and later, the type has been
        replaced by subclassing the Rule object.

        """
        return _libsbml.Rule_getType(self)

    def isAlgebraic(self):
        """
        isAlgebraic(self) -> bool

        Predicate returning @c True if this Rule is an AlgebraicRule.

        @return @c True if this Rule is an AlgebraicRule, @c False otherwise.

        """
        return _libsbml.Rule_isAlgebraic(self)

    def isAssignment(self):
        """
        isAssignment(self) -> bool

        Predicate returning @c True if this Rule is an AssignmentRule.

        @return @c True if this Rule is an AssignmentRule, @c False otherwise.

        """
        return _libsbml.Rule_isAssignment(self)

    def isCompartmentVolume(self):
        """
        isCompartmentVolume(self) -> bool

        Predicate returning @c True if this Rule is an CompartmentVolumeRule
        or equivalent.

        This libSBML method works for SBML Level&nbsp;1 models (where there is
        such a thing as an explicit CompartmentVolumeRule), as well as other Levels of
        SBML.  For Levels above Level&nbsp;1, this method checks the symbol
        being affected by the rule, and returns @c True if the symbol is the
        identifier of a Compartment object defined in the model.

        @return @c True if this Rule is a CompartmentVolumeRule, @c False
        otherwise.

        """
        return _libsbml.Rule_isCompartmentVolume(self)

    def isParameter(self):
        """
        isParameter(self) -> bool

        Predicate returning @c True if this Rule is an ParameterRule or
        equivalent.

        This libSBML method works for SBML Level&nbsp;1 models (where there is
        such a thing as an explicit ParameterRule), as well as other Levels of
        SBML.  For Levels above Level&nbsp;1, this method checks the symbol
        being affected by the rule, and returns @c True if the symbol is the
        identifier of a Parameter object defined in the model.

        @return @c True if this Rule is a ParameterRule, @c False
        otherwise.

        """
        return _libsbml.Rule_isParameter(self)

    def isRate(self):
        """
        isRate(self) -> bool

        Predicate returning @c True if this Rule is a RateRule (SBML
        Levels&nbsp;2&ndash;3) or has a 'type' attribute value of @c 'rate'
        (SBML Level&nbsp;1).

        @return @c True if this Rule is a RateRule (Level&nbsp;2) or has
        type 'rate' (Level&nbsp;1), @c False otherwise.

        """
        return _libsbml.Rule_isRate(self)

    def isScalar(self):
        """
        isScalar(self) -> bool

        Predicate returning @c True if this Rule is an AssignmentRule (SBML
        Levels&nbsp;2&ndash;3) or has a 'type' attribute value of @c 'scalar'
        (SBML Level&nbsp;1).

        @return @c True if this Rule is an AssignmentRule (Level&nbsp;2) or has
        type 'scalar' (Level&nbsp;1), @c False otherwise.

        """
        return _libsbml.Rule_isScalar(self)

    def isSpeciesConcentration(self):
        """
        isSpeciesConcentration(self) -> bool

        Predicate returning @c True if this Rule is a SpeciesConcentrationRule
        or equivalent.

        This libSBML method works for SBML Level&nbsp;1 models (where there is
        such a thing as an explicit SpeciesConcentrationRule), as well as
        other Levels of SBML.  For Levels above Level&nbsp;1, this method
        checks the symbol being affected by the rule, and returns @c True if
        the symbol is the identifier of a Species object defined in the model.

        @return @c True if this Rule is a SpeciesConcentrationRule, @c False
        otherwise.

        """
        return _libsbml.Rule_isSpeciesConcentration(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object, either
        @link libsbml#SBML_ASSIGNMENT_RULE SBML_ASSIGNMENT_RULE@endlink,
        @link libsbml#SBML_RATE_RULE SBML_RATE_RULE@endlink, or
        @link libsbml#SBML_ALGEBRAIC_RULE SBML_ALGEBRAIC_RULE@endlink 
        for %SBML Core.

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Rule_getTypeCode(self)

    def getL1TypeCode(self):
        """
        getL1TypeCode(self) -> int

        Returns the SBML Level&nbsp;1 type code for this Rule object.

        This method only applies to SBML Level&nbsp;1 model objects.  If this is
        not an SBML Level&nbsp;1 rule object, this method will return
        @link libsbml#SBML_UNKNOWN SBML_UNKNOWN@endlink.

        @return the SBML Level&nbsp;1 type code for this Rule (namely,
        @link libsbml#SBML_COMPARTMENT_VOLUME_RULE SBML_COMPARTMENT_VOLUME_RULE@endlink,
        @link libsbml#SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink,
        @link libsbml#SBML_SPECIES_CONCENTRATION_RULE SBML_SPECIES_CONCENTRATION_RULE@endlink, or
        @link libsbml#SBML_UNKNOWN SBML_UNKNOWN@endlink).

        """
        return _libsbml.Rule_getL1TypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        The returned value can be any of a number of different strings,
        depending on the SBML Level in use and the kind of Rule object this
        is.  The rules as of libSBML version @htmlinclude libsbml-version.html
        are the following:
        <ul>
        <li> (Level&nbsp;2 and&nbsp;3) RateRule: returns @c 'rateRule'
        <li> (Level&nbsp;2 and&nbsp;3) AssignmentRule: returns @c 'assignmentRule' 
        <li> (Level&nbsp;2 and&nbsp;3) AlgebraicRule: returns @c 'algebraicRule'
        <li> (Level&nbsp;1 Version&nbsp;1) SpecieConcentrationRule: returns @c 'specieConcentrationRule'
        <li> (Level&nbsp;1 Version&nbsp;2) SpeciesConcentrationRule: returns @c 'speciesConcentrationRule'
        <li> (Level&nbsp;1) CompartmentVolumeRule: returns @c 'compartmentVolumeRule'
        <li> (Level&nbsp;1) ParameterRule: returns @c 'parameterRule'
        <li> Unknown rule type: returns @c 'unknownRule'
        </ul>

        Beware that the last (@c 'unknownRule') is not a valid SBML element
        name.

        @return the name of this element

        """
        return _libsbml.Rule_getElementName(self)

    def setL1TypeCode(self, *args):
        """
        setL1TypeCode(self, int type) -> int

        Sets the SBML Level&nbsp;1 type code for this Rule.

        @param type the SBML Level&nbsp;1 type code for this Rule. The allowable
        values are @link libsbml#SBML_COMPARTMENT_VOLUME_RULE SBML_COMPARTMENT_VOLUME_RULE@endlink,
        @link libsbml#SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, and
        @link libsbml#SBML_SPECIES_CONCENTRATION_RULE SBML_SPECIES_CONCENTRATION_RULE@endlink.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        if given @p type value is not one of the above.

        """
        return _libsbml.Rule_setL1TypeCode(self, *args)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if all the required elements for this Rule
        object have been set.

        The only required element for a Rule object is the 'math' subelement.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.Rule_hasRequiredElements(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this Rule
        object have been set.

        The required attributes for a Rule object depend on the type of Rule
        it is.  For AssignmentRule and RateRule objects (and SBML
        Level&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and
        ParameterRule objects), the required attribute is 'variable'; for
        AlgebraicRule objects, there is no required attribute.

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Rule_hasRequiredAttributes(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Rule_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Rule_renameUnitSIdRefs(self, *args)

    def getId(self):
        """
        getId(self) -> string

        @internal

        @internal

        """
        return _libsbml.Rule_getId(self)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.Rule_replaceSIDWithFunction(self, *args)

    def divideAssignmentsToSIdByFunction(self, *args):
        """
        divideAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this rule assigns a value or a change to the 'id' element, replace the 'math' object with the function (existing/function).

        @internal

        """
        return _libsbml.Rule_divideAssignmentsToSIdByFunction(self, *args)

    def multiplyAssignmentsToSIdByFunction(self, *args):
        """
        multiplyAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing*function).

        @internal

        """
        return _libsbml.Rule_multiplyAssignmentsToSIdByFunction(self, *args)

Rule_swigregister = _libsbml.Rule_swigregister
Rule_swigregister(Rule)

class ListOfRules(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Rule objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfRules, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfRules, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfRules
        __init__(self, SBMLNamespaces sbmlns) -> ListOfRules

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfRules(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfRules object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfRules object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfRules(long level, long version)</pre>

        Creates a new ListOfRules object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfRules(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfRules

        Creates and returns a deep copy of this ListOfRules object.

        @return the (deep) copy of this ListOfRules object.

        """
        return _libsbml.ListOfRules_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Rule objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_RULE SBML_RULE@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfRules_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfRules, the XML element name is @c 'listOfRules'.

        @return the name of this element, i.e., @c 'listOfRules'.

        """
        return _libsbml.ListOfRules_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Rule
        get(self, unsigned int n) -> Rule
        get(self, string sid) -> Rule
        get(self, string sid) -> Rule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a Rule from the ListOfRules.

        @param n the index number of the Rule to get.

        @return the nth Rule in this ListOfRules.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a Rule from the ListOfRules based on its identifier.

        @param sid a string representing the identifier of the Rule to get.

        @return Rule in this ListOfRules with the given @p sid or @c None if no
        such Rule exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfRules_get(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        Note that AssignmentRules and RateRules do not actually have IDs, but
        the libsbml interface pretends that they do: no assignment rule or rate
        rule is returned by this function.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.ListOfRules_getElementBySId(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Rule
        remove(self, string sid) -> Rule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfRules items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfRules items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfRules_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfRules
    __del__ = lambda self : None;
ListOfRules_swigregister = _libsbml.ListOfRules_swigregister
ListOfRules_swigregister(ListOfRules)

class AlgebraicRule(Rule):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML <em>algebraic rule</em> representing <em>0 = f(<b>W</b>)</em>.

    The rule type AlgebraicRule is derived from the parent class Rule.  It
    is used to express equations that are neither assignments of model
    variables nor rates of change.  AlgebraicRule does not add any
    attributes to the basic Rule; its role is simply to distinguish this
    case from the other cases.

    In the context of a simulation, algebraic rules are in effect at all
    times, <em>t</em> >= <em>0</em>.  For purposes of evaluating
    expressions that involve the delay 'csymbol' (see the SBML
    specification), algebraic rules are considered to apply also at
    <em>t</em> <= <em>0</em>.  Please consult the relevant SBML
    specification for additional information about the semantics of
    assignments, rules, and entity values for simulation time <em>t</em>
    <= <em>0</em>.

    An SBML model must not be overdetermined.  The ability to define
    arbitrary algebraic expressions in an SBML model introduces the
    possibility that a model is mathematically overdetermined by the overall
    system of equations constructed from its rules, reactions and events.
    Therefore, if an algebraic rule is introduced in a model, for at least
    one of the entities referenced in the rule's 'math' element the value of
    that entity must not be completely determined by other constructs in the
    model.  This means that at least this entity must not have the attribute
    'constant'=@c True and there must also not be a rate rule or assignment
    rule for it.  Furthermore, if the entity is a Species object, its value
    must not be determined by reactions, which means that it must either
    have the attribute 'boundaryCondition'=@c True or else not be involved
    in any reaction at all.  These restrictions are explained in more detail
    in the SBML specification documents.

    In SBML Levels 2 and&nbsp;3, Reaction object identifiers can be
    referenced in the 'math' expression of an algebraic rule, but reaction
    rates can never be <em>determined</em> by algebraic rules.  This is true
    even when a reaction does not contain a KineticLaw
    @if conly structure @else object@endif.  (In such cases of missing
    kinetic law definitions, the model is valid but incomplete; the rates of
    reactions lacking kinetic laws are simply undefined, and not determined by
    the algebraic rule.)

    @section rules-general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into three
    subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible functional
    forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary
    function returning a numerical result, <b><em>V</em></b> is a vector of
    variables that does not include <em>x</em>, and <b><em>W</em></b> is a
    vector of variables that may include <em>x</em>):

    <table border='0' cellpadding='0' class='centered' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    @li <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)
    @li SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.

    @li Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;

    @li Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and

    @li Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section rules-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection rules-no-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops---dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection rules-not-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in
    Appendix&nbsp;B of the SBML Level&nbsp;3 Version&nbsp;1 Core
    specification for assessing whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)

    @section RuleType_t Rule types for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for
    distinguishing rules; specifically, it uses an attribute whose value is
    drawn from an enumeration of 3 values.  LibSBML supports this using methods
    that work @if clike a libSBML enumeration type, RuleType_t, whose values
    are @else with the enumeration values @endif@~ listed below.

    @li @link libsbml#RULE_TYPE_RATE RULE_TYPE_RATE@endlink: Indicates
    the rule is a 'rate' rule.
    @li @link libsbml#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink:
    Indicates the rule is a 'scalar' rule.
    @li @link libsbml#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink:
    Indicates the rule type is unknown or not yet set.

    """
    __swig_setmethods__ = {}
    for _s in [Rule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AlgebraicRule, name, value)
    __swig_getmethods__ = {}
    for _s in [Rule]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AlgebraicRule, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> AlgebraicRule
        __init__(self, SBMLNamespaces sbmlns) -> AlgebraicRule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>AlgebraicRule(SBMLNamespaces sbmlns)</pre>

        Creates a new AlgebraicRule object using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind of
        SBML object, are either invalid or mismatched with respect to the parent
        SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>AlgebraicRule(long level, long version)</pre>

        Creates a new AlgebraicRule object using the given SBML @p level and @p
        version values.

        @param level the SBML Level to assign to this AlgebraicRule object.

        @param version the SBML Version to assign to this AlgebraicRule object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        """
        this = _libsbml.new_AlgebraicRule(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_AlgebraicRule
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> AlgebraicRule

        Creates and returns a deep copy of this AlgebraicRule object.

        @return the (deep) copy of this Rule object.

        """
        return _libsbml.AlgebraicRule_clone(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        AlgebraicRule object have been set.

        In SBML Levels&nbsp;2&ndash;3, there is no required attribute
        for an AlgebraicRule object.  For Level&nbsp;1, the only required
        attribute is 'formula'.

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.AlgebraicRule_hasRequiredAttributes(self)

AlgebraicRule_swigregister = _libsbml.AlgebraicRule_swigregister
AlgebraicRule_swigregister(AlgebraicRule)

class AssignmentRule(Rule):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML <em>assignment rule</em> representing <em>x = f(<b>Y</b>)</em>.

    The rule type AssignmentRule is derived from the parent class Rule.  It
    is used to express equations that set the values of variables.  The
    left-hand side (the attribute named 'variable') of an assignment rule
    can refer to the identifier of a Species, SpeciesReference (in SBML
    Level&nbsp;3), Compartment, or Parameter
    @if conly structure @else object@endif@~ in the model (but not a
    Reaction).  The entity identified must have its 'constant' attribute set
    to @c False.  The effects of an assignment rule construct are in general
    terms the same, but differ in the precise details depending on the type of
    SBML component being set:
    <ul>

    <li> <em>In the case of a species</em>, an SBML assignment rule sets the
    referenced species' quantity (whether a 'concentration' or 'amount') to
    the value determined by the formula in the MathML subelement 'math'.
    The unit associated with the value produced by the 'math' formula @em
    should (in SBML Level&nbsp;2 Version&nbsp;4 and in SBML Level&nbsp;3) or @em must (in
    SBML releases prior to Level&nbsp;2 version&nbsp;4) be equal to the unit
    associated with the species' quantity.  <em>Restrictions</em>: There
    must not be both an AssignmentRule 'variable' attribute and a
    SpeciesReference 'species' attribute having the same value in a model,
    unless the referenced Species @if conly structure @else object@endif@~ has
    its 'boundaryCondition' attribute set to @c True.  In other words, an
    assignment rule cannot be defined for a species that is created or
    destroyed in a reaction unless that species is defined as a boundary
    condition in the model.

    <li> (For SBML Level&nbsp;3 only) <em>In the case of a species
    reference</em>, an assignment rule sets the stoichiometry of the
    referenced reactant or product to the value determined by the formula in
    'math'.  The unit associated with the value produced by the 'math'
    formula should be consistent with the unit 'dimensionless', because
    reactant and product stoichiometries in reactions are dimensionless
    quantities.

    <li> <em>In the case of a compartment</em>, an SBML assignment rule sets
    the referenced compartment's size to the value determined by the formula
    in the 'math' subelement of the AssignmentRule
    @if conly structure @else object@endif@~.  The overall units of the
    formula in 'math' @em should (in SBML Level&nbsp;2 Version&nbsp;4 and in
    SBML Level&nbsp;3) or @em must (in SBML releases prior to Level&nbsp;2
    version&nbsp;4) be the same as the units of the size of the compartment.

    <li> <em>In the case of a parameter</em>, an assignment rule sets the
    referenced parameter's value to that determined by the formula in the
    'math' subelement of the AssignmentRule
    @if conly structure @else object@endif@~.  The overall units of the
    formula in the 'math' subelement @em should (in SBML Level&nbsp;2
    Version&nbsp;4 and in SBML Level&nbsp;3) or @em must (in SBML releases
    prior to Level&nbsp;2 version&nbsp;4) be the same as the units defined for
    the parameter.  </ul>

    In the context of a simulation, assignment rules are in effect at all
    times, <em>t</em> >= <em>0</em>.  For purposes of evaluating
    expressions that involve the <em>delay</em> 'csymbol' (see the SBML
    Level&nbsp;2 specification), assignment rules are considered to apply
    also at <em>t</em> <= <em>0</em>.  Please consult the relevant
    SBML specification for additional information about the semantics of
    assignments, rules, and entity values for simulation time <em>t</em>
    <= <em>0</em>.

    A model must not contain more than one AssignmentRule or RateRule
    @if conly structure @else object@endif@~ having the same value of
    'variable'; in other words, in the set of all assignment rules and rate
    rules in an SBML model, each variable appearing in the left-hand sides can
    only appear once.  This simply follows from the fact that an indeterminate
    system would result if a model contained more than one assignment rule for
    the same variable or both an assignment rule and a rate rule for the same
    variable.

    Similarly, a model must also not contain <em>both</em> an AssignmentRule
    and an InitialAssignment definition for the same variable, because both
    kinds of constructs apply prior to and at the start of simulation time,
    i.e., <em>t</em> <= <em>0</em>.  If a model contained both an
    initial assignment and an assignment rule for the same variable, an
    indeterminate system would result.

    The value calculated by an AssignmentRule
    @if conly structure @else object@endif@~ overrides the value assigned to
    the given symbol by the model component defining that symbol.  For
    example, if a Compartment @if conly structure @else object@endif's
    'size' attribute value is set in its definition, and the model also
    contains an AssignmentRule @if conly structure @else object@endif@~ 
    having that compartment's 'id' as its 'variable' value, then the 'size'
    assigned in the Compartment @if conly structure @else object@endif@~
    definition is ignored and the value assigned based on the computation
    defined in the AssignmentRule.  This does <em>not</em> mean that a
    definition for a given symbol can be omitted if there is an AssignmentRule
    @if conly structure @else object@endif@~ involving it.  For example, 
    there must be a Parameter @if conly structure @else object@endif@~
    definition for a given parameter if there is an AssignmentRule definition
    for that parameter.  It is only a question of which value definition takes
    precedence.

    @section rules-general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into three
    subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible functional
    forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary
    function returning a numerical result, <b><em>V</em></b> is a vector of
    variables that does not include <em>x</em>, and <b><em>W</em></b> is a
    vector of variables that may include <em>x</em>):

    <table border='0' cellpadding='0' class='centered' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    @li <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)
    @li SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.

    @li Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;

    @li Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and

    @li Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section rules-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection rules-no-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops---dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection rules-not-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in
    Appendix&nbsp;B of the SBML Level&nbsp;3 Version&nbsp;1 Core
    specification for assessing whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)

    @section RuleType_t Rule types for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for
    distinguishing rules; specifically, it uses an attribute whose value is
    drawn from an enumeration of 3 values.  LibSBML supports this using methods
    that work @if clike a libSBML enumeration type, RuleType_t, whose values
    are @else with the enumeration values @endif@~ listed below.

    @li @link libsbml#RULE_TYPE_RATE RULE_TYPE_RATE@endlink: Indicates
    the rule is a 'rate' rule.
    @li @link libsbml#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink:
    Indicates the rule is a 'scalar' rule.
    @li @link libsbml#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink:
    Indicates the rule type is unknown or not yet set.

    """
    __swig_setmethods__ = {}
    for _s in [Rule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AssignmentRule, name, value)
    __swig_getmethods__ = {}
    for _s in [Rule]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AssignmentRule, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> AssignmentRule
        __init__(self, SBMLNamespaces sbmlns) -> AssignmentRule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>AssignmentRule(SBMLNamespaces sbmlns)</pre>

        Creates a new AssignmentRule using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>AssignmentRule(long level, long version)</pre>

        Creates a new AssignmentRule using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this AssignmentRule.

        @param version a long integer, the SBML Version to assign to this
        AssignmentRule.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        """
        this = _libsbml.new_AssignmentRule(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_AssignmentRule
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> AssignmentRule

        Creates and returns a deep copy of this AssignmentRule object.

        @return the (deep) copy of this Rule object.

        """
        return _libsbml.AssignmentRule_clone(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        AssignmentRule object have been set.

        In SBML Levels&nbsp;2&ndash;3, the only required attribute for
        an AssignmentRule object is 'variable'.  For Level&nbsp;1, where the
        equivalent attribute is known by different names ('compartment',
        'species', or 'name', depending on the type of object), there is an
        additional required attribute called 'formula'.

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.AssignmentRule_hasRequiredAttributes(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.AssignmentRule_renameSIdRefs(self, *args)

AssignmentRule_swigregister = _libsbml.AssignmentRule_swigregister
AssignmentRule_swigregister(AssignmentRule)

class RateRule(Rule):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML <em>rate rule</em> representing <em>dx/dt = f(<b>Y</b>)</em>.

    The rule type RateRule is derived from the parent class Rule.  It is
    used to express equations that determine the rates of change of
    variables.  The left-hand side (the 'variable' attribute) can refer to
    the identifier of a species, compartment, or parameter (but not a
    reaction).  The entity identified must have its 'constant' attribute set
    to @c False.  The effects of a RateRule are in general terms the same,
    but differ in the precise details depending on which variable is being
    set:

    <ul> <li> <em>In the case of a species</em>, a RateRule sets the rate of
    change of the species' quantity (<em>concentration</em> or <em>amount of
    substance</em>) to the value determined by the formula in the 'math'
    subelement of the RateRule object.  The overall units of the formula in
    'math' @em should (in SBML Level&nbsp;2 Version&nbsp;4 and in SBML Level&nbsp;3) or @em
    must (in SBML releases prior to Level&nbsp;2 version&nbsp;4) be equal to
    the unit of <em>species quantity</em> divided by the model-wide unit of
    <em>time</em>.  <em>Restrictions</em>: There must not be both a RateRule
    'variable' attribute and a SpeciesReference 'species' attribute having
    the same value, unless that species has its 'boundaryCondition'
    attribute is set to @c True.  This means a rate rule cannot be defined
    for a species that is created or destroyed in a reaction, unless that
    species is defined as a boundary condition in the model.

    <li> (For SBML Level&nbsp;3 only) <em>In the case of a species
    reference</em>, a RateRule sets the rate of change of the stoichiometry
    of the referenced reactant or product to the value determined by the
    formula in 'math'.  The unit associated with the value produced by the
    'math' formula should be consistent with the unit 'dimensionless'
    divided by the model-wide unit of <em>time</em>.

    <li> <em>In the case of a compartment</em>, a RateRule sets the rate of
    change of the compartment's size to the value determined by the formula
    in the 'math' subelement of the RateRule object.  The overall units of
    the formula @em should (in SBML Level&nbsp;2 Version&nbsp;4 and in SBML
    Level&nbsp;3) or @em must (in SBML releases prior to Level&nbsp;2
    version&nbsp;4) be the units of the compartment's <em>size</em> divided
    by the model-wide unit of <em>time</em>.

    <li> <em>In the case of a parameter</em>, a RateRule sets the rate of
    change of the parameter's value to that determined by the formula in the
    'math' subelement of the RateRule object.  The overall units of the
    formula @em should (in SBML Level&nbsp;2 Version&nbsp;4 and in SBML
    Level&nbsp;3) or @em must (in SBML releases prior to Level&nbsp;2
    version&nbsp;4) be the Parameter object's 'unit' attribute value divided
    by the model-wide unit of <em>time</em>.  </ul>

    In the context of a simulation, rate rules are in effect for simulation
    time <em>t</em> &lt; <em>0</em>.  Please consult the relevant SBML
    specification for additional information about the semantics of
    assignments, rules, and entity values for simulation time <em>t</em>
    <= <em>0</em>.

    As mentioned in the description of AssignmentRule, a model must not
    contain more than one RateRule or AssignmentRule object having the same
    value of 'variable'; in other words, in the set of all assignment rules
    and rate rules in an SBML model, each variable appearing in the
    left-hand sides can only appear once.  This simply follows from the fact
    that an indeterminate system would result if a model contained more than
    one assignment rule for the same variable or both an assignment rule and
    a rate rule for the same variable.

    @section rules-general General summary of SBML rules

    In SBML Level&nbsp;3 as well as Level&nbsp;2, rules are separated into three
    subclasses for the benefit of model analysis software.  The three
    subclasses are based on the following three different possible functional
    forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary
    function returning a numerical result, <b><em>V</em></b> is a vector of
    variables that does not include <em>x</em>, and <b><em>W</em></b> is a
    vector of variables that may include <em>x</em>):

    <table border='0' cellpadding='0' class='centered' style='font-size: small'>
    <tr><td width='120px'><em>Algebraic:</em></td><td width='250px'>left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em></td></tr>
    <tr><td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em></td></tr>
    <tr><td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em></td></tr>
    </table>

    In their general form given above, there is little to distinguish
    between <em>assignment</em> and <em>algebraic</em> rules.  They are treated as
    separate cases for the following reasons:

    @li <em>Assignment</em> rules can simply be evaluated to calculate
    intermediate values for use in numerical methods.  They are statements
    of equality that hold at all times.  (For assignments that are only
    performed once, see InitialAssignment.)
    @li SBML needs to place restrictions on assignment rules, for example
    the restriction that assignment rules cannot contain algebraic loops.

    @li Some simulators do not contain numerical solvers capable of solving
    unconstrained algebraic equations, and providing more direct forms such
    as assignment rules may enable those simulators to process models they
    could not process if the same assignments were put in the form of
    general algebraic equations;

    @li Those simulators that <em>can</em> solve these algebraic equations make a
    distinction between the different categories listed above; and

    @li Some specialized numerical analyses of models may only be applicable
    to models that do not contain <em>algebraic</em> rules.

    The approach taken to covering these cases in SBML is to define an
    abstract Rule structure containing a subelement, 'math', to hold the
    right-hand side expression, then to derive subtypes of Rule that add
    attributes to distinguish the cases of algebraic, assignment and rate
    rules.  The 'math' subelement must contain a MathML expression defining the
    mathematical formula of the rule.  This MathML formula must return a
    numerical value.  The formula can be an arbitrary expression referencing
    the variables and other entities in an SBML model.

    Each of the three subclasses of Rule (AssignmentRule, AlgebraicRule,
    RateRule) inherit the the 'math' subelement and other fields from SBase.
    The AssignmentRule and RateRule classes add an additional attribute,
    'variable'.  See the definitions of AssignmentRule, AlgebraicRule and
    RateRule for details about the structure and interpretation of each one.

    @section rules-restrictions Additional restrictions on SBML rules

    An important design goal of SBML rule semantics is to ensure that a
    model's simulation and analysis results will not be dependent on when or
    how often rules are evaluated.  To achieve this, SBML needs to place two
    restrictions on rule use.  The first concerns algebraic loops in the system
    of assignments in a model, and the second concerns overdetermined systems.

    @subsection rules-no-loops A model must not contain algebraic loops

    The combined set of InitialAssignment, AssignmentRule and KineticLaw
    objects in a model constitute a set of assignment statements that should be
    considered as a whole.  (A KineticLaw object is counted as an assignment
    because it assigns a value to the symbol contained in the 'id' attribute of
    the Reaction object in which it is defined.)  This combined set of
    assignment statements must not contain algebraic loops---dependency
    chains between these statements must terminate.  To put this more formally,
    consider a directed graph in which nodes are assignment statements and
    directed arcs exist for each occurrence of an SBML species, compartment or
    parameter symbol in an assignment statement's 'math' subelement.  Let the
    directed arcs point from the statement assigning the symbol to the
    statements that contain the symbol in their 'math' subelement expressions.
    This graph must be acyclic.

    SBML does not specify when or how often rules should be evaluated.
    Eliminating algebraic loops ensures that assignment statements can be
    evaluated any number of times without the result of those evaluations
    changing.  As an example, consider the set of equations <em>x = x + 1</em>,
    <em>y = z + 200</em> and <em>z = y + 100</em>.  If this set of equations
    were interpreted as a set of assignment statements, it would be invalid
    because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type
    of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule
    for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop).
    Conversely, the following set of equations would constitute a valid set of
    assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x
    + 100</em>.

    @subsection rules-not-overdetermined A model must not be overdetermined

    An SBML model must not be overdetermined; that is, a model must not
    define more equations than there are unknowns in a model.  An SBML model
    that does not contain AlgebraicRule structures cannot be overdetermined.

    LibSBML implements the static analysis procedure described in
    Appendix&nbsp;B of the SBML Level&nbsp;3 Version&nbsp;1 Core
    specification for assessing whether a model is overdetermined.

    (In summary, assessing whether a given continuous, deterministic,
    mathematical model is overdetermined does not require dynamic analysis; it
    can be done by analyzing the system of equations created from the model.
    One approach is to construct a bipartite graph in which one set of vertices
    represents the variables and the other the set of vertices represents the
    equations.  Place edges between vertices such that variables in the system
    are linked to the equations that determine them.  For algebraic equations,
    there will be edges between the equation and each variable occurring in the
    equation.  For ordinary differential equations (such as those defined by
    rate rules or implied by the reaction rate definitions), there will be a
    single edge between the equation and the variable determined by that
    differential equation.  A mathematical model is overdetermined if the
    maximal matchings of the bipartite graph contain disconnected vertexes
    representing equations.  If one maximal matching has this property, then
    all the maximal matchings will have this property; i.e., it is only
    necessary to find one maximal matching.)

    @section RuleType_t Rule types for SBML Level 1

    SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for
    distinguishing rules; specifically, it uses an attribute whose value is
    drawn from an enumeration of 3 values.  LibSBML supports this using methods
    that work @if clike a libSBML enumeration type, RuleType_t, whose values
    are @else with the enumeration values @endif@~ listed below.

    @li @link libsbml#RULE_TYPE_RATE RULE_TYPE_RATE@endlink: Indicates
    the rule is a 'rate' rule.
    @li @link libsbml#RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink:
    Indicates the rule is a 'scalar' rule.
    @li @link libsbml#RULE_TYPE_INVALID RULE_TYPE_INVALID@endlink:
    Indicates the rule type is unknown or not yet set.

    """
    __swig_setmethods__ = {}
    for _s in [Rule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RateRule, name, value)
    __swig_getmethods__ = {}
    for _s in [Rule]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RateRule, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> RateRule
        __init__(self, SBMLNamespaces sbmlns) -> RateRule

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>RateRule(SBMLNamespaces sbmlns)</pre>

        Creates a new RateRule using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>RateRule(long level, long version)</pre>

        Creates a new RateRule using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this RateRule

        @param version a long integer, the SBML Version to assign to this
        RateRule

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        """
        this = _libsbml.new_RateRule(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_RateRule
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> RateRule

        Creates and returns a deep copy of this RateRule object.

        @return the (deep) copy of this RateRule object.

        """
        return _libsbml.RateRule_clone(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this RateRule object
        have been set.

        In SBML Levels&nbsp;2&ndash;3, the only required attribute for a
        RateRule object is 'variable'.  For Level&nbsp;1, where the equivalent
        attribute is known by different names ('compartment', 'species', or
        'name', depending on the type of object), there is an additional
        required attribute called 'formula'.

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.RateRule_hasRequiredAttributes(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.RateRule_renameSIdRefs(self, *args)

RateRule_swigregister = _libsbml.RateRule_swigregister
RateRule_swigregister(RateRule)

class Constraint(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML <em>constraint</em>, for stating validity assumptions.

    The Constraint object class was introduced in SBML Level&nbsp;2
    Version&nbsp;2 as a mechanism for stating the assumptions under which a
    model is designed to operate.  The <em>constraints</em> are statements
    about permissible values of different quantities in a model.
    Constraints are not used to compute dynamical values for simulation or
    analysis, but rather, they serve an advisory role for
    simulation/analysis tools.

    SBML's Constraint object class has one required attribute, 'id', to
    give the parameter a unique identifier by which other parts of an SBML
    model definition can refer to it.  A Constraint object can also have an
    optional 'name' attribute of type @c string.  Identifiers and names must
    be used according to the guidelines described in the SBML specification
    (e.g., Section 3.3 in the Level&nbsp;2 Version 4 specification).  

    Constraint has one required subelement, 'math', containing a MathML
    formula defining the condition of the constraint.  This formula must
    return a boolean value of @c True when the model is a <em>valid</em>
    state.  The formula can be an arbitrary expression referencing the
    variables and other entities in an SBML model.  The evaluation of 'math'
    and behavior of constraints are described in more detail below.

    A Constraint structure also has an optional subelement called 'message'.
    This can contain a message in XHTML format that may be displayed to the
    user when the condition of the formula in the 'math' subelement
    evaluates to a value of @c False.  Software tools are not required to
    display the message, but it is recommended that they do so as a matter
    of best practice.  The XHTML content within a 'message' subelement must
    follow the same restrictions as for the 'notes' element on SBase
    described in in the SBML Level&nbsp;2 specification; please consult the
    <a target='_blank' href='http://sbml.org/Documents/Specifications'>SBML
    specification document</a> corresponding to the SBML Level and Version
    of your model for more information about the requirements for 'notes'
    content.

    Constraint was introduced in SBML Level&nbsp;2 Version&nbsp;2.  It is
    not available in earlier versions of Level&nbsp;2 nor in any version of
    Level&nbsp;1.

    @section constraint-semantics Semantics of Constraints

    In the context of a simulation, a Constraint has effect at all times
    <em>t >= 0</em>.  Each Constraint's 'math' subelement is first
    evaluated after any InitialAssignment definitions in a model at <em>t =
    0</em> and can conceivably trigger at that point.  (In other words, a
    simulation could fail a constraint immediately.)

    Constraint structures <em>cannot and should not</em> be used to compute
    the dynamical behavior of a model as part of, for example, simulation.
    Constraints may be used as input to non-dynamical analysis, for instance
    by expressing flux constraints for flux balance analysis.

    The results of a simulation of a model containing a constraint are
    invalid from any simulation time at and after a point when the function
    given by the 'math' subelement returns a value of @c False.  Invalid
    simulation results do not make a prediction of the behavior of the
    biochemical reaction network represented by the model.  The precise
    behavior of simulation tools is left undefined with respect to
    constraints.  If invalid results are detected with respect to a given
    constraint, the 'message' subelement may optionally be displayed to the
    user.  The simulation tool may also halt the simulation or clearly
    delimit in output data the simulation time point at which the simulation
    results become invalid.

    SBML does not impose restrictions on duplicate Constraint definitions or
    the order of evaluation of Constraint objects in a model.  It is
    possible for a model to define multiple constraints all with the same
    mathematical expression.  Since the failure of any constraint indicates
    that the model simulation has entered an invalid state, a system is not
    required to attempt to detect whether other constraints in the model
    have failed once any one constraint has failed.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constraint, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Constraint, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Constraint
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Constraint
        __init__(self, SBMLNamespaces sbmlns) -> Constraint
        __init__(self, Constraint orig) -> Constraint

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Constraint(SBMLNamespaces sbmlns)</pre>

        Creates a new Constraint using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Constraint(long level, long version)</pre>

        Creates a new Constraint using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Constraint

        @param version a long integer, the SBML Version to assign to this
        Constraint

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Constraint(Constraint orig)</pre>

        Copy constructor; creates a copy of this Constraint.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Constraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Constraint

        Creates and returns a deep copy of this Constraint object.

        @return the (deep) copy of this Constraint object.

        """
        return _libsbml.Constraint_clone(self)

    def getMessage(self):
        """
        getMessage(self) -> XMLNode

        Get the message, if any, associated with this Constraint

        @return the message for this Constraint, as an XMLNode.

        """
        return _libsbml.Constraint_getMessage(self)

    def getMessageString(self):
        """
        getMessageString(self) -> string

        Get the message string, if any, associated with this Constraint

        @return the message for this Constraint, as a string.

        """
        return _libsbml.Constraint_getMessageString(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical expression of this Constraint

        @return the math for this Constraint, as an ASTNode.

        """
        return _libsbml.Constraint_getMath(self)

    def isSetMessage(self):
        """
        isSetMessage(self) -> bool

        Predicate returning @c True if a
        message is defined for this Constraint.

        @return @c True if the message of this Constraint is set,
        @c False otherwise.

        """
        return _libsbml.Constraint_isSetMessage(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c True if a
        mathematical formula is defined for this Constraint.

        @return @c True if the 'math' subelement for this Constraint is
        set, @c False otherwise.

        """
        return _libsbml.Constraint_isSetMath(self)

    def setMessage(self, *args):
        """
        setMessage(self, XMLNode xhtml) -> int

        Sets the message of this Constraint.

        The XMLNode tree passed in @p xhtml is copied.

        @param xhtml an XML tree containing XHTML content.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.Constraint_setMessage(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the mathematical expression of this Constraint to a copy of the
        AST given as @p math.

        @param math an ASTNode expression to be assigned as the 'math'
        subelement of this Constraint

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.Constraint_setMath(self, *args)

    def unsetMessage(self):
        """
        unsetMessage(self) -> int

        Unsets the 'message' subelement of this Constraint.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Constraint_unsetMessage(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Constraint_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Constraint_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.Constraint_replaceSIDWithFunction(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_CONSTRAINT SBML_CONSTRAINT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Constraint_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Constraint, is
        always @c 'constraint'.

        @return the name of this element, i.e., @c 'constraint'.

        """
        return _libsbml.Constraint_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for this Constraint object
        have been set.

        @note The required elements for a Constraint object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.Constraint_hasRequiredElements(self)

Constraint_swigregister = _libsbml.Constraint_swigregister
Constraint_swigregister(Constraint)

class ListOfConstraints(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Constraint objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfConstraints, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfConstraints, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfConstraints
        __init__(self, SBMLNamespaces sbmlns) -> ListOfConstraints

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfConstraints(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfConstraints object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfConstraints object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfConstraints(long level, long version)</pre>

        Creates a new ListOfConstraints object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfConstraints(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfConstraints

        Creates and returns a deep copy of this ListOfConstraints object.

        @return the (deep) copy of this ListOfConstraints object.

        """
        return _libsbml.ListOfConstraints_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Constraint objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf
        instance: @link libsbml#SBML_CONSTRAINT SBML_CONSTRAINT@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfConstraints_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfConstraints, the XML element name is @c 'listOfConstraints'.

        @return the name of this element.

        """
        return _libsbml.ListOfConstraints_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Constraint
        get(self, unsigned int n) -> Constraint

        Get a Constraint from the ListOfConstraints.

        @param n the index number of the Constraint to get.

        @return the nth Constraint in this ListOfConstraints.

        @see size()

        """
        return _libsbml.ListOfConstraints_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Constraint

        Removes the nth item from this ListOfConstraints items and returns a
        pointer to it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()

        """
        return _libsbml.ListOfConstraints_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfConstraints
    __del__ = lambda self : None;
ListOfConstraints_swigregister = _libsbml.ListOfConstraints_swigregister
ListOfConstraints_swigregister(ListOfConstraints)

class Reaction(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An SBML reaction between species in an SBML model.

    A @em reaction represents any transformation, transport or binding
    process, typically a chemical reaction, that can change the quantity of
    one or more species.  In SBML, a reaction is defined primarily in terms
    of the participating reactants and products (and their corresponding
    stoichiometries), along with optional modifier species, an optional rate
    at which the reaction takes place, and optional parameters.

    As with other major objects in SBML, Reaction has a mandatory attribute,
    'id', used to give the compartment type an identifier.  The identifier
    must be a text string conforming to the identifer syntax permitted in
    SBML.  In SBML Level&nbsp;2 and Level&nbsp;3, the reaction 'id'
    identifier can be used in mathematical formulas elsewhere in an SBML
    model to represent the rate of that reaction; this usage is explained
    below.  Reaction also has an optional 'name' attribute, of type @c
    string.  The 'id' and 'name' must be used according to the guidelines
    described in the SBML specification.

    The species participating as reactants, products, and/or modifiers in a
    reaction are declared using lists of SpeciesReference and/or
    ModifierSpeciesReference instances stored in subelements
    'listOfReactants', 'listOfProducts' and 'listOfModifiers'.  Certain
    restrictions are placed on the appearance of species in reaction
    definitions:
    <ul>
    <li> The ability of a species to appear as a reactant or product of any
    reaction in a model is governed by certain flags in that species'
    definition; see the definition of Species for more information.

    <li> Any species appearing in the mathematical formula of the subelement
    'kineticLaw' (described below) of a Reaction must be declared in at
    least one of that Reaction's lists of reactants, products, and/or
    modifiers.  Put another way, it is an error for a reaction's kinetic law
    formula to refer to species that have not been declared for that
    reaction.

    <li> A reaction definition can contain an empty list of reactants
    <em>or</em> an empty list of products, but it must have at least one
    reactant or product; in other words, a reaction without any reactant or
    product species is not permitted.  (This restriction does not apply to
    modifier species, which remain optional in all cases.)
    </ul>

    A reaction can contain up to one KineticLaw object in a subelement named
    'kineticLaw'.  It defines the speed at which the process defined by the
    reaction takes place.  The description of KineticLaw provides more
    details about its use.  Note that although the inclusion of a KineticLaw
    object in an instance of a Reaction component is optional, there is no
    useful default that can be substituted in place of a missing rate
    expression in a reaction.  Moreover, a reaction's rate cannot be defined
    in any other way in SBML---InitialAssignment, AssignmentRule,
    RateRule, AlgebraicRule, Event, and other constructs in SBML cannot be
    used to set the reaction rate separately.  Nevertheless, for some
    modeling applications, reactions without any defined rate can be
    perfectly acceptable.

    Reaction also has a boolean attribute named 'reversible' for indicating
    whether the reaction is reversible.  This attribute is optional in SBML
    Level&nbsp;2, with a default of @c True; it is mandatory in SBML
    Level&nbsp;3 (with no default value).  To say that a reaction is @em
    reversible is to say it can proceed in either the forward or the reverse
    direction.  Although the reversibility of a reaction can sometimes be
    deduced by inspecting its rate expression, this is not always the case,
    especially for complicated expressions.  Moreover, the need in SBML to
    allow rate expressions (i.e., KineticLaw) to be optional leads to the
    need for a separate flag indicating reversibility.  Note that labeling a
    reaction as irreversible is an assertion that the reaction always
    proceeds in the given forward direction.  (Why else would it be flagged
    as irreversible?)  This implies the rate expression in the KineticLaw
    always has a non-negative value during simulations.  Software tools
    could provide a means of optionally testing that this condition holds.
    The presence of reversibility information in two places (i.e., the rate
    expression and the 'reversible' attribute on Reaction) leaves open the
    possibility that a model could contain contradictory information, but
    the creation of such a model would be an error on the part of the
    software generating it.

    The Reaction object class has another boolean attribute called 'fast'.
    This attribute is optional in SBML Level&nbsp;2, with a default of @c False; it is mandatory in SBML Level&nbsp;3 (with no default value).  It
    is used to indicate that a reaction occurs on a vastly faster time scale
    than others in a system.  Readers are directed to the SBML Level&nbsp;2
    Version&nbsp;4 specification, which provides more detail about the
    conditions under which a reaction can be considered to be fast in this
    sense.  The attribute's default value is @c False.  SBML Level&nbsp;1
    and Level&nbsp;2 Version&nbsp;1 incorrectly claimed that software tools
    could ignore this attribute if they did not implement support for the
    corresponding concept; however, further research in SBML has revealed
    that this is not true, and 'fast' <em>cannot be ignored</em> if it is
    set to @c True.  SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 therefore
    stipulate that if a model has any reactions with 'fast' set to @c True,
    a software tool must be able to respect the attribute or else indicate
    to the user that it does not have the capacity to do so.  Analysis
    software cannot ignore the value of the 'fast' attribute because doing
    so may lead to different results as compared to a software system that
    <em>does</em> make use of 'fast'.

    In SBML Level&nbsp;3 Version&nbsp;1, the Reaction object has an
    additional optional attribute named 'compartment', whose value must be
    the identifier of a compartment defined in the enclosing Model object.
    The 'compartment' attribute can be used to indicate the compartment in
    which the reaction is assumed to take place.  If the attribute is
    present, its value must be the identifier of a Compartment object
    defined in the enclosing Model object.  Similar to the 'reversible'
    attribute, the value of the 'compartment' attribute has no direct impact
    on the construction of mathematical equations for the SBML model.  When
    a kinetic law is given for a reaction, the compartment location may
    already be implicit in the kinetic law (although this cannot always be
    guaranteed).  Nevertheless, software tools may find the 'compartment'
    attribute value useful for such purposes as analyzing the structure of
    the model, guiding the modeler in constructing correct rate formulas,
    and visualization purposes.

    Readers are urged to read the SBML specification for more details about
    the proper use of Reaction.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Reaction, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Reaction, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Reaction
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Reaction
        __init__(self, SBMLNamespaces sbmlns) -> Reaction
        __init__(self, Reaction orig) -> Reaction

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Reaction(SBMLNamespaces sbmlns)</pre>

        Creates a new Reaction using the given SBMLNamespaces object
        @p  sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Reaction(long level, long version)</pre>

        Creates a new Reaction using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Reaction

        @param version a long integer, the SBML Version to assign to this
        Reaction

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Reaction(Reaction orig)</pre>

        Copy constructor; creates a copy of this Reaction.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Reaction(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Reaction

        Creates and returns a deep copy of this Reaction object.

        @return the (deep) copy of this Reaction object.

        """
        return _libsbml.Reaction_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        @param id string representing the id of objects to find.

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.Reaction_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid, or
        @c None if no such object is found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        """
        return _libsbml.Reaction_getElementByMetaId(self, *args)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Reaction_renameSIdRefs(self, *args)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this Reaction object to 'typical' default
        values.

        The SBML Reaction component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:

        @li Sets the 'reversible' attribute to @c True
        @li Sets the 'fast' attribute to @c False
        @li Marks the 'fast' attribute as @em not having been set

        @warning <span class='warning'>SBML definitions before SBML Level&nbsp;2
        Version&nbsp;2 incorrectly indicated that software tools could ignore the
        'fast' attribute if they did not implement support for the corresponding
        concept; however, further research in SBML has revealed that this is not
        true, and 'fast' <em>cannot be ignored</em> if it is set to @c True.
        Beginning with SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications
        therefore stipulate that if a model has any reactions with 'fast' set to
        @c True, a software tool must be able to respect the attribute or else
        indicate to the user that it does not have the capacity to do so.  Readers
        are directed to the SBML specifications, which provides more detail about
        the conditions under which a reaction can be considered to be fast in this
        sense.</span>

        """
        return _libsbml.Reaction_initDefaults(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Reaction.

        @return the id of this Reaction.

        """
        return _libsbml.Reaction_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Reaction.

        @return the name of this Reaction.

        """
        return _libsbml.Reaction_getName(self)

    def getKineticLaw(self, *args):
        """
        getKineticLaw(self) -> KineticLaw
        getKineticLaw(self) -> KineticLaw

        Returns the KineticLaw object contained in this Reaction.

        @return the KineticLaw instance.

        """
        return _libsbml.Reaction_getKineticLaw(self, *args)

    def getReversible(self):
        """
        getReversible(self) -> bool

        Returns the value of the 'reversible' attribute on the Reaction as a
        boolean value.

        @return the reversibility status of this Reaction.

        """
        return _libsbml.Reaction_getReversible(self)

    def getFast(self):
        """
        getFast(self) -> bool

        Returns the value of the 'fast' attribute of this Reaction.

        @return the 'fast' status of this Reaction.

        @warning <span class='warning'>SBML definitions before SBML Level&nbsp;2
        Version&nbsp;2 incorrectly indicated that software tools could ignore the
        'fast' attribute if they did not implement support for the corresponding
        concept; however, further research in SBML has revealed that this is not
        true, and 'fast' <em>cannot be ignored</em> if it is set to @c True.
        Beginning with SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications
        therefore stipulate that if a model has any reactions with 'fast' set to
        @c True, a software tool must be able to respect the attribute or else
        indicate to the user that it does not have the capacity to do so.  Readers
        are directed to the SBML specifications, which provides more detail about
        the conditions under which a reaction can be considered to be fast in this
        sense.</span>

        """
        return _libsbml.Reaction_getFast(self)

    def getCompartment(self):
        """
        getCompartment(self) -> string

        (SBML Level&nbsp;3 only) Returns the value of the 'compartment'
        attribute on the Reaction.

        @return the compartment of this Reaction.

        @note The 'compartment' attribute is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present on Reaction in lower Levels of
        SBML.

        """
        return _libsbml.Reaction_getCompartment(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        Reaction's 'id' attribute is set.

        @return @c True if the 'id' attribute of this Reaction is
        set, @c False otherwise.

        """
        return _libsbml.Reaction_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        Reaction's 'name' attribute is set.

        @return @c True if the 'name' attribute of this Reaction is
        set, @c False otherwise.

        """
        return _libsbml.Reaction_isSetName(self)

    def isSetKineticLaw(self):
        """
        isSetKineticLaw(self) -> bool

        Predicate returning @c True if this
        Reaction contains a kinetic law object.

        @return @c True if a KineticLaw is present in this Reaction,, @c False
        otherwise.

        """
        return _libsbml.Reaction_isSetKineticLaw(self)

    def isSetFast(self):
        """
        isSetFast(self) -> bool

        Predicate returning @c True if the value of
        the 'fast' attribute on this Reaction.

        @return @c True if the 'fast' attribute is true, @c False otherwise.

        @warning <span class='warning'>SBML definitions before SBML Level&nbsp;2
        Version&nbsp;2 incorrectly indicated that software tools could ignore the
        'fast' attribute if they did not implement support for the corresponding
        concept; however, further research in SBML has revealed that this is not
        true, and 'fast' <em>cannot be ignored</em> if it is set to @c True.
        Beginning with SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications
        therefore stipulate that if a model has any reactions with 'fast' set to
        @c True, a software tool must be able to respect the attribute or else
        indicate to the user that it does not have the capacity to do so.  Readers
        are directed to the SBML specifications, which provides more detail about
        the conditions under which a reaction can be considered to be fast in this
        sense.</span>

        """
        return _libsbml.Reaction_isSetFast(self)

    def isSetCompartment(self):
        """
        isSetCompartment(self) -> bool

        Predicate returning @c True if this
        Reaction's 'compartment' attribute is set.

        @return @c True if the 'compartment' attribute of this Reaction is
        set, @c False otherwise.

        @note The 'compartment' attribute is available in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.

        """
        return _libsbml.Reaction_isSetCompartment(self)

    def isSetReversible(self):
        """
        isSetReversible(self) -> bool

        Predicate returning @c True if this
        Reaction's 'reversible' attribute is set.

        @return @c True if the 'reversible' attribute of this Reaction is
        set, @c False otherwise.

        """
        return _libsbml.Reaction_isSetReversible(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Reaction.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this Reaction

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Reaction_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Reaction.

        The string in @p name is copied.

        @param name the new name for the Reaction

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Reaction_setName(self, *args)

    def setKineticLaw(self, *args):
        """
        setKineticLaw(self, KineticLaw kl) -> int

        Sets the 'kineticLaw' subelement of this Reaction to a copy of the
        given KineticLaw object.

        @param kl the KineticLaw object to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink

        """
        return _libsbml.Reaction_setKineticLaw(self, *args)

    def setReversible(self, *args):
        """
        setReversible(self, bool value) -> int

        Sets the value of the 'reversible' attribute of this Reaction.

        @param value the value of the 'reversible' attribute.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.Reaction_setReversible(self, *args)

    def setFast(self, *args):
        """
        setFast(self, bool value) -> int

        Sets the value of the 'fast' attribute of this Reaction.

        @param value the value of the 'fast' attribute.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @warning <span class='warning'>SBML definitions before SBML Level&nbsp;2
        Version&nbsp;2 incorrectly indicated that software tools could ignore the
        'fast' attribute if they did not implement support for the corresponding
        concept; however, further research in SBML has revealed that this is not
        true, and 'fast' <em>cannot be ignored</em> if it is set to @c True.
        Beginning with SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications
        therefore stipulate that if a model has any reactions with 'fast' set to
        @c True, a software tool must be able to respect the attribute or else
        indicate to the user that it does not have the capacity to do so.  Readers
        are directed to the SBML specifications, which provides more detail about
        the conditions under which a reaction can be considered to be fast in this
        sense.</span>

        """
        return _libsbml.Reaction_setFast(self, *args)

    def setCompartment(self, *args):
        """
        setCompartment(self, string sid) -> int

        Sets the value of the 'compartment' attribute of this Reaction.

        The string @p sid is copied.  

        @param sid the string to use as the compartment of this Reaction

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The 'compartment' attribute is available in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.

        """
        return _libsbml.Reaction_setCompartment(self, *args)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Reaction_unsetName(self)

    def unsetKineticLaw(self):
        """
        unsetKineticLaw(self) -> int

        Unsets the 'kineticLaw' subelement of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Reaction_unsetKineticLaw(self)

    def unsetFast(self):
        """
        unsetFast(self) -> int

        Unsets the value of the 'fast' attribute of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @warning <span class='warning'>SBML definitions before SBML Level&nbsp;2
        Version&nbsp;2 incorrectly indicated that software tools could ignore the
        'fast' attribute if they did not implement support for the corresponding
        concept; however, further research in SBML has revealed that this is not
        true, and 'fast' <em>cannot be ignored</em> if it is set to @c True.
        Beginning with SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications
        therefore stipulate that if a model has any reactions with 'fast' set to
        @c True, a software tool must be able to respect the attribute or else
        indicate to the user that it does not have the capacity to do so.  Readers
        are directed to the SBML specifications, which provides more detail about
        the conditions under which a reaction can be considered to be fast in this
        sense.</span>

        """
        return _libsbml.Reaction_unsetFast(self)

    def unsetCompartment(self):
        """
        unsetCompartment(self) -> int

        Unsets the value of the 'compartment' attribute of this Reaction.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The 'compartment' attribute is available in SBML
        Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in
        lower Levels of SBML.

        """
        return _libsbml.Reaction_unsetCompartment(self)

    def addReactant(self, *args):
        """
        addReactant(self, SpeciesReference sr) -> int

        Adds a given SpeciesReference object as a reactant in this Reaction.

        The SpeciesReference instance in @p sr is copied.

        @param sr a SpeciesReference object referring to a Species in the
        enclosing Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createReactant()

        """
        return _libsbml.Reaction_addReactant(self, *args)

    def addProduct(self, *args):
        """
        addProduct(self, SpeciesReference sr) -> int

        Adds a given SpeciesReference object as a product in this Reaction.

        The SpeciesReference instance in @p sr is copied.

        @param sr a SpeciesReference object referring to a Species in the
        enclosing Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createProduct()

        """
        return _libsbml.Reaction_addProduct(self, *args)

    def addModifier(self, *args):
        """
        addModifier(self, ModifierSpeciesReference msr) -> int

        Adds a given ModifierSpeciesReference object as a product in this
        Reaction.

        The ModifierSpeciesReference instance in @p msr is copied.

        @param msr a ModifierSpeciesReference object referring to a Species in
        the enclosing Model

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createModifier()

        """
        return _libsbml.Reaction_addModifier(self, *args)

    def createReactant(self):
        """
        createReactant(self) -> SpeciesReference

        Creates a new SpeciesReference, adds it to this Reaction's list of
        reactants, and returns it.

        @return a new SpeciesReference object.

        """
        return _libsbml.Reaction_createReactant(self)

    def createProduct(self):
        """
        createProduct(self) -> SpeciesReference

        Creates a new SpeciesReference, adds it to this Reaction's list of
        products, and returns it.

        @return a new SpeciesReference object.

        """
        return _libsbml.Reaction_createProduct(self)

    def createModifier(self):
        """
        createModifier(self) -> ModifierSpeciesReference

        Creates a new ModifierSpeciesReference, adds it to this Reaction's
        list of modifiers and returns it.

        @return a new ModifierSpeciesReference object.

        """
        return _libsbml.Reaction_createModifier(self)

    def createKineticLaw(self):
        """
        createKineticLaw(self) -> KineticLaw

        Creates a new KineticLaw object, installs it as this Reaction's
        'kineticLaw' subelement, and returns it.

        If this Reaction had a previous KineticLaw, it will be destroyed.

        @return the new KineticLaw object

        """
        return _libsbml.Reaction_createKineticLaw(self)

    def getListOfReactants(self, *args):
        """
        getListOfReactants(self) -> ListOfSpeciesReferences
        getListOfReactants(self) -> ListOfSpeciesReferences

        Returns the list of reactants in this Reaction object.

        @return the ListOfSpeciesReferences containing the references to the
        species acting as reactants in this reaction

        """
        return _libsbml.Reaction_getListOfReactants(self, *args)

    def getListOfProducts(self, *args):
        """
        getListOfProducts(self) -> ListOfSpeciesReferences
        getListOfProducts(self) -> ListOfSpeciesReferences

        Returns the list of products in this Reaction object.

        @return the ListOfSpeciesReferences containing the references to the
        species acting as products in this reaction

        """
        return _libsbml.Reaction_getListOfProducts(self, *args)

    def getListOfModifiers(self, *args):
        """
        getListOfModifiers(self) -> ListOfSpeciesReferences
        getListOfModifiers(self) -> ListOfSpeciesReferences

        Returns the list of modifiers in this Reaction object.

        @return the ListOfSpeciesReferences containing the references to the
        species acting as modifiers in this reaction

        """
        return _libsbml.Reaction_getListOfModifiers(self, *args)

    def getReactant(self, *args):
        """
        getReactant(self, unsigned int n) -> SpeciesReference
        getReactant(self, unsigned int n) -> SpeciesReference
        getReactant(self, string species) -> SpeciesReference
        getReactant(self, string species) -> SpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getReactant(string species)</pre>

        Returns the reactant species (as a SpeciesReference object) having 
        a specific identifier in this Reaction.

        @param species the identifier of the reactant Species ('species' 
        attribute of the reactant SpeciesReference object)

        @return a SpeciesReference object, or @c None if no species with the
        given identifier @p species appears as a reactant in this Reaction.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getReactant(long n)</pre>

        Returns the nth reactant species (as a SpeciesReference object) 
        in the list of reactants in this Reaction.

        Callers should first call getNumReactants() to find out how many
        reactants there are, to avoid using an invalid index number.

        @param n the index of the reactant sought.

        @return the nth reactant (as a SpeciesReference object) of this
        Reaction.

        """
        return _libsbml.Reaction_getReactant(self, *args)

    def getProduct(self, *args):
        """
        getProduct(self, unsigned int n) -> SpeciesReference
        getProduct(self, unsigned int n) -> SpeciesReference
        getProduct(self, string species) -> SpeciesReference
        getProduct(self, string species) -> SpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getProduct(string species)</pre>

        Returns the product species (as a SpeciesReference object) having 
        a specific identifier in this Reaction.

        @param species the identifier of the product Species ('species'
        attribute of the product SpeciesReference object)

        @return a SpeciesReference object, or @c None if no species with the
        given identifier @p species appears as a product in this Reaction.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getProduct(long n)</pre>

        Returns the nth product species (as a SpeciesReference object) 
        in the list of products in this Reaction.

        Callers should first call getNumProducts() to find out how many
        products there are, to avoid using an invalid index number.

        @param n the index of the product sought.

        @return the nth product (as a SpeciesReference object) of this
        Reaction.

        """
        return _libsbml.Reaction_getProduct(self, *args)

    def getModifier(self, *args):
        """
        getModifier(self, unsigned int n) -> ModifierSpeciesReference
        getModifier(self, unsigned int n) -> ModifierSpeciesReference
        getModifier(self, string species) -> ModifierSpeciesReference
        getModifier(self, string species) -> ModifierSpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getModifier(string species)</pre>

        Returns the modifier species (as a ModifierSpeciesReference object) 
        having a specific identifier in this Reaction.

        @param species the identifier of the modifier Species ('species' 
        attribute of the ModifierSpeciesReference object)

        @return a ModifierSpeciesReference object, or @c None if no species with
        the given identifier @p species appears as a modifier in this
        Reaction.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getModifier(long n)</pre>

        Returns the nth modifier species (as a ModifierSpeciesReference object) 
        in the list of modifiers of this Reaction.

        Callers should first call getNumModifiers() to find out how many
        modifiers there are, to avoid using an invalid index number.

        @param n the index of the modifier species sought

        @return the nth modifier (as a ModifierSpeciesReference object) of
        this Reaction.

        """
        return _libsbml.Reaction_getModifier(self, *args)

    def getNumReactants(self):
        """
        getNumReactants(self) -> unsigned int

        Returns the number of reactant species in this Reaction.

        @return the number of reactants in this Reaction.

        """
        return _libsbml.Reaction_getNumReactants(self)

    def getNumProducts(self):
        """
        getNumProducts(self) -> unsigned int

        Returns the number of product species in this Reaction.

        @return the number of products in this Reaction.

        """
        return _libsbml.Reaction_getNumProducts(self)

    def getNumModifiers(self):
        """
        getNumModifiers(self) -> unsigned int

        Returns the number of modifier species in this Reaction.

        @return the number of modifiers in this Reaction.

        """
        return _libsbml.Reaction_getNumModifiers(self)

    def removeReactant(self, *args):
        """
        removeReactant(self, unsigned int n) -> SpeciesReference
        removeReactant(self, string species) -> SpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeReactant(string species)</pre>

        Removes the reactant species (SpeciesReference object) having the given  
        'species' attribute in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param species the 'species' attribute of the reactant SpeciesReference 
        object

        @return the removed reactant SpeciesReference object, or @c None if no 
        reactant SpeciesReference object with the given 'species' attribute 
        @p species exists in this Reaction.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeReactant(long n)</pre>

        Removes the nth reactant species (SpeciesReference object) in the list of 
        reactants in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        The caller should first call getNumReactants() to find out how many
        reactants there are, to avoid using an invalid index number.

        @param n the index of the reactant SpeciesReference object to remove

        @return the removed reactant SpeciesReference object, or @c None if the 
        given index is out of range.

        """
        return _libsbml.Reaction_removeReactant(self, *args)

    def removeProduct(self, *args):
        """
        removeProduct(self, unsigned int n) -> SpeciesReference
        removeProduct(self, string species) -> SpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeProduct(string species)</pre>

        Removes the product species (SpeciesReference object) having the given  
        'species' attribute in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param species the 'species' attribute of the product SpeciesReference 
        object

        @return the removed product SpeciesReference object, or @c None if no 
        product SpeciesReference object with the given 'species' attribute 
        @p species exists in this Reaction.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeProduct(long n)</pre>

        Removes the nth product species (SpeciesReference object) in the list of 
        products in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        The caller should first call getNumProducts() to find out how many
        products there are, to avoid using an invalid index number.

        @param n the index of the product SpeciesReference object to remove

        @return the removed product SpeciesReference object, or @c None if the 
        given index is out of range.

        """
        return _libsbml.Reaction_removeProduct(self, *args)

    def removeModifier(self, *args):
        """
        removeModifier(self, unsigned int n) -> ModifierSpeciesReference
        removeModifier(self, string species) -> ModifierSpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeModifier(string species)</pre>

        Removes the modifier species (ModifierSpeciesReference object) having 
        the given 'species' attribute in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param species the 'species' attribute of the ModifierSpeciesReference 
        object

        @return the removed ModifierSpeciesReference object, or @c None if no 
        ModifierSpeciesReference object with the given 'species' attribute @p 
        species exists in this Reaction.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeModifier(long n)</pre>

        Removes the nth modifier species (ModifierSpeciesReference object) in 
        the list of  modifiers in this Reaction and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        The caller should first call getNumModifiers() to find out how many
        modifiers there are, to avoid using an invalid index number.

        @param n the index of the ModifierSpeciesReference object to remove

        @return the removed ModifierSpeciesReference object, or @c None if the 
        given index is out of range.

        """
        return _libsbml.Reaction_removeModifier(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor and assignment operator.

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.Reaction_connectToChild(self)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.Reaction_enablePackageInternal(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_REACTION SBML_REACTION@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Reaction_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Reaction, is
        always @c 'reaction'.

        @return the name of this element, i.e., @c 'reaction'.

        """
        return _libsbml.Reaction_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        Reaction object have been set.

        The required attributes for a Reaction object are:
        @li 'id' (or 'name' in SBML Level&nbsp;1)
        @li 'fast' (in Level&nbsp;3 only, where it is defined as a required attribute)
        @li 'reversible' (in Level&nbsp;3 only, where it is defined as a required attribute)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Reaction_hasRequiredAttributes(self)

Reaction_swigregister = _libsbml.Reaction_swigregister
Reaction_swigregister(Reaction)

class ListOfReactions(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Reaction objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfReactions, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfReactions, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfReactions
        __init__(self, SBMLNamespaces sbmlns) -> ListOfReactions

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfReactions(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfReactions object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfReactions object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfReactions(long level, long version)</pre>

        Creates a new ListOfReactions object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfReactions(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfReactions

        Creates and returns a deep copy of this ListOfReactions object.

        @return the (deep) copy of this ListOfReactions object.

        """
        return _libsbml.ListOfReactions_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Reaction objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_REACTION SBML_REACTION@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfReactions_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object

        For ListOfReactions, the XML element name is @c 'listOfReactions'.

        @return the name of this element, i.e., @c 'listOfReactions'.

        """
        return _libsbml.ListOfReactions_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Reaction
        get(self, unsigned int n) -> Reaction
        get(self, string sid) -> Reaction
        get(self, string sid) -> Reaction

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a Reaction from the ListOfReactions.

        @param n the index number of the Reaction to get.

        @return the nth Reaction in this ListOfReactions.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a Reaction from the ListOfReactions based on its identifier.

        @param sid a string representing the identifier of the Reaction to get.

        @return Reaction in this ListOfReactions with the given @p sid or @c
        None if no such Reaction exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfReactions_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Reaction
        remove(self, string sid) -> Reaction

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfReactions items and returns a
        pointer to it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfReactions items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfReactions_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfReactions
    __del__ = lambda self : None;
ListOfReactions_swigregister = _libsbml.ListOfReactions_swigregister
ListOfReactions_swigregister(ListOfReactions)

class KineticLaw(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html The rate expression for an SBML reaction.

    An object of class KineticLaw is used to describe the rate at which the
    process defined by a given Reaction takes place.  KineticLaw has
    subelements called 'math' (for MathML content) and 'listOfParameters'
    (of class ListOfParameters), in addition to the attributes and
    subelements it inherits from SBase.

    KineticLaw's 'math' subelement for holding a MathML formula defines the
    rate of the reaction.  The formula may refer to other entities in a
    model as well as local parameter definitions within the scope of the
    Reaction (see below).  It is important to keep in mind, however, that
    the only Species identifiers that can be used in this formula are those
    declared in the lists of reactants, products and modifiers in the
    Reaction structure.  (In other words, before a species can be referenced
    in the KineticLaw, it must be declared in one of those lists.)

    KineticLaw provides a way to define @em local parameters whose
    identifiers can be used in the 'math' formula of that KineticLaw
    instance.  Prior to SBML Level&nbsp;3, these parameter definitions are
    stored inside a 'listOfParameters' subelement containing Parameter
    objects; in SBML Level&nbsp;3, this is achieved using a specialized
    object class called LocalParameter and the containing subelement is
    called 'listOfLocalParameters'.  In both cases, the parameters so
    defined are only visible within the KineticLaw; they cannot be accessed
    outside.  A local parameter within one reaction is not visible from
    within another reaction, nor is it visible to any other construct
    outside of the KineticLaw in which it is defined.  In addition, another
    important feature is that if such a Parameter (or in Level&nbsp;3,
    LocalParameter) object has the same identifier as another object in the
    scope of the enclosing Model, the definition inside the KineticLaw takes
    precedence.  In other words, within the KineticLaw's 'math' formula,
    references to local parameter identifiers <strong>shadow any identical
    global identifiers</strong>.

    The values of local parameters defined within KineticLaw objects cannot
    change.  In SBML Level&nbsp;3, this quality is built into the
    LocalParameter construct.  In Level&nbsp;2, where the same kind of
    Parameter object class is used as for global parameters, the Parameter
    objects' 'constant' attribute must always have a value of @c True
    (either explicitly or left to its default value).


    @section shadowing-warning A warning about identifier shadowing

    A common misconception is that different classes of objects (e.g.,
    species, compartments, parameters) in SBML have different identifier
    scopes.  They do not.  The implication is that if a KineticLaw's local
    parameter definition uses an identifier identical to @em any other
    identifier defined in the model outside the KineticLaw, even if the
    other identifier does @em not belong to a parameter type of object, the
    local parameter's identifier takes precedence within that KineticLaw's
    'math' formula.  It is not an error in SBML for identifiers to shadow
    each other this way, but can lead to confusing and subtle errors.


    @section version-diffs SBML Level/Version differences

    In SBML Level&nbsp;2 Version&nbsp;1, the SBML specification
    included two additional attributes on KineticLaw called 'substanceUnits'
    and 'timeUnits'.  They were removed beginning with SBML Level&nbsp;2
    Version&nbsp;2 because further research determined they introduced many
    problems.  The most significant problem was that their use could easily
    lead to the creation of valid models whose reactions nevertheless could
    not be integrated into a system of equations without outside knowledge
    for converting the quantities used.  Examination of real-life models
    revealed that a common reason for using 'substanceUnits' on KineticLaw
    was to set the units of all reactions to the same set of substance
    units, something that is better achieved by using UnitDefinition to
    redefine @c 'substance' for the whole Model.

    As mentioned above, in SBML Level&nbsp;2 Versions 2&ndash;4, local
    parameters are of class Parameter.  In SBML Level&nbsp;3, the class of
    object is LocalParameter.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KineticLaw, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KineticLaw, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_KineticLaw
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> KineticLaw
        __init__(self, SBMLNamespaces sbmlns) -> KineticLaw
        __init__(self, KineticLaw orig) -> KineticLaw

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>KineticLaw(SBMLNamespaces sbmlns)</pre>

        Creates a new KineticLaw using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>KineticLaw(long level, long version)</pre>

        Creates a new KineticLaw using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this KineticLaw

        @param version a long integer, the SBML Version to assign to this
        KineticLaw

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>KineticLaw(KineticLaw orig)</pre>

        Copy constructor; creates a copy of this KineticLaw.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_KineticLaw(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> KineticLaw

        Creates and returns a deep copy of this KineticLaw object.

        @return the (deep) copy of this KineticLaw object.

        """
        return _libsbml.KineticLaw_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        @param id string representing the id of objects to find.

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.KineticLaw_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid, or
        @c None if no such object is found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        """
        return _libsbml.KineticLaw_getElementByMetaId(self, *args)

    def getFormula(self):
        """
        getFormula(self) -> string

        Returns the mathematical formula for this KineticLaw object and return
        it as as a text string.

        This is fundamentally equivalent to
        @if java KineticLaw.getMath()@else getMath()@endif.
        This variant is provided principally for compatibility compatibility
        with SBML Level&nbsp;1.

        @return a string representing the formula of this KineticLaw.

        @note @htmlinclude level-1-uses-text-string-math.html

        @see getMath()

        """
        return _libsbml.KineticLaw_getFormula(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Returns the mathematical formula for this KineticLaw object and return
        it as as an AST.

        This is fundamentally equivalent to
        @if java KineticLaw.getFormula()@else getFormula()@endif.
        The latter is provided principally for compatibility compatibility
        with SBML Level&nbsp;1, which represented mathematical formulas in
        text-string form.

        @return the ASTNode representation of the mathematical formula.

        @see getFormula()

        """
        return _libsbml.KineticLaw_getMath(self)

    def getTimeUnits(self):
        """
        getTimeUnits(self) -> string

        (SBML Level&nbsp;2 Version&nbsp;1 only) Returns the value of the
        'timeUnits' attribute of this KineticLaw object.

        @return the 'timeUnits' attribute value.

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_getTimeUnits(self)

    def getSubstanceUnits(self):
        """
        getSubstanceUnits(self) -> string

        (SBML Level&nbsp;2 Version&nbsp;1 only) Returns the value of the
        'substanceUnits' attribute of this KineticLaw object.

        @return the 'substanceUnits' attribute value.

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_getSubstanceUnits(self)

    def isSetFormula(self):
        """
        isSetFormula(self) -> bool

        Predicate returning @c True if this KineticLaw's 'formula' attribute is
        set.

        This is functionally identical to the method
        @if java KineticLaw.isSetMath()@else isSetMath()@endif.  It is
        provided in order to mirror the parallel between
        @if java KineticLaw.getFormula()@else getFormula()@endif@~ and
        @if java KineticLaw.getMath()@else getMath()@endif.

        @return @c True if the formula (meaning the @c math subelement) of
        this KineticLaw is set, @c False otherwise.

        @note @htmlinclude level-1-uses-text-string-math.html

        @see isSetMath()

        """
        return _libsbml.KineticLaw_isSetFormula(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate returning @c True if this Kinetic's 'math' subelement is set.

        This is identical to the method
        @if java KineticLaw.isSetFormula()@else isSetFormula()@endif.
        It is provided in order to mirror the parallel between
        @if java KineticLaw.getFormula()@else getFormula()@endif@~ and
        @if java KineticLaw.getMath()@else getMath()@endif.

        @return @c True if the formula (meaning the @c math subelement) of
        this KineticLaw is set, @c False otherwise.

        @see isSetFormula()

        """
        return _libsbml.KineticLaw_isSetMath(self)

    def isSetTimeUnits(self):
        """
        isSetTimeUnits(self) -> bool

        (SBML Level&nbsp;2 Version&nbsp;1 only) Predicate returning @c True if
        this SpeciesReference's 'timeUnits' attribute is set.

        @return @c True if the 'timeUnits' attribute of this KineticLaw object
        is set, @c False otherwise.

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_isSetTimeUnits(self)

    def isSetSubstanceUnits(self):
        """
        isSetSubstanceUnits(self) -> bool

        (SBML Level&nbsp;2 Version&nbsp;1 only) Predicate returning @c True if
        this SpeciesReference's 'substanceUnits' attribute is set.

        @return @c True if the 'substanceUnits' attribute of this KineticLaw
        object is set, @c False otherwise.

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_isSetSubstanceUnits(self)

    def setFormula(self, *args):
        """
        setFormula(self, string formula) -> int

        Sets the mathematical expression of this KineticLaw instance to the
        given @p formula.

        The given @p formula string is copied.  Internally, libSBML stores the
        mathematical expression as an ASTNode.

        @param formula the mathematical expression to use, represented in
        text-string form.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note @htmlinclude level-1-uses-text-string-math.html

        @see setMath()

        """
        return _libsbml.KineticLaw_setFormula(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the mathematical expression of this KineticLaw instance to a copy
        of the given ASTNode.

        This is fundamentally identical to
        @if java KineticLaw.setFormula()@else getFormula()@endif.
        The latter is provided principally for compatibility compatibility with
        SBML Level&nbsp;1, which represented mathematical formulas in text-string
        form.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see setFormula()

        """
        return _libsbml.KineticLaw_setMath(self, *args)

    def setTimeUnits(self, *args):
        """
        setTimeUnits(self, string sid) -> int

        (SBML Level&nbsp;2 Version&nbsp;1 only) Sets the 'timeUnits' attribute
        of this KineticLaw object to a copy of the identifier in @p sid.

        @param sid the identifier of the units to use.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_setTimeUnits(self, *args)

    def setSubstanceUnits(self, *args):
        """
        setSubstanceUnits(self, string sid) -> int

        (SBML Level&nbsp;2 Version&nbsp;1 only) Sets the 'substanceUnits'
        attribute of this KineticLaw object to a copy of the identifier given
        in @p sid.

        @param sid the identifier of the units to use.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_setSubstanceUnits(self, *args)

    def unsetTimeUnits(self):
        """
        unsetTimeUnits(self) -> int

        (SBML Level&nbsp;2 Version&nbsp;1 only) Unsets the 'timeUnits'
        attribugte of this KineticLaw object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_unsetTimeUnits(self)

    def unsetSubstanceUnits(self):
        """
        unsetSubstanceUnits(self) -> int

        (SBML Level&nbsp;2 Version&nbsp;1 only) Unsets the 'substanceUnits'
        attribute of this KineticLaw object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attributes 'timeUnits' and 'substanceUnits' are present only
        in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2
        Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were
        removed.  For compatibility with new versions of SBML, users are
        cautioned to avoid these attributes.

        """
        return _libsbml.KineticLaw_unsetSubstanceUnits(self)

    def addParameter(self, *args):
        """
        addParameter(self, Parameter p) -> int

        Adds a copy of the given Parameter object to the list of local
        parameters in this KineticLaw.

        @param p the Parameter to add

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createParameter()

        """
        return _libsbml.KineticLaw_addParameter(self, *args)

    def addLocalParameter(self, *args):
        """
        addLocalParameter(self, LocalParameter p) -> int

        Adds a copy of the given LocalParameter object to the list of local
        parameters in this KineticLaw.

        @param p the LocalParameter to add

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createLocalParameter()

        """
        return _libsbml.KineticLaw_addLocalParameter(self, *args)

    def createParameter(self):
        """
        createParameter(self) -> Parameter

        Creates a new Parameter object, adds it to this KineticLaw's list of
        local parameters, and returns the Parameter object created.

        @return a new Parameter object instance

        @see addParameter()

        """
        return _libsbml.KineticLaw_createParameter(self)

    def createLocalParameter(self):
        """
        createLocalParameter(self) -> LocalParameter

        Creates a new LocalParameter object, adds it to this KineticLaw's list
        of local parameters, and returns the LocalParameter object created.

        @return a new LocalParameter object instance

        @see addLocalParameter()

        """
        return _libsbml.KineticLaw_createLocalParameter(self)

    def getListOfParameters(self, *args):
        """
        getListOfParameters(self) -> ListOfParameters
        getListOfParameters(self) -> ListOfParameters

        Returns the list of local parameters in this KineticLaw object.

        @return the list of Parameters for this KineticLaw.

        """
        return _libsbml.KineticLaw_getListOfParameters(self, *args)

    def getListOfLocalParameters(self, *args):
        """
        getListOfLocalParameters(self) -> ListOfLocalParameters
        getListOfLocalParameters(self) -> ListOfLocalParameters

        Returns the list of local parameters in this KineticLaw object.

        @return the list of LocalParameters for this KineticLaw.

        """
        return _libsbml.KineticLaw_getListOfLocalParameters(self, *args)

    def getParameter(self, *args):
        """
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, unsigned int n) -> Parameter
        getParameter(self, string sid) -> Parameter
        getParameter(self, string sid) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getParameter(long n)</pre>

        Returns the nth Parameter object in the list of local parameters in
        this KineticLaw instance.

        @param n the index of the Parameter object sought

        @return the nth Parameter of this KineticLaw.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getParameter(string sid)</pre>

        Returns a local parameter based on its identifier.

        @param sid the identifier of the Parameter being sought.

        @return the Parameter object in this KineticLaw instace having the
        given 'id', or @c None if no such Parameter exists.

        """
        return _libsbml.KineticLaw_getParameter(self, *args)

    def getLocalParameter(self, *args):
        """
        getLocalParameter(self, unsigned int n) -> LocalParameter
        getLocalParameter(self, unsigned int n) -> LocalParameter
        getLocalParameter(self, string sid) -> LocalParameter
        getLocalParameter(self, string sid) -> LocalParameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getLocalParameter(long n)</pre>

        Returns the nth LocalParameter object in the list of local parameters in
        this KineticLaw instance.

        @param n the index of the LocalParameter object sought

        @return the nth LocalParameter of this KineticLaw.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getLocalParameter(string sid)</pre>

        Returns a local parameter based on its identifier.

        @param sid the identifier of the LocalParameter being sought.

        @return the LocalParameter object in this KineticLaw instace having the
        given 'id', or @c None if no such LocalParameter exists.

        """
        return _libsbml.KineticLaw_getLocalParameter(self, *args)

    def getNumParameters(self):
        """
        getNumParameters(self) -> unsigned int

        Returns the number of local parameters in this KineticLaw instance.

        @return the number of Parameters in this KineticLaw.

        """
        return _libsbml.KineticLaw_getNumParameters(self)

    def getNumLocalParameters(self):
        """
        getNumLocalParameters(self) -> unsigned int

        Returns the number of local parameters in this KineticLaw instance.

        @return the number of LocalParameters in this KineticLaw.

        """
        return _libsbml.KineticLaw_getNumLocalParameters(self)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units of
        measurement assumed for the 'math' expression of this KineticLaw.

        @par
        The units are calculated based on the mathematical expression in the
        KineticLaw and the model quantities referenced by <code>&lt;ci&gt;</code>
        elements used within that expression.  The
        @if java KineticLaw.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif@~
        method returns the calculated units. 

        @note The functionality that facilitates unit analysis depends on the
        model as a whole.  Thus, in cases where the object has not been added to
        a model or the model itself is incomplete, unit analysis is not possible
        and this method will return @c None. 

        @warning <span class='warning'>Note that it is possible the 'math'
        expression in the KineticLaw contains pure numbers or parameters with
        undeclared units.  In those cases, it is not possible to calculate the
        units of the overall expression without making assumptions.  LibSBML does
        not make assumptions about the units, and
        KineticLaw.getDerivedUnitDefinition() returns the units as far as it is
        able to determine them.  For example, in an expression <em>X + Y</em>, if
        <em>X</em> has unambiguously-defined units and <em>Y</em> does not, it
        will return the units of <em>X</em>.  <strong>It is important that callers
        also invoke the method</strong>
        KineticLaw.containsUndeclaredUnits()<strong>to determine whether this
        situation holds</strong>.  Callers may wish to take suitable actions in
        those scenarios.</span>

        @return a UnitDefinition that expresses the units of the math 
        expression of this KineticLaw, or @c None if one cannot be constructed.

        @see containsUndeclaredUnits()

        """
        return _libsbml.KineticLaw_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c True if the math expression of this KineticLaw
        contains parameters/numbers with undeclared units.

        @return @c True if the math expression of this KineticLaw
        includes parameters/numbers 
        with undeclared units, @c False otherwise.

        @note A return value of @c True indicates that the UnitDefinition
        returned by
        @if java KineticLaw.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif@~
        may not accurately represent the units of the expression.

        @see getDerivedUnitDefinition()

        """
        return _libsbml.KineticLaw_containsUndeclaredUnits(self, *args)

    def removeParameter(self, *args):
        """
        removeParameter(self, unsigned int n) -> Parameter
        removeParameter(self, string sid) -> Parameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeParameter(long n)</pre>

        Removes the nth Parameter object in the list of local parameters 
        in this KineticLaw instance and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the Parameter object to remove

        @return the Parameter object removed.  As mentioned above, 
        the caller owns the returned item. @c None is returned if the given index 
        is out of range.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeParameter(string sid)</pre>

        Removes a Parameter object with the given identifier in the list of
        local parameters in this KineticLaw instance and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the Parameter to remove

        @return the Parameter object removed.  As mentioned above, the 
        caller owns the returned object. @c None is returned if no Parameter
        object with the identifier exists in this KineticLaw instance.

        """
        return _libsbml.KineticLaw_removeParameter(self, *args)

    def removeLocalParameter(self, *args):
        """
        removeLocalParameter(self, unsigned int n) -> LocalParameter
        removeLocalParameter(self, string sid) -> LocalParameter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeLocalParameter(long n)</pre>

        Removes the nth LocalParameter object in the list of local parameters 
        in this KineticLaw instance and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the LocalParameter object to remove

        @return the LocalParameter object removed.  As mentioned above, 
        the caller owns the returned item. @c None is returned if the given index 
        is out of range.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeLocalParameter(string sid)</pre>

        Removes a LocalParameter object with the given identifier in the list of
        local parameters in this KineticLaw instance and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param sid the identifier of the LocalParameter to remove

        @return the LocalParameter object removed.  As mentioned above, the 
        caller owns the returned object. @c None is returned if no LocalParameter
        object with the identifier exists in this KineticLaw instance.

        """
        return _libsbml.KineticLaw_removeLocalParameter(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define one ore more child
        elements.  Basically, this function needs to be called in constructor,
        copy constructor and assignment operator.

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.KineticLaw_connectToChild(self)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.KineticLaw_enablePackageInternal(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_KINETIC_LAW SBML_KINETIC_LAW@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.KineticLaw_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Species, is
        always @c 'kineticLaw'.

        @return the name of this element, i.e., @c 'kineticLaw'.

        """
        return _libsbml.KineticLaw_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        KineticLaw object have been set.

        The required attributes for a KineticLaw object are:
        @li 'formula' (SBML Level&nbsp;1 only)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.KineticLaw_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if all the required elements for this
        KineticLaw object have been set.

        @note The required elements for a KineticLaw object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.KineticLaw_hasRequiredElements(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Finds this KineticLaw's Reaction parent and calls unsetKineticLaw() on
        it, indirectly deleting itself.

        Overridden from the SBase function since the parent is not a ListOf.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.KineticLaw_removeFromParentAndDelete(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.KineticLaw_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.KineticLaw_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.KineticLaw_replaceSIDWithFunction(self, *args)

    def divideAssignmentsToSIdByFunction(self, *args):
        """
        divideAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this reaction id matches the provided 'id' string, replace the 'math' object with the function (existing/function).

        @internal

        """
        return _libsbml.KineticLaw_divideAssignmentsToSIdByFunction(self, *args)

    def multiplyAssignmentsToSIdByFunction(self, *args):
        """
        multiplyAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing*function).

        @internal

        """
        return _libsbml.KineticLaw_multiplyAssignmentsToSIdByFunction(self, *args)

KineticLaw_swigregister = _libsbml.KineticLaw_swigregister
KineticLaw_swigregister(KineticLaw)

class SimpleSpeciesReference(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Abstract class for references to species in reactions.

    As mentioned in the description of Reaction, every species that enters
    into a given reaction must appear in that reaction's lists of reactants,
    products and/or modifiers.  In an SBML model, all species that may
    participate in any reaction are listed in the 'listOfSpecies' element of
    the top-level Model object.  Lists of products, reactants and modifiers
    in Reaction objects do not introduce new species, but rather, they refer
    back to those listed in the model's top-level 'listOfSpecies'.  For
    reactants and products, the connection is made using SpeciesReference
    objects; for modifiers, it is made using ModifierSpeciesReference
    objects.  SimpleSpeciesReference is an abstract type that serves as the
    parent class of both SpeciesReference and ModifierSpeciesReference.  It
    is used simply to hold the attributes and elements that are common to
    the latter two structures.

    The SimpleSpeciesReference structure has a mandatory attribute,
    'species', which must be a text string conforming to the identifer
    syntax permitted in %SBML.  This attribute is inherited by the
    SpeciesReference and ModifierSpeciesReference subclasses derived from
    SimpleSpeciesReference.  The value of the 'species' attribute must be
    the identifier of a species defined in the enclosing Model.  The species
    is thereby declared as participating in the reaction being defined.  The
    precise role of that species as a reactant, product, or modifier in the
    reaction is determined by the subclass of SimpleSpeciesReference (i.e.,
    either SpeciesReference or ModifierSpeciesReference) in which the
    identifier appears.

    SimpleSpeciesReference also contains an optional attribute, 'id',
    allowing instances to be referenced from other structures.  No SBML
    structures currently do this; however, such structures are anticipated
    in future SBML Levels.

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleSpeciesReference, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleSpeciesReference, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SimpleSpeciesReference
    __del__ = lambda self : None;
    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this SimpleSpeciesReference.

        @return the id of this SimpleSpeciesReference.

        """
        return _libsbml.SimpleSpeciesReference_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this SimpleSpeciesReference.

        @return the name of this SimpleSpeciesReference.

        """
        return _libsbml.SimpleSpeciesReference_getName(self)

    def getSpecies(self):
        """
        getSpecies(self) -> string

        Get the value of the 'species' attribute.

        @return the value of the attribute 'species' for this
        SimpleSpeciesReference.

        """
        return _libsbml.SimpleSpeciesReference_getSpecies(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        SimpleSpeciesReference's 'id' attribute is set.

        @return @c True if the 'id' attribute of this SimpleSpeciesReference is
        set, @c False otherwise.

        """
        return _libsbml.SimpleSpeciesReference_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        SimpleSpeciesReference's 'name' attribute is set.

        @return @c True if the 'name' attribute of this SimpleSpeciesReference is
        set, @c False otherwise.

        """
        return _libsbml.SimpleSpeciesReference_isSetName(self)

    def isSetSpecies(self):
        """
        isSetSpecies(self) -> bool

        Predicate returning @c True if this
        SimpleSpeciesReference's 'species' attribute is set.

        @return @c True if the 'species' attribute of this
        SimpleSpeciesReference is set, @c False otherwise.

        """
        return _libsbml.SimpleSpeciesReference_isSetSpecies(self)

    def setSpecies(self, *args):
        """
        setSpecies(self, string sid) -> int

        Sets the 'species' attribute of this SimpleSpeciesReference.

        The identifier string passed in @p sid is copied.

        @param sid the identifier of a species defined in the enclosing
        Model's ListOfSpecies.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.SimpleSpeciesReference_setSpecies(self, *args)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this SimpleSpeciesReference.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this SimpleSpeciesReference

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.SimpleSpeciesReference_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this SimpleSpeciesReference.

        The string in @p name is copied.

        @param name the new name for the SimpleSpeciesReference

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.SimpleSpeciesReference_setName(self, *args)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this SimpleSpeciesReference.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SimpleSpeciesReference_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this SimpleSpeciesReference.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SimpleSpeciesReference_unsetName(self)

    def isModifier(self):
        """
        isModifier(self) -> bool

        Predicate returning @c True if this
        is a ModifierSpeciesReference.

        @return @c True if this SimpleSpeciesReference's subclass is
        ModiferSpeciesReference, @c False if it is a plain SpeciesReference.

        """
        return _libsbml.SimpleSpeciesReference_isModifier(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.SimpleSpeciesReference_renameSIdRefs(self, *args)

SimpleSpeciesReference_swigregister = _libsbml.SimpleSpeciesReference_swigregister
SimpleSpeciesReference_swigregister(SimpleSpeciesReference)

class SpeciesReference(SimpleSpeciesReference):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A reference to an SBML species in a reaction.

    The Reaction structure provides a way to express which species act as
    reactants and which species act as products in a reaction.  In a given
    reaction, references to those species acting as reactants and/or
    products are made using instances of SpeciesReference structures in a
    Reaction object's lists of reactants and products.

    A species can occur more than once in the lists of reactants and
    products of a given Reaction instance.  The effective stoichiometry for
    a species in a reaction is the sum of the stoichiometry values given on
    the SpeciesReference object in the list of products minus the sum of
    stoichiometry values given on the SpeciesReference objects in the list
    of reactants.  A positive value indicates the species is effectively a
    product and a negative value indicates the species is effectively a
    reactant.  SBML places no restrictions on the effective stoichiometry of
    a species in a reaction; for example, it can be zero.  In the following
    SBML fragment, the two reactions have the same effective stoichiometry
    for all their species:
    @verbatim
     <reaction id='x'>
         <listOfReactants>
             <speciesReference species='a'/>
             <speciesReference species='a'/>
             <speciesReference species='b'/>
         </listOfReactants>
         <listOfProducts>
             <speciesReference species='c'/>
             <speciesReference species='b'/>
         </listProducts>
     </reaction>
     <reaction id='y'>
         <listOfReactants>
             <speciesReference species='a' stoichiometry='2'/>
         </listOfReactants>
         <listOfProducts>
             <speciesReference species='c'/>
         </listProducts>
     </reaction>
     @endverbatim

    The precise structure of SpeciesReference differs between SBML
    Level&nbsp;2 and Level&nbsp;3.  We discuss the two variants in separate
    sections below.

    @section spr-l2 SpeciesReference in SBML Level 2

    The mandatory 'species' attribute of SpeciesReference must have as its
    value the identifier of an existing species defined in the enclosing
    Model.  The species is thereby designated as a reactant or product in
    the reaction.  Which one it is (i.e., reactant or product) is indicated
    by whether the SpeciesReference appears in the Reaction's 'reactant' or
    'product' lists.

    Product and reactant stoichiometries can be specified using
    <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
    SpeciesReference object.  The 'stoichiometry' attribute is of type
    double and should contain values greater than zero (0).  The
    'stoichiometryMath' element is implemented as an element containing a
    MathML expression.  These two are mutually exclusive; only one of
    'stoichiometry' or 'stoichiometryMath' should be defined in a given
    SpeciesReference instance.  When neither the attribute nor the element
    is present, the value of 'stoichiometry' in the SpeciesReference
    instance defaults to @c 1.

    For maximum interoperability, the 'stoichiometry' attribute should be
    used in preference to 'stoichiometryMath' when a species' stoichiometry
    is a simple scalar number (integer or decimal).  When the stoichiometry
    is a rational number, or when it is a more complicated formula,
    'stoichiometryMath' must be used.  The MathML expression in
    'stoichiometryMath' may also refer to identifiers of entities in a model
    (except reaction identifiers).  However, the only species identifiers
    that can be used in 'stoichiometryMath' are those referenced in the
    Reaction list of reactants, products and modifiers.

    The following is a simple example of a species reference for species @c
    X0, with stoichiometry @c 2, in a list of reactants within a reaction
    having the identifier @c J1:
    @verbatim
     <model>
         ...
         <listOfReactions>
             <reaction id='J1'>
                 <listOfReactants>
                     <speciesReference species='X0' stoichiometry='2'>
                 </listOfReactants>
                 ...
             </reaction>
             ...
         </listOfReactions>
         ...
     </model>
     @endverbatim

    The following is a more complex example of a species reference for
    species X0, with a stoichiometry formula consisting of the parameter
    @c x:
    @verbatim
     <model>
         ...
         <listOfReactions>
             <reaction id='J1'>
                 <listOfReactants>
                     <speciesReference species='X0'>
                         <stoichiometryMath>
                             <math xmlns='http://www.w3.org/1998/Math/MathML'>
                                 <ci>x</ci>
                             </math>
                         </stoichiometryMath>
                     </speciesReference>
                 </listOfReactants>
                 ...
             </reaction>
             ...
         </listOfReactions>
         ...
     </model>
     @endverbatim


    @section spr-l3 SpeciesReference in SBML Level 3

    In Level 2's definition of a reaction, the stoichiometry attribute of a
    SpeciesReference is actually a combination of two factors, the standard
    biochemical stoichiometry and a conversion factor that may be needed to
    translate the units of the species quantity to the units of the reaction
    rate. Unfortunately, Level&nbsp;2 offers no direct way of decoupling
    these two factors, or for explicitly indicating the units. The only way
    to do it in Level&nbsp;2 is to use the StoichiometryMath object
    associated with SpeciesReferences, and to reference SBML Parameter
    objects from within the StoichiometryMath formula. This works because
    Parameter offers a way to attach units to a numerical value, but the
    solution is indirect and awkward for something that should be a simple
    matter.  Moreover, the question of how to properly encode
    stoichiometries in SBML reactions has caused much confusion among
    implementors of SBML software.

    SBML Level&nbsp;3 approaches this problem differently.  It (1) extends
    the the use of the SpeciesReference identifier to represent the value of
    the 'stoichiometry' attribute, (2) makes the 'stoichiometry' attribute
    optional, (3) removes StoichiometryMath, and (4) adds a new 'constant'
    boolean attribute on SpeciesReference.

    As in Level&nbsp;2, the 'stoichiometry' attribute is of type
    @c float and should contain values greater than zero (@c 0).  A
    missing 'stoichiometry' implies that the stoichiometry is either
    unknown, or to be obtained from an external source, or determined by an
    InitialAssignment object or other SBML construct elsewhere in the model.

    A species reference's stoichiometry is set by its 'stoichiometry'
    attribute exactly once.  If the SpeciesReference object's 'constant'
    attribute has the value @c True, then the stoichiometry is fixed and
    cannot be changed except by an InitialAssignment object.  These two
    methods of setting the stoichiometry (i.e., using 'stoichiometry'
    directly, or using InitialAssignment) differ in that the 'stoichiometry'
    attribute can only be set to a literal floating-point number, whereas
    InitialAssignment allows the value to be set using an arbitrary
    mathematical expression.  (As an example, the approach could be used to
    set the stoichiometry to a rational number of the form @em p/@em q,
    where @em p and @em q are integers, something that is occasionally
    useful in the context of biochemical reaction networks.)  If the species
    reference's 'constant' attribute has the value @c False, the species
    reference's value may be overridden by an InitialAssignment or changed
    by AssignmentRule or AlgebraicRule, and in addition, for simulation time
    <em>t &gt; 0</em>, it may also be changed by a RateRule or Event
    objects.  (However, some of these constructs are mutually exclusive; see
    the SBML Level&nbsp;3 Version&nbsp;1 Core specifiation for more
    details.)  It is not an error to define 'stoichiometry' on a species
    reference and also redefine the stoichiometry using an
    InitialAssignment, but the 'stoichiometry' attribute in that case is
    ignored.

    The value of the 'id' attribute of a SpeciesReference can be used as the
    content of a <code>&lt;ci&gt;</code> element in MathML formulas
    elsewhere in the model.  When the identifier appears in a MathML
    <code>&lt;ci&gt;</code> element, it represents the stoichiometry of the
    corresponding species in the reaction where the SpeciesReference object
    instance appears.  More specifically, it represents the value of the
    'stoichiometry' attribute on the SpeciesReference object.

    In SBML Level 3, the unit of measurement associated with the value of a
    species' stoichiometry is always considered to be @c dimensionless.
    This has the following implications:
    <ul>

    <li> When a species reference's identifier appears in mathematical
    formulas elsewhere in the model, the unit associated with that value is
    @c dimensionless.

    <li> The units of the 'math' elements of AssignmentRule,
    InitialAssignment and EventAssignment objects setting the stoichiometry
    of the species reference should be @c dimensionless.

    <li> If a species reference's identifier is the subject of a RateRule,
    the unit associated with the RateRule object's value should be
    <code>dimensionless</code>/<em>time</em>, where <em>time</em> is the
    model-wide unit of time set on the Model object.

    </ul>

    """
    __swig_setmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeciesReference, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeciesReference, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SpeciesReference
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> SpeciesReference
        __init__(self, SBMLNamespaces sbmlns) -> SpeciesReference
        __init__(self, SpeciesReference orig) -> SpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SpeciesReference(SBMLNamespaces sbmlns)</pre>

        Creates a new SpeciesReference using the given SBMLNamespaces object
        @p sbmlns.

        @param sbmlns an SBMLNamespaces object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SpeciesReference(long level, long version)</pre>

        Creates a new SpeciesReference using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this SpeciesReference

        @param version a long integer, the SBML Version to assign to this
        SpeciesReference

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SpeciesReference(SpeciesReference orig)</pre>

        Copy constructor; creates a copy of this SpeciesReference.

        @param orig the SpeciesReference instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_SpeciesReference(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SpeciesReference

        Creates and returns a deep copy of this SpeciesReference object.

        @return the (deep) copy of this SpeciesReference object.

        """
        return _libsbml.SpeciesReference_clone(self)

    def initDefaults(self):
        """
        initDefaults(self)

        Initializes the fields of this SpeciesReference object to 'typical'
        default values.

        The SBML SpeciesReference component has slightly different aspects and
        default attribute values in different SBML Levels and Versions.
        This method sets the values to certain common defaults, based
        mostly on what they are in SBML Level&nbsp;2.  Specifically:
        <ul>
        <li> Sets attribute 'stoichiometry' to @c 1.0
        <li> (Applies to Level&nbsp;1 models only) Sets attribute 'denominator' to @c 1
        </ul>

        @see getDenominator()
        @see setDenominator()
        @see getStoichiometry()
        @see setStoichiometry()
        @see getStoichiometryMath()
        @see setStoichiometryMath()

        """
        return _libsbml.SpeciesReference_initDefaults(self)

    def getStoichiometry(self):
        """
        getStoichiometry(self) -> double

        Get the value of the 'stoichiometry' attribute.

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c float and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @return the value of the (scalar) 'stoichiometry' attribute of this
        SpeciesReference.

        @see getStoichiometryMath()

        """
        return _libsbml.SpeciesReference_getStoichiometry(self)

    def getStoichiometryMath(self, *args):
        """
        getStoichiometryMath(self) -> StoichiometryMath
        getStoichiometryMath(self) -> StoichiometryMath

        Get the content of the 'stoichiometryMath' subelement as an ASTNode
        tree.

        The 'stoichiometryMath' element exists only in SBML Level 2.  There,
        product and reactant stoichiometries can be specified using
        <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c float and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or decimal).

        @return the content of the 'stoichiometryMath' subelement of this
        SpeciesReference.

        """
        return _libsbml.SpeciesReference_getStoichiometryMath(self, *args)

    def getDenominator(self):
        """
        getDenominator(self) -> int

        Get the value of the 'denominator' attribute, for the case of a
        rational-numbered stoichiometry or a model in SBML Level&nbsp;1.

        The 'denominator' attribute is only actually written out in the case
        of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number
        stoichiometries are written as MathML elements in the
        'stoichiometryMath' subelement.  However, as a convenience to users,
        libSBML allows the creation and manipulation of rational-number
        stoichiometries by supplying the numerator and denominator directly
        rather than having to manually create an ASTNode object.  LibSBML
        will write out the appropriate constructs (either a combination of
        'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or a
        'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).

        @return the value of the 'denominator' attribute of this
        SpeciesReference.

        """
        return _libsbml.SpeciesReference_getDenominator(self)

    def getConstant(self):
        """
        getConstant(self) -> bool

        Get the value of the 'constant' attribute.

        @return the value of the 'constant' attribute of this
        SpeciesReference.

        """
        return _libsbml.SpeciesReference_getConstant(self)

    def isSetStoichiometryMath(self):
        """
        isSetStoichiometryMath(self) -> bool

        Predicate returning @c True if this
        SpeciesReference's 'stoichiometryMath' subelement is set

        @return @c True if the 'stoichiometryMath' subelement of this
        SpeciesReference is set, @c False otherwise.

        """
        return _libsbml.SpeciesReference_isSetStoichiometryMath(self)

    def isSetConstant(self):
        """
        isSetConstant(self) -> bool

        Predicate returning @c True if this
        SpeciesReference's 'constant' attribute is set

        @return @c True if the 'constant' attribute of this
        SpeciesReference is set, @c False otherwise.

        """
        return _libsbml.SpeciesReference_isSetConstant(self)

    def isSetStoichiometry(self):
        """
        isSetStoichiometry(self) -> bool

        Predicate returning @c True if this
        SpeciesReference's 'stoichiometry' attribute is set.

        @return @c True if the 'stoichiometry' attribute of this
        SpeciesReference is set, @c False otherwise.

        """
        return _libsbml.SpeciesReference_isSetStoichiometry(self)

    def setStoichiometry(self, *args):
        """
        setStoichiometry(self, double value) -> int

        Sets the value of the 'stoichiometry' attribute of this
        SpeciesReference.

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c float and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @param value the new value of the 'stoichiometry' attribute

        @note In SBML Level&nbsp;2, the 'stoichiometryMath' subelement of this
        SpeciesReference object will be unset because the 'stoichiometry'
        attribute and the stoichiometryMath' subelement are mutually
        exclusive.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.SpeciesReference_setStoichiometry(self, *args)

    def setStoichiometryMath(self, *args):
        """
        setStoichiometryMath(self, StoichiometryMath math) -> int

        Sets the 'stoichiometryMath' subelement of this SpeciesReference.

        The Abstract Syntax Tree in @p math is copied.

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c float and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @param math the StoichiometryMath expression that is to be copied as the
        content of the 'stoichiometryMath' subelement.

        @note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this
        SpeciesReference object will be unset (isSetStoichiometry() will
        return @c False although getStoichiometry() will return @c 1.0) if the
        given math is not null because the 'stoichiometry' attribute and the
        stoichiometryMath' subelement are mutually exclusive.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink

        """
        return _libsbml.SpeciesReference_setStoichiometryMath(self, *args)

    def setDenominator(self, *args):
        """
        setDenominator(self, int value) -> int

        Set the value of the 'denominator' attribute, for the case of a
        rational-numbered stoichiometry or a model in SBML Level&nbsp;1.

        The 'denominator' attribute is only actually written out in the case
        of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number
        stoichiometries are written as MathML elements in the
        'stoichiometryMath' subelement.  However, as a convenience to users,
        libSBML allows the creation and manipulation of rational-number
        stoichiometries by supplying the numerator and denominator directly
        rather than having to manually create an ASTNode object.  LibSBML
        will write out the appropriate constructs (either a combination of
        'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or
        a 'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).

        @param value the scalar value 

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.SpeciesReference_setDenominator(self, *args)

    def setConstant(self, *args):
        """
        setConstant(self, bool flag) -> int

        Sets the 'constant' attribute of this SpeciesReference to the given boolean
        @p flag.

        @param flag a boolean, the value for the 'constant' attribute of this
        SpeciesReference instance

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.SpeciesReference_setConstant(self, *args)

    def unsetStoichiometryMath(self):
        """
        unsetStoichiometryMath(self) -> int

        Unsets the 'stoichiometryMath' subelement of this SpeciesReference.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        In SBML Level 2, product and reactant stoichiometries can be specified
        using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a
        SpeciesReference object.  The former is to be used when a
        stoichiometry is simply a scalar number, while the latter is for
        occasions when it needs to be a rational number or it needs to
        reference other mathematical expressions.  The 'stoichiometry'
        attribute is of type @c float and should contain values greater than
        zero (@c 0).  The 'stoichiometryMath' element is implemented as an
        element containing a MathML expression.  These two are mutually
        exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should
        be defined in a given SpeciesReference instance.  When neither the
        attribute nor the element is present, the value of 'stoichiometry' in
        the SpeciesReference instance defaults to @c 1.  For maximum
        interoperability between different software tools, the 'stoichiometry'
        attribute should be used in preference to 'stoichiometryMath' when a
        species' stoichiometry is a simple scalar number (integer or
        decimal).

        In SBML Level 3, there is no StoichiometryMath, and SpeciesReference
        objects have only the 'stoichiometry' attribute.

        @note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this
        SpeciesReference object will be reset to a default value (@c 1.0) if
        the 'stoichiometry' attribute has not been set.

        """
        return _libsbml.SpeciesReference_unsetStoichiometryMath(self)

    def unsetStoichiometry(self):
        """
        unsetStoichiometry(self) -> int

        Unsets the 'stoichiometry' attribute of this SpeciesReference.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note In SBML Level&nbsp;1, the 'stoichiometry' attribute of this
        SpeciesReference object will be just reset to a default value (@c 1.0)
        and isSetStoichiometry() will still return @c True.  In SBML
        Level&nbsp;2, the 'stoichiometry' attribute of this object will be
        unset (which will result in isSetStoichiometry() returning @c False,
        although getStoichiometry() will return @c 1.0) if the
        'stoichiometryMath' subelement is set, otherwise the attribute
        will be just reset to the default value (@c 1.0) (and
        isSetStoichiometry() will still return @c True).  In SBML
        Level&nbsp;3, the 'stoichiometry' attribute of this object will be set
        to @c NaN and isSetStoichiometry() will return @c False.

        """
        return _libsbml.SpeciesReference_unsetStoichiometry(self)

    def createStoichiometryMath(self):
        """
        createStoichiometryMath(self) -> StoichiometryMath

        Creates a new, empty StoichiometryMath object, adds it to this
        SpeciesReference, and returns it.

        @return the newly created StoichiometryMath object instance

        @see Reaction.addReactant()
        @see Reaction.addProduct()

        """
        return _libsbml.SpeciesReference_createStoichiometryMath(self)

    def setAnnotation(self, *args):
        """
        setAnnotation(self, XMLNode annotation) -> int
        setAnnotation(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setAnnotation(XMLNode annotation)</pre>

        Sets the value of the 'annotation' subelement of this SBML object to a
        copy of @p annotation.

        Any existing content of the 'annotation' subelement is discarded.
        Unless you have taken steps to first copy and reconstitute any
        existing annotations into the @p annotation that is about to be
        assigned, it is likely that performing such wholesale replacement is
        unfriendly towards other software applications whose annotations are
        discarded.  An alternative may be to use appendAnnotation().

        @param annotation an XML structure that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see appendAnnotation()
        @see appendAnnotation()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setAnnotation(string annotation)</pre>

        Sets the value of the 'annotation' subelement of this SBML object to a
        copy of @p annotation.

        Any existing content of the 'annotation' subelement is discarded.
        Unless you have taken steps to first copy and reconstitute any
        existing annotations into the @p annotation that is about to be
        assigned, it is likely that performing such wholesale replacement is
        unfriendly towards other software applications whose annotations are
        discarded.  An alternative may be to use appendAnnotation().

        @param annotation an XML string that is to be used as the content
        of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see appendAnnotation()
        @see appendAnnotation()

        """
        return _libsbml.SpeciesReference_setAnnotation(self, *args)

    def appendAnnotation(self, *args):
        """
        appendAnnotation(self, XMLNode annotation) -> int
        appendAnnotation(self, string annotation) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendAnnotation(XMLNode annotation)</pre>

        Appends annotation content to any existing content in the 'annotation'
        subelement of this object.

        The content in @p annotation is copied.  Unlike
        SpeciesReference.setAnnotation(),
        this method allows other annotations to be preserved when an application
        adds its own data.

        @param annotation an XML structure that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see setAnnotation()
        @see setAnnotation()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>appendAnnotation(string annotation)</pre>

        Appends annotation content to any existing content in the 'annotation'
        subelement of this object.

        The content in @p annotation is copied.  Unlike
        SpeciesReference.setAnnotation(), this
        method allows other annotations to be preserved when an application
        adds its own data.

        @param annotation an XML string that is to be copied and appended
        to the content of the 'annotation' subelement of this object

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see setAnnotation()
        @see setAnnotation()

        """
        return _libsbml.SpeciesReference_appendAnnotation(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_SPECIES_REFERENCE SBML_SPECIES_REFERENCE@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.SpeciesReference_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        SpeciesReference, is always @c 'speciesReference'.

        @return the name of this element, i.e., @c 'speciesReference'.

        """
        return _libsbml.SpeciesReference_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this SpeciesReference object
        have been set.

        The required attributes for a SpeciesReference object are:
        @li 'species'
        @li 'constant' (only available SBML Level&nbsp;3)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.SpeciesReference_hasRequiredAttributes(self)

SpeciesReference_swigregister = _libsbml.SpeciesReference_swigregister
SpeciesReference_swigregister(SpeciesReference)

class ListOfSpeciesReferences(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of SpeciesReference objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfSpeciesReferences, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfSpeciesReferences, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfSpeciesReferences
        __init__(self, SBMLNamespaces sbmlns) -> ListOfSpeciesReferences

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfSpeciesReferences(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfSpeciesReferences object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfSpeciesReferences object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfSpeciesReferences(long level, long version)</pre>

        Creates a new, empty ListOfSpeciesReferences object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfSpeciesReferences(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfSpeciesReferences

        Creates and returns a deep copy of this ListOfSpeciesReferences object.

        @return the (deep) copy of this ListOfSpeciesReferences object.

        """
        return _libsbml.ListOfSpeciesReferences_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., SpeciesReference objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for objects contained in this list:
        @link libsbml#SBML_SPECIES_REFERENCE SBML_SPECIES_REFERENCE@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfSpeciesReferences_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfSpeciesReferences, the XML element name is @c
        'listOfSpeciesReferences'.

        @return the name of this element, i.e., @c 'listOfSpeciesReferences'.

        """
        return _libsbml.ListOfSpeciesReferences_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> SimpleSpeciesReference
        get(self, unsigned int n) -> SimpleSpeciesReference
        get(self, string sid) -> SimpleSpeciesReference
        get(self, string sid) -> SimpleSpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a SpeciesReference from the ListOfSpeciesReferences.

        @param n the index number of the SpeciesReference to get.

        @return the nth SpeciesReference in this ListOfSpeciesReferences.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a SpeciesReference from the ListOfSpeciesReferences
        based on its identifier.

        @param sid a string representing the identifier 
        of the SpeciesReference to get.

        @return SpeciesReference in this ListOfSpeciesReferences
        with the given @p sid or @c None if no such
        SpeciesReference exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfSpeciesReferences_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> SimpleSpeciesReference
        remove(self, string sid) -> SimpleSpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfSpeciesReferences items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfSpeciesReferences items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfSpeciesReferences_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfSpeciesReferences
    __del__ = lambda self : None;
ListOfSpeciesReferences_swigregister = _libsbml.ListOfSpeciesReferences_swigregister
ListOfSpeciesReferences_swigregister(ListOfSpeciesReferences)

class ModifierSpeciesReference(SimpleSpeciesReference):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A reference to an SBML <em>modifier species</em>.

    Sometimes a species appears in the kinetic rate formula of a reaction
    but is itself neither created nor destroyed in that reaction (for
    example, because it acts as a catalyst or inhibitor).  In SBML, all such
    species are simply called @em modifiers without regard to the detailed
    role of those species in the model.  The Reaction structure provides a
    way to express which species act as modifiers in a given reaction.  This
    is the purpose of the list of modifiers available in Reaction.  The list
    contains instances of ModifierSpeciesReference structures.

    The ModifierSpeciesReference structure inherits the mandatory attribute
    'species' and optional attributes 'id' and 'name' from the parent class
    SimpleSpeciesReference.  See the description of SimpleSpeciesReference
    for more information about these.

    The value of the 'species' attribute must be the identifier of a species
    defined in the enclosing Model; this species is designated as a modifier
    for the current reaction.  A reaction may have any number of modifiers.
    It is permissible for a modifier species to appear simultaneously in the
    list of reactants and products of the same reaction where it is
    designated as a modifier, as well as to appear in the list of reactants,
    products and modifiers of other reactions in the model.

    """
    __swig_setmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModifierSpeciesReference, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleSpeciesReference]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModifierSpeciesReference, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ModifierSpeciesReference
        __init__(self, SBMLNamespaces sbmlns) -> ModifierSpeciesReference

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModifierSpeciesReference(SBMLNamespaces sbmlns)</pre>

        Creates a new ModifierSpeciesReference using the given SBMLNamespaces
        object @p sbmlns.

        @param sbmlns an SBMLNamespaces object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModifierSpeciesReference(long level, long version)</pre>

        Creates a new ModifierSpeciesReference using the given SBML @p level and
        @p version values.

        @param level a long integer, the SBML Level to assign to this
        ModifierSpeciesReference

        @param version a long integer, the SBML Version to assign to this
        ModifierSpeciesReference

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        """
        this = _libsbml.new_ModifierSpeciesReference(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ModifierSpeciesReference
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> ModifierSpeciesReference

        Creates and returns a deep copy of this ModifierSpeciesReference object.

        @return the (deep) copy of this ModifierSpeciesReference object.

        """
        return _libsbml.ModifierSpeciesReference_clone(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code for this %SBML object.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_MODIFIER_SPECIES_REFERENCE SBML_MODIFIER_SPECIES_REFERENCE@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ModifierSpeciesReference_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Species, is
        always @c 'modifierSpeciesReference'.

        @return the name of this element, i.e., @c 'modifierSpeciesReference'.

        """
        return _libsbml.ModifierSpeciesReference_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this ModifierSpeciesReference object
        have been set.

        The required attributes for a ModifierSpeciesReference object are:
        species

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.ModifierSpeciesReference_hasRequiredAttributes(self)

ModifierSpeciesReference_swigregister = _libsbml.ModifierSpeciesReference_swigregister
ModifierSpeciesReference_swigregister(ModifierSpeciesReference)

class Event(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A discontinuous SBML <em>event</em>.

    An SBML Event object defines when the event can occur, the variables
    that are affected by it, how the variables are affected, and the event's
    relationship to other events.  The effect of the event can optionally be
    delayed after the occurrence of the condition which invokes it.

    The operation of Event is divided into two phases (even when the event
    is not delayed): one when the event is @em triggered, and the other when
    the event is @em executed.  Trigger objects define the conditions for
    triggering an event, Delay objects define when the event is actually
    executed, EventAssignment objects define the effects of executing the
    event, and (in SBML Level&nbsp;3) Priority objects influence the order
    of EventAssignment performance in cases of simultaneous events.  Please
    consult the descriptions of Trigger, Delay, EventAssignment and Priority
    for more information.

    @section event-version-diffs SBML Level/Version differences

    @subsection sbml-l3 SBML Level 3

    SBML Level 3 introduces several changes to the structure and components
    of Events compared to SBML Level&nbsp;2.  These changes fall into two
    main categories: changes to what is optional or required, and additions
    of new attributes and elements.
    <ul>
    <li> The attribute 'useValuesFromTriggerTime' on Event is mandatory (it
    was optional in Level&nbsp;2);
    <li> Event's 'listOfEventAssignments' element (of class
    ListOfEventAssignments) is optional (it was mandatory in Level&nbsp;2);
    <li> Event's 'priority' element (of class Priority) is new in
    Level&nbsp;3; and
    <li> The Trigger object gains new mandatory attributes (described as part
    of the definition of Trigger).
    </ul>

    The changes to the attributes of Event are described below; the changes
    to Trigger and Priority are described in their respective sections.

    @subsection sbml-l2 SBML Level 2

    In SBML Level&nbsp;2 versions before Version&nbsp;4, the semantics of
    Event time delays were defined such that the expressions in the event's
    assignments were always evaluated at the time the event was
    <em>triggered</em>.  This definition made it difficult to define an event
    whose assignment formulas were meant to be evaluated at the time the
    event was <em>executed</em> (i.e., after the time period defined by the
    value of the Delay element).  In SBML Level&nbsp;2 Version&nbsp;4 and in
    Level&nbsp;3, the attribute 'useValuesFromTriggerTime' on Event allows a
    model to indicate the time at which the event's assignments are intended
    the values of the assignment formulas are computed at the moment the
    event is triggered, not after the delay.  If 'useValuesFromTriggerTime'=@c False, it means that the formulas in the event's assignments are to be
    computed @em after the delay, at the time the event is executed.

    The definition of Event in SBML Level&nbsp;2 Versions 1 and 2 includes
    an additional attribute called 'timeUnits', which allowed the time units
    of the Delay to be set explicitly.  Later Versions of SBML Level&nbsp;2
    as well as SBML Level&nbsp;3 do not define this attribute.  LibSBML
    supports this attribute for compatibility with previous versions of SBML
    Level&nbsp;2; however, if a model in SBML Level&nbsp;3 or Level&nbsp;2
    Versions&nbsp;3&ndash;4 format sets the attribute, the
    consistency-checking method SBMLDocument.checkConsistency() will report
    an error.

    The attribute 'useValuesFromTriggerTime' was introduced in SBML
    Level&nbsp;2 Version&nbsp;4.  Models defined in prior Versions of SBML
    Level&nbsp;2 cannot use this attribute, and
    SBMLDocument.checkConsistency() will report an error if they do.

    @section semantics Semantics of events in SBML Level 3 Version&nbsp;1

    The detailed semantics of events are described in the specification
    documents for each SBML Level/Version.  Here we include the description
    from the SBML Level&nbsp;1 Version&nbsp;1.
    Any transition of a Trigger object's 'math' formula from the value @c False to @c True will cause the enclosing Event object to
    <em>trigger</em>.  Such a transition is not possible at the very start
    of a simulation (i.e., at time <em>t = 0</em>) unless the Trigger
    object's 'initialValue' attribute has a value of @c False; this defines
    the value of the trigger formula to be @c False immediately prior to the
    start of simulation, thereby giving it the potential to change in value
    from @c False to @c True when the formula is evaluated at <em>t =
    0</em>.  If 'initialValue'=@c True, then the trigger expression cannot
    transition from @c False to @c True at <em>t = 0</em> but may do so at
    some time <em>t > 0</em>.

    Consider an Event object definition <EM>E</EM> with delay <em>d</em> in
    which the Trigger object's 'math' formula makes a transition in value
    from @c False to @c True at times <em>t<sub>1</sub></em> and
    <em>t<sub>2</sub></em>.  The EventAssignment within the Event object
    will have effect at <em>t<sub>1</sub> + d</em> and
    <em>t<sub>2</sub> + d</em> irrespective of the relative times of
    <em>t<sub>1</sub></em> and <em>t<sub>2</sub></em>.  For example, events
    can 'overlap' so that <em>t<sub>1</sub> < t<sub>2</sub> <
    t<sub>1</sub> + d</em> still causes an event assignments to occur at
    <em>t<sub>1</sub> + d</em> and <em>t<sub>2</sub> + d</em>.

    It is entirely possible for two events to be executed simultaneously,
    and it is possible for events to trigger other events (i.e., an event
    assignment can cause an event to trigger).  This leads to several
    points:
    <ul>

    <li> A software package should retest all event triggers after executing
    an event assignment in order to account for the possibility that the
    assignment causes another event trigger to transition from @c False to
    @c True.  This check should be made after each individual Event object's
    execution, even when several events are to be executed simultaneously.

    <li> Any Event object whose Trigger 'persistent' attribute has the value
    @c False must have its trigger expression reevaluated continuously
    between when the event is triggered and when it is executed.  If
    its trigger expression ever evaluates to @c False, it must be removed
    from the queue of events pending execution and treated as any other
    event whose trigger expression evaluates to @c False.

    <li> Although the precise time at which events are executed is not
    resolved beyond the given execution point in simulated time, it is
    assumed that the order in which the events occur <em>is</em> resolved.
    This order can be significant in determining the overall outcome of a
    given simulation.  When an event <EM>X</EM> <em>triggers</em> another
    event <EM>Y</EM> and event <EM>Y</EM> has zero delay, then event
    <EM>Y</EM> is added to the existing set of simultaneous events that are
    pending <em>execution</em>.  Events <EM>X</EM> and <EM>Y</EM> form a
    cascade of events at the same point in simulation time.  An event such
    as <EM>Y</EM> may have a special priority if it contains a Priority
    subobject.

    <li> All events in a model are open to being in a cascade.  The position
    of an event in the event queue does not affect whether it can be in the
    cascade: event <EM>Y</EM> can be triggered whether it is before or after
    <EM>X</EM> in the queue of events pending execution.  A cascade of
    events can be potentially infinite (never terminate); when this occurs a
    simulator should indicate this has occurred---it is incorrect for a
    simulator to break a cascade arbitrarily and continue the simulation
    without at least indicating that the infinite cascade occurred.

    <li> Simultaneous events having no defined priorities are executed in an
    undefined order.  This does not mean that the behavior of the simulation
    is completely undefined; merely that the <em>order</em> of execution of
    these particular events is undefined.  A given simulator may use any
    algorithm to choose an order as long as every event is executed exactly
    once.

    <li> Events with defined priorities are executed in the order implied by
    their Priority 'math' formula values, with events having higher
    priorities being executed ahead of events with lower priorities, and
    events with identical priorities being executed in a random order with
    respect to one another (as determined at run-time by some random
    algorithm equivalent to coin-flipping).  Newly-triggered events that are
    to be executed immediately (i.e., if they define no delays) should be
    inserted into the queue of events pending execution according to their
    priorities: events with higher priority values value must be inserted
    ahead of events with lower priority values and after any pending events
    with even higher priorities, and inserted randomly among pending events
    with the same priority values.  Events without Priority objects must be
    inserted into the queue in some fashion, but the algorithm used to place
    it in the queue is undefined.  Similarly, there is no restriction on the
    order of a newly-inserted event with a defined Priority with respect to
    any other pending Event without a defined Priority.

    <li> A model variable that is the target of one or more event
    assignments can change more than once when simultaneous events are
    processed at some time point <em>t</em>.  The model's behavior (output)
    for such a variable is the value of the variable at the end of
    processing all the simultaneous events at time <em>t</em>.

    </ul>

    @see Trigger
    @see Priority
    @see Delay
    @see EventAssignment

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Event, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Event, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Event
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Event
        __init__(self, SBMLNamespaces sbmlns) -> Event
        __init__(self, Event orig) -> Event

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Event(SBMLNamespaces sbmlns)</pre>

        Creates a new Event using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Event(long level, long version)</pre>

        Creates a new Event using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Event

        @param version a long integer, the SBML Version to assign to this
        Event

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Event(Event orig)</pre>

        Copy constructor; creates a copy of this Event.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Event(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Event

        Creates and returns a deep copy of this Event object.

        @return the (deep) copy of this Event object.

        """
        return _libsbml.Event_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.Event_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid, or
        @c None if no such object is found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        """
        return _libsbml.Event_getElementByMetaId(self, *args)

    def getId(self):
        """
        getId(self) -> string

        Returns the value of the 'id' attribute of this Event.

        @return the id of this Event.

        """
        return _libsbml.Event_getId(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the value of the 'name' attribute of this Event.

        @return the name of this Event.

        """
        return _libsbml.Event_getName(self)

    def getTrigger(self, *args):
        """
        getTrigger(self) -> Trigger
        getTrigger(self) -> Trigger

        Get the event trigger portion of this Event.

        @return the Trigger object of this Event.

        """
        return _libsbml.Event_getTrigger(self, *args)

    def getDelay(self, *args):
        """
        getDelay(self) -> Delay
        getDelay(self) -> Delay

        Get the assignment delay portion of this Event, if there is one.

        @return the delay of this Event if one is defined, or @c None if none
        is defined.

        """
        return _libsbml.Event_getDelay(self, *args)

    def getPriority(self, *args):
        """
        getPriority(self) -> Priority
        getPriority(self) -> Priority

        (SBML Level&nbsp;3 only) Get the event priority portion of this
        Event.

        @return the Priority object of this Event.

        @note The element 'priority' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Event_getPriority(self, *args)

    def getTimeUnits(self):
        """
        getTimeUnits(self) -> string

        Get the value of the 'timeUnits' attribute of this Event, if it has one.

        @return the value of the attribute 'timeUnits' as a string.

        @warning <span class='warning'>Definitions of Event in SBML Level 2
        Versions&nbsp;1 and&nbsp;2 included the additional attribute called
        'timeUnits', but it was removed in SBML Level&nbsp;2 Version&nbsp;3.
        LibSBML supports this attribute for compatibility with previous versions
        of SBML Level&nbsp;2, but its use is discouraged since models in
        Level&nbsp;2 Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a
        Version&nbsp;3 or&nbsp;4 model sets the attribute, the
        consistency-checking method SBMLDocument.checkConsistency() will report
        an error.</span>

        """
        return _libsbml.Event_getTimeUnits(self)

    def getUseValuesFromTriggerTime(self):
        """
        getUseValuesFromTriggerTime(self) -> bool

        Get the value of the 'useValuesFromTriggerTime' attribute of this Event.

        @par
        The optional Delay on Event means there are two times to consider when
        computing the results of an event: the time at which the event is
        <em>triggered</em>, and the time at which assignments are
        <em>executed</em>.  It is also possible to distinguish between the
        time at which the EventAssignment's expression is calculated, and the
        time at which the assignment is made: the expression could be
        evaluated at the same time the assignments are performed, i.e., when
        the event is <em>executed</em>, but it could also be defined to be
        evaluated at the time the event is <em>triggered</em>.

        In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics
        of Event time delays were defined such that the expressions in the
        event's assignments were always evaluated at the time the event was
        <em>triggered</em>.  This definition made it difficult to define an
        event whose assignment formulas were meant to be evaluated at the time
        the event was <em>executed</em> (i.e., after the time period defined
        by the value of the Delay element).  In SBML Level&nbsp;2
        Version&nbsp;4, the attribute 'useValuesFromTriggerTime' on Event
        allows a model to indicate the time at which the event's assignments
        are intended to be evaluated.  In SBML Level&nbsp;2, the attribute has
        a default value of @c True, which corresponds to the interpretation of
        event assignments prior to Version&nbsp;4: the values of the
        assignment formulas are computed at the moment the event is triggered,
        not after the delay.  If 'useValuesFromTriggerTime'=@c False, it means
        that the formulas in the event's assignments are to be computed after
        the delay, at the time the event is executed.  In SBML Level&nbsp;3,
        the attribute is mandatory, not optional, and all events must specify
        a value for it.

        @return the value of the attribute 'useValuesFromTriggerTime' as a boolean.

        @warning <span class='warning'>The attribute 'useValuesFromTriggerTime'
        was introduced in SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in
        models defined using SBML Level&nbsp;2 versions prior to Version&nbsp;4.
        If a Level&nbsp;2 Version&nbsp;1&ndash;3 model sets the attribute, the
        consistency-checking method SBMLDocument.checkConsistency() will report
        an error.</span>

        """
        return _libsbml.Event_getUseValuesFromTriggerTime(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Predicate returning @c True if this
        Event's 'id' attribute is set.

        @return @c True if the 'id' attribute of this Event is
        set, @c False otherwise.

        """
        return _libsbml.Event_isSetId(self)

    def isSetName(self):
        """
        isSetName(self) -> bool

        Predicate returning @c True if this
        Event's 'name' attribute is set.

        @return @c True if the 'name' attribute of this Event is
        set, @c False otherwise.

        """
        return _libsbml.Event_isSetName(self)

    def isSetTrigger(self):
        """
        isSetTrigger(self) -> bool

        Predicate for testing whether the trigger for this Event is set.

        @return @c True if the trigger of this Event is set, @c False
        otherwise.

        """
        return _libsbml.Event_isSetTrigger(self)

    def isSetDelay(self):
        """
        isSetDelay(self) -> bool

        Predicate for testing whether the delay for this Event is set.

        @return @c True if the delay of this Event is set, @c False
        otherwise.

        """
        return _libsbml.Event_isSetDelay(self)

    def isSetPriority(self):
        """
        isSetPriority(self) -> bool

        (SBML Level&nbsp;3 only) Predicate for testing whether the priority
        for this Event is set.

        @return @c True if the priority of this Event is set, @c False
        otherwise.

        @note The element 'priority' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Event_isSetPriority(self)

    def isSetTimeUnits(self):
        """
        isSetTimeUnits(self) -> bool

        Predicate for testing whether the 'timeUnits' attribute of this Event
        is set.

        @return @c True if the 'timeUnits' attribute of this Event is
        set, @c False otherwise.

        @warning <span class='warning'>Definitions of Event in SBML Level 2
        Versions&nbsp;1 and&nbsp;2 included the additional attribute called
        'timeUnits', but it was removed in SBML Level&nbsp;2 Version&nbsp;3.
        LibSBML supports this attribute for compatibility with previous versions
        of SBML Level&nbsp;2, but its use is discouraged since models in
        Level&nbsp;2 Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a
        Version&nbsp;3 or&nbsp;4 model sets the attribute, the
        consistency-checking method SBMLDocument.checkConsistency() will report
        an error.</span>

        """
        return _libsbml.Event_isSetTimeUnits(self)

    def isSetUseValuesFromTriggerTime(self):
        """
        isSetUseValuesFromTriggerTime(self) -> bool

        Predicate for testing whether the 'useValuesFromTriggerTime' attribute of this Event
        is set.

        @return @c True if the 'useValuesFromTriggerTime' attribute of this Event is
        set, @c False otherwise.

        @note In SBML Level&nbsp;2, this attribute is optional and has a default value of
        @c True, whereas in Level&nbsp;3 Version&nbsp;1, this optional is mandatory and
        has no default value.

        """
        return _libsbml.Event_isSetUseValuesFromTriggerTime(self)

    def setId(self, *args):
        """
        setId(self, string sid) -> int

        Sets the value of the 'id' attribute of this Event.

        The string @p sid is copied.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @param sid the string to use as the identifier of this Event

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Event_setId(self, *args)

    def setName(self, *args):
        """
        setName(self, string name) -> int

        Sets the value of the 'name' attribute of this Event.

        The string in @p name is copied.

        @param name the new name for the Event

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Event_setName(self, *args)

    def setTrigger(self, *args):
        """
        setTrigger(self, Trigger trigger) -> int

        Sets the trigger definition of this Event to a copy of the given
        Trigger object instance.

        @param trigger the Trigger object instance to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink

        """
        return _libsbml.Event_setTrigger(self, *args)

    def setDelay(self, *args):
        """
        setDelay(self, Delay delay) -> int

        Sets the delay definition of this Event to a copy of the given Delay
        object instance.

        @param delay the Delay object instance to use

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink

        """
        return _libsbml.Event_setDelay(self, *args)

    def setPriority(self, *args):
        """
        setPriority(self, Priority priority) -> int

        (SBML Level&nbsp;3 only) Sets the priority definition of this Event
        to a copy of the given Priority object instance.

        @param priority the Priority object instance to use

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The element 'priority' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Event_setPriority(self, *args)

    def setTimeUnits(self, *args):
        """
        setTimeUnits(self, string sid) -> int

        Sets the 'timeUnits' attribute of this Event to a copy of @p sid.

        @param sid the identifier of the time units to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @warning <span class='warning'>Definitions of Event in SBML Level 2
        Versions&nbsp;1 and&nbsp;2 included the additional attribute called
        'timeUnits', but it was removed in SBML Level&nbsp;2 Version&nbsp;3.
        LibSBML supports this attribute for compatibility with previous versions
        of SBML Level&nbsp;2, but its use is discouraged since models in
        Level&nbsp;2 Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a
        Version&nbsp;3 or&nbsp;4 model sets the attribute, the
        consistency-checking method SBMLDocument.checkConsistency() will report
        an error.</span>

        """
        return _libsbml.Event_setTimeUnits(self, *args)

    def setUseValuesFromTriggerTime(self, *args):
        """
        setUseValuesFromTriggerTime(self, bool value) -> int

        Sets the 'useValuesFromTriggerTime' attribute of this Event to a @p value.

        @par
        The optional Delay on Event means there are two times to consider when
        computing the results of an event: the time at which the event is
        <em>triggered</em>, and the time at which assignments are
        <em>executed</em>.  It is also possible to distinguish between the
        time at which the EventAssignment's expression is calculated, and the
        time at which the assignment is made: the expression could be
        evaluated at the same time the assignments are performed, i.e., when
        the event is <em>executed</em>, but it could also be defined to be
        evaluated at the time the event is <em>triggered</em>.

        In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics
        of Event time delays were defined such that the expressions in the
        event's assignments were always evaluated at the time the event was
        <em>triggered</em>.  This definition made it difficult to define an
        event whose assignment formulas were meant to be evaluated at the time
        the event was <em>executed</em> (i.e., after the time period defined
        by the value of the Delay element).  In SBML Level&nbsp;2
        Version&nbsp;4, the attribute 'useValuesFromTriggerTime' on Event
        allows a model to indicate the time at which the event's assignments
        are intended to be evaluated.  In SBML Level&nbsp;2, the attribute has
        a default value of @c True, which corresponds to the interpretation of
        event assignments prior to Version&nbsp;4: the values of the
        assignment formulas are computed at the moment the event is triggered,
        not after the delay.  If 'useValuesFromTriggerTime'=@c False, it means
        that the formulas in the event's assignments are to be computed after
        the delay, at the time the event is executed.  In SBML Level&nbsp;3,
        the attribute is mandatory, not optional, and all events must specify
        a value for it.

        @param value the value of useValuesFromTriggerTime to use.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @warning <span class='warning'>The attribute 'useValuesFromTriggerTime'
        was introduced in SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in
        models defined using SBML Level&nbsp;2 versions prior to Version&nbsp;4.
        If a Level&nbsp;2 Version&nbsp;1&ndash;3 model sets the attribute, the
        consistency-checking method SBMLDocument.checkConsistency() will report
        an error.</span>

        """
        return _libsbml.Event_setUseValuesFromTriggerTime(self, *args)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the value of the 'id' attribute of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Event_unsetId(self)

    def unsetName(self):
        """
        unsetName(self) -> int

        Unsets the value of the 'name' attribute of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Event_unsetName(self)

    def unsetDelay(self):
        """
        unsetDelay(self) -> int

        Unsets the Delay of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Event_unsetDelay(self)

    def unsetPriority(self):
        """
        unsetPriority(self) -> int

        (SBML Level&nbsp;3 only) Unsets the Priority of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The element 'priority' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Event_unsetPriority(self)

    def unsetTrigger(self):
        """
        unsetTrigger(self) -> int

        Unsets the Trigger of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note The element 'priority' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Event_unsetTrigger(self)

    def unsetTimeUnits(self):
        """
        unsetTimeUnits(self) -> int

        Unsets the 'timeUnits' attribute of this Event.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @warning <span class='warning'>Definitions of Event in SBML Level 2
        Versions&nbsp;1 and&nbsp;2 included the additional attribute called
        'timeUnits', but it was removed in SBML Level&nbsp;2 Version&nbsp;3.
        LibSBML supports this attribute for compatibility with previous versions
        of SBML Level&nbsp;2, but its use is discouraged since models in
        Level&nbsp;2 Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a
        Version&nbsp;3 or&nbsp;4 model sets the attribute, the
        consistency-checking method SBMLDocument.checkConsistency() will report
        an error.</span>

        """
        return _libsbml.Event_unsetTimeUnits(self)

    def addEventAssignment(self, *args):
        """
        addEventAssignment(self, EventAssignment ea) -> int

        Appends a copy of the given EventAssignment to this Event.

        @param ea the EventAssignment object to add.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH@endlink
        @li @link libsbml#LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH@endlink
        @li @link libsbml#LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note This method should be used with some caution.  The fact that this
        method @em copies the object passed to it means that the caller will be
        left holding a physically different object instance than the one contained
        inside this object.  Changes made to the original object instance (such as
        resetting attribute values) will <em>not affect the instance in this
        object</em>.  In addition, the caller should make sure to free the
        original object if it is no longer being used, or else a memory leak will
        result.  Please see other methods on this class (particularly a
        corresponding method whose name begins with the word <code>create</code>)
        for alternatives that do not lead to these issues. 

        @see createEventAssignment()

        """
        return _libsbml.Event_addEventAssignment(self, *args)

    def createEventAssignment(self):
        """
        createEventAssignment(self) -> EventAssignment

        Creates a new, empty EventAssignment, adds it to this Event's list of
        event assignments and returns the EventAssignment.

        @return the newly created EventAssignment object instance

        @see addEventAssignment()

        """
        return _libsbml.Event_createEventAssignment(self)

    def createTrigger(self):
        """
        createTrigger(self) -> Trigger

        Creates a new, empty Trigger, adds it to this Event and 
        returns the Trigger.

        @return the newly created Trigger object instance

        """
        return _libsbml.Event_createTrigger(self)

    def createDelay(self):
        """
        createDelay(self) -> Delay

        Creates a new, empty Delay, adds it to this Event and 
        returns the Delay.

        @return the newly created Delay object instance

        """
        return _libsbml.Event_createDelay(self)

    def createPriority(self):
        """
        createPriority(self) -> Priority

        (SBML Level&nbsp;3 only) Creates a new, empty Priority, adds it to this
        Event and returns the Priority.

        @return the newly created Priority object instance

        @note The element 'priority' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Event_createPriority(self)

    def getListOfEventAssignments(self, *args):
        """
        getListOfEventAssignments(self) -> ListOfEventAssignments
        getListOfEventAssignments(self) -> ListOfEventAssignments

        Returns the list of event assignments for this Event.

        @return the list of EventAssignments for this Event.

        """
        return _libsbml.Event_getListOfEventAssignments(self, *args)

    def getEventAssignment(self, *args):
        """
        getEventAssignment(self, unsigned int n) -> EventAssignment
        getEventAssignment(self, unsigned int n) -> EventAssignment
        getEventAssignment(self, string variable) -> EventAssignment
        getEventAssignment(self, string variable) -> EventAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getEventAssignment(string variable)</pre>

        Return the event assignment indicated by the given @p variable.

        @param variable a string, the identifier of the variable whose
        EventAssignment is being sought.

        @return the EventAssignment for the given @p variable, or @c None if
        no such EventAssignment exits.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getEventAssignment(long n)</pre>

        Return a specific EventAssignment object of this Event.

        @param n an integer, the index of the EventAssignment object to return

        @return the <code>n</code>th EventAssignment of this Event.

        """
        return _libsbml.Event_getEventAssignment(self, *args)

    def getNumEventAssignments(self):
        """
        getNumEventAssignments(self) -> unsigned int

        Returns the number of EventAssignment objects attached to this
        Event.

        @return the number of EventAssignments in this Event.

        """
        return _libsbml.Event_getNumEventAssignments(self)

    def removeEventAssignment(self, *args):
        """
        removeEventAssignment(self, unsigned int n) -> EventAssignment
        removeEventAssignment(self, string variable) -> EventAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeEventAssignment(string variable)</pre>

        Removes the EventAssignment object with the given 'variable' attribute 
        from this Event object and returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.
        If none of the EventAssignment objects in this Event object have the 
        'variable' attribute @p variable, then @c None is returned.

        @param variable the 'variable' attribute of the EventAssignment object 
        to remove

        @return the EventAssignment object removed.  As mentioned above, the 
        caller owns the returned object. @c None is returned if no EventAssignment
        object with the 'variable' attribute exists in this Event object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeEventAssignment(long n)</pre>

        Removes the nth EventAssignment object from this Event object and
        returns a pointer to it.

        The caller owns the returned object and is responsible for deleting it.

        @param n the index of the EventAssignment object to remove

        @return the EventAssignment object removed.  As mentioned above, 
        the caller owns the returned item. @c None is returned if the given index 
        is out of range.

        """
        return _libsbml.Event_removeEventAssignment(self, *args)

    def connectToChild(self):
        """
        connectToChild(self)

        @internal
        Sets this SBML object to child SBML objects (if any).
        (Creates a child-parent relationship by the parent)

        Subclasses must override this function if they define
        one ore more child elements.
        Basically, this function needs to be called in
        constructor, copy constructor and assignment operator.

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.Event_connectToChild(self)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with this element and child
        elements (if any).
        (This is an internal implementation for enablePackage function)

        @note Subclasses of the SBML Core package in which one or more child
        elements are defined must override this function.

        @internal

        """
        return _libsbml.Event_enablePackageInternal(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_EVENT SBML_EVENT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Event_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Event, is
        always @c 'event'.

        @return the name of this element, i.e., @c 'event'.

        """
        return _libsbml.Event_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        Event object have been set.

        The required attributes for an Event object are:
        @li 'useValuesfromTriggerTime' (required in SBML Level&nbsp;3)

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.Event_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for the given Event_t structure
        have been set.

        @note The required elements for an Event object are:
        @li 'trigger'
        @li 'listOfEventAssignments' (required in SBML Level&nbsp;2, optional in Level&nbsp;3)

        """
        return _libsbml.Event_hasRequiredElements(self)

Event_swigregister = _libsbml.Event_swigregister
Event_swigregister(Event)

class ListOfEvents(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of Event objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfEvents, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfEvents, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfEvents
        __init__(self, SBMLNamespaces sbmlns) -> ListOfEvents

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfEvents(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfEvents object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfEvents object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfEvents(long level, long version)</pre>

        Creates a new ListOfEvents object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfEvents(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfEvents

        Creates and returns a deep copy of this ListOfEvents object.

        @return the (deep) copy of this ListOfEvents object.

        """
        return _libsbml.ListOfEvents_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., Event objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf:
        @link libsbml#SBML_EVENT SBML_EVENT@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfEvents_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfEvents, the XML element name is @c 'listOfEvents'.

        @return the name of this element, i.e., @c 'listOfEvents'.

        """
        return _libsbml.ListOfEvents_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> Event
        get(self, unsigned int n) -> Event
        get(self, string sid) -> Event
        get(self, string sid) -> Event

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get an Event from the ListOfEvents.

        @param n the index number of the Event to get.

        @return the <code>n</code>th Event in this ListOfEvents.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get an Event from the ListOfEvents
        based on its identifier.

        @param sid a string representing the identifier 
        of the Event to get.

        @return Event in this ListOfEvents
        with the given @p sid or @c None if no such
        Event exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfEvents_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> Event
        remove(self, string sid) -> Event

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfEvents items and returns a pointer to
        it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfEvents items with the given identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then
        @c None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfEvents_remove(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfEvents
    __del__ = lambda self : None;
ListOfEvents_swigregister = _libsbml.ListOfEvents_swigregister
ListOfEvents_swigregister(ListOfEvents)

class EventAssignment(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An assignment to a variable by an SBML <em>event</em>.

    Event contains an optional element called 'listOfEventAssignments', of
    class ListOfEventAssignments.  In every instance of an event definition
    in a model, the object's 'listOfEventAssignments' element must have a
    non-empty list of one or more 'eventAssignment' elements of class
    EventAssignment.  The object class EventAssignment has one required
    attribute, 'variable', and a required element, 'math'.  Being derived
    from SBase, it also has all the usual attributes and elements of its
    parent class.

    An Event object defines when the event can occur, the variables that are
    affected by the event, and how the variables are affected.  The purpose
    of the EventAssignment object class is to define how variables are
    affected by an Event.  In SBML Level&nbsp;2, every Event object instance
    must have a nonempty list of event assignments; in SBML Level&nbsp;3,
    the list of assignments is optional.

    The operation of an Event is divided into two phases (regardless of
    whether a delay is involved): one phase when the event is @em triggered,
    and the other when the event is @em executed.   EventAssignment objects
    are interpreted when an event is executed.  The effects are described
    below.

    @section event-variable The attribute 'variable'

    The EventAssignment attribute 'variable' must be the identifier of an
    existing Compartment, Species, SpeciesReference, or Parameter
    instance defined in the model.  When the event is executed, the value of
    the model component identified by 'variable' is changed by the
    EventAssignment to the value computed by the 'math' element; that is, a
    species' quantity, species reference's stoichiometry, compartment's size
    or parameter's value are reset to the value computed by 'math'.

    Certain restrictions are placed on what can appear in 'variable':
    <ul>
    <li> The object identified by the value of the EventAssignment attribute
    'variable' must not have its 'constant' attribute set to or default to
    @c True.  (Constants cannot be affected by events.)

    <li> The 'variable' attribute must not contain the identifier of a
    reaction; only species, species references, compartment and parameter
    values may be set by an Event.

    <li> The value of every 'variable' attribute must be unique among the set
    of EventAssignment structures within a given Event structure.  In other
    words, a single event cannot have multiple EventAssignment objects
    assigning the same variable.  (All of them would be performed at the
    same time when that particular Event triggers, resulting in
    indeterminacy.)  However, @em separate Event instances can refer to the
    same variable.

    <li> A variable cannot be assigned a value in an EventAssignment object
    instance and also be assigned a value by an AssignmentRule; i.e., the
    value of an EventAssignment's 'variable' attribute cannot be the same as
    the value of a AssignmentRule' 'variable' attribute.  (Assignment rules
    hold at all times, therefore it would be inconsistent to also define an
    event that reassigns the value of the same variable.)
    </ul>

    Note that the time of assignment of the object identified by the
    value of the 'variable' attribute is always the time at which the Event
    is <em>executed</em>, not when it is <em>triggered</em>.  The timing is
    controlled by the optional Delay in an Event.  The time of
    assignment is not affected by the 'useValuesFromTriggerTime'
    attribute on Event---that attribute affects the time at which the
    EventAssignment's 'math' expression is @em evaluated.  In other
    words, SBML allows decoupling the time at which the
    'variable' is assigned from the time at which its value
    expression is calculated.

    @section event-math The 'math' subelement in an EventAssignment

    The MathML expression contained in an EventAssignment defines the new
    value of the variable being assigned by the Event.

    As mentioned above, the time at which the expression in 'math' is
    evaluated is determined by the attribute 'useValuesFromTriggerTime' on
    Event.  If the attribute value is @c True, the expression must be
    evaluated when the event is @em triggered; more precisely, the values of
    identifiers occurring in MathML <code>&lt;ci&gt;</code> elements in the
    EventAssignment's 'math' expression are the values they have at the
    point when the event @em triggered.  If, instead,
    'useValuesFromTriggerTime''s value is @c False, it means the values at
    @em execution time should be used; that is, the values of identifiers
    occurring in MathML <code>&lt;ci&gt;</code> elements in the
    EventAssignment's 'math' expression are the values they have at the
    point when the event @em executed.

    @section eventassignment-version-diffs SBML Level/Version differences

    Between Version&nbsp;4 and previous versions of SBML Level&nbsp;2, the
    requirements regarding the matching of units between an
    EvengAssignment's formula and the units of the object identified by the
    'variable' attribute changed.  Previous versions required consistency,
    but in SBML Level&nbsp;2 Version&nbsp;4 and in SBML Level&nbsp;3, unit
    consistency is only @em recommended.  More precisely:
    <ul>

    <li> In the case of a species, an EventAssignment sets the referenced
    species' quantity (concentration or amount of substance) to the value
    determined by the formula in the EventAssignment's 'math' subelement.
    The units of the 'math' formula should (in SBML Level&nbsp;2
    Version&nbsp;4 and in Level&nbsp;3) or must (in previous Versions of
    Level&nbsp;2) be identical to the units of the species.

    <li> (SBML Level&nbsp;3 only.) In the case of a species reference, an
    EventAssignment sets the stoichiometry of the reactant or product
    referenced by the SpeciesReference object to the value determined by the
    formula in the 'math' element.  The unit associated with the value
    produced by the 'math' formula should be @c dimensionless, because
    reactant and product stoichiometries in reactions are dimensionless
    quantities.

    <li> In the case of a compartment, an EventAssignment sets the
    referenced compartment's size to the size determined by the formula in
    the 'math' subelement of the EventAssignment.  The overall units of the
    formula should (in SBML Level&nbsp;2 Version&nbsp;4 and in Level&nbsp;3)
    or must (in previous Versions of Level&nbsp;2) be identical to the units
    specified for the size of the compartment identified by the
    EventAssignment's 'variable' attribute.

    <li> In the case of a parameter, an EventAssignment sets the referenced
    parameter's value to that determined by the formula in 'math'.  The
    overall units of the formula should (in SBML Level&nbsp;2 Version&nbsp;4
    and Level&nbsp;3) or must (in previous Versions of Level&nbsp;2) be
    identical to the units defined for the parameter.
    </ul>

    Note that the formula placed in the 'math' element <em>has no assumed
    units</em>.  The consistency of the units of the formula, and the units
    of the entity which the assignment affects, must be explicitly
    established just as in the case of the value of the Delay subelement.
    An approach similar to the one discussed in the context of Delay may be
    used for the formula of an EventAssignment.

    @see Event

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAssignment, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventAssignment, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_EventAssignment
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> EventAssignment
        __init__(self, SBMLNamespaces sbmlns) -> EventAssignment
        __init__(self, EventAssignment orig) -> EventAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>EventAssignment(SBMLNamespaces sbmlns)</pre>

        Creates a new EventAssignment using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>EventAssignment(long level, long version)</pre>

        Creates a new EventAssignment using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this EventAssignment

        @param version a long integer, the SBML Version to assign to this
        EventAssignment

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>EventAssignment(EventAssignment orig)</pre>

        Copy constructor; creates a copy of this EventAssignment.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_EventAssignment(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> EventAssignment

        Creates and returns a deep copy of this EventAssignment object.

        @return the (deep) copy of this EventAssignment object.

        """
        return _libsbml.EventAssignment_clone(self)

    def getVariable(self):
        """
        getVariable(self) -> string

        Get the value of this EventAssignment's 'variable' attribute.

        @return the identifier stored in the 'variable' attribute of this
        EventAssignment.

        """
        return _libsbml.EventAssignment_getVariable(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical expression in this EventAssignment's 'math'
        subelement.

        @return the top ASTNode of an abstract syntax tree representing the
        mathematical formula in this EventAssignment.

        """
        return _libsbml.EventAssignment_getMath(self)

    def isSetVariable(self):
        """
        isSetVariable(self) -> bool

        Predicate for testing whether the attribute 'variable' of this
        EventAssignment is set.

        @return @c True if the 'variable' attribute of this EventAssignment
        is set, @c False otherwise.

        """
        return _libsbml.EventAssignment_isSetVariable(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate for testing whether the 'math' subelement of this
        EventAssignment is set.

        @return @c True if this EventAssignment has a 'math' subelement,
        @c False otherwise.

        """
        return _libsbml.EventAssignment_isSetMath(self)

    def setVariable(self, *args):
        """
        setVariable(self, string sid) -> int

        Sets the attribute 'variable' of this EventAssignment to a copy of
        the given identifier string.

        @param sid the identifier of a Compartment, Species or (global)
        Parameter defined in this model.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.EventAssignment_setVariable(self, *args)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' subelement of this EventAssignment to a copy of the
        given ASTNode.

        @param math an ASTNode that will be copied and stored as the
        mathematical formula for this EventAssignment.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.EventAssignment_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units of
        measurement assumed for the 'math' expression of this EventAssignment.

        @par
        The units are calculated based on the mathematical expression in the
        EventAssignment and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The method
        EventAssignment.getDerivedUnitDefinition() returns the calculated units,
        to the extent that libSBML can compute them. 

        @note The functionality that facilitates unit analysis depends on the
        model as a whole.  Thus, in cases where the object has not been added to
        a model or the model itself is incomplete, unit analysis is not possible
        and this method will return @c None. 

        @warning <span class='warning'>Note that it is possible the 'math'
        expression in the EventAssignment contains literal numbers or parameters
        with undeclared units.  In those cases, it is not possible to calculate
        the units of the overall expression without making assumptions.  LibSBML
        does not make assumptions about the units, and
        EventAssignment.getDerivedUnitDefinition() only returns the units as far
        as it is able to determine them.  For example, in an expression <em>X +
        Y</em>, if <em>X</em> has unambiguously-defined units and <em>Y</em> does
        not, it will return the units of <em>X</em>.  When using this method,
        <strong>it is critical that callers also invoke the method</strong>
        EventAssignment.containsUndeclaredUnits() <strong>to determine whether
        this situation holds</strong>.  Callers should take suitable action in
        those situations.</span>

        @return a UnitDefinition that expresses the units of the math 
        expression of this EventAssignment, or @c None if one cannot be constructed.

        @see containsUndeclaredUnits()

        """
        return _libsbml.EventAssignment_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c True if the math expression of this
        EventAssignment contains literal numbers or parameters with undeclared
        units.

        @par
        The units are calculated based on the mathematical expression in the
        EventAssignment and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The method
        EventAssignment.getDerivedUnitDefinition() returns the calculated units,
        to the extent that libSBML can compute them.

        If the expression contains literal numbers or parameters with undeclared
        units, libSBML may not be able to compute the full units of the
        expression and will only return what it can compute.  Callers should
        always use EventAssignment.containsUndeclaredUnits() when using
        EventAssignment.getDerivedUnitDefinition() to decide whether the
        returned units may be incomplete.

        @return @c True if the math expression of this EventAssignment
        includes parameters/numbers 
        with undeclared units, @c False otherwise.

        @note A return value of @c True indicates that the UnitDefinition
        returned by EventAssignment.getDerivedUnitDefinition() may not
        accurately represent the units of the expression.

        @see getDerivedUnitDefinition()

        """
        return _libsbml.EventAssignment_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_EVENT_ASSIGNMENT SBML_EVENT_ASSIGNMENT@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.EventAssignment_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for
        EventAssignment, is always @c 'eventAssignment'.

        @return the name of this element, i.e., @c 'eventAssignment'.

        """
        return _libsbml.EventAssignment_getElementName(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required attributes for this
        EventAssignment object have been set.

        The required attributes for a EventAssignment object are:
        @li 'variable'

        @return @c True if the required attributes have been set, @c False
        otherwise.

        """
        return _libsbml.EventAssignment_hasRequiredAttributes(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if all the required elements for this
        EventAssignment object have been set.

        @note The required elements for a EventAssignment object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.EventAssignment_hasRequiredElements(self)

    def getId(self):
        """
        getId(self) -> string

        @internal

        @internal

        """
        return _libsbml.EventAssignment_getId(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.EventAssignment_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.EventAssignment_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.EventAssignment_replaceSIDWithFunction(self, *args)

    def divideAssignmentsToSIdByFunction(self, *args):
        """
        divideAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing/function).

        @internal

        """
        return _libsbml.EventAssignment_divideAssignmentsToSIdByFunction(self, *args)

    def multiplyAssignmentsToSIdByFunction(self, *args):
        """
        multiplyAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing*function).

        @internal

        """
        return _libsbml.EventAssignment_multiplyAssignmentsToSIdByFunction(self, *args)

EventAssignment_swigregister = _libsbml.EventAssignment_swigregister
EventAssignment_swigregister(EventAssignment)

class ListOfEventAssignments(ListOf):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A list of EventAssignment objects.

    @par
    The various ListOf___ @if conly structures @else classes@endif@~ in SBML
    are merely containers used for organizing the main components of an SBML
    model.  In libSBML's implementation, ListOf___
    @if conly data structures @else classes@endif@~ are derived from the
    intermediate utility @if conly structure @else class@endif@~ ListOf, which
    is not defined by the SBML specifications but serves as a useful
    programmatic construct.  ListOf is itself is in turn derived from SBase,
    which provides all of the various ListOf___
    @if conly data structures @else classes@endif@~ with common features
    defined by the SBML specification, such as 'metaid' attributes and
    annotations.

    The relationship between the lists and the rest of an SBML model is
    illustrated by the following (for SBML Level&nbsp;2 Version&nbsp;4):

    @htmlinclude listof-illustration.html

    Readers may wonder about the motivations for using the ListOf___
    containers in SBML.  A simpler approach in XML might be to place the
    components all directly at the top level of the model definition.  The
    choice made in SBML is to group them within XML elements named after
    %ListOf<em>Classname</em>, in part because it helps organize the
    components.  More importantly, the fact that the container classes are
    derived from SBase means that software tools can add information @em about
    the lists themselves into each list container's 'annotation'.

    @see ListOfFunctionDefinitions
    @see ListOfUnitDefinitions
    @see ListOfCompartmentTypes
    @see ListOfSpeciesTypes
    @see ListOfCompartments
    @see ListOfSpecies
    @see ListOfParameters
    @see ListOfInitialAssignments
    @see ListOfRules
    @see ListOfConstraints
    @see ListOfReactions
    @see ListOfEvents

    @if conly
    @note In the C API for libSBML, functions that in other language APIs
    would be inherited by the various ListOf___ structures not shown in the
    pages for the individual ListOf___'s.  Instead, the functions are defined
    on ListOf_t.  <strong>Please consult the documentation for ListOf_t for
    the many common functions available for manipulating ListOf___
    structures</strong>.  The documentation for the individual ListOf___
    structures (ListOfCompartments_t, ListOfReactions_t, etc.) does not reveal
    all of the functionality available. @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [ListOf]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListOfEventAssignments, name, value)
    __swig_getmethods__ = {}
    for _s in [ListOf]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListOfEventAssignments, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> ListOfEventAssignments
        __init__(self, SBMLNamespaces sbmlns) -> ListOfEventAssignments

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfEventAssignments(SBMLNamespaces sbmlns)</pre>

        Creates a new ListOfEventAssignments object.

        The object is constructed such that it is valid for the SBML Level and
        Version combination determined by the SBMLNamespaces object in @p
        sbmlns.

        @param sbmlns an SBMLNamespaces object that is used to determine the
        characteristics of the ListOfEventAssignments object to be created.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ListOfEventAssignments(long level, long version)</pre>

        Creates a new ListOfEventAssignments object.

        The object is constructed such that it is valid for the given SBML
        Level and Version combination.

        @param level the SBML Level

        @param version the Version within the SBML Level

        """
        this = _libsbml.new_ListOfEventAssignments(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ListOfEventAssignments

        Creates and returns a deep copy of this ListOfEventAssignments object.

        @return the (deep) copy of this ListOfEventAssignments object.

        """
        return _libsbml.ListOfEventAssignments_clone(self)

    def getItemTypeCode(self):
        """
        getItemTypeCode(self) -> int

        Returns the libSBML type code for the objects contained in this ListOf
        (i.e., EventAssignment objects, if the list is non-empty).

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for the objects contained in this ListOf:
        @link libsbml#SBML_EVENT_ASSIGNMENT SBML_EVENT_ASSIGNMENT@endlink (default).

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.ListOfEventAssignments_getItemTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object.

        For ListOfEventAssignments, the XML element name is @c
        'listOfEventAssignments'.

        @return the name of this element, i.e., @c 'listOfEventAssignments'.

        """
        return _libsbml.ListOfEventAssignments_getElementName(self)

    def get(self, *args):
        """
        get(self, unsigned int n) -> EventAssignment
        get(self, unsigned int n) -> EventAssignment
        get(self, string sid) -> EventAssignment
        get(self, string sid) -> EventAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(long n)</pre>

        Get a EventAssignment from the ListOfEventAssignments.

        @param n the index number of the EventAssignment to get.

        @return the nth EventAssignment in this ListOfEventAssignments.

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>get(string sid)</pre>

        Get a EventAssignment from the ListOfEventAssignments
        based on its identifier.

        @param sid a string representing the identifier 
        of the EventAssignment to get.

        @return EventAssignment in this ListOfEventAssignments
        with the given @p sid or @c None if no such
        EventAssignment exists.

        @see get()
        @see size()

        """
        return _libsbml.ListOfEventAssignments_get(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int n) -> EventAssignment
        remove(self, string sid) -> EventAssignment

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(long n)</pre>

        Removes the nth item from this ListOfEventAssignments items and returns
        a pointer to it.

        The caller owns the returned item and is responsible for deleting it.

        @param n the index of the item to remove

        @see size()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string sid)</pre>

        Removes item in this ListOfEventAssignments items with the given
        identifier.

        The caller owns the returned item and is responsible for deleting it.
        If none of the items in this list have the identifier @p sid, then @c
        None is returned.

        @param sid the identifier of the item to remove

        @return the item removed.  As mentioned above, the caller owns the
        returned item.

        """
        return _libsbml.ListOfEventAssignments_remove(self, *args)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the
        model-wide SId namespace, or @c None if no such object is found.

        Note that EventAssignments do not actually have IDs, but the libsbml
        interface pretends that they do: no event assignment is returned by this
        function.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.ListOfEventAssignments_getElementBySId(self, *args)

    __swig_destroy__ = _libsbml.delete_ListOfEventAssignments
    __del__ = lambda self : None;
ListOfEventAssignments_swigregister = _libsbml.ListOfEventAssignments_swigregister
ListOfEventAssignments_swigregister(ListOfEventAssignments)

class Trigger(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html The trigger expression for an SBML <em>event</em>.

    An Event object defines when the event can occur, the variables that are
    affected by the event, and how the variables are affected.  The Trigger
    construct in SBML is used to define a mathematical expression that
    determines when an Event is @em triggered.

    A Trigger object in SBML Level&nbsp;2 and Level&nbsp;3 contains one
    subelement named 'math' containing a MathML expression.  The expression
    must evaluate to a value of type @c boolean.  The exact moment at which
    the expression evaluates to @c True is the time point when the Event is
    @em triggered.  In SBML Level&nbsp;3, Trigger has additional attributes
    that must be assigned values; they are discussed in a separate section
    below.

    An event only @em triggers when its Trigger expression makes the
    transition in value from @c False to @c True.  The event will also
    trigger at any subsequent time points when the trigger makes this
    transition; in other words, an event can be triggered multiple times
    during a simulation if its trigger condition makes the transition from
    @c False to @c True more than once.  In SBML Level&nbsp;3, the behavior
    at the very start of simulation (i.e., at <em>t = 0</em>, where
    <em>t</em> stands for time) is determined in part by the boolean flag
    'initialValue'.  This and other additional features introduced in SBML
    Level&nbsp;3 are discussed further below.

    @section trigger-version-diffs Version differences

    SBML Level&nbsp;3 Version&nbsp;1 introduces two required attributes
    on the Trigger object: 'persistent' and 'initialValue'.  The rest of
    this introduction describes these two attributes.

    @subsection trigger-persistent The 'persistent' attribute on Trigger

    In the interval between when an Event object <em>triggers</em> (i.e.,
    its Trigger object expression transitions in value from @c False to
    @c True) and when its assignments are to be <em>executed</em>, conditions
    in the model may change such that the trigger expression transitions
    back from @c True to @c False.  Should the event's assignments still be
    made if this happens?  Answering this question is the purpose of the
    'persistent' attribute on Trigger.

    If the boolean attribute 'persistent' has a value of @c True, then once
    the event is triggered, all of its assignments are always performed when
    the time of execution is reached.  The name @em persistent is meant to
    evoke the idea that the trigger expression does not have to be
    re-checked after it triggers if 'persistent'=@c True.  Conversely, if
    the attribute value is @c False, then the trigger expression is not
    assumed to persist: if the expression transitions in value back to @c False at any time between when the event triggered and when it is to be
    executed, the event is no longer considered to have triggered and its
    assignments are not executed.  (If the trigger expression transitions
    once more to @c True after that point, then the event is triggered, but
    this then constitutes a whole new event trigger-and-execute sequence.)

    The 'persistent' attribute can be especially useful when Event objects
    contain Delay objects, but it is relevant even in a model without delays
    if the model contains two or more events.  As explained in the
    introduction to this section, the operation of all events in SBML
    (delayed or not) is conceptually divided into two phases,
    <em>triggering</em> and <em>execution</em>; however, unless events have
    priorities associated with them, SBML does not mandate a particular
    ordering of event execution in the case of simultaneous events.  Models
    with multiple events can lead to situations where the execution of one
    event affects another event's trigger expression value.  If that other
    event has 'persistent'=@c False, and its trigger expression evaluates to
    @c False before it is to be executed, the event must not be executed
    after all.

    @subsection trigger-initialvalue The 'initialValue' attribute on Trigger

    As mentioned above, an event <em>triggers</em> when the mathematical
    expression in its Trigger object transitions in value from @c False to
    @c True.  An unanswered question concerns what happens at the start of a
    simulation: can event triggers make this transition at <em>t = 0</em>,
    where <em>t</em> stands for time?

    In order to determine whether an event may trigger at <em>t = 0</em>, it
    is necessary to know what value the Trigger object's 'math' expression
    had immediately prior to <em>t = 0</em>.  This starting value of the
    trigger expression is determined by the value of the boolean attribute
    'initialValue'.  A value of @c True means the trigger expression is
    taken to have the value @c True immediately prior to <em>t = 0</em>.  In
    that case, the trigger cannot transition in value from @c False to @c True at the moment simulation begins (because it has the value @c True
    both before and after <em>t = 0</em>), and can only make the transition
    from @c False to @c True sometime <em>after</em> <em>t = 0</em>.  (To do
    that, it would also first have to transition to @c False before it could
    make the transition from @c False back to @c True.)  Conversely, if
    'initialValue'=@c False, then the trigger expression is assumed to start
    with the value @c False, and therefore may trigger at <em>t = 0</em> if
    the expression evaluates to @c True at that moment.


    @see Event
    @see Delay
    @see EventAssignment

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trigger, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Trigger, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Trigger
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Trigger
        __init__(self, SBMLNamespaces sbmlns) -> Trigger
        __init__(self, Trigger orig) -> Trigger

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Trigger(SBMLNamespaces sbmlns)</pre>

        Creates a new Trigger using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Trigger(long level, long version)</pre>

        Creates a new Trigger using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Trigger

        @param version a long integer, the SBML Version to assign to this
        Trigger

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Trigger(Trigger orig)</pre>

        Copy constructor; creates a copy of this Trigger.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Trigger(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Trigger

        Creates and returns a deep copy of this Trigger object.

        @return the (deep) copy of this Trigger object.

        """
        return _libsbml.Trigger_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula for the trigger and return it
        as an AST.

        @return the math of this Trigger.

        """
        return _libsbml.Trigger_getMath(self)

    def getInitialValue(self):
        """
        getInitialValue(self) -> bool

        (SBML Level&nbsp;3 only) Get the value of the 'initialValue' attribute
        of this Trigger.

        @return the boolean value stored as the 'initialValue' attribute value
        in this Trigger.

        @note The attribute 'initialValue' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Trigger_getInitialValue(self)

    def getPersistent(self):
        """
        getPersistent(self) -> bool

        (SBML Level&nbsp;3 only) Get the value of the 'persistent' attribute
        of this Trigger.

        @return the boolean value stored as the 'persistent' attribute value
        in this Trigger.

        @note The attribute 'persistent' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Trigger_getPersistent(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the math for this trigger is set.

        @return @c True if the formula (meaning the 'math' subelement) of
        this Trigger is set, @c False otherwise.

        """
        return _libsbml.Trigger_isSetMath(self)

    def isSetInitialValue(self):
        """
        isSetInitialValue(self) -> bool

        (SBML Level&nbsp;3 only) Predicate to test whether the 'initialValue'
        attribute for this trigger is set.

        @return @c True if the initialValue attribute of
        this Trigger is set, @c False otherwise.

        @note The attribute 'initialValue' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Trigger_isSetInitialValue(self)

    def isSetPersistent(self):
        """
        isSetPersistent(self) -> bool

        (SBML Level&nbsp;3 only) Predicate to test whether the 'persistent'
        attribute for this trigger is set.

        @return @c True if the persistent attribute of
        this Trigger is set, @c False otherwise.

        @note The attribute 'persistent' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Trigger_isSetPersistent(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the trigger expression of this Trigger instance to a copy of the given
        ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.Trigger_setMath(self, *args)

    def setInitialValue(self, *args):
        """
        setInitialValue(self, bool initialValue) -> int

        (SBML Level&nbsp;3 only) Sets the 'initialValue' attribute of this Trigger instance.

        @param initialValue a boolean representing the initialValue to be set.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attribute 'initialValue' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Trigger_setInitialValue(self, *args)

    def setPersistent(self, *args):
        """
        setPersistent(self, bool persistent) -> int

        (SBML Level&nbsp;3 only) Sets the 'persistent' attribute of this Trigger instance.

        @param persistent a boolean representing the persistent value to be set.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        @note The attribute 'persistent' is available in SBML Level&nbsp;3
        Version&nbsp;1 Core, but is not present in lower Levels of SBML.

        """
        return _libsbml.Trigger_setPersistent(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_TRIGGER SBML_TRIGGER@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Trigger_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Trigger, is
        always @c 'trigger'.

        @return the name of this element, i.e., @c 'trigger'.

        """
        return _libsbml.Trigger_getElementName(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Trigger_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Trigger_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.Trigger_replaceSIDWithFunction(self, *args)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for this Trigger object
        have been set.

        @note The required elements for a Trigger object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.Trigger_hasRequiredElements(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if
        all the required attributes for this Trigger object
        have been set.

        The required attributes for a Trigger object are:
        @li 'persistent' (required in SBML Level&nbsp;3)
        @li 'initialValue' (required in SBML Level&nbsp;3)

        @return a boolean value indicating whether all the required
        attributes for this object have been defined.

        """
        return _libsbml.Trigger_hasRequiredAttributes(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Finds this Trigger's Event parent and calls unsetTrigger() on it, indirectly deleting itself.  Overridden from the SBase function since the parent is not a ListOf.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Trigger_removeFromParentAndDelete(self)

Trigger_swigregister = _libsbml.Trigger_swigregister
Trigger_swigregister(Trigger)

class Delay(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A delay on the time of execution of an SBML <em>event</em>.

    An Event object defines when the event can occur, the variables that
    are affected by the event, and how the variables are affected.  The
    effect of the event can optionally be delayed after the occurrence of
    the condition which invokes it.  An event delay is defined using an
    object of class Delay.

    The object class Delay is derived from SBase and adds a single
    subelement called 'math'.  This subelement is used to hold MathML
    content.  The mathematical formula represented by 'math' must evaluate
    to a numerical value.  It is used as the length of time between when the
    event is @em triggered and when the event's assignments are
    actually @em executed.  If no delay is present on a given Event, a time
    delay of zero is assumed.

    The expression in 'math' must be evaluated at the time the event is @em
    triggered.  The expression must always evaluate to a nonnegative number
    (otherwise, a nonsensical situation could arise where an event is
    defined to execute before it is triggered!).

    @section delay-units The units of the mathematical expression in a Delay

    In SBML Level&nbsp;2 versions before Version&nbsp;4, the units of the
    numerical value computed by the Delay's 'math' expression are @em
    required to be in units of time, or the model is considered to have a
    unit consistency error.  In Level&nbsp;2 Version&nbsp;4 as well as SBML
    Level&nbsp;3 Version&nbsp;1 Core, this requirement is relaxed; these
    specifications only stipulate that the units of the numerical value
    computed by a Delay instance's 'math' expression @em should match the
    model's units of time (meaning the definition of the @c time units in
    the model).  LibSBML respects these requirements, and depending on
    whether an earlier Version of SBML Level&nbsp;2 is in use, libSBML may
    or may not flag unit inconsistencies as errors or merely warnings.

    Note that <em>units are not predefined or assumed</em> for the contents
    of 'math' in a Delay object; rather, they must be defined explicitly for
    each instance of a Delay object in a model.  This is an important point
    to bear in mind when literal numbers are used in delay expressions.  For
    example, the following Event instance would result in a warning logged
    by SBMLDocument.checkConsistency() about the fact that libSBML cannot
    verify the consistency of the units of the expression.  The reason is
    that the formula inside the 'math' element does not have any declared
    units, whereas what is expected in this context is units of time:
    @verbatim
    <model>
        ...
        <listOfEvents>
            <event useValuesFromTriggerTime='true'>
                ...
                <delay>
                    <math xmlns='http://www.w3.org/1998/Math/MathML'>
                        <cn> 1 </cn>
                    </math>
                </delay>
                ...
            </event>
        </listOfEvents>
        ...
    </model>
    @endverbatim

    The <code>&lt;cn&gt; 1 &lt;/cn&gt;</code> within the mathematical formula
    of the @c delay above has <em>no units declared</em>.  To make the
    expression have the needed units of time, literal numbers should be
    avoided in favor of defining Parameter objects for each quantity, and
    declaring units for the Parameter values.  The following fragment of
    SBML illustrates this approach:
    @verbatim
    <model>
        ...
        <listOfParameters>
            <parameter id='transcriptionDelay' value='10' units='second'/>
        </listOfParameters>
        ...
        <listOfEvents>
            <event useValuesFromTriggerTime='true'>
                ...
                <delay>
                    <math xmlns='http://www.w3.org/1998/Math/MathML'>
                        <ci> transcriptionDelay </ci>
                    </math>
                </delay>
                ...
            </event>
        </listOfEvents>
        ...
    </model>
    @endverbatim

    In SBML Level&nbsp;3, an alternative approach is available in the form
    of the @c units attribute, which SBML Level&nbsp;3 allows to appear on
    MathML @c cn elements.  The value of this attribute can be used to
    indicate the unit of measurement to be associated with the number in the
    content of a @c cn element.  The attribute is named @c units but,
    because it appears inside MathML element (which is in the XML namespace
    for MathML and not the namespace for SBML), it must always be prefixed
    with an XML namespace prefix for the SBML Level&nbsp;3 Version&nbsp;1
    namespace.  The following is an example of this approach:
    @verbatim
    <model timeUnits='second' ...>
        ...
        <listOfEvents>
            <event useValuesFromTriggerTime='true'>
                ...
                <delay>
                    <math xmlns='http://www.w3.org/1998/Math/MathML'
                          xmlns:sbml='http://www.sbml.org/sbml/level3/version1/core'>
                        <cn sbml:units='second'> 10 </cn>
                    </math>
                </delay>
                ...
            </event>
        </listOfEvents>
        ...
    </model>
    @endverbatim

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Delay, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Delay, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Delay
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Delay
        __init__(self, SBMLNamespaces sbmlns) -> Delay
        __init__(self, Delay orig) -> Delay

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Delay(SBMLNamespaces sbmlns)</pre>

        Creates a new Delay using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments.

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Delay(long level, long version)</pre>

        Creates a new Delay using the given SBML @p level and @p version
        values.

        @param level a long integer, the SBML Level to assign to this Delay

        @param version a long integer, the SBML Version to assign to this
        Delay

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Delay(Delay orig)</pre>

        Copy constructor; creates a copy of this Delay.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Delay(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Delay

        Creates and returns a deep copy of this Delay object.

        @return the (deep) copy of this Delay object.

        """
        return _libsbml.Delay_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula for the delay and return it
        as an AST.

        @return the math of this Delay.

        """
        return _libsbml.Delay_getMath(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the formula for this delay is set.

        @return @c True if the formula (meaning the @c math subelement) of
        this Delay is set, @c False otherwise.

        """
        return _libsbml.Delay_isSetMath(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the delay expression of this Delay instance to a copy of the given
        ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t.  @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.Delay_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition that expresses the units
        of measurement assumed for the 'math' expression of this Delay.

        @par
        Delay elements in SBML express a time delay for an Event.  Beginning
        with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are
        calculated based on the mathematical expression and the model quantities
        referenced by <code>&lt;ci&gt;</code> elements used within that
        expression.  (In SBML Level &nbsp;2 Version&nbsp;1, there exists an
        attribute on Event called 'timeUnits'.  This attribute can be used to set
        the units of the Delay expression explicitly.)  The method
        Delay.getDerivedUnitDefinition() returns what libSBML computes the units
        to be, to the extent that libSBML can compute them.

        @note The functionality that facilitates unit analysis depends on the
        model as a whole.  Thus, in cases where the object has not been added to
        a model or the model itself is incomplete, unit analysis is not possible
        and this method will return @c None. 

        @warning <span class='warning'>Note that it is possible the 'math'
        expression in the Delay contains literal numbers or parameters with
        undeclared units.  In those cases, it is not possible to calculate the
        units of the overall expression without making assumptions.  LibSBML does
        not make assumptions about the units, and
        Delay.getDerivedUnitDefinition() only returns the units as far as it is
        able to determine them.  For example, in an expression <em>X + Y</em>, if
        <em>X</em> has unambiguously-defined units and <em>Y</em> does not, it
        will return the units of <em>X</em>.  When using this method, <strong>it
        is critical that callers also invoke the method</strong>
        Delay.containsUndeclaredUnits() <strong>to determine whether this
        situation holds</strong>.  Callers should take suitable action in those
        situations.</span>

        @return a UnitDefinition that expresses the units of the math 
        expression of this Delay, or @c None if one cannot be constructed.

        @see containsUndeclaredUnits()

        """
        return _libsbml.Delay_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c True if the 'math' expression in this Delay
        instance contains parameters with undeclared units or literal numbers.

        @par
        Delay elements in SBML express a time delay for an Event.  Beginning
        with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are
        calculated based on the mathematical expression and the model quantities
        referenced by <code>&lt;ci&gt;</code> elements used within that
        expression.  (In SBML Level &nbsp;2 Version&nbsp;1, there exists an
        attribute on Event called 'timeUnits'.  This attribute can be used to set
        the units of the Delay expression explicitly.)  The method
        Delay.getDerivedUnitDefinition() returns what libSBML computes the units
        to be, to the extent that libSBML can compute them.

        If the expression contains literal numbers or parameters with undeclared
        units, <strong>libSBML may not be able to compute the full units of the
        expression</strong> and will only return what it can compute.  Callers
        should always use Delay.containsUndeclaredUnits() when using
        Delay.getDerivedUnitDefinition() to decide whether the returned units
        may be incomplete.

        @return @c True if the math expression of this Delay includes
        numbers/parameters with undeclared units, @c False otherwise.

        @note A return value of @c True indicates that the UnitDefinition
        returned by Delay.getDerivedUnitDefinition() may not accurately
        represent the units of the expression.

        @see getDerivedUnitDefinition()

        """
        return _libsbml.Delay_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_DELAY SBML_DELAY@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Delay_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Delay, is
        always @c 'delay'.

        @return the name of this element, i.e., @c 'delay'.

        @see getTypeCode()

        """
        return _libsbml.Delay_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for this Delay object
        have been set.

        @note The required elements for a Delay object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.Delay_hasRequiredElements(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Finds this Delay's Event parent and calls unsetDelay() on it, indirectly
        deleting itself.

        Overridden from the SBase function since the parent is not a ListOf.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Delay_removeFromParentAndDelete(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Delay_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Delay_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.Delay_replaceSIDWithFunction(self, *args)

Delay_swigregister = _libsbml.Delay_swigregister
Delay_swigregister(Delay)

class Priority(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html The priority of execution of an SBML <em>event</em>.

    The Priority object class (which was introduced in SBML Level&nbsp;3
    Version&nbsp;1), like Delay, is derived from SBase and contains a MathML
    formula stored in the element 'math'.  This formula is used to compute a
    dimensionless numerical value that influences the order in which a
    simulator is to perform the assignments of two or more events that
    happen to be executed simultaneously.  The formula may evaluate to any
    @c float value (and thus may be a positive or negative number, or
    zero), with positive numbers taken to signifying a higher priority than
    zero or negative numbers.  If no Priority object is present on a given
    Event object, no priority is defined for that event.

    @section priority-interp The interpretation of priorities on events in a model

    For the purposes of SBML, <em>simultaneous event execution</em> is
    defined as the situation in which multiple events have identical
    times of execution.  The time of execution is calculated as the
    sum of the time at which a given event's Trigger is <em>triggered</em>
    plus its Delay duration, if any.  Here, <em>identical times</em> means
    <em>mathematically equal</em> instants in time.  (In practice,
    simulation software adhering to this specification may have to
    rely on numerical equality instead of strict mathematical
    equality; robust models will ensure that this difference will not
    cause significant discrepancies from expected behavior.)

    If no Priority subobjects are defined for two or more Event objects,
    then those events are still executed simultaneously but their order of
    execution is <em>undefined by the SBML Level&nbsp;3 Version&nbsp;1
    specification</em>.  A software implementation may choose to execute
    such simultaneous events in any order, as long as each event is executed
    only once and the requirements of checking the 'persistent' attribute
    (and acting accordingly) are satisfied.

    If Priority subobjects are defined for two or more
    simultaneously-triggered events, the order in which those particular
    events must be executed is dictated by their Priority objects,
    as follows.  If the values calculated using the two Priority
    objects' 'math' expressions differ, then the event having
    the higher priority value must be executed before the event with
    the lower value.  If, instead, the two priority values are
    mathematically equal, then the two events must be triggered in a
    <em>random</em> order.  It is important to note that a <em>random
    order is not the same as an undefined order</em>: given multiple
    runs of the same model with identical conditions, an undefined
    ordering would permit a system to execute the events in (for
    example) the same order every time (according to whatever scheme
    may have been implemented by the system), whereas the explicit
    requirement for random ordering means that the order of execution
    in different simulation runs depends on random chance.  In other
    words, given two events <em>A</em> and <em>B</em>, a randomly-determined
    order must lead to an equal chance of executing <em>A</em> first or
    <em>B</em> first, every time those two events are executed
    simultaneously.

    A model may contain a mixture of events, some of which have
    Priority subobjects and some do not.  Should a combination of
    simultaneous events arise in which some events have priorities
    defined and others do not, the set of events with defined
    priorities must trigger in the order determined by their Priority
    objects, and the set of events without Priority objects must be
    executed in an <em>undefined</em> order with respect to each other
    and with respect to the events with Priority subobjects.  (Note
    that <em>undefined order</em> does not necessarily mean random
    order, although a random ordering would be a valid implementation
    of this requirement.)

    The following example may help further clarify these points.
    Suppose a model contains four events that should be executed
    simultaneously, with two of the events having Priority objects
    with the same value and the other two events having Priority
    objects with the same, but different, value.  The two events with
    the higher priorities must be executed first, in a random order
    with respect to each other, and the remaining two events must be
    executed after them, again in a random order, for a total of four
    possible and equally-likely event executions: A-B-C-D, A-B-D-C,
    B-A-C-D, and B-A-D-C.  If, instead, the model contains four events
    all having the same Priority values, there are 4! or 24
    possible orderings, each of which must be equally likely to be
    chosen.  Finally, if none of the four events has a Priority
    subobject defined, or even if exactly one of the four events has a
    defined Priority, there are again 24 possible orderings, but the
    likelihood of choosing any particular ordering is undefined; the
    simulator can choose between events as it wishes.  (The SBML
    specification only defines the effects of priorities on Event
    objects with respect to <em>other</em> Event objects with
    priorities.  Putting a priority on a <em>single</em> Event object
    in a model does not cause it to fall within that scope.)

    @section priority-eval Evaluation of Priority expressions

    An event's Priority object 'math' expression must be
    evaluated at the time the Event is to be <em>executed</em>.  During
    a simulation, all simultaneous events have their Priority values
    calculated, and the event with the highest priority is selected for
    next execution.  Note that it is possible for the execution of one
    Event object to cause the Priority value of another
    simultaneously-executing Event object to change (as well as to
    trigger other events, as already noted).  Thus, after executing
    one event, and checking whether any other events in the model have
    been triggered, all remaining simultaneous events that
    <em>either</em> (i) have Trigger objects with attributes
    'persistent'=@c False <em>or</em> (ii) have Trigger
    expressions that did not transition from @c True to
    @c False, must have their Priority expression reevaluated.
    The highest-priority remaining event must then be selected for 
    execution next.

    @section priority-units Units of Priority object's mathematical expressions

    The unit associated with the value of a Priority object's
    'math' expression should be @c dimensionless.  This is
    because the priority expression only serves to provide a relative
    ordering between different events, and only has meaning with
    respect to other Priority object expressions.  The value of
    Priority objects is not comparable to any other kind of object in
    an SBML model.

    @note The Priority construct exists only in SBML Level&nbsp;3; it cannot
    be used in SBML Level&nbsp;2 or Level&nbsp;1 models.

    @see Event
    @see Delay
    @see EventAssignment

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Priority, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Priority, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Priority
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> Priority
        __init__(self, SBMLNamespaces sbmlns) -> Priority
        __init__(self, Priority orig) -> Priority

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Priority(SBMLNamespaces sbmlns)</pre>

        Creates a new Priority object using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        @note The Priority construct exists only in SBML Level&nbsp;3; it
        cannot be used in SBML Level&nbsp;2 or Level&nbsp;1 models.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Priority(long level, long version)</pre>

        Creates a new Priority object using the given SBML @p level and @p
        version values.

        @param level a long integer, the SBML Level to assign to this Priority

        @param version a long integer, the SBML Version to assign to this
        Priority

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.

        @note The Priority construct exists only in SBML Level&nbsp;3; it
        cannot be used in SBML Level&nbsp;2 or Level&nbsp;1 models.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Priority(Priority orig)</pre>

        Copy constructor; creates a copy of this Priority.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Priority(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Priority

        Creates and returns a deep copy of this Priority object.

        @return the (deep) copy of this Priority object.

        """
        return _libsbml.Priority_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Get the mathematical formula for the priority and return it
        as an AST.

        @return the math of this Priority.

        """
        return _libsbml.Priority_getMath(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the formula for this delay is set.

        @return @c True if the formula (meaning the @c math subelement) of
        this Priority is set, @c False otherwise.

        """
        return _libsbml.Priority_isSetMath(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the math expression of this Priority instance to a copy of the given
        ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t.  @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.Priority_setMath(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_PRIORITY SBML_PRIORITY@endlink (default).
        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.Priority_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for Priority, is
        always @c 'priority'.

        @return the name of this element, i.e., @c 'priority'.

        @see getTypeCode()

        """
        return _libsbml.Priority_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if all the required elements for this
        Priority object have been set.

        @note The required elements for a Priority object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.Priority_hasRequiredElements(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Finds this Priority's Event parent and calls unsetPriority() on it,
        indirectly deleting itself.

        Overridden from the SBase function since the parent is not a ListOf.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.Priority_removeFromParentAndDelete(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Priority_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.Priority_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.Priority_replaceSIDWithFunction(self, *args)

Priority_swigregister = _libsbml.Priority_swigregister
Priority_swigregister(Priority)

class SBO(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Facilities for using the Systems Biology Ontology.

    @htmlinclude not-sbml-warning.html

    The values of 'id' attributes on SBML components allow the components to
    be cross-referenced within a model. The values of 'name' attributes on
    SBML components provide the opportunity to assign them meaningful labels
    suitable for display to humans.  The specific identifiers and labels
    used in a model necessarily must be unrestricted by SBML, so that
    software and users are free to pick whatever they need.  However, this
    freedom makes it more difficult for software tools to determine, without
    additional human intervention, the semantics of models more precisely
    than the semantics provided by the SBML object classes defined in other
    sections of this document.  For example, there is nothing inherent in a
    parameter with identifier <code>k</code> that would indicate to a
    software tool it is a first-order rate constant (if that's what
    <code>k</code> happened to be in some given model).  However, one may
    need to convert a model between different representations (e.g.,
    Henri-Michaelis-Menten versus elementary steps), or to use it with
    different modeling approaches (discrete or continuous).  One may also
    need to relate the model components with other description formats such
    as SBGN (<a target='_blank'
    href='http://www.sbgn.org/'>http://www.sbgn.org/</a>) using deeper
    semantics.  Although an advanced software tool <em>might</em> be able to
    deduce the semantics of some model components through detailed analysis
    of the kinetic rate expressions and other parts of the model, this
    quickly becomes infeasible for any but the simplest of models.

    An approach to solving this problem is to associate model components
    with terms from carefully curated controlled vocabularies (CVs).  This
    is the purpose of the optional 'sboTerm' attribute provided on the SBML
    class SBase.  The 'sboTerm' attribute always refers to terms belonging
    to the Systems Biology Ontology (SBO).

    @section use Use of SBO

    Labeling model components with terms from shared controlled vocabularies
    allows a software tool to identify each component using identifiers that
    are not tool-specific.  An example of where this is useful is the desire
    by many software developers to provide users with meaningful names for
    reaction rate equations.  Software tools with editing interfaces
    frequently provide these names in menus or lists of choices for users.
    However, without a standardized set of names or identifiers shared
    between developers, a given software package cannot reliably interpret
    the names or identifiers of reactions used in models written by other
    tools.

    The first solution that might come to mind is to stipulate that certain
    common reactions always have the same name (e.g., 'Michaelis-Menten'), but
    this is simply impossible to do: not only do humans often disagree on
    the names themselves, but it would not allow for correction of errors or
    updates to the list of predefined names except by issuing new releases
    of the SBML specification---to say nothing of many other limitations
    with this approach.  Moreover, the parameters and variables that appear
    in rate expressions also need to be identified in a way that software
    tools can interpret mechanically, implying that the names of these
    entities would also need to be regulated.

    The Systems Biology Ontology (SBO) provides terms for identifying most
    elements of SBML. The relationship implied by an 'sboTerm' on an SBML
    model component is <em>is-a</em> between the characteristic of the
    component meant to be described by %SBO on this element and the %SBO
    term identified by the value of the 'sboTerm'. By adding %SBO term
    references on the components of a model, a software tool can provide
    additional details using independent, shared vocabularies that can
    enable <em>other</em> software tools to recognize precisely what the
    component is meant to be.  Those tools can then act on that information.
    For example, if the %SBO identifier @c 'SBO:0000049' is assigned
    to the concept of 'first-order irreversible mass-action kinetics,
    continuous framework', and a given KineticLaw object in a model has an
    'sboTerm' attribute with this value, then regardless of the identifier
    and name given to the reaction itself, a software tool could use this to
    inform users that the reaction is a first-order irreversible mass-action
    reaction.  This kind of reverse engineering of the meaning of reactions
    in a model would be difficult to do otherwise, especially for more
    complex reaction types.

    The presence of %SBO labels on Compartment, Species, and Reaction
    objects in SBML can help map those entities to equivalent concepts in
    other standards, such as (but not limited to) BioPAX (<a target='_blank'
    href='http://www.biopax.org/'>http://www.biopax.org/</a>), PSI-MI (<a
    target='_blank'
    href='http://www.psidev.info/index.php?q=node/60'>http://www.psidev.info</a>),
    or the Systems Biology Graphical Notation (SBGN, <a target='_blank'
    href='http://www.sbgn.org/'>http://www.sbgn.org/</a>).  Such mappings
    can be used in conversion procedures, or to build interfaces, with %SBO
    becoming a kind of 'glue' between standards of representation.

    The presence of the label on a kinetic expression can also allow
    software tools to make more intelligent decisions about reaction rate
    expressions.  For example, an application could recognize certain types
    of reaction formulas as being ones it knows how to solve with optimized
    procedures.  The application could then use internal, optimized code
    implementing the rate formula indexed by identifiers such as
    @c 'SBO:0000049' appearing in SBML models.

    Finally, %SBO labels may be very valuable when it comes to model
    integration, by helping identify interfaces, convert mathematical
    expressions and parameters etc.

    Although the use of %SBO can be beneficial, it is critical to keep in
    mind that the presence of an 'sboTerm' value on an object <em>must not
    change the fundamental mathematical meaning</em> of the model.  An SBML
    model must be defined such that it stands on its own and does not depend
    on additional information added by %SBO terms for a correct mathematical
    interpretation.  %SBO term definitions will not imply any alternative
    mathematical semantics for any SBML object labeled with that term.  Two
    important reasons motivate this principle.  First, it would be too
    limiting to require all software tools to be able to understand the %SBO
    vocabularies in addition to understanding SBML.  Supporting %SBO is not
    only additional work for the software developer; for some kinds of
    applications, it may not make sense.  If %SBO terms on a model are
    optional, it follows that the SBML model <em>must</em> remain
    unambiguous and fully interpretable without them, because an application
    reading the model may ignore the terms.  Second, we believe allowing the
    use of 'sboTerm' to alter the mathematical meaning of a model would
    allow too much leeway to shoehorn inconsistent concepts into SBML
    objects, ultimately reducing the interoperability of the models.

    @section relationship Relationships between SBO and SBML

    The goal of %SBO labeling for SBML is to clarify to the fullest extent
    possible the nature of each element in a model.  The approach taken in
    %SBO begins with a hierarchically-structured set of controlled
    vocabularies with six main divisions: (1) entity, (2) participant role,
    (3) quantitative parameter, (4) modeling framework, (5) mathematical
    expression, and (6) interaction.  The web site for %SBO (<a
    target='_blank'
    href='http://biomodels.net/sbo'>http://biomodels.net</a>) should be
    consulted for the current version of the ontology.

    The Systems Biology Ontology (SBO) is not part of SBML; it is being
    developed separately, to allow the modeling community to evolve the
    ontology independently of SBML.  However, the terms in the ontology are
    being designed keeping SBML components in mind, and are classified into
    subsets that can be directly related with SBML components such as
    reaction rate expressions, parameters, and others.  The use of 'sboTerm'
    attributes is optional, and the presence of 'sboTerm' on an element does
    not change the way the model is <em>interpreted</em>.  Annotating SBML
    elements with %SBO terms adds additional semantic information that may
    be used to <em>convert</em> the model into another model, or another
    format.  Although %SBO support provides an important source of
    information to understand the meaning of a model, software does not need
    to support 'sboTerm' to be considered SBML-compliant.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBO, name)
    __repr__ = _swig_repr
    def isQuantitativeParameter(*args):
        """
        isQuantitativeParameter(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'quantiative parameter'</em>, @c False
        otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isQuantitativeParameter(*args)

    if _newclass:isQuantitativeParameter = staticmethod(isQuantitativeParameter)
    __swig_getmethods__["isQuantitativeParameter"] = lambda x: isQuantitativeParameter
    def isParticipantRole(*args):
        """
        isParticipantRole(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'participant role'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isParticipantRole(*args)

    if _newclass:isParticipantRole = staticmethod(isParticipantRole)
    __swig_getmethods__["isParticipantRole"] = lambda x: isParticipantRole
    def isModellingFramework(*args):
        """
        isModellingFramework(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'modeling framework'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isModellingFramework(*args)

    if _newclass:isModellingFramework = staticmethod(isModellingFramework)
    __swig_getmethods__["isModellingFramework"] = lambda x: isModellingFramework
    def isMathematicalExpression(*args):
        """
        isMathematicalExpression(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'mathematical expression'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isMathematicalExpression(*args)

    if _newclass:isMathematicalExpression = staticmethod(isMathematicalExpression)
    __swig_getmethods__["isMathematicalExpression"] = lambda x: isMathematicalExpression
    def isKineticConstant(*args):
        """
        isKineticConstant(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'kinetic constant'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isKineticConstant(*args)

    if _newclass:isKineticConstant = staticmethod(isKineticConstant)
    __swig_getmethods__["isKineticConstant"] = lambda x: isKineticConstant
    def isReactant(*args):
        """
        isReactant(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'reactant'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isReactant(*args)

    if _newclass:isReactant = staticmethod(isReactant)
    __swig_getmethods__["isReactant"] = lambda x: isReactant
    def isProduct(*args):
        """
        isProduct(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'product'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isProduct(*args)

    if _newclass:isProduct = staticmethod(isProduct)
    __swig_getmethods__["isProduct"] = lambda x: isProduct
    def isModifier(*args):
        """
        isModifier(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'modifier'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isModifier(*args)

    if _newclass:isModifier = staticmethod(isModifier)
    __swig_getmethods__["isModifier"] = lambda x: isModifier
    def isRateLaw(*args):
        """
        isRateLaw(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'rate law'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isRateLaw(*args)

    if _newclass:isRateLaw = staticmethod(isRateLaw)
    __swig_getmethods__["isRateLaw"] = lambda x: isRateLaw
    def isEvent(*args):
        """
        isEvent(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'event'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isEvent(*args)

    if _newclass:isEvent = staticmethod(isEvent)
    __swig_getmethods__["isEvent"] = lambda x: isEvent
    def isPhysicalParticipant(*args):
        """
        isPhysicalParticipant(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'physical participant</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isPhysicalParticipant(*args)

    if _newclass:isPhysicalParticipant = staticmethod(isPhysicalParticipant)
    __swig_getmethods__["isPhysicalParticipant"] = lambda x: isPhysicalParticipant
    def isParticipant(*args):
        """
        isParticipant(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'participant'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isParticipant(*args)

    if _newclass:isParticipant = staticmethod(isParticipant)
    __swig_getmethods__["isParticipant"] = lambda x: isParticipant
    def isInteraction(*args):
        """
        isInteraction(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'interaction'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isInteraction(*args)

    if _newclass:isInteraction = staticmethod(isInteraction)
    __swig_getmethods__["isInteraction"] = lambda x: isInteraction
    def isEntity(*args):
        """
        isEntity(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'entity'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isEntity(*args)

    if _newclass:isEntity = staticmethod(isEntity)
    __swig_getmethods__["isEntity"] = lambda x: isEntity
    def isFunctionalEntity(*args):
        """
        isFunctionalEntity(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'functional entity'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isFunctionalEntity(*args)

    if _newclass:isFunctionalEntity = staticmethod(isFunctionalEntity)
    __swig_getmethods__["isFunctionalEntity"] = lambda x: isFunctionalEntity
    def isMaterialEntity(*args):
        """
        isMaterialEntity(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'material entity'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isMaterialEntity(*args)

    if _newclass:isMaterialEntity = staticmethod(isMaterialEntity)
    __swig_getmethods__["isMaterialEntity"] = lambda x: isMaterialEntity
    def isConservationLaw(*args):
        """
        isConservationLaw(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'conservation law'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isConservationLaw(*args)

    if _newclass:isConservationLaw = staticmethod(isConservationLaw)
    __swig_getmethods__["isConservationLaw"] = lambda x: isConservationLaw
    def isSteadyStateExpression(*args):
        """
        isSteadyStateExpression(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'steady state expression'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isSteadyStateExpression(*args)

    if _newclass:isSteadyStateExpression = staticmethod(isSteadyStateExpression)
    __swig_getmethods__["isSteadyStateExpression"] = lambda x: isSteadyStateExpression
    def isFunctionalCompartment(*args):
        """
        isFunctionalCompartment(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'functional compartment'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isFunctionalCompartment(*args)

    if _newclass:isFunctionalCompartment = staticmethod(isFunctionalCompartment)
    __swig_getmethods__["isFunctionalCompartment"] = lambda x: isFunctionalCompartment
    def isContinuousFramework(*args):
        """
        isContinuousFramework(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'continuous framework'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isContinuousFramework(*args)

    if _newclass:isContinuousFramework = staticmethod(isContinuousFramework)
    __swig_getmethods__["isContinuousFramework"] = lambda x: isContinuousFramework
    def isDiscreteFramework(*args):
        """
        isDiscreteFramework(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'discrete framework'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isDiscreteFramework(*args)

    if _newclass:isDiscreteFramework = staticmethod(isDiscreteFramework)
    __swig_getmethods__["isDiscreteFramework"] = lambda x: isDiscreteFramework
    def isLogicalFramework(*args):
        """
        isLogicalFramework(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'logical framework'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isLogicalFramework(*args)

    if _newclass:isLogicalFramework = staticmethod(isLogicalFramework)
    __swig_getmethods__["isLogicalFramework"] = lambda x: isLogicalFramework
    def isMetadataRepresentation(*args):
        """
        isMetadataRepresentation(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'metadata representation'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isMetadataRepresentation(*args)

    if _newclass:isMetadataRepresentation = staticmethod(isMetadataRepresentation)
    __swig_getmethods__["isMetadataRepresentation"] = lambda x: isMetadataRepresentation
    def isOccurringEntityRepresentation(*args):
        """
        isOccurringEntityRepresentation(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'occurring entity representation'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isOccurringEntityRepresentation(*args)

    if _newclass:isOccurringEntityRepresentation = staticmethod(isOccurringEntityRepresentation)
    __swig_getmethods__["isOccurringEntityRepresentation"] = lambda x: isOccurringEntityRepresentation
    def isPhysicalEntityRepresentation(*args):
        """
        isPhysicalEntityRepresentation(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'physical entity representation'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isPhysicalEntityRepresentation(*args)

    if _newclass:isPhysicalEntityRepresentation = staticmethod(isPhysicalEntityRepresentation)
    __swig_getmethods__["isPhysicalEntityRepresentation"] = lambda x: isPhysicalEntityRepresentation
    def isSystemsDescriptionParameter(*args):
        """
        isSystemsDescriptionParameter(unsigned int term) -> bool

        Returns @c True if the given term identifier comes from the stated branch of %SBO.

        @return @c True if @p term is-a %SBO <em>'systems description parameter'</em>, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isSystemsDescriptionParameter(*args)

    if _newclass:isSystemsDescriptionParameter = staticmethod(isSystemsDescriptionParameter)
    __swig_getmethods__["isSystemsDescriptionParameter"] = lambda x: isSystemsDescriptionParameter
    def isObselete(*args):
        """
        isObselete(unsigned int term) -> bool

        Predicate for checking whether the given term is obsolete.

        @return @c True if @p term is-a %SBO <em>'obsolete'</em> term, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_isObselete(*args)

    if _newclass:isObselete = staticmethod(isObselete)
    __swig_getmethods__["isObselete"] = lambda x: isObselete
    def intToString(*args):
        """
        intToString(int sboTerm) -> string

        Returns the integer as a correctly formatted %SBO identifier string.

        @return the given integer sboTerm as a zero-padded seven digit string.

        @note If the sboTerm is not in the correct range
        (0000000&ndash;9999999), an empty string is returned.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_intToString(*args)

    if _newclass:intToString = staticmethod(intToString)
    __swig_getmethods__["intToString"] = lambda x: intToString
    def stringToInt(*args):
        """
        stringToInt(string sboTerm) -> int

        Returns the string as a correctly formatted %SBO integer portion.

        @return the given string sboTerm as an integer.  If the sboTerm is not
        in the correct format (a zero-padded, seven digit string), <code>-1</code> is
        returned.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_stringToInt(*args)

    if _newclass:stringToInt = staticmethod(stringToInt)
    __swig_getmethods__["stringToInt"] = lambda x: stringToInt
    def checkTerm(*args):
        """
        checkTerm(string sboTerm) -> bool
        checkTerm(int sboTerm) -> bool

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>checkTerm(string sboTerm)</pre>

        Checks the format of the given %SBO identifier string.

        @return @c True if sboTerm is in the correct format (a zero-padded, seven
        digit string), @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>checkTerm(int sboTerm)</pre>

        Checks the format of the given %SBO identifier, given in the form of
        the integer portion alone.

        @return @c True if sboTerm is in the range (0000000&ndash;9999999), @c False
        otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBO_checkTerm(*args)

    if _newclass:checkTerm = staticmethod(checkTerm)
    __swig_getmethods__["checkTerm"] = lambda x: checkTerm
    def __init__(self): 
        """__init__(self) -> SBO"""
        this = _libsbml.new_SBO()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBO
    __del__ = lambda self : None;
SBO_swigregister = _libsbml.SBO_swigregister
SBO_swigregister(SBO)

def SBO_isQuantitativeParameter(*args):
  """
    SBO_isQuantitativeParameter(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'quantiative parameter'</em>, @c False
    otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isQuantitativeParameter(*args)

def SBO_isParticipantRole(*args):
  """
    SBO_isParticipantRole(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'participant role'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isParticipantRole(*args)

def SBO_isModellingFramework(*args):
  """
    SBO_isModellingFramework(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'modeling framework'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isModellingFramework(*args)

def SBO_isMathematicalExpression(*args):
  """
    SBO_isMathematicalExpression(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'mathematical expression'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isMathematicalExpression(*args)

def SBO_isKineticConstant(*args):
  """
    SBO_isKineticConstant(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'kinetic constant'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isKineticConstant(*args)

def SBO_isReactant(*args):
  """
    SBO_isReactant(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'reactant'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isReactant(*args)

def SBO_isProduct(*args):
  """
    SBO_isProduct(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'product'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isProduct(*args)

def SBO_isModifier(*args):
  """
    SBO_isModifier(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'modifier'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isModifier(*args)

def SBO_isRateLaw(*args):
  """
    SBO_isRateLaw(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'rate law'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isRateLaw(*args)

def SBO_isEvent(*args):
  """
    SBO_isEvent(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'event'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isEvent(*args)

def SBO_isPhysicalParticipant(*args):
  """
    SBO_isPhysicalParticipant(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'physical participant</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isPhysicalParticipant(*args)

def SBO_isParticipant(*args):
  """
    SBO_isParticipant(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'participant'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isParticipant(*args)

def SBO_isInteraction(*args):
  """
    SBO_isInteraction(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'interaction'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isInteraction(*args)

def SBO_isEntity(*args):
  """
    SBO_isEntity(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'entity'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isEntity(*args)

def SBO_isFunctionalEntity(*args):
  """
    SBO_isFunctionalEntity(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'functional entity'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isFunctionalEntity(*args)

def SBO_isMaterialEntity(*args):
  """
    SBO_isMaterialEntity(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'material entity'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isMaterialEntity(*args)

def SBO_isConservationLaw(*args):
  """
    SBO_isConservationLaw(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'conservation law'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isConservationLaw(*args)

def SBO_isSteadyStateExpression(*args):
  """
    SBO_isSteadyStateExpression(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'steady state expression'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isSteadyStateExpression(*args)

def SBO_isFunctionalCompartment(*args):
  """
    SBO_isFunctionalCompartment(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'functional compartment'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isFunctionalCompartment(*args)

def SBO_isContinuousFramework(*args):
  """
    SBO_isContinuousFramework(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'continuous framework'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isContinuousFramework(*args)

def SBO_isDiscreteFramework(*args):
  """
    SBO_isDiscreteFramework(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'discrete framework'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isDiscreteFramework(*args)

def SBO_isLogicalFramework(*args):
  """
    SBO_isLogicalFramework(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'logical framework'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isLogicalFramework(*args)

def SBO_isMetadataRepresentation(*args):
  """
    SBO_isMetadataRepresentation(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'metadata representation'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isMetadataRepresentation(*args)

def SBO_isOccurringEntityRepresentation(*args):
  """
    SBO_isOccurringEntityRepresentation(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'occurring entity representation'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isOccurringEntityRepresentation(*args)

def SBO_isPhysicalEntityRepresentation(*args):
  """
    SBO_isPhysicalEntityRepresentation(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'physical entity representation'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isPhysicalEntityRepresentation(*args)

def SBO_isSystemsDescriptionParameter(*args):
  """
    SBO_isSystemsDescriptionParameter(unsigned int term) -> bool

    Returns @c True if the given term identifier comes from the stated branch of %SBO.

    @return @c True if @p term is-a %SBO <em>'systems description parameter'</em>, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isSystemsDescriptionParameter(*args)

def SBO_isObselete(*args):
  """
    SBO_isObselete(unsigned int term) -> bool

    Predicate for checking whether the given term is obsolete.

    @return @c True if @p term is-a %SBO <em>'obsolete'</em> term, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_isObselete(*args)

def SBO_intToString(*args):
  """
    SBO_intToString(int sboTerm) -> string

    Returns the integer as a correctly formatted %SBO identifier string.

    @return the given integer sboTerm as a zero-padded seven digit string.

    @note If the sboTerm is not in the correct range
    (0000000&ndash;9999999), an empty string is returned.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_intToString(*args)

def SBO_stringToInt(*args):
  """
    SBO_stringToInt(string sboTerm) -> int

    Returns the string as a correctly formatted %SBO integer portion.

    @return the given string sboTerm as an integer.  If the sboTerm is not
    in the correct format (a zero-padded, seven digit string), <code>-1</code> is
    returned.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_stringToInt(*args)

def SBO_checkTerm(*args):
  """
    checkTerm(string sboTerm) -> bool
    SBO_checkTerm(int sboTerm) -> bool

    This method has multiple variants; they differ in the arguments
     they accept.  Each variant is described separately below.

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>checkTerm(string sboTerm)</pre>

    Checks the format of the given %SBO identifier string.

    @return @c True if sboTerm is in the correct format (a zero-padded, seven
    digit string), @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~
       

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>checkTerm(int sboTerm)</pre>

    Checks the format of the given %SBO identifier, given in the form of
    the integer portion alone.

    @return @c True if sboTerm is in the range (0000000&ndash;9999999), @c False
    otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBO_checkTerm(*args)

class SyntaxChecker(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Methods for checking the validity of SBML identifiers.

    @htmlinclude not-sbml-warning.html

    This utility class provides static methods for checking the syntax of
    identifiers and other text used in an SBML model.  The methods allow
    callers to verify that strings such as SBML identifiers and XHTML notes
    text conform to the SBML specifications.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SyntaxChecker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SyntaxChecker, name)
    __repr__ = _swig_repr
    def isValidSBMLSId(*args):
        """
        isValidSBMLSId(string sid) -> bool

        Returns true @c True or @c False depending on whether the argument
        string conforms to the syntax of SBML identifiers.

        @par
        In SBML, identifiers that are the values of 'id' attributes on objects
        must conform to a data type called <code>SId</code> in the SBML
        specifications.  LibSBML does not provide an explicit <code>SId</code>
        data type; it uses ordinary character strings, which is easier for
        applications to support.  (LibSBML does, however, test for identifier
        validity at various times, such as when reading in models from files
        and data streams.) 

        This method provides programs with the ability to test explicitly that
        the identifier strings they create conform to the SBML identifier
        syntax.

        @param sid string to be checked for conformance to SBML identifier
        syntax.

        @return @c True if the string conforms to type SBML data type
        <code>SId</code>, @c False otherwise.

        @par
        SBML has strict requirements for the syntax of identifiers, that is, the
        values of the 'id' attribute present on most types of SBML objects.
        The following is a summary of the definition of the SBML identifier type
        <code>SId</code>, which defines the permitted syntax of identifiers.  We
        express the syntax using an extended form of BNF notation:
        <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
        letter ::= 'a'..'z','A'..'Z'
        digit  ::= '0'..'9'
        idChar ::= letter | digit | '_'
        SId    ::= ( letter | '_' ) idChar*</pre>
        The characters <code>(</code> and <code>)</code> are used for grouping, the
        character <code>*</code> 'zero or more times', and the character
        <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
        determined by an exact character sequence match; i.e., comparisons must be
        performed in a case-sensitive manner.  In addition, there are a few
        conditions for the uniqueness of identifiers in an SBML model.  Please
        consult the SBML specifications for the exact details of the uniqueness
        requirements.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike isValidUnitSId(string sid) @else SyntaxChecker.isValidUnitSId() @endif@~
        @see @if clike isValidXMLID(string sid) @else SyntaxChecker.isValidXMLID() @endif@~

        """
        return _libsbml.SyntaxChecker_isValidSBMLSId(*args)

    if _newclass:isValidSBMLSId = staticmethod(isValidSBMLSId)
    __swig_getmethods__["isValidSBMLSId"] = lambda x: isValidSBMLSId
    def isValidXMLID(*args):
        """
        isValidXMLID(string id) -> bool

        Returns @c True or @c False depending on whether the argument string
        conforms to the XML data type <code>ID</code>.

        @par
        The optional attribute named 'metaid', present on every major SBML
        component type, is for supporting metadata annotations using RDF (<a
        href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
        attribute value has the data type <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
        identifier type, which means each 'metaid' value must be globally unique
        within an SBML file.  The latter point is important, because the
        uniqueness criterion applies across <em>any</em> attribute with type
        <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
        by SBML---something to be aware of if your application-specific XML
        content inside the 'annotation' subelement happens to use the XML
        <code>ID</code> type.  Although SBML itself specifies the use of <a
        href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
        the 'metaid' attribute, SBML-compatible applications should be careful if
        they use XML <code>ID</code>'s in XML portions of a model that are not
        defined by SBML, such as in the application-specific content of the
        'annotation' subelement.  Finally, note that LibSBML does not provide an
        explicit XML <code>ID</code> data type; it uses ordinary character
        strings, which is easier for applications to support. 

        This method provides programs with the ability to test explicitly that
        the identifier strings they create conform to the SBML identifier
        syntax.

        @param id string to be checked for conformance to the syntax of
        <a target='_blank' href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.

        @return @c True if the string is a syntactically-valid value for the
        XML type <a target='_blank'
        href='http://www.w3.org/TR/REC-xml/#id'>ID</a>, @c False otherwise.

        @note @htmlinclude xmlid-syntax.html

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike isValidSBMLSId(string sid) @else SyntaxChecker.isValidSBMLSId() @endif@~
        @see @if clike isValidUnitSId(string sid) @else SyntaxChecker.isValidUnitSId() @endif@~

        """
        return _libsbml.SyntaxChecker_isValidXMLID(*args)

    if _newclass:isValidXMLID = staticmethod(isValidXMLID)
    __swig_getmethods__["isValidXMLID"] = lambda x: isValidXMLID
    def isValidXMLanyURI(*args):
        """
        isValidXMLanyURI(string uri) -> bool

        Returns @c True or @c False depending on whether the @p uri argument string
        conforms to the XML data type <code>anyURI</code>.

        Type anyURI is defined by XML Schema 1.0. It is a character string 
        data type whose values are interpretable as URIs (Universal Resource 
        Identifiers) as described by the W3C document RFC 3986.  LibSBML
        does not provide an explicit XML <code>anyURI</code> data type; it uses
        ordinary character strings, which is easier for applications to
        support.  LibSBML does, however, test for anyURI validity at
        various times, such as when reading in models from files and data
        streams.

        This method provides programs with the ability to test explicitly that
        the strings they create conform to the XML anyURI syntax.

        @param uri string to be checked for conformance to the syntax of
        <a target='_blank' 
        href='http://www.w3.org/TR/xmlschema-2/#anyURI'>anyURI</a>.

        @return @c True if the string is a syntactically-valid value for the
        XML type <a target='_blank'
        href='http://www.w3.org/TR/xmlschema-2/#anyURI'>anyURI</a>, 
        @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SyntaxChecker_isValidXMLanyURI(*args)

    if _newclass:isValidXMLanyURI = staticmethod(isValidXMLanyURI)
    __swig_getmethods__["isValidXMLanyURI"] = lambda x: isValidXMLanyURI
    def isValidUnitSId(*args):
        """
        isValidUnitSId(string units) -> bool

        Returns @c True or @c False depending on whether the argument string
        conforms to the syntax of SBML unit identifiers.

        In SBML, the identifiers of units (of both the predefined units and
        user-defined units) must conform to a data type called
        <code>UnitSId</code> in the SBML specifications.  LibSBML does not
        provide an explicit <code>UnitSId</code> data type; it uses ordinary
        character strings, which is easier for applications to support.
        LibSBML does, however, test for identifier validity at various times,
        such as when reading in models from files and data streams.

        This method provides programs with the ability to test explicitly that
        the identifier strings they create conform to the SBML identifier
        syntax.

        @param units string to be checked for conformance to SBML unit
        identifier syntax.

        @return @c True if the string conforms to type SBML data type
        <code>UnitSId</code>, @c False otherwise.

        @note @htmlinclude unitid-syntax.html

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike isValidSBMLSId(string sid) @else SyntaxChecker.isValidSBMLSId() @endif@~
        @see @if clike isValidXMLID(string sid) @else SyntaxChecker.isValidXMLID() @endif@~

        """
        return _libsbml.SyntaxChecker_isValidUnitSId(*args)

    if _newclass:isValidUnitSId = staticmethod(isValidUnitSId)
    __swig_getmethods__["isValidUnitSId"] = lambda x: isValidUnitSId
    def hasExpectedXHTMLSyntax(*args):
        """
        hasExpectedXHTMLSyntax(XMLNode xhtml, SBMLNamespaces sbmlns = None) -> bool
        hasExpectedXHTMLSyntax(XMLNode xhtml) -> bool

        Returns @c True or @c False depending on whether the given XMLNode
        object contains valid XHTML content.

        @par
        The optional SBML element named 'notes', present on every major SBML
        component type (and in SBML Level&nbsp;3, the 'message' subelement of
        Constraint), is intended as a place for storing optional information
        intended to be seen by humans.  An example use of the 'notes' element
        would be to contain formatted user comments about the model element in
        which the 'notes' element is enclosed.  Every object derived directly or
        indirectly from type SBase can have a separate value for 'notes', allowing
        users considerable freedom when adding comments to their models.

        The format of 'notes' elements conform to the definition of <a
        target='_blank' href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.
        However, the content cannot be @em entirely free-form; it must satisfy
        certain requirements defined in the <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specifications</a>
        for specific SBML Levels.  To help verify the formatting of 'notes'
        content, libSBML provides the static utility method
        SyntaxChecker.hasExpectedXHTMLSyntax(); this
        method implements a verification process that lets callers check whether
        the content of a given XMLNode object conforms to the SBML requirements
        for 'notes' and 'message' structure.  Developers are urged to consult the
        appropriate <a target='_blank'
        href='http://sbml.org/Documents/Specifications'>SBML specification
        document</a> for the Level and Version of their model for more in-depth
        explanations of using 'notes' in SBML.  The SBML Level&nbsp;2 and &nbsp;3
        specifications have considerable detail about how 'notes' element content
        must be structured.

        An aspect of XHTML validity is that the content is declared to be in
        the XML namespace for XHTML&nbsp;1.0.  There is more than one way in
        which this can be done in XML.  In particular, a model might not
        contain the declaration within the 'notes' or 'message' subelement
        itself, but might instead place the declaration on an enclosing
        element and use an XML namespace prefix within the 'notes' element to
        refer to it.  In other words, the following is valid:
        @verbatim
        <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'
              xmlns:xhtml='http://www.w3.org/1999/xhtml'>
          <model>
            <notes>
              <xhtml:body>
                <xhtml:center><xhtml:h2>A Simple Mitotic Oscillator</xhtml:h2></xhtml:center>
                <xhtml:p>A minimal cascade model for the mitotic oscillator.</xhtml:p>
              </xhtml:body>
            </notes>
          ... rest of model ...
        </sbml>
        @endverbatim
        Contrast the above with the following, self-contained version, which
        places the XML namespace declaration within the <code>&lt;notes&gt;</code>
        element itself:
        @verbatim
        <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'>
          <model>
            <notes>
              <html xmlns='http://www.w3.org/1999/xhtml'>
                <head>
                  <title/>
                </head>
                <body>
                  <center><h2>A Simple Mitotic Oscillator</h2></center>
                  <p>A minimal cascade model for the mitotic oscillator.</p>
                </body>
              </html>
            </notes>
          ... rest of model ...
        </sbml>
        @endverbatim

        Both of the above are valid XML.  The purpose of the @p sbmlns
        argument to this method is to allow callers to check the validity of
        'notes' and 'message' subelements whose XML namespace declarations
        have been put elsewhere in the manner illustrated above.  Callers can
        can pass in the SBMLNamespaces object of a higher-level model
        component if the XMLNode object does not itself have the XML namespace
        declaration for XHTML&nbsp;1.0.

        @param xhtml the XMLNode to be checked for conformance.
        @param sbmlns the SBMLNamespaces associated with the object.

        @return @c True if the XMLNode content conforms, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.SyntaxChecker_hasExpectedXHTMLSyntax(*args)

    if _newclass:hasExpectedXHTMLSyntax = staticmethod(hasExpectedXHTMLSyntax)
    __swig_getmethods__["hasExpectedXHTMLSyntax"] = lambda x: hasExpectedXHTMLSyntax
    def isValidInternalSId(*args):
        """
        isValidInternalSId(string sid) -> bool

        @internal
        Returns true @c True or @c False depending on whether the argument
        string conforms to the syntax of SBML identifiers or is empty.

        @internal

        """
        return _libsbml.SyntaxChecker_isValidInternalSId(*args)

    if _newclass:isValidInternalSId = staticmethod(isValidInternalSId)
    __swig_getmethods__["isValidInternalSId"] = lambda x: isValidInternalSId
    def isValidInternalUnitSId(*args):
        """
        isValidInternalUnitSId(string sid) -> bool

        @internal

        @internal

        """
        return _libsbml.SyntaxChecker_isValidInternalUnitSId(*args)

    if _newclass:isValidInternalUnitSId = staticmethod(isValidInternalUnitSId)
    __swig_getmethods__["isValidInternalUnitSId"] = lambda x: isValidInternalUnitSId
    def __init__(self): 
        """__init__(self) -> SyntaxChecker"""
        this = _libsbml.new_SyntaxChecker()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SyntaxChecker
    __del__ = lambda self : None;
SyntaxChecker_swigregister = _libsbml.SyntaxChecker_swigregister
SyntaxChecker_swigregister(SyntaxChecker)

def SyntaxChecker_isValidSBMLSId(*args):
  """
    SyntaxChecker_isValidSBMLSId(string sid) -> bool

    Returns true @c True or @c False depending on whether the argument
    string conforms to the syntax of SBML identifiers.

    @par
    In SBML, identifiers that are the values of 'id' attributes on objects
    must conform to a data type called <code>SId</code> in the SBML
    specifications.  LibSBML does not provide an explicit <code>SId</code>
    data type; it uses ordinary character strings, which is easier for
    applications to support.  (LibSBML does, however, test for identifier
    validity at various times, such as when reading in models from files
    and data streams.) 

    This method provides programs with the ability to test explicitly that
    the identifier strings they create conform to the SBML identifier
    syntax.

    @param sid string to be checked for conformance to SBML identifier
    syntax.

    @return @c True if the string conforms to type SBML data type
    <code>SId</code>, @c False otherwise.

    @par
    SBML has strict requirements for the syntax of identifiers, that is, the
    values of the 'id' attribute present on most types of SBML objects.
    The following is a summary of the definition of the SBML identifier type
    <code>SId</code>, which defines the permitted syntax of identifiers.  We
    express the syntax using an extended form of BNF notation:
    <pre style='margin-left: 2em; border: none; font-weight: bold; font-size: 13px; color: black'>
    letter ::= 'a'..'z','A'..'Z'
    digit  ::= '0'..'9'
    idChar ::= letter | digit | '_'
    SId    ::= ( letter | '_' ) idChar*</pre>
    The characters <code>(</code> and <code>)</code> are used for grouping, the
    character <code>*</code> 'zero or more times', and the character
    <code>|</code> indicates logical 'or'.  The equality of SBML identifiers is
    determined by an exact character sequence match; i.e., comparisons must be
    performed in a case-sensitive manner.  In addition, there are a few
    conditions for the uniqueness of identifiers in an SBML model.  Please
    consult the SBML specifications for the exact details of the uniqueness
    requirements.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike isValidUnitSId(string sid) @else SyntaxChecker.isValidUnitSId() @endif@~
    @see @if clike isValidXMLID(string sid) @else SyntaxChecker.isValidXMLID() @endif@~

    """
  return _libsbml.SyntaxChecker_isValidSBMLSId(*args)

def SyntaxChecker_isValidXMLID(*args):
  """
    SyntaxChecker_isValidXMLID(string id) -> bool

    Returns @c True or @c False depending on whether the argument string
    conforms to the XML data type <code>ID</code>.

    @par
    The optional attribute named 'metaid', present on every major SBML
    component type, is for supporting metadata annotations using RDF (<a
    href='http://www.w3.org/RDF/'>Resource Description Format</a>).  The
    attribute value has the data type <a
    href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a>, the XML
    identifier type, which means each 'metaid' value must be globally unique
    within an SBML file.  The latter point is important, because the
    uniqueness criterion applies across <em>any</em> attribute with type
    <code>ID</code> anywhere in the file, not just the 'metaid' attribute used
    by SBML---something to be aware of if your application-specific XML
    content inside the 'annotation' subelement happens to use the XML
    <code>ID</code> type.  Although SBML itself specifies the use of <a
    href='http://www.w3.org/TR/REC-xml/#id'>XML <code>ID</code></a> only for
    the 'metaid' attribute, SBML-compatible applications should be careful if
    they use XML <code>ID</code>'s in XML portions of a model that are not
    defined by SBML, such as in the application-specific content of the
    'annotation' subelement.  Finally, note that LibSBML does not provide an
    explicit XML <code>ID</code> data type; it uses ordinary character
    strings, which is easier for applications to support. 

    This method provides programs with the ability to test explicitly that
    the identifier strings they create conform to the SBML identifier
    syntax.

    @param id string to be checked for conformance to the syntax of
    <a target='_blank' href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.

    @return @c True if the string is a syntactically-valid value for the
    XML type <a target='_blank'
    href='http://www.w3.org/TR/REC-xml/#id'>ID</a>, @c False otherwise.

    @note @htmlinclude xmlid-syntax.html

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike isValidSBMLSId(string sid) @else SyntaxChecker.isValidSBMLSId() @endif@~
    @see @if clike isValidUnitSId(string sid) @else SyntaxChecker.isValidUnitSId() @endif@~

    """
  return _libsbml.SyntaxChecker_isValidXMLID(*args)

def SyntaxChecker_isValidXMLanyURI(*args):
  """
    SyntaxChecker_isValidXMLanyURI(string uri) -> bool

    Returns @c True or @c False depending on whether the @p uri argument string
    conforms to the XML data type <code>anyURI</code>.

    Type anyURI is defined by XML Schema 1.0. It is a character string 
    data type whose values are interpretable as URIs (Universal Resource 
    Identifiers) as described by the W3C document RFC 3986.  LibSBML
    does not provide an explicit XML <code>anyURI</code> data type; it uses
    ordinary character strings, which is easier for applications to
    support.  LibSBML does, however, test for anyURI validity at
    various times, such as when reading in models from files and data
    streams.

    This method provides programs with the ability to test explicitly that
    the strings they create conform to the XML anyURI syntax.

    @param uri string to be checked for conformance to the syntax of
    <a target='_blank' 
    href='http://www.w3.org/TR/xmlschema-2/#anyURI'>anyURI</a>.

    @return @c True if the string is a syntactically-valid value for the
    XML type <a target='_blank'
    href='http://www.w3.org/TR/xmlschema-2/#anyURI'>anyURI</a>, 
    @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SyntaxChecker_isValidXMLanyURI(*args)

def SyntaxChecker_isValidUnitSId(*args):
  """
    SyntaxChecker_isValidUnitSId(string units) -> bool

    Returns @c True or @c False depending on whether the argument string
    conforms to the syntax of SBML unit identifiers.

    In SBML, the identifiers of units (of both the predefined units and
    user-defined units) must conform to a data type called
    <code>UnitSId</code> in the SBML specifications.  LibSBML does not
    provide an explicit <code>UnitSId</code> data type; it uses ordinary
    character strings, which is easier for applications to support.
    LibSBML does, however, test for identifier validity at various times,
    such as when reading in models from files and data streams.

    This method provides programs with the ability to test explicitly that
    the identifier strings they create conform to the SBML identifier
    syntax.

    @param units string to be checked for conformance to SBML unit
    identifier syntax.

    @return @c True if the string conforms to type SBML data type
    <code>UnitSId</code>, @c False otherwise.

    @note @htmlinclude unitid-syntax.html

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike isValidSBMLSId(string sid) @else SyntaxChecker.isValidSBMLSId() @endif@~
    @see @if clike isValidXMLID(string sid) @else SyntaxChecker.isValidXMLID() @endif@~

    """
  return _libsbml.SyntaxChecker_isValidUnitSId(*args)

def SyntaxChecker_hasExpectedXHTMLSyntax(*args):
  """
    hasExpectedXHTMLSyntax(XMLNode xhtml, SBMLNamespaces sbmlns = None) -> bool
    SyntaxChecker_hasExpectedXHTMLSyntax(XMLNode xhtml) -> bool

    Returns @c True or @c False depending on whether the given XMLNode
    object contains valid XHTML content.

    @par
    The optional SBML element named 'notes', present on every major SBML
    component type (and in SBML Level&nbsp;3, the 'message' subelement of
    Constraint), is intended as a place for storing optional information
    intended to be seen by humans.  An example use of the 'notes' element
    would be to contain formatted user comments about the model element in
    which the 'notes' element is enclosed.  Every object derived directly or
    indirectly from type SBase can have a separate value for 'notes', allowing
    users considerable freedom when adding comments to their models.

    The format of 'notes' elements conform to the definition of <a
    target='_blank' href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.
    However, the content cannot be @em entirely free-form; it must satisfy
    certain requirements defined in the <a target='_blank'
    href='http://sbml.org/Documents/Specifications'>SBML specifications</a>
    for specific SBML Levels.  To help verify the formatting of 'notes'
    content, libSBML provides the static utility method
    SyntaxChecker.hasExpectedXHTMLSyntax(); this
    method implements a verification process that lets callers check whether
    the content of a given XMLNode object conforms to the SBML requirements
    for 'notes' and 'message' structure.  Developers are urged to consult the
    appropriate <a target='_blank'
    href='http://sbml.org/Documents/Specifications'>SBML specification
    document</a> for the Level and Version of their model for more in-depth
    explanations of using 'notes' in SBML.  The SBML Level&nbsp;2 and &nbsp;3
    specifications have considerable detail about how 'notes' element content
    must be structured.

    An aspect of XHTML validity is that the content is declared to be in
    the XML namespace for XHTML&nbsp;1.0.  There is more than one way in
    which this can be done in XML.  In particular, a model might not
    contain the declaration within the 'notes' or 'message' subelement
    itself, but might instead place the declaration on an enclosing
    element and use an XML namespace prefix within the 'notes' element to
    refer to it.  In other words, the following is valid:
    @verbatim
    <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'
          xmlns:xhtml='http://www.w3.org/1999/xhtml'>
      <model>
        <notes>
          <xhtml:body>
            <xhtml:center><xhtml:h2>A Simple Mitotic Oscillator</xhtml:h2></xhtml:center>
            <xhtml:p>A minimal cascade model for the mitotic oscillator.</xhtml:p>
          </xhtml:body>
        </notes>
      ... rest of model ...
    </sbml>
    @endverbatim
    Contrast the above with the following, self-contained version, which
    places the XML namespace declaration within the <code>&lt;notes&gt;</code>
    element itself:
    @verbatim
    <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'>
      <model>
        <notes>
          <html xmlns='http://www.w3.org/1999/xhtml'>
            <head>
              <title/>
            </head>
            <body>
              <center><h2>A Simple Mitotic Oscillator</h2></center>
              <p>A minimal cascade model for the mitotic oscillator.</p>
            </body>
          </html>
        </notes>
      ... rest of model ...
    </sbml>
    @endverbatim

    Both of the above are valid XML.  The purpose of the @p sbmlns
    argument to this method is to allow callers to check the validity of
    'notes' and 'message' subelements whose XML namespace declarations
    have been put elsewhere in the manner illustrated above.  Callers can
    can pass in the SBMLNamespaces object of a higher-level model
    component if the XMLNode object does not itself have the XML namespace
    declaration for XHTML&nbsp;1.0.

    @param xhtml the XMLNode to be checked for conformance.
    @param sbmlns the SBMLNamespaces associated with the object.

    @return @c True if the XMLNode content conforms, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

    """
  return _libsbml.SyntaxChecker_hasExpectedXHTMLSyntax(*args)

def SyntaxChecker_isValidInternalSId(*args):
  """
    SyntaxChecker_isValidInternalSId(string sid) -> bool

    @internal
    Returns true @c True or @c False depending on whether the argument
    string conforms to the syntax of SBML identifiers or is empty.

    @internal

    """
  return _libsbml.SyntaxChecker_isValidInternalSId(*args)

def SyntaxChecker_isValidInternalUnitSId(*args):
  """
    SyntaxChecker_isValidInternalUnitSId(string sid) -> bool

    @internal

    @internal

    """
  return _libsbml.SyntaxChecker_isValidInternalUnitSId(*args)

class StoichiometryMath(SBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Stochiometry expressions in SBML Level 2 reactions.

    @section l2-stoichiometries Stoichiometries in SBML Level 2

    In SBML Level 2, product and reactant stoichiometries can be specified
    using @em either the 'stoichiometry' attribute or a 'stoichiometryMath'
    element in a SpeciesReference object.  The 'stoichiometry' attribute is
    of type @c float and should contain values greater than zero (0).  The
    'stoichiometryMath' element is implemented as an element containing a
    MathML expression.  These two are mutually exclusive; only one of
    'stoichiometry' or 'stoichiometryMath' should be defined in a given
    SpeciesReference instance.  When neither the attribute nor the element
    is present, the value of 'stoichiometry' in the enclosing
    SpeciesReference instance defaults to @c 1.

    For maximum interoperability, SpeciesReference's 'stoichiometry'
    attribute should be used in preference to 'stoichiometryMath' when a
    species' stoichiometry is a simple scalar number (integer or decimal).
    When the stoichiometry is a rational number, or when it is a more
    complicated formula, 'stoichiometryMath' must be used.  The MathML
    expression in 'stoichiometryMath' may also refer to identifiers of
    entities in a model (except reaction identifiers).  However, the only
    species identifiers that can be used in 'stoichiometryMath' are those
    referenced in the enclosing Reaction's list of reactants, products and
    modifiers.

    The 'stoichiometry' attribute and the 'stoichiometryMath' element, when
    either is used, is each interpreted as a factor applied to the reaction
    rate to produce the rate of change of the species identified by the
    'species' attribute in the enclosing SpeciesReference.  This is the
    normal interpretation of a stoichiometry, but in SBML, one additional
    consideration has to be taken into account.  The reaction rate, which is
    the result of the KineticLaw's 'math' element, is always in the model's
    @em substance per @em time units.  However, the rate of change of the
    species will involve the species' @em substance units (i.e., the units
    identified by the Species object's 'substanceUnits' attribute), and
    these units may be different from the model's default @em substance
    units.  If the units @em are different, the stoichiometry must
    incorporate a conversion factor for converting the model's @em substance
    units to the species' @em substance units.  The conversion factor is
    assumed to be included in the scalar value of the 'stoichiometry'
    attribute if 'stoichiometry' is used.  If instead 'stoichiometryMath' is
    used, then the product of the model's 'substance' units times the
    'stoichiometryMath' units must match the @em substance units of the
    species.  Note that in either case, if the species' units and the
    model's default @em substance units are the same, the stoichiometry ends
    up being a dimensionless number and equivalent to the standard chemical
    stoichiometry found in textbooks.  Examples and more explanations of
    this are given in the SBML specification.

    The following is a simple example of a species reference for species @c
    'X0', with stoichiometry @c 2, in a list of reactants within a reaction
    having the identifier @c 'J1':
    @verbatim
     <model>
         ...
         <listOfReactions>
             <reaction id='J1'>
                 <listOfReactants>
                     <speciesReference species='X0' stoichiometry='2'>
                 </listOfReactants>
                 ...
             </reaction>
             ...
         </listOfReactions>
         ...
     </model>
     @endverbatim

    The following is a more complex example of a species reference for
    species @c 'X0', with a stoichiometry formula consisting of
    a rational number:
    @verbatim
     <model>
         ...
         <listOfReactions>
             <reaction id='J1'>
                 <listOfReactants>
                     <speciesReference species='X0'>
                         <stoichiometryMath>
                             <math xmlns='http://www.w3.org/1998/Math/MathML'> 
                                 <cn type='rational'> 3 <sep/> 2 </cn>
                             </math>
                         </stoichiometryMath>
                     </speciesReference>
                 </listOfReactants>
                 ...
             </reaction>
             ...
         </listOfReactions>
         ...
     </model>
     @endverbatim

    Additional discussions of stoichiometries and implications for species
    and reactions are included in the documentation of SpeciesReference
    class.

    @section l3-stoichiometries Stoichiometries in SBML Level 3

    The StoichiometryMath construct is not defined in SBML Level&nbsp;3
    Version&nbsp;1 Core.  Instead, Level&nbsp;3 defines the identifier of
    SpeciesReference objects as a stand-in for the stoichiometry of the
    reactant or product being referenced, and allows that identifier to be
    used elsewhere in SBML models, including (for example) InitialAssignment
    objects.  This makes it possible to achieve the same effect as
    StoichiometryMath, but with other SBML objects.  For instance, to
    produce a stoichiometry value that is a rational number, a model can use
    InitialAssignment to assign the identifier of a SpeciesReference object
    to a MathML expression evaluating to a rational number.  This is
    analogous to the same way that, in Level&nbsp;2, the model would use
    StoichiometryMath with a MathML expression evaluating to a rational
    number.

    In SBML Level 2, the stoichiometry of a reactant or product is a
    combination of both a <em>biochemical stoichiometry</em> (meaning, the
    standard stoichiometry of a species in a reaction) and any necessary
    unit conversion factors. The introduction of an explicit attribute on
    the Species object for a conversion factor allows Level&nbsp;3 to avoid
    having to overload the meaning of stoichiometry.  In Level&nbsp;3, the
    stoichiometry given by a SpeciesReference object in a reaction is a
    'proper' biochemical stoichiometry, meaning a dimensionless number free
    of unit conversions.

    @see SpeciesReference
    @see Reaction

    """
    __swig_setmethods__ = {}
    for _s in [SBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StoichiometryMath, name, value)
    __swig_getmethods__ = {}
    for _s in [SBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StoichiometryMath, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_StoichiometryMath
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level, unsigned int version) -> StoichiometryMath
        __init__(self, SBMLNamespaces sbmlns) -> StoichiometryMath
        __init__(self, StoichiometryMath orig) -> StoichiometryMath

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>StoichiometryMath(SBMLNamespaces sbmlns)</pre>

        Creates a new StoichiometryMath object using the given SBMLNamespaces object
        @p sbmlns.

        @par
        The SBMLNamespaces object encapsulates SBML Level/Version/namespaces
        information.  It is used to communicate the SBML Level, Version, and (in
        Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.  A
        common approach to using libSBML's SBMLNamespaces facilities is to create an
        SBMLNamespaces object somewhere in a program once, then hand that object
        as needed to object constructors that accept SBMLNamespaces as arguments. 

        @param sbmlns an SBMLNamespaces object.

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note The StoichiometryMath construct exists only in SBML Level&nbsp;2.
        It is an optional construct available for defining the stoichiometries of
        reactants and products in Reaction objects.  Note that a different
        mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not
        available.  Please consult the top of this libSBML StoichiometryMath
        documentation for more information about the differences between SBML
        Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>StoichiometryMath(long level, long version)</pre>

        Creates a new StoichiometryMath object using the given SBML @p level
        values.

        @param level a long integer, the SBML Level to assign to this StoichiometryMath

        @param version a long integer, the SBML Version to assign to this
        StoichiometryMath

        @throws SBMLConstructorException
        Thrown if the given @p level and @p version combination, or this kind
        of SBML object, are either invalid or mismatched with respect to the
        parent SBMLDocument object.

        @note The StoichiometryMath construct exists only in SBML Level&nbsp;2.
        It is an optional construct available for defining the stoichiometries of
        reactants and products in Reaction objects.  Note that a different
        mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not
        available.  Please consult the top of this libSBML StoichiometryMath
        documentation for more information about the differences between SBML
        Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.

        @note Attempting to add an object to an SBMLDocument having a different
        combination of SBML Level, Version and XML namespaces than the object
        itself will result in an error at the time a caller attempts to make the
        addition.  A parent object must have compatible Level, Version and XML
        namespaces.  (Strictly speaking, a parent may also have more XML
        namespaces than a child, but the reverse is not permitted.)  The
        restriction is necessary to ensure that an SBML model has a consistent
        overall structure.  This requires callers to manage their objects
        carefully, but the benefit is increased flexibility in how models can be
        created by permitting callers to create objects bottom-up if desired.  In
        situations where objects are not yet attached to parents (e.g.,
        SBMLDocument), knowledge of the intented SBML Level and Version help
        libSBML determine such things as whether it is valid to assign a
        particular value to an attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>StoichiometryMath(StoichiometryMath orig)</pre>

        Copy constructor; creates a copy of this StoichiometryMath.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_StoichiometryMath(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> StoichiometryMath

        Creates and returns a deep copy of this StoichiometryMath object.

        @return the (deep) copy of this StoichiometryMath object.

        """
        return _libsbml.StoichiometryMath_clone(self)

    def getMath(self):
        """
        getMath(self) -> ASTNode

        Retrieves the mathematical formula within this StoichiometryMath and
        return it as an AST.

        @return the math of this StoichiometryMath.

        @note The StoichiometryMath construct exists only in SBML Level&nbsp;2.
        It is an optional construct available for defining the stoichiometries of
        reactants and products in Reaction objects.  Note that a different
        mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not
        available.  Please consult the top of this libSBML StoichiometryMath
        documentation for more information about the differences between SBML
        Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.

        """
        return _libsbml.StoichiometryMath_getMath(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        Predicate to test whether the math for this StoichiometryMath object
        is set.

        @return @c True if the formula (meaning the @c math subelement) of
        this StoichiometryMath is set, @c False otherwise.

        @note The StoichiometryMath construct exists only in SBML Level&nbsp;2.
        It is an optional construct available for defining the stoichiometries of
        reactants and products in Reaction objects.  Note that a different
        mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not
        available.  Please consult the top of this libSBML StoichiometryMath
        documentation for more information about the differences between SBML
        Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.

        """
        return _libsbml.StoichiometryMath_isSetMath(self)

    def setMath(self, *args):
        """
        setMath(self, ASTNode math) -> int

        Sets the 'math' expression of this StoichiometryMath instance to a
        copy of the given ASTNode.

        @param math an ASTNode representing a formula tree.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note The StoichiometryMath construct exists only in SBML Level&nbsp;2.
        It is an optional construct available for defining the stoichiometries of
        reactants and products in Reaction objects.  Note that a different
        mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not
        available.  Please consult the top of this libSBML StoichiometryMath
        documentation for more information about the differences between SBML
        Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.

        """
        return _libsbml.StoichiometryMath_setMath(self, *args)

    def getDerivedUnitDefinition(self, *args):
        """
        getDerivedUnitDefinition(self) -> UnitDefinition
        getDerivedUnitDefinition(self) -> UnitDefinition

        Calculates and returns a UnitDefinition object that expresses the
        units returned by the math expression in this StoichiometryMath
        object.

        The units are calculated based on the mathematical expression in the
        StoichiometryMath and the model quantities referenced by
        <code>&lt;ci&gt;</code> elements used within that expression.  The
        StoichiometryMath.getDerivedUnitDefinition() method returns the
        calculated units.

        Note that the functionality that facilitates unit analysis depends 
        on the model as a whole.  Thus, in cases where the object has not 
        been added to a model or the model itself is incomplete,
        unit analysis is not possible and this method will return @c None.

        @return a UnitDefinition that expresses the units of the math, 
        or @c None if one cannot be constructed.

        @warning <span class='warning'>Note that it is possible the 'math'
        expression in the StoichiometryMath instance contains literal numbers or
        parameters with undeclared units.  In those cases, it is not possible to
        calculate the units of the overall expression without making
        assumptions.  LibSBML does not make assumptions about the units, and
        StoichiometryMath.getDerivedUnitDefinition() only returns the units as
        far as it is able to determine them.  For example, in an expression
        <em>X + Y</em>, if <em>X</em> has unambiguously-defined units and
        <em>Y</em> does not, it will return the units of <em>X</em>.  When using
        this method, <strong>it is critical that callers also invoke the
        method</strong> StoichiometryMath.containsUndeclaredUnits() <strong>to
        determine whether this situation holds</strong>.  Callers should take
        suitable action in those situations.</span>

        @see containsUndeclaredUnits()

        """
        return _libsbml.StoichiometryMath_getDerivedUnitDefinition(self, *args)

    def containsUndeclaredUnits(self, *args):
        """
        containsUndeclaredUnits(self) -> bool
        containsUndeclaredUnits(self) -> bool

        Predicate returning @c True if the math
        expression of this StoichiometryMath object contains literal numbers
        or parameters with undeclared units.

        The StoichiometryMath.getDerivedUnitDefinition() method returns what
        libSBML computes the units of the Stoichiometry to be, to the extent
        that libSBML can compute them.  However, if the expression contains
        literal numbers or parameters with undeclared units, libSBML may not
        be able to compute the full units of the expression and will only
        return what it can compute.  Callers should always use
        StoichiometryMath.containsUndeclaredUnits() when using
        StoichiometryMath.getDerivedUnitDefinition() to decide whether the
        returned units may be incomplete.

        @return @c True if the math expression of this StoichiometryMath
        includes numbers/parameters with undeclared units, @c False otherwise.

        @note A return value of @c True indicates that the UnitDefinition
        returned by StoichiometryMath.getDerivedUnitDefinition() may not
        accurately represent the units of the expression.

        @see getDerivedUnitDefinition()

        """
        return _libsbml.StoichiometryMath_containsUndeclaredUnits(self, *args)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the libSBML type code of this object instance.

        @par
        LibSBML attaches an identifying code to every kind of SBML object.  These
        are integer constants known as <em>SBML type codes</em>.  The names of all
        the codes begin with the characters &ldquo;<code>SBML_</code>&rdquo;.
        @if clike The set of possible type codes for core elements is defined in
        the enumeration #SBMLTypeCode_t, and in addition, libSBML plug-ins for
        SBML Level&nbsp;3 packages define their own extra enumerations of type
        codes (e.g., #SBMLLayoutTypeCode_t for the Level&nbsp;3 Layout
        package).@endif@if java In the Java language interface for libSBML, the
        type codes are defined as static integer constants in the interface class
        {@link libsbmlConstants}.  @endif@if python In the Python language
        interface for libSBML, the type codes are defined as static integer
        constants in the interface class @link libsbml@endlink.@endif@if csharp In
        the C# language interface for libSBML, the type codes are defined as
        static integer constants in the interface class
        @link libsbmlcs.libsbml@endlink.@endif@~  Note that different Level&nbsp;3
        package plug-ins may use overlapping type codes; to identify the package
        to which a given object belongs, call the <code>getPackageName()</code>
        method on the object.

        @return the SBML type code for this object:
        @link libsbml#SBML_STOICHIOMETRY_MATH SBML_STOICHIOMETRY_MATH@endlink (default).

        @warning <span class='warning'>The specific integer values of the possible
        type codes may be reused by different Level&nbsp;3 package plug-ins.
        Thus, to identifiy the correct code, <strong>it is necessary to invoke
        both getTypeCode() and getPackageName()</strong>.</span>

        @see getElementName()
        @see getPackageName()

        """
        return _libsbml.StoichiometryMath_getTypeCode(self)

    def getElementName(self):
        """
        getElementName(self) -> string

        Returns the XML element name of this object, which for StoichiometryMath, is
        always @c 'stoichiometryMath'.

        @return the name of this element, i.e., @c 'stoichiometryMath'.

        """
        return _libsbml.StoichiometryMath_getElementName(self)

    def hasRequiredElements(self):
        """
        hasRequiredElements(self) -> bool

        Predicate returning @c True if
        all the required elements for this StoichiometryMath object
        have been set.

        @note The required elements for a StoichiometryMath object are:
        @li 'math'

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.StoichiometryMath_hasRequiredElements(self)

    def removeFromParentAndDelete(self):
        """
        removeFromParentAndDelete(self) -> int

        Finds this StoichiometryMath's SpeciesReference parent and calls
        unsetStoichiometryMath() on it, indirectly deleting itself.

        Overridden from the SBase function since the parent is not a ListOf.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.StoichiometryMath_removeFromParentAndDelete(self)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c SIdRef type attribute value with another
        value.

        @par
        In SBML, object identifiers are of a data type called <code>SId</code>.
        In SBML Level&nbsp;3, an explicit data type called <code>SIdRef</code> was
        introduced for attribute values that refer to <code>SId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to an identifier', but the effective
        data type was the same as <code>SIdRef</code>in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>SIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all attributes and (if appropriate)
        mathematical formulas in MathML content, comparing the referenced
        identifiers to the value of @p oldid.  If any matches are found, the
        matching values are replaced with @p newid.  The method does @em not
        descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.StoichiometryMath_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Replaces all uses of a given @c UnitSIdRef type attribute value with
        another value.

        @par
        In SBML, unit definitions have identifiers of type <code>UnitSId</code>.  In
        SBML Level&nbsp;3, an explicit data type called <code>UnitSIdRef</code> was
        introduced for attribute values that refer to <code>UnitSId</code> values; in
        previous Levels of SBML, this data type did not exist and attributes were
        simply described to as 'referring to a unit identifier', but the effective
        data type was the same as <code>UnitSIdRef</code> in Level&nbsp;3.  These and
        other methods of libSBML refer to the type <code>UnitSIdRef</code> for all
        Levels of SBML, even if the corresponding SBML specification did not
        explicitly name the data type.

        This method works by looking at all unit identifier attribute values
        (including, if appropriate, inside mathematical formulas), comparing the
        referenced unit identifiers to the value of @p oldid.  If any matches
        are found, the matching values are replaced with @p newid.  The method
        does @em not descend into child elements.

        @param oldid the old identifier
        @param newid the new identifier

        """
        return _libsbml.StoichiometryMath_renameUnitSIdRefs(self, *args)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace all nodes with the name 'id' from the child 'math' object with the provided function.

        @internal

        """
        return _libsbml.StoichiometryMath_replaceSIDWithFunction(self, *args)

StoichiometryMath_swigregister = _libsbml.StoichiometryMath_swigregister
StoichiometryMath_swigregister(StoichiometryMath)

class SBMLNamespaces(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Set of SBML Level + Version + namespace triples.

    @htmlinclude not-sbml-warning.html

    There are differences in the definitions of components between different
    SBML Levels, as well as Versions within Levels.  For example, the
    'sboTerm' attribute was not introduced until Level&nbsp;2
    Version&nbsp;2, and then only on certain component classes; the SBML
    Level&nbsp;2 Version&nbsp;3 specification moved the 'sboTerm' attribute
    to the SBase class, thereby allowing nearly all components to have SBO
    annotations.  As a result of differences such as those, libSBML needs to
    track the SBML Level and Version of every object created.

    The purpose of the SBMLNamespaces object class is to make it easier to
    communicate SBML Level and Version data between libSBML constructors and
    other methods.  The SBMLNamespaces object class tracks 3-tuples
    (triples) consisting of SBML Level, Version, and the corresponding SBML
    XML namespace.

    The plural name (SBMLNamespaces) is not a mistake, because in SBML
    Level&nbsp;3, objects may have extensions added by Level&nbsp;3 packages
    used by a given model and therefore may have multiple namespaces
    associated with them; however, until the introduction of SBML
    Level&nbsp;3, the SBMLNamespaces object only records one SBML
    Level/Version/namespace combination at a time.  Most constructors for
    SBML objects in libSBML take a SBMLNamespaces object as an argument,
    thereby allowing the constructor to produce the proper combination of
    attributes and other internal data structures for the given SBML Level
    and Version.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLNamespaces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLNamespaces, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBMLNamespaces
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int level = SBML_DEFAULT_LEVEL, unsigned int version = SBML_DEFAULT_VERSION) -> SBMLNamespaces
        __init__(self, unsigned int level = SBML_DEFAULT_LEVEL) -> SBMLNamespaces
        __init__(self) -> SBMLNamespaces
        __init__(self, unsigned int level, unsigned int version, string pkgName, 
            unsigned int pkgVersion, string pkgPrefix = "") -> SBMLNamespaces
        __init__(self, unsigned int level, unsigned int version, string pkgName, 
            unsigned int pkgVersion) -> SBMLNamespaces
        __init__(self, SBMLNamespaces orig) -> SBMLNamespaces

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLNamespaces(SBMLNamespaces orig)</pre>

        Copy constructor; creates a copy of a SBMLNamespaces.

        @param orig the SBMLNamespaces instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLNamespaces(long level = SBML_DEFAULT_LEVEL, long version = SBML_DEFAULT_VERSION)</pre>

        Creates a new SBMLNamespaces object corresponding to the given SBML
        @p level and @p version.

        @par
        SBMLNamespaces objects are used in libSBML to communicate SBML Level and
        Version data between constructors and other methods.  The SBMLNamespaces
        object class holds triples consisting of SBML Level, Version, and the
        corresponding SBML XML namespace.  Most constructors for SBML objects in
        libSBML take a SBMLNamespaces object as an argument, thereby allowing
        the constructor to produce the proper combination of attributes and
        other internal data structures for the given SBML Level and Version.

        The plural name (SBMLNamespaces) is not a mistake, because in SBML
        Level&nbsp;3, objects may have extensions added by Level&nbsp;3 packages
        used by a given model and therefore may have multiple namespaces
        associated with them.  In SBML Levels below Level&nbsp;3, the
        SBMLNamespaces object only records one SBML Level/Version/namespace
        combination at a time.  Most constructors for SBML objects in libSBML
        take a SBMLNamespaces object as an argument, thereby allowing the
        constructor to produce the proper combination of attributes and other
        internal data structures for the given SBML Level and Version. 

        @param level the SBML level
        @param version the SBML version

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLNamespaces(long level, long version, string &pkgName, long pkgVersion, string pkgPrefix = '')</pre>

        (For extensions) Creates a new SBMLNamespaces object corresponding to
        the combination of (1) the given SBML @p level and @p version, and (2)
        the given @p package with the @p package @p version.

        @par
        SBMLNamespaces objects are used in libSBML to communicate SBML Level and
        Version data between constructors and other methods.  The SBMLNamespaces
        object class holds triples consisting of SBML Level, Version, and the
        corresponding SBML XML namespace.  Most constructors for SBML objects in
        libSBML take a SBMLNamespaces object as an argument, thereby allowing
        the constructor to produce the proper combination of attributes and
        other internal data structures for the given SBML Level and Version.

        The plural name (SBMLNamespaces) is not a mistake, because in SBML
        Level&nbsp;3, objects may have extensions added by Level&nbsp;3 packages
        used by a given model and therefore may have multiple namespaces
        associated with them.  In SBML Levels below Level&nbsp;3, the
        SBMLNamespaces object only records one SBML Level/Version/namespace
        combination at a time.  Most constructors for SBML objects in libSBML
        take a SBMLNamespaces object as an argument, thereby allowing the
        constructor to produce the proper combination of attributes and other
        internal data structures for the given SBML Level and Version. 

        @param level   the SBML Level
        @param version the SBML Version
        @param pkgName the string of package name (e.g. 'layout', 'multi')
        @param pkgVersion the package version
        @param pkgPrefix the prefix of the package namespace (e.g. 'layout', 'multi') to be added.
        The package's name will be used if the given string is empty (default).

        @throws SBMLExtensionException if the extension module that supports the
        combination of the given SBML Level, SBML Version, package name, and
        package version has not been registered with libSBML.

        """
        this = _libsbml.new_SBMLNamespaces(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLNamespaces

        Creates and returns a deep copy of this SBMLNamespaces object.

        @return the (deep) copy of this SBMLNamespaces object.

        """
        return _libsbml.SBMLNamespaces_clone(self)

    def getSBMLNamespaceURI(*args):
        """
        getSBMLNamespaceURI(unsigned int level, unsigned int version) -> string

        Returns a string representing the SBML XML namespace for the 
        given @p level and @p version of SBML.

        @param level the SBML level
        @param version the SBML version

        @return a string representing the SBML namespace that reflects the
        SBML Level and Version specified.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBMLNamespaces_getSBMLNamespaceURI(*args)

    if _newclass:getSBMLNamespaceURI = staticmethod(getSBMLNamespaceURI)
    __swig_getmethods__["getSBMLNamespaceURI"] = lambda x: getSBMLNamespaceURI
    def getSupportedNamespaces():
        """
        getSupportedNamespaces() -> List

        Returns a list of all supported SBMLNamespaces in this version of 
        libsbml. 

        @return a list with supported SBML namespaces. 

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBMLNamespaces_getSupportedNamespaces()

    if _newclass:getSupportedNamespaces = staticmethod(getSupportedNamespaces)
    __swig_getmethods__["getSupportedNamespaces"] = lambda x: getSupportedNamespaces
    def freeSBMLNamespaces(*args):
        """
        freeSBMLNamespaces(List supportedNS)

        Frees the list of supported namespaces as generated by
        getSupportedNamespaces().

        @param supportedNS the list to be freed.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBMLNamespaces_freeSBMLNamespaces(*args)

    if _newclass:freeSBMLNamespaces = staticmethod(freeSBMLNamespaces)
    __swig_getmethods__["freeSBMLNamespaces"] = lambda x: freeSBMLNamespaces
    def getURI(self):
        """
        getURI(self) -> string

        Returns a string representing the SBML XML namespace of this
        object.

        @return a string representing the SBML namespace that reflects the
        SBML Level and Version of this object.

        """
        return _libsbml.SBMLNamespaces_getURI(self)

    def getLevel(self, *args):
        """
        getLevel(self) -> unsigned int
        getLevel(self) -> unsigned int

        Get the SBML Level of this SBMLNamespaces object.

        @return the SBML Level of this SBMLNamespaces object.

        """
        return _libsbml.SBMLNamespaces_getLevel(self, *args)

    def getVersion(self, *args):
        """
        getVersion(self) -> unsigned int
        getVersion(self) -> unsigned int

        Get the SBML Version of this SBMLNamespaces object.

        @return the SBML Version of this SBMLNamespaces object.

        """
        return _libsbml.SBMLNamespaces_getVersion(self, *args)

    def getNamespaces(self, *args):
        """
        getNamespaces(self) -> XMLNamespaces
        getNamespaces(self) -> XMLNamespaces

        Get the XML namespaces list for this SBMLNamespaces object.

        @par
        SBMLNamespaces objects are used in libSBML to communicate SBML Level and
        Version data between constructors and other methods.  The SBMLNamespaces
        object class holds triples consisting of SBML Level, Version, and the
        corresponding SBML XML namespace.  Most constructors for SBML objects in
        libSBML take a SBMLNamespaces object as an argument, thereby allowing
        the constructor to produce the proper combination of attributes and
        other internal data structures for the given SBML Level and Version.

        The plural name (SBMLNamespaces) is not a mistake, because in SBML
        Level&nbsp;3, objects may have extensions added by Level&nbsp;3 packages
        used by a given model and therefore may have multiple namespaces
        associated with them.  In SBML Levels below Level&nbsp;3, the
        SBMLNamespaces object only records one SBML Level/Version/namespace
        combination at a time.  Most constructors for SBML objects in libSBML
        take a SBMLNamespaces object as an argument, thereby allowing the
        constructor to produce the proper combination of attributes and other
        internal data structures for the given SBML Level and Version.

        @return the XML namespaces of this SBMLNamespaces object.

        """
        return _libsbml.SBMLNamespaces_getNamespaces(self, *args)

    def addNamespaces(self, *args):
        """
        addNamespaces(self, XMLNamespaces xmlns) -> int

        Add the given XML namespaces list to the set of namespaces within this
        SBMLNamespaces object.

        The following code gives an example of how one could add the XHTML
        namespace to the list of namespaces recorded by the top-level
        <code>&lt;sbml&gt;</code> element of a model.  It gives the new
        namespace a prefix of <code>html</code>.
        @if cpp
        @code{.cpp}
        SBMLDocumentsd;
        try
        {
            sd = new SBMLDocument(3, 1);
        }
        catch (SBMLConstructorException e)
        {
            // Here, have code to handle a truly exceptional situation. Candidate
            // causes include invalid combinations of SBML Level and Version
            // (impossible if hardwired as given here), running out of memory, and
            // unknown system exceptions.
        }

        SBMLNamespaces sn = sd->getNamespaces();
        if (sn != None)
        {
            sn->add('http://www.w3.org/1999/xhtml', 'html');
        }
        else
        {
            // Handle another truly exceptional situation.
        }
        @endcode
        @endif
        @if java
        @code{.java}
        SBMLDocument sd;
        try
        {
            sd = new SBMLDocument(3, 1);
        }
        catch (SBMLConstructorException e)
        {
            // Here, have code to handle a truly exceptional situation. Candidate
            // causes include invalid combinations of SBML Level and Version
            // (impossible if hardwired as given here), running out of memory, and
            // unknown system exceptions.
        }

        SBMLNamespaces sn = sd.getNamespaces();
        if (sn != null)
        {
            sn.add('http://www.w3.org/1999/xhtml', 'html');
        }
        else
        {
            // Handle another truly exceptional situation.
         }
        @endcode
        @endif
        @if python
        @code{.py}
        sbmlDoc = None
        try:
          sbmlDoc = SBMLDocument(3, 1)
        except ValueError:
          # Do something to handle exceptional situation.  Candidate
          # causes include invalid combinations of SBML Level and Version
          # (impossible if hardwired as given here), running out of memory, and
          # unknown system exceptions.

        namespaces = sbmlDoc.getNamespaces()
        if namespaces == None:
          # Do something to handle case of no namespaces.

        status = namespaces.add('http://www.w3.org/1999/xhtml', 'html')
        if status != LIBSBML_OPERATION_SUCCESS:
          # Do something to handle failure.
        @endcode
        @endif
        @if csharp
        @code{.cs}
        SBMLDocument sd = null;
        try
        {
            sd = new SBMLDocument(3, 1);
        }
        catch (SBMLConstructorException e)
        {
            // Here, have code to handle a truly exceptional situation.
            // Candidate causes include invalid combinations of SBML
            // Level and Version (impossible if hardwired as given here),
            // running out of memory, and unknown system exceptions.
        }

        XMLNamespaces sn = sd.getNamespaces();
        if (sn != null)
        {
            sn.add('http://www.w3.org/1999/xhtml', 'html');
        }
        else
        {
            // Handle another truly exceptional situation.
        }
        @endcode
        @endif@~

        @param xmlns the XML namespaces to be added.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.SBMLNamespaces_addNamespaces(self, *args)

    def addNamespace(self, *args):
        """
        addNamespace(self, string uri, string prefix) -> int

        Add an XML namespace (a pair of URI and prefix) to the set of namespaces
        within this SBMLNamespaces object.

        @param uri    the XML namespace to be added.
        @param prefix the prefix of the namespace to be added.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.SBMLNamespaces_addNamespace(self, *args)

    def removeNamespace(self, *args):
        """
        removeNamespace(self, string uri) -> int

        Removes an XML namespace from the set of namespaces within this 
        SBMLNamespaces object.

        @param uri    the XML namespace to be added.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        """
        return _libsbml.SBMLNamespaces_removeNamespace(self, *args)

    def addPackageNamespace(self, *args):
        """
        addPackageNamespace(self, string pkgName, unsigned int pkgVersion, string prefix = "") -> int
        addPackageNamespace(self, string pkgName, unsigned int pkgVersion) -> int

        Add an XML namespace (a pair of URI and prefix) of a package extension
        to the set of namespaces within this SBMLNamespaces object.

        The SBML Level and SBML Version of this object is used.

        @param pkgName the string of package name (e.g. 'layout', 'multi')
        @param pkgVersion the package version
        @param prefix the prefix of the package namespace to be added.
        The package's name will be used if the given string is empty (default).

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note An XML namespace of a non-registered package extension can't be
        added by this function (@link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink 
        will be returned).

        @see addNamespace()

        """
        return _libsbml.SBMLNamespaces_addPackageNamespace(self, *args)

    def addPackageNamespaces(self, *args):
        """
        addPackageNamespaces(self, XMLNamespaces xmlns) -> int

        Add the XML namespaces of package extensions in the given XMLNamespace
        object to the set of namespaces within this SBMLNamespaces object
        (Non-package XML namespaces are not added by this function).

        @param xmlns the XML namespaces to be added.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note XML namespaces of a non-registered package extensions are not
        added (just ignored) by this function. @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink will be returned if the given
        xmlns is null.

        """
        return _libsbml.SBMLNamespaces_addPackageNamespaces(self, *args)

    def removePackageNamespace(self, *args):
        """
        removePackageNamespace(self, unsigned int level, unsigned int version, string pkgName, 
            unsigned int pkgVersion) -> int

        Removes an XML namespace of a package extension from the set of namespaces 
        within this SBMLNamespaces object.

        @param level   the SBML level
        @param version the SBML version
        @param pkgName the string of package name (e.g. 'layout', 'multi')
        @param pkgVersion the package version

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        """
        return _libsbml.SBMLNamespaces_removePackageNamespace(self, *args)

    def addPkgNamespace(self, *args):
        """
        addPkgNamespace(self, string pkgName, unsigned int pkgVersion, string prefix = "") -> int
        addPkgNamespace(self, string pkgName, unsigned int pkgVersion) -> int

        @internal
        Add an XML namespace (a pair of URI and prefix) of a package extension
        to the set of namespaces within this SBMLNamespaces object.

        The SBML Level and SBML Version of this object is used.

        @param pkgName the string of package name (e.g. 'layout', 'multi')
        @param pkgVersion the package version
        @param prefix the prefix of the package namespace to be added.
        The package's name will be used if the given string is empty (default).

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note An XML namespace of a non-registered package extension can't be
        added by this function (@link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink 
        will be returned).

        @see addNamespace()

        @internal

        """
        return _libsbml.SBMLNamespaces_addPkgNamespace(self, *args)

    def addPkgNamespaces(self, *args):
        """
        addPkgNamespaces(self, XMLNamespaces xmlns) -> int

        @internal
        Add the XML namespaces of package extensions in the given XMLNamespace
        object to the set of namespaces within this SBMLNamespaces object.

        Non-package XML namespaces are not added by this function.

        @param xmlns the XML namespaces to be added.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note XML namespaces of a non-registered package extensions are not
        added (just ignored) by this function. @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink will be returned if the given
        xmlns is null.

        @internal

        """
        return _libsbml.SBMLNamespaces_addPkgNamespaces(self, *args)

    def removePkgNamespace(self, *args):
        """
        removePkgNamespace(self, unsigned int level, unsigned int version, string pkgName, 
            unsigned int pkgVersion) -> int

        @internal
        Removes an XML namespace of a package extension from the set of
        namespaces within this SBMLNamespaces object.

        @param level   the SBML level
        @param version the SBML version
        @param pkgName the string of package name (e.g. 'layout', 'multi')
        @param pkgVersion the package version

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        @internal

        """
        return _libsbml.SBMLNamespaces_removePkgNamespace(self, *args)

    def isSBMLNamespace(*args):
        """
        isSBMLNamespace(string uri) -> bool

        Predicate returning @c True if the given URL is one of SBML XML
        namespaces.

        @param uri the URI of namespace

        @return @c True if the 'uri' is one of SBML namespaces, @c False otherwise.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.SBMLNamespaces_isSBMLNamespace(*args)

    if _newclass:isSBMLNamespace = staticmethod(isSBMLNamespace)
    __swig_getmethods__["isSBMLNamespace"] = lambda x: isSBMLNamespace
    def isValidCombination(self):
        """
        isValidCombination(self) -> bool

        Predicate returning @c True if the given set of namespaces represent a
        valid set

        @return @c True if the set of namespaces is valid, @c False otherwise.

        """
        return _libsbml.SBMLNamespaces_isValidCombination(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        Returns the name of the main package for this namespace.

        @return the name of the main package for this namespace.
        'core' will be returned if this namespace is defined in the SBML 
        core.

        """
        return _libsbml.SBMLNamespaces_getPackageName(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLNamespaces_swigregister = _libsbml.SBMLNamespaces_swigregister
SBMLNamespaces_swigregister(SBMLNamespaces)

def SBMLNamespaces_getSBMLNamespaceURI(*args):
  """
    SBMLNamespaces_getSBMLNamespaceURI(unsigned int level, unsigned int version) -> string

    Returns a string representing the SBML XML namespace for the 
    given @p level and @p version of SBML.

    @param level the SBML level
    @param version the SBML version

    @return a string representing the SBML namespace that reflects the
    SBML Level and Version specified.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBMLNamespaces_getSBMLNamespaceURI(*args)

def SBMLNamespaces_getSupportedNamespaces():
  """
    SBMLNamespaces_getSupportedNamespaces() -> List

    Returns a list of all supported SBMLNamespaces in this version of 
    libsbml. 

    @return a list with supported SBML namespaces. 

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBMLNamespaces_getSupportedNamespaces()

def SBMLNamespaces_freeSBMLNamespaces(*args):
  """
    SBMLNamespaces_freeSBMLNamespaces(List supportedNS)

    Frees the list of supported namespaces as generated by
    getSupportedNamespaces().

    @param supportedNS the list to be freed.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBMLNamespaces_freeSBMLNamespaces(*args)

def SBMLNamespaces_isSBMLNamespace(*args):
  """
    SBMLNamespaces_isSBMLNamespace(string uri) -> bool

    Predicate returning @c True if the given URL is one of SBML XML
    namespaces.

    @param uri the URI of namespace

    @return @c True if the 'uri' is one of SBML namespaces, @c False otherwise.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.SBMLNamespaces_isSBMLNamespace(*args)

class SBMLTransforms(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Methods for transform elements of SBML

    @internal

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLTransforms, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLTransforms, name)
    __repr__ = _swig_repr
    def replaceFD(*args):
        """
        replaceFD(ASTNode math, FunctionDefinition fd, IdList idsToExclude = None)
        replaceFD(ASTNode math, FunctionDefinition fd)
        replaceFD(ASTNode math, ListOfFunctionDefinitions lofd, IdList idsToExclude = None)
        replaceFD(ASTNode math, ListOfFunctionDefinitions lofd)
        """
        return _libsbml.SBMLTransforms_replaceFD(*args)

    if _newclass:replaceFD = staticmethod(replaceFD)
    __swig_getmethods__["replaceFD"] = lambda x: replaceFD
    def expandInitialAssignments(*args):
        """
        expandInitialAssignments(Model m) -> bool

        @internal

        @internal

        """
        return _libsbml.SBMLTransforms_expandInitialAssignments(*args)

    if _newclass:expandInitialAssignments = staticmethod(expandInitialAssignments)
    __swig_getmethods__["expandInitialAssignments"] = lambda x: expandInitialAssignments
    def evaluateASTNode(*args):
        """
        evaluateASTNode(ASTNode node, Model m = None) -> double
        evaluateASTNode(ASTNode node) -> double

        @internal

        @internal

        """
        return _libsbml.SBMLTransforms_evaluateASTNode(*args)

    if _newclass:evaluateASTNode = staticmethod(evaluateASTNode)
    __swig_getmethods__["evaluateASTNode"] = lambda x: evaluateASTNode
    def mapComponentValues(*args):
        """mapComponentValues(Model m) -> IdList"""
        return _libsbml.SBMLTransforms_mapComponentValues(*args)

    if _newclass:mapComponentValues = staticmethod(mapComponentValues)
    __swig_getmethods__["mapComponentValues"] = lambda x: mapComponentValues
    def clearComponentValues():
        """clearComponentValues()"""
        return _libsbml.SBMLTransforms_clearComponentValues()

    if _newclass:clearComponentValues = staticmethod(clearComponentValues)
    __swig_getmethods__["clearComponentValues"] = lambda x: clearComponentValues
    def __init__(self): 
        """__init__(self) -> SBMLTransforms"""
        this = _libsbml.new_SBMLTransforms()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLTransforms
    __del__ = lambda self : None;
SBMLTransforms_swigregister = _libsbml.SBMLTransforms_swigregister
SBMLTransforms_swigregister(SBMLTransforms)

def SBMLTransforms_replaceFD(*args):
  """
    replaceFD(ASTNode math, FunctionDefinition fd, IdList idsToExclude = None)
    replaceFD(ASTNode math, FunctionDefinition fd)
    replaceFD(ASTNode math, ListOfFunctionDefinitions lofd, IdList idsToExclude = None)
    SBMLTransforms_replaceFD(ASTNode math, ListOfFunctionDefinitions lofd)
    """
  return _libsbml.SBMLTransforms_replaceFD(*args)

def SBMLTransforms_expandInitialAssignments(*args):
  """
    SBMLTransforms_expandInitialAssignments(Model m) -> bool

    @internal

    @internal

    """
  return _libsbml.SBMLTransforms_expandInitialAssignments(*args)

def SBMLTransforms_evaluateASTNode(*args):
  """
    evaluateASTNode(ASTNode node, Model m = None) -> double
    SBMLTransforms_evaluateASTNode(ASTNode node) -> double

    @internal

    @internal

    """
  return _libsbml.SBMLTransforms_evaluateASTNode(*args)

def SBMLTransforms_mapComponentValues(*args):
  """SBMLTransforms_mapComponentValues(Model m) -> IdList"""
  return _libsbml.SBMLTransforms_mapComponentValues(*args)

def SBMLTransforms_clearComponentValues():
  """SBMLTransforms_clearComponentValues()"""
  return _libsbml.SBMLTransforms_clearComponentValues()

CNV_TYPE_BOOL = _libsbml.CNV_TYPE_BOOL
CNV_TYPE_DOUBLE = _libsbml.CNV_TYPE_DOUBLE
CNV_TYPE_INT = _libsbml.CNV_TYPE_INT
CNV_TYPE_SINGLE = _libsbml.CNV_TYPE_SINGLE
CNV_TYPE_STRING = _libsbml.CNV_TYPE_STRING
class ConversionOption(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A single configuration setting for an SBML converter.

    @htmlinclude libsbml-facility-only-warning.html

    LibSBML provides a number of converters that can perform transformations
    on SBML documents.  These converters allow their behaviors to be
    controlled by setting property values.  Converter properties are
    communicated using objects of class ConversionProperties, and within
    such objects, individual options are encapsulated using ConversionOption
    objects.

    A ConversionOption @if conly structure @else object@endif@~ consists of
    four parts:
    @li A @em key, acting as the name of the option.
    @li A @em value of this option.
    @li A @em type for the value; the type code is chosen from @if clike
    an enumeration @else a set of integer constants@endif@~ whose names all
    begin with the prefix <code>CNV_TYPE_</code>.  (See the separate <a
    class='el' href='#ConversionOptionType_t'>subsection</a> below for more
    information.)
    @li A @em description consisting of a text string that describes the
    option in some way.

    There are no constraints on the values of keys or descriptions;
    authors of SBML converters are free to choose them as they see fit.

    @section ConversionOptionType_t Conversion option data types

    An option in ConversionOption must have a data type declared, to
    indicate whether it is a string value, an integer, and so forth.  The
    possible types of values are taken from
    @if clike the enumeration ConversionOptionType_t @else a set of
    constants whose symbol names begin with the prefix
    <code>CNV_TYPE_</code>@endif. The following are the possible values:

    <p>
    <center>
    <table width='90%' cellspacing='1' cellpadding='1' border='0' class='normal-font'>
    <tr style='background: lightgray' class='normal-font'>
    <td><strong>Enumerator</strong></td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr>
    <td><code>@link libsbml#CNV_TYPE_BOOL CNV_TYPE_BOOL@endlink</code></td>
    <td>Indicates the value type is a Boolean.</td>
    </tr>
    <tr>
    <td><code>@link libsbml#CNV_TYPE_DOUBLE CNV_TYPE_DOUBLE@endlink</code></td>
    <td>Indicates the value type is a double-sized float.</td>
    </tr>
    <tr>
    <td><code>@link libsbml#CNV_TYPE_INT CNV_TYPE_INT@endlink</code></td>
    <td>Indicates the value type is an integer.</td>
    </tr>
    <tr>
    <td><code>@link libsbml#CNV_TYPE_SINGLE CNV_TYPE_SINGLE@endlink</code></td>
    <td>Indicates the value type is a float.</td>
    </tr>
    <tr>
    <td><code>@link libsbml#CNV_TYPE_STRING CNV_TYPE_STRING@endlink</code></td>
    <td>Indicates the value type is a string.</td>
    </tr>
    </table>
    </center>

    @see ConversionProperties

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversionOption, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConversionOption, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string key, string value = "", ConversionOptionType_t type = CNV_TYPE_STRING, 
            string description = "") -> ConversionOption
        __init__(self, string key, string value = "", ConversionOptionType_t type = CNV_TYPE_STRING) -> ConversionOption
        __init__(self, string key, string value = "") -> ConversionOption
        __init__(self, string key) -> ConversionOption
        __init__(self, string key, char value, string description = "") -> ConversionOption
        __init__(self, string key, char value) -> ConversionOption
        __init__(self, string key, bool value, string description = "") -> ConversionOption
        __init__(self, string key, bool value) -> ConversionOption
        __init__(self, string key, double value, string description = "") -> ConversionOption
        __init__(self, string key, double value) -> ConversionOption
        __init__(self, string key, float value, string description = "") -> ConversionOption
        __init__(self, string key, float value) -> ConversionOption
        __init__(self, string key, int value, string description = "") -> ConversionOption
        __init__(self, string key, int value) -> ConversionOption
        __init__(self, ConversionOption orig) -> ConversionOption

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(string key, double value, string description='')</pre>

        Creates a new ConversionOption specialized for double-type options.

        @param key the key for this option
        @param value the value for this option
        @param description an optional description

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(string key, int value, string description='')</pre>

        Creates a new ConversionOption specialized for integer-type options.

        @param key the key for this option
        @param value the value for this option
        @param description an optional description

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(string key, float value, string description='')</pre>

        Creates a new ConversionOption specialized for float-type options.

        @param key the key for this option
        @param value the value for this option
        @param description an optional description

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(string key, string value='', ConversionOptionType_t type=CNV_TYPE_STRING, string description='')</pre>

        Creates a new ConversionOption.

        This is the general constructor, taking arguments for all aspects of
        an option.  Other constructors exist with different arguments.

        @par
        The conversion @p type argument value must be one of
        @if clike the values defined in the enumeration
        ConversionOptionType_t.@endif@if java the constants whose names begin
        with the characters <code>CNV_TYPE_</code> in the interface class
        {@link libsbmlConstants}.@endif@if python the constants whose names begin
        with the characters <code>CNV_TYPE_</code> in the interface class
        @link libsbml libsbml@endlink.@endif

        @param key the key for this option
        @param value an optional value for this option
        @param type the type of this option
        @param description the description for this option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(ConversionOption orig)</pre>

        Copy constructor; creates a copy of an ConversionOption object.

        @param orig the ConversionOption object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(string key, bool value, string description='')</pre>

        Creates a new ConversionOption specialized for Boolean-type options.

        @param key the key for this option
        @param value the value for this option
        @param description an optional description

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionOption(string key, string value, string description='')</pre>

        Creates a new ConversionOption specialized for string-type options.

        @param key the key for this option
        @param value the value for this option
        @param description an optional description

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_ConversionOption(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ConversionOption
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> ConversionOption

        Creates and returns a deep copy of this ConversionOption object.

        @return the (deep) copy of this ConversionOption object.

        """
        return _libsbml.ConversionOption_clone(self)

    def getKey(self):
        """
        getKey(self) -> string

        Returns the key for this option.

        @return the key, as a string.

        """
        return _libsbml.ConversionOption_getKey(self)

    def setKey(self, *args):
        """
        setKey(self, string key)

        Sets the key for this option.

        @param key a string representing the key to set.

        """
        return _libsbml.ConversionOption_setKey(self, *args)

    def getValue(self):
        """
        getValue(self) -> string

        Returns the value of this option.

        @return the value of this option, as a string.

        """
        return _libsbml.ConversionOption_getValue(self)

    def setValue(self, *args):
        """
        setValue(self, string value)

        Sets the value for this option.

        @param value the value to set, as a string.

        """
        return _libsbml.ConversionOption_setValue(self, *args)

    def getDescription(self):
        """
        getDescription(self) -> string

        Returns the description string for this option.

        @return the description of this option.

        """
        return _libsbml.ConversionOption_getDescription(self)

    def setDescription(self, *args):
        """
        setDescription(self, string description)

        Sets the description text for this option.

        @param description the description to set for this option.

        """
        return _libsbml.ConversionOption_setDescription(self, *args)

    def getType(self):
        """
        getType(self) -> ConversionOptionType_t

        Returns the type of this option

        @return the type of this option.

        """
        return _libsbml.ConversionOption_getType(self)

    def setType(self, *args):
        """
        setType(self, ConversionOptionType_t type)

        Sets the type of this option.

        @par
        The conversion @p type argument value must be one of
        @if clike the values defined in the enumeration
        ConversionOptionType_t.@endif@if java the constants whose names begin
        with the characters <code>CNV_TYPE_</code> in the interface class
        {@link libsbmlConstants}.@endif@if python the constants whose names begin
        with the characters <code>CNV_TYPE_</code> in the interface class
        @link libsbml libsbml@endlink.@endif

        @param type the type value to use.

        """
        return _libsbml.ConversionOption_setType(self, *args)

    def getBoolValue(self):
        """
        getBoolValue(self) -> bool

        Returns the value of this option as a Boolean.

        @return the value of this option.

        """
        return _libsbml.ConversionOption_getBoolValue(self)

    def setBoolValue(self, *args):
        """
        setBoolValue(self, bool value)

        Set the value of this option to a given Boolean value.

        Invoking this method will also set the type of the option to
        @link libsbml#CNV_TYPE_BOOL CNV_TYPE_BOOL@endlink.

        @param value the Boolean value to set

        """
        return _libsbml.ConversionOption_setBoolValue(self, *args)

    def getDoubleValue(self):
        """
        getDoubleValue(self) -> double

        Returns the value of this option as a @c float.

        @return the value of this option.

        """
        return _libsbml.ConversionOption_getDoubleValue(self)

    def setDoubleValue(self, *args):
        """
        setDoubleValue(self, double value)

        Set the value of this option to a given @c float value.

        Invoking this method will also set the type of the option to
        @link libsbml#CNV_TYPE_DOUBLE CNV_TYPE_DOUBLE@endlink.

        @param value the value to set

        """
        return _libsbml.ConversionOption_setDoubleValue(self, *args)

    def getFloatValue(self):
        """
        getFloatValue(self) -> float

        Returns the value of this option as a @c float.

        @return the value of this option as a float

        """
        return _libsbml.ConversionOption_getFloatValue(self)

    def setFloatValue(self, *args):
        """
        setFloatValue(self, float value)

        Set the value of this option to a given @c float value.

        Invoking this method will also set the type of the option to
        @link libsbml#CNV_TYPE_SINGLE CNV_TYPE_SINGLE@endlink.

        @param value the value to set

        """
        return _libsbml.ConversionOption_setFloatValue(self, *args)

    def getIntValue(self):
        """
        getIntValue(self) -> int

        Returns the value of this option as an @c integer.

        @return the value of this option, as an int

        """
        return _libsbml.ConversionOption_getIntValue(self)

    def setIntValue(self, *args):
        """
        setIntValue(self, int value)

        Set the value of this option to a given @c int value.

        Invoking this method will also set the type of the option to
        @link libsbml#CNV_TYPE_INT CNV_TYPE_INT@endlink.

        @param value the value to set

        """
        return _libsbml.ConversionOption_setIntValue(self, *args)

ConversionOption_swigregister = _libsbml.ConversionOption_swigregister
ConversionOption_swigregister(ConversionOption)

class ConversionProperties(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Set of configuration option values for a converter.

    @htmlinclude libsbml-facility-only-warning.html

    LibSBML provides a number of converters that can perform transformations
    on SBML documents. The properties of SBML converters are communicated
    using objects of class ConversionProperties, and within such objects,
    individual options are encapsulated using ConversionOption objects.  The
    ConversionProperties class provides numerous methods for setting and
    getting options.

    ConversionProperties objects are also used to determine the target SBML
    namespace when an SBML converter's behavior depends on the intended
    Level+Version combination of SBML.  In addition, it is conceivable that
    conversions may be affected by SBML Level&nbsp;3 packages being used by an
    SBML document; consequently, the packages in use are also communicated by
    the values of the SBML namespaces set on a ConversionProperties object.

    @see ConversionOption
    @see SBMLNamespaces

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversionProperties, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConversionProperties, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SBMLNamespaces targetNS = None) -> ConversionProperties
        __init__(self) -> ConversionProperties
        __init__(self, ConversionProperties orig) -> ConversionProperties

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionProperties(ConversionProperties orig)</pre>

        Copy constructor.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ConversionProperties(SBMLNamespaces targetNS=None)</pre>

        Constructor that initializes the conversion properties
        with a specific SBML target namespace.

        @param targetNS the target namespace to convert to

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_ConversionProperties(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ConversionProperties

        Creates and returns a deep copy of this ConversionProperties object.

        @return the (deep) copy of this ConversionProperties object.

        """
        return _libsbml.ConversionProperties_clone(self)

    __swig_destroy__ = _libsbml.delete_ConversionProperties
    __del__ = lambda self : None;
    def getTargetNamespaces(self):
        """
        getTargetNamespaces(self) -> SBMLNamespaces

        Returns the current target SBML namespace.

        @return the SBMLNamepaces object expressing the target namespace.

        """
        return _libsbml.ConversionProperties_getTargetNamespaces(self)

    def hasTargetNamespaces(self):
        """
        hasTargetNamespaces(self) -> bool

        Returns @c True if the target SBML namespace has been set.

        @return @c True if the target namespace has been set, @c False
        otherwise.

        """
        return _libsbml.ConversionProperties_hasTargetNamespaces(self)

    def setTargetNamespaces(self, *args):
        """
        setTargetNamespaces(self, SBMLNamespaces targetNS)

        Sets the target namespace.

        @param targetNS the target namespace to use.

        """
        return _libsbml.ConversionProperties_setTargetNamespaces(self, *args)

    def getDescription(self, *args):
        """
        getDescription(self, string key) -> string

        Returns the description string for a given option in this properties
        object.

        @param key the key for the option.

        @return the description text of the option with the given key.

        """
        return _libsbml.ConversionProperties_getDescription(self, *args)

    def getType(self, *args):
        """
        getType(self, string key) -> ConversionOptionType_t

        Returns the type of a given option in this properties object.

        @param key the key for the option.

        @return the type of the option with the given key.

        """
        return _libsbml.ConversionProperties_getType(self, *args)

    def getOption(self, *args):
        """
        getOption(self, string key) -> ConversionOption
        getOption(self, int index) -> ConversionOption

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getOption(int index)</pre>

        Returns the ConversionOption object for the given index.

        @param index the index for the option.

        @return the option with the given index.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getOption(string key)</pre>

        Returns the ConversionOption object for a given key.

        @param key the key for the option.

        @return the option with the given key.

        """
        return _libsbml.ConversionProperties_getOption(self, *args)

    def addOption(self, *args):
        """
        addOption(self, ConversionOption option)
        addOption(self, string key, string value = "", ConversionOptionType_t type = CNV_TYPE_STRING, 
            string description = "")
        addOption(self, string key, string value = "", ConversionOptionType_t type = CNV_TYPE_STRING)
        addOption(self, string key, string value = "")
        addOption(self, string key)
        addOption(self, string key, char value, string description = "")
        addOption(self, string key, char value)
        addOption(self, string key, bool value, string description = "")
        addOption(self, string key, bool value)
        addOption(self, string key, double value, string description = "")
        addOption(self, string key, double value)
        addOption(self, string key, float value, string description = "")
        addOption(self, string key, float value)
        addOption(self, string key, int value, string description = "")
        addOption(self, string key, int value)

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(string key, double value, string description='')</pre>

        Adds a new ConversionOption object with the given parameters.

        @param key the key for the new option
        @param value the double value of that option
        @param description (optional) the description for the option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(ConversionOption option)</pre>

        Adds a copy of the given option to this properties object.

        @param option the option to add
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(string key, int value, string description='')</pre>

        Adds a new ConversionOption object with the given parameters.

        @param key the key for the new option
        @param value the integer value of that option
        @param description (optional) the description for the option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(string key, float value, string description='')</pre>

        Adds a new ConversionOption object with the given parameters.

        @param key the key for the new option
        @param value the float value of that option
        @param description (optional) the description for the option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(string key, string value='', ConversionOptionType_t type=CNV_TYPE_STRING, string description='')</pre>

        Adds a new ConversionOption object with the given parameters.

        @param key the key for the new option
        @param value (optional) the value of that option
        @param type (optional) the type of the option (see the documentation
        for ConversionOption for more information about the types)
        @param description (optional) the description for the option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(string key, bool value, string description='')</pre>

        Adds a new ConversionOption object with the given parameters.

        @param key the key for the new option
        @param value the boolean value of that option
        @param description (optional) the description for the option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addOption(string key, string value, string description='')</pre>

        Adds a new ConversionOption object with the given parameters.

        @param key the key for the new option
        @param value the string value of that option
        @param description (optional) the description for the option

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.ConversionProperties_addOption(self, *args)

    def removeOption(self, *args):
        """
        removeOption(self, string key) -> ConversionOption

        Removes the option with the given key from this properties object.

        @param key the key for the new option to remove
        @return the removed option

        """
        return _libsbml.ConversionProperties_removeOption(self, *args)

    def hasOption(self, *args):
        """
        hasOption(self, string key) -> bool

        Returns @c True if this properties object contains an option with
        the given key.

        @param key the key of the option to find.

        @return @c True if an option with the given @p key exists in
        this properties object, @c False otherwise.

        """
        return _libsbml.ConversionProperties_hasOption(self, *args)

    def getValue(self, *args):
        """
        getValue(self, string key) -> string

        Returns the value of the given option as a string.

        @param key the key for the option.

        @return the string value of the option with the given key.

        """
        return _libsbml.ConversionProperties_getValue(self, *args)

    def setValue(self, *args):
        """
        setValue(self, string key, string value)

        Sets the value of the given option to a string.

        @param key the key for the option
        @param value the new value

        """
        return _libsbml.ConversionProperties_setValue(self, *args)

    def getBoolValue(self, *args):
        """
        getBoolValue(self, string key) -> bool

        Returns the value of the given option as a Boolean.

        @param key the key for the option.

        @return the boolean value of the option with the given key.

        """
        return _libsbml.ConversionProperties_getBoolValue(self, *args)

    def setBoolValue(self, *args):
        """
        setBoolValue(self, string key, bool value)

        Sets the value of the given option to a Boolean.

        @param key the key for the option.

        @param value the new Boolean value.

        """
        return _libsbml.ConversionProperties_setBoolValue(self, *args)

    def getDoubleValue(self, *args):
        """
        getDoubleValue(self, string key) -> double

        Returns the value of the given option as a @c float.

        @param key the key for the option.

        @return the double value of the option with the given key.

        """
        return _libsbml.ConversionProperties_getDoubleValue(self, *args)

    def setDoubleValue(self, *args):
        """
        setDoubleValue(self, string key, double value)

        Sets the value of the given option to a @c float.

        @param key the key for the option.

        @param value the new double value.

        """
        return _libsbml.ConversionProperties_setDoubleValue(self, *args)

    def getFloatValue(self, *args):
        """
        getFloatValue(self, string key) -> float

        Returns the value of the given option as a @c float.

        @param key the key for the option.

        @return the float value of the option with the given key.

        """
        return _libsbml.ConversionProperties_getFloatValue(self, *args)

    def setFloatValue(self, *args):
        """
        setFloatValue(self, string key, float value)

        Sets the value of the given option to a @c float.

        @param key the key for the option.

        @param value the new float value.

        """
        return _libsbml.ConversionProperties_setFloatValue(self, *args)

    def getIntValue(self, *args):
        """
        getIntValue(self, string key) -> int

        Returns the value of the given option as an integer.

        @param key the key for the option.

        @return the int value of the option with the given key.

        """
        return _libsbml.ConversionProperties_getIntValue(self, *args)

    def setIntValue(self, *args):
        """
        setIntValue(self, string key, int value)

        Sets the value of the given option to an integer.

        @param key the key for the option.

        @param value the new integer value.

        """
        return _libsbml.ConversionProperties_setIntValue(self, *args)

    def getNumOptions(self):
        """
        getNumOptions(self) -> int

        Returns the number of options in this Conversion Properties object

        @return the number of options in this properties object

        """
        return _libsbml.ConversionProperties_getNumOptions(self)

ConversionProperties_swigregister = _libsbml.ConversionProperties_swigregister
ConversionProperties_swigregister(ConversionProperties)

class SBMLConverter(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base class for SBML converters.

    @htmlinclude libsbml-facility-only-warning.html

    The SBMLConverter class is the base class for the various SBML @em
    converters: classes of objects that transform or convert SBML documents.
    These transformations can involve essentially anything that can be written
    algorithmically; examples include converting the units of measurement in a
    model, or converting from one Level+Version combination of SBML to
    another.  Applications can also create their own converters by subclassing
    SBMLConverter and following the examples of the existing converters.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLConverter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLConverter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLConverter
        __init__(self, string name) -> SBMLConverter
        __init__(self, SBMLConverter c) -> SBMLConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLConverter()</pre>

        Creates a new SBMLConverter object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLConverter(string name)</pre>

        Creates a new SBMLConverter object with a given name.

        @param name the name for the converter to create
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLConverter(SBMLConverter c)</pre>

        Copy constructor; creates a copy of an SBMLConverter object.

        @param c the SBMLConverter object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        if self.__class__ == SBMLConverter:
            _self = None
        else:
            _self = self
        this = _libsbml.new_SBMLConverter(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLConverter
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLConverter

        Creates and returns a deep copy of this SBMLConverter object.

        @return the (deep) copy of this SBMLConverter object.

        """
        return _libsbml.SBMLConverter_clone(self)

    def getDocument(self, *args):
        """
        getDocument(self) -> SBMLDocument
        getDocument(self) -> SBMLDocument

        Returns the SBML document that is the subject of the conversions.

        @return the current SBMLDocument object.

        """
        return _libsbml.SBMLConverter_getDocument(self, *args)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.  The run-time properties of the converter object can
        be adjusted by using the method
        SBMLConverter.setProperties().

        @return the default properties for the converter.

        @see setProperties()
        @see matchesProperties()

        """
        return _libsbml.SBMLConverter_getDefaultProperties(self)

    def getTargetNamespaces(self):
        """
        getTargetNamespaces(self) -> SBMLNamespaces

        Returns the target SBML namespaces of the currently set properties.

        SBML namespaces are used by libSBML to express the Level+Version of
        the SBML document (and, possibly, any SBML Level&nbsp;3 packages in
        use). Some converters' behavior is affected by the SBML namespace
        configured in the converter.  For example, the actions of
        SBMLLevelVersionConverter, the converter for converting SBML documents
        from one Level+Version combination to another, are fundamentally
        dependent on the SBML namespaces being targeted.

        @return the SBMLNamespaces object that describes the SBML namespaces
        in effect.

        """
        return _libsbml.SBMLConverter_getTargetNamespaces(self)

    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Predicate returning @c True if this converter's properties matches a
        given set of configuration properties.

        @param props the configuration properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLConverter_matchesProperties(self, *args)

    def setDocument(self, *args):
        """
        setDocument(self, SBMLDocument doc) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setDocument(SBMLDocument doc)</pre>

        Sets the current SBML document to the given SBMLDocument object.

        @param doc the document to use for this conversion.

        @return integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned ultimately depends on the specific subclass of
        SBMLConverter being used, but the default method can return the
        following values:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @warning Even though the argument @p doc is 'const', it is immediately
        cast to a non-const version, which is then usually changed by the
        converter upon a successful conversion.  This variant of the
        setDocument() method is here solely to preserve backwards compatibility.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setDocument(SBMLDocument doc)</pre>

        Sets the current SBML document to the given SBMLDocument object.

        @param doc the document to use for this conversion.

        @return integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned ultimately depends on the specific subclass of
        SBMLConverter being used, but the default method can return the
        following values:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.SBMLConverter_setDocument(self, *args)

    def setProperties(self, *args):
        """
        setProperties(self, ConversionProperties props) -> int

        Sets the configuration properties to be used by this converter.

        @param props the ConversionProperties object defining the properties
        to set.

        @return integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned ultimately depends on the specific subclass of
        SBMLConverter being used, but the default method can return the
        following values:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getProperties()
        @see matchesProperties()

        """
        return _libsbml.SBMLConverter_setProperties(self, *args)

    def getProperties(self):
        """
        getProperties(self) -> ConversionProperties

        Returns the current properties in effect for this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the current properties for this converter; in other words, the
        settings in effect at this moment.  To change the property values, you
        can use SBMLConverter.setProperties().

        @return the currently set configuration properties.

        @see setProperties()
        @see matchesProperties()

        """
        return _libsbml.SBMLConverter_getProperties(self)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned depends on the converter subclass; please consult
        the documentation for the relevant class to find out what the
        possibilities are.

        """
        return _libsbml.SBMLConverter_convert(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the name of this converter. 

        @return a name for this converter

        """
        return _libsbml.SBMLConverter_getName(self)

    def __disown__(self):
        self.this.disown()
        _libsbml.disown_SBMLConverter(self)
        return weakref_proxy(self)
SBMLConverter_swigregister = _libsbml.SBMLConverter_swigregister
SBMLConverter_swigregister(SBMLConverter)

class SBMLConverterRegistry(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Registry of all libSBML SBML converters.

    @htmlinclude libsbml-facility-only-warning.html

    LibSBML provides facilities for transforming and converting SBML
    documents in various ways.  These transformations can involve
    essentially anything that can be written algorithmically; examples
    include converting the units of measurement in a model, or converting
    from one Level+Version combination of SBML to another.  Converters are
    implemented as objects derived from the class SBMLConverter.

    The converter registry, implemented as a singleton object of class
    SBMLConverterRegistry, maintains a list of known converters and provides
    methods for discovering them.  Callers can use the method
    SBMLConverterRegistry.getNumConverters() to find out how many
    converters are registered, then use
    SBMLConverterRegistry.getConverterByIndex() to
    iterate over each one; alternatively, callers can use
    SBMLConverterRegistry.getConverterFor()
    to search for a converter having specific properties.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLConverterRegistry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLConverterRegistry, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def getInstance():
        """
        getInstance() -> SBMLConverterRegistry

        Returns the singleton instance for the converter registry.

        Prior to using the registry, callers have to obtain a copy of the
        registry.  This static method provides the means for doing that.

        @return the singleton for the converter registry.

        """
        return _libsbml.SBMLConverterRegistry_getInstance()

    if _newclass:getInstance = staticmethod(getInstance)
    __swig_getmethods__["getInstance"] = lambda x: getInstance
    def addConverter(self, *args):
        """
        addConverter(self, SBMLConverter converter) -> int

        Adds the given converter to the registry of SBML converters.

        @param converter the converter to add to the registry.

        @return integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.SBMLConverterRegistry_addConverter(self, *args)

    def getConverterByIndex(self, *args):
        """
        getConverterByIndex(self, int index) -> SBMLConverter

        Returns the converter with the given index number.

        Converters are given arbitrary index numbers by the registry.  Callers
        can use the method SBMLConverterRegistry.getNumConverters() to find
        out how many converters are registered, then use this method to
        iterate over the list and obtain each one in turn.

        @param index the zero-based index of the converter to fetch.

        @return the converter with the given index number, or @c None if the
        number is less than @c 0 or there is no converter at the given index
        position.

        """
        return _libsbml.SBMLConverterRegistry_getConverterByIndex(self, *args)

    def getConverterFor(self, *args):
        """
        getConverterFor(self, ConversionProperties props) -> SBMLConverter

        Returns the converter that best matches the given configuration
        properties.

        Many converters provide the ability to configure their behavior.  This
        is realized through the use of @em properties that offer different @em
        options.  The present method allows callers to search for converters
        that have specific property values.  Callers can do this by creating a
        ConversionProperties object, adding the desired option(s) to the
        object, then passing the object to this method.

        @param props a ConversionProperties object defining the properties
        to match against.

        @return the converter matching the properties, or @c None if no
        suitable converter is found.

        @see getConverterByIndex()

        """
        return _libsbml.SBMLConverterRegistry_getConverterFor(self, *args)

    def getNumConverters(self):
        """
        getNumConverters(self) -> int

        Returns the number of converters known by the registry.

        @return the number of registered converters.

        @see getConverterByIndex()

        """
        return _libsbml.SBMLConverterRegistry_getNumConverters(self)

    __swig_destroy__ = _libsbml.delete_SBMLConverterRegistry
    __del__ = lambda self : None;
SBMLConverterRegistry_swigregister = _libsbml.SBMLConverterRegistry_swigregister
SBMLConverterRegistry_swigregister(SBMLConverterRegistry)

def SBMLConverterRegistry_getInstance():
  """
    SBMLConverterRegistry_getInstance() -> SBMLConverterRegistry

    Returns the singleton instance for the converter registry.

    Prior to using the registry, callers have to obtain a copy of the
    registry.  This static method provides the means for doing that.

    @return the singleton for the converter registry.

    """
  return _libsbml.SBMLConverterRegistry_getInstance()

class SBMLFunctionDefinitionConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter to expand user-defined functions in-line.

    @htmlinclude libsbml-facility-only-warning.html

    This converter manipulates user-defined functions in an SBML file.  When
    invoked on a model, it performs the following operations:

    @li Reads the list of user-defined functions in the model (i.e., the list
    of FunctionDefinition objects);
    @li Looks for invocations of the function in mathematical expressions
    throughout the model; and
    @li For each invocation found, replaces the invocation with a in-line copy
    of the function's body, similar to how macro expansions might be performed
    in scripting and programming languages.

    For example, suppose the model contains a function definition
    representing the function <code>f(x, y) = x * y</code>.  Further
    suppose this functions invoked somewhere else in the model, in
    a mathematical formula, as <code>f(s, p)</code>.  The outcome of running
    SBMLFunctionDefinitionConverter on the model will be to replace
    the call to <code>f</code> with the expression <code>s * p</code>.

    @section usage Configuration and use of SBMLFunctionDefinitionConverter

    SBMLFunctionDefinitionConverter is enabled by creating a
    ConversionProperties object with the option @c
    'expandFunctionDefinitions', and passing this properties object to
    SBMLDocument.convert().
    The converter accepts one option:

    @li @c 'skipIds': if set, it should be a string containing a
    comma-separated list of identifiers (SBML 'id' values) that are to be
    skipped during function conversion.  Functions whose identifiers are
    found in this list will not be converted.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLFunctionDefinitionConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLFunctionDefinitionConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLFunctionDefinitionConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLFunctionDefinitionConverter
        __init__(self, SBMLFunctionDefinitionConverter obj) -> SBMLFunctionDefinitionConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLFunctionDefinitionConverter()</pre>

        Creates a new SBMLFunctionDefinitionConverter object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLFunctionDefinitionConverter(SBMLFunctionDefinitionConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLFunctionDefinitionConverter
        object.

        @param obj the SBMLFunctionDefinitionConverter object to copy.

        """
        this = _libsbml.new_SBMLFunctionDefinitionConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLFunctionDefinitionConverter

        Creates and returns a deep copy of this SBMLFunctionDefinitionConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLFunctionDefinitionConverter_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLFunctionDefinitionConverter
    __del__ = lambda self : None;
    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLFunctionDefinitionConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLFunctionDefinitionConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_CONV_INVALID_SRC_DOCUMENT LIBSBML_CONV_INVALID_SRC_DOCUMENT@endlink

        """
        return _libsbml.SBMLFunctionDefinitionConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLFunctionDefinitionConverter_getDefaultProperties(self)

SBMLFunctionDefinitionConverter_swigregister = _libsbml.SBMLFunctionDefinitionConverter_swigregister
SBMLFunctionDefinitionConverter_swigregister(SBMLFunctionDefinitionConverter)

def SBMLFunctionDefinitionConverter_init():
  """SBMLFunctionDefinitionConverter_init()"""
  return _libsbml.SBMLFunctionDefinitionConverter_init()

class SBMLIdConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter for replacing object identifiers.

    @htmlinclude libsbml-facility-only-warning.html

    This converter translates all instances of a given identifier (i.e., SBML object 'id'
    attribute value) of type 'SId' in a Model to another identifier.  It does this based on a list of source
    identifiers, translating each one to its corresponding replacement value
    in a list of replacement identifiers.  It also updates all references to
    the identifiers so replaced.  (More technically, it replaces all values
    known as type @c SIdRef in the SBML Level&nbsp;3 specifications.)

    This converter only searches the global SId namespace for the Model child of the 
    SBMLDocument.  It does not replace any IDs or SIdRefs for LocalParameters, nor
    does it replace any UnitSIds or UnitSIdRefs.  It likewise does not replace any IDs
    in a new namespace introduced by a package, such as the PortSId namespace
    from the Hierarchical %Model Composition package, nor any Model objects that are
    not the direct child of the SBMLDocument, such as the ModelDefinitions from 
    the Hierarchical %Model Composition package.

    If, however, a package introduces a new element with an 'id' attribute
    of type SId, any attribute of type SIdRef, or child of type SIdRef (such as 
    a new Math child of a package element), those IDs will be replaced if they
    match a source identifier.

    @section SBMLIdConverter-usage Configuration and use of SBMLIdConverter

    SBMLIdConverter is enabled by creating a ConversionProperties object with
    the option @c 'renameSIds', and passing this properties object to
    SBMLDocument.convert().
    The converter accepts two options, and both must
    be set or else no conversion is performed:

    @li @c 'currentIds': A comma-separated list of identifiers to replace.
    @li @c 'newIds': A comma-separated list of identifiers to use as the
    replacements.  The values should correspond one-to-one with the identifiers
    in @c 'currentIds' that should be replaced.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLIdConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLIdConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLIdConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLIdConverter
        __init__(self, SBMLIdConverter obj) -> SBMLIdConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLIdConverter(SBMLIdConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLIdConverter
        object.

        @param obj the SBMLIdConverter object to copy.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLIdConverter()</pre>

        Creates a new SBMLIdConverter object.

        """
        this = _libsbml.new_SBMLIdConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLIdConverter

        Creates and returns a deep copy of this SBMLIdConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLIdConverter_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLIdConverter
    __del__ = lambda self : None;
    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLIdConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLIdConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.SBMLIdConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLIdConverter_getDefaultProperties(self)

SBMLIdConverter_swigregister = _libsbml.SBMLIdConverter_swigregister
SBMLIdConverter_swigregister(SBMLIdConverter)

def SBMLIdConverter_init():
  """SBMLIdConverter_init()"""
  return _libsbml.SBMLIdConverter_init()

class SBMLInferUnitsConverter(SBMLConverter):
    """
    This method has multiple variants; they differ in the arguments
     they accept.  Each variant is described separately below.

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>SBMLInferUnitsConverter()</pre>

    Creates a new SBMLInferUnitsConverter object.
       

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>SBMLInferUnitsConverter(SBMLInferUnitsConverter obj)</pre>

    Copy constructor; creates a copy of an SBMLInferUnitsConverter
    object.

    @param obj the SBMLInferUnitsConverter object to copy.

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLInferUnitsConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLInferUnitsConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLInferUnitsConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLInferUnitsConverter
        __init__(self, SBMLInferUnitsConverter obj) -> SBMLInferUnitsConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLInferUnitsConverter()</pre>

        Creates a new SBMLInferUnitsConverter object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLInferUnitsConverter(SBMLInferUnitsConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLInferUnitsConverter
        object.

        @param obj the SBMLInferUnitsConverter object to copy.

        """
        this = _libsbml.new_SBMLInferUnitsConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLInferUnitsConverter
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLInferUnitsConverter

        Creates and returns a deep copy of this SBMLConverter object.

        @return the (deep) copy of this SBMLConverter object.

        """
        return _libsbml.SBMLInferUnitsConverter_clone(self)

    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Predicate returning @c True if this converter's properties matches a
        given set of configuration properties.

        @param props the configuration properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLInferUnitsConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned depends on the converter subclass; please consult
        the documentation for the relevant class to find out what the
        possibilities are.

        """
        return _libsbml.SBMLInferUnitsConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.  The run-time properties of the converter object can
        be adjusted by using the method
        SBMLConverter.setProperties().

        @return the default properties for the converter.

        @see setProperties()
        @see matchesProperties()

        """
        return _libsbml.SBMLInferUnitsConverter_getDefaultProperties(self)

SBMLInferUnitsConverter_swigregister = _libsbml.SBMLInferUnitsConverter_swigregister
SBMLInferUnitsConverter_swigregister(SBMLInferUnitsConverter)

def SBMLInferUnitsConverter_init():
  """SBMLInferUnitsConverter_init()"""
  return _libsbml.SBMLInferUnitsConverter_init()

class SBMLInitialAssignmentConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter that removes SBML <em>initial assignments</em>.

    @htmlinclude libsbml-facility-only-warning.html

    This is an SBML converter for replacing InitialAssignment objects, when
    possible, by setting the initial value attributes on the model objects
    being assigned.  In other words, for every object that is the target of an
    initial assignment in the model, the converter evaluates the mathematical
    expression of the assignment to get a @em numerical value, and then sets
    the corresponding attribute of the object to the value.  The effects for
    different kinds of SBML components are as follows:

    <center>
    <table border='0' class='text-table width80 normal-font alt-row-colors'>
    <tr style='background: lightgray; font-size: 14px;'>
    <th align='left' width='200'>Component</th>
    <th align='left'>Effect</th>
    </tr>
    <tr>
    <td>Compartment</td>
    <td>Sets the value of the <code>size</code> attribute.</td>
    </tr>
    <tr>
    <td>Species</td>
    <td>Sets the value of either the <code>initialAmount</code>
    or the <code>initialConcentration</code> attributes, depending
    on the value of the Species object's
    <code>hasOnlySubstanceUnits</code> attribute.</td>
    </tr>
    <tr>
    <td>Parameter</td>
    <td>Sets the value of the <code>value</code> attribute.</td>
    </tr>
    <tr>
    <td>SpeciesReference</td>
    <td>Sets the value of the <code>stoichiometry</code> attribute
    in the Reaction object where the SpeciesReference object appears.</td>
    </tr>
    </table>
    </center>

    @section SBMLInitialAssignmentConverter-usage Configuration and use of SBMLInitialAssignmentConverter

    SBMLInitialAssignmentConverter is enabled by creating a
    ConversionProperties object with the option @c 'expandInitialAssignments',
    and passing this properties object to SBMLDocument.convert().  The converter offers no other options.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLInitialAssignmentConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLInitialAssignmentConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLInitialAssignmentConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLInitialAssignmentConverter
        __init__(self, SBMLInitialAssignmentConverter obj) -> SBMLInitialAssignmentConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLInitialAssignmentConverter(SBMLInitialAssignmentConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLInitialAssignmentConverter
        object.

        @param obj the SBMLInitialAssignmentConverter object to copy.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLInitialAssignmentConverter()</pre>

        Creates a new SBMLInitialAssignmentConverter object.

        """
        this = _libsbml.new_SBMLInitialAssignmentConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLInitialAssignmentConverter

        Creates and returns a deep copy of this SBMLInitialAssignmentConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLInitialAssignmentConverter_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLInitialAssignmentConverter
    __del__ = lambda self : None;
    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLInitialAssignmentConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLInitialAssignmentConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.SBMLInitialAssignmentConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLInitialAssignmentConverter_getDefaultProperties(self)

SBMLInitialAssignmentConverter_swigregister = _libsbml.SBMLInitialAssignmentConverter_swigregister
SBMLInitialAssignmentConverter_swigregister(SBMLInitialAssignmentConverter)

def SBMLInitialAssignmentConverter_init():
  """SBMLInitialAssignmentConverter_init()"""
  return _libsbml.SBMLInitialAssignmentConverter_init()

class SBMLLevelVersionConverter(SBMLConverter):
    """
    This method has multiple variants; they differ in the arguments
     they accept.  Each variant is described separately below.

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>SBMLLevelVersionConverter()</pre>

    Creates a new SBMLLevelVersionConverter object.
       

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>SBMLLevelVersionConverter(SBMLLevelVersionConverter obj)</pre>

    Copy constructor; creates a copy of an SBMLLevelVersionConverter
    object.

    @param obj the SBMLLevelVersionConverter object to copy.

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLLevelVersionConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLLevelVersionConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLLevelVersionConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLLevelVersionConverter
        __init__(self, SBMLLevelVersionConverter obj) -> SBMLLevelVersionConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLLevelVersionConverter()</pre>

        Creates a new SBMLLevelVersionConverter object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLLevelVersionConverter(SBMLLevelVersionConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLLevelVersionConverter
        object.

        @param obj the SBMLLevelVersionConverter object to copy.

        """
        this = _libsbml.new_SBMLLevelVersionConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLLevelVersionConverter
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLLevelVersionConverter

        Creates and returns a deep copy of this SBMLConverter object.

        @return the (deep) copy of this SBMLConverter object.

        """
        return _libsbml.SBMLLevelVersionConverter_clone(self)

    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Predicate returning @c True if this converter's properties matches a
        given set of configuration properties.

        @param props the configuration properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLLevelVersionConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned depends on the converter subclass; please consult
        the documentation for the relevant class to find out what the
        possibilities are.

        """
        return _libsbml.SBMLLevelVersionConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.  The run-time properties of the converter object can
        be adjusted by using the method
        SBMLConverter.setProperties().

        @return the default properties for the converter.

        @see setProperties()
        @see matchesProperties()

        """
        return _libsbml.SBMLLevelVersionConverter_getDefaultProperties(self)

    def getTargetLevel(self):
        """
        getTargetLevel(self) -> unsigned int

        Returns the target SBML Level for the conversion.

        @return an integer indicating the SBML Level.

        """
        return _libsbml.SBMLLevelVersionConverter_getTargetLevel(self)

    def getTargetVersion(self):
        """
        getTargetVersion(self) -> unsigned int

        Returns the target SBML Version for the conversion.

        @return an integer indicating the Version within the SBML Level.

        """
        return _libsbml.SBMLLevelVersionConverter_getTargetVersion(self)

    def getValidityFlag(self):
        """
        getValidityFlag(self) -> bool

        Returns the flag indicating whether the conversion has been set to 'strict'.

        @return @c True if strict validity has been requested, @c False
        otherwise.

        """
        return _libsbml.SBMLLevelVersionConverter_getValidityFlag(self)

SBMLLevelVersionConverter_swigregister = _libsbml.SBMLLevelVersionConverter_swigregister
SBMLLevelVersionConverter_swigregister(SBMLLevelVersionConverter)

def SBMLLevelVersionConverter_init():
  """SBMLLevelVersionConverter_init()"""
  return _libsbml.SBMLLevelVersionConverter_init()

class SBMLLocalParameterConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter to turn local parameters into global ones.

    @htmlinclude libsbml-facility-only-warning.html

    This converter essentially promotes local parameters to global parameters.
    It works by examining every Reaction object for LocalParameter objects,
    then creating Parameter objects on the model for each one found, and
    finally removing the original LocalParameter objects.  It creates new
    identifiers for the fresh Parameter objects by concatenating the
    identifier of the reaction with the identifier of the original
    LocalParameter object.

    This converter can be useful for software applications that do not have
    the ability to handle local parameters on reactions.  Such applications
    could check incoming models for local parameters and run those models
    through this converter before proceeding with other steps.

    @section SBMLLocalParameterConverter-usage Configuration and use of SBMLLocalParameterConverter

    SBMLLocalParameterConverter is enabled by creating a ConversionProperties
    object with the option @c 'promoteLocalParameters', and passing this
    properties object to SBMLDocument.convert().  The converter offers no other options.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLLocalParameterConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLLocalParameterConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLLocalParameterConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLLocalParameterConverter
        __init__(self, SBMLLocalParameterConverter obj) -> SBMLLocalParameterConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLLocalParameterConverter(SBMLLocalParameterConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLLocalParameterConverter
        object.

        @param obj the SBMLLocalParameterConverter object to copy.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLLocalParameterConverter()</pre>

        Creates a new SBMLLocalParameterConverter object.

        """
        this = _libsbml.new_SBMLLocalParameterConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLLocalParameterConverter

        Creates and returns a deep copy of this SBMLLocalParameterConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLLocalParameterConverter_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLLocalParameterConverter
    __del__ = lambda self : None;
    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLLocalParameterConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLLocalParameterConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.SBMLLocalParameterConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLLocalParameterConverter_getDefaultProperties(self)

SBMLLocalParameterConverter_swigregister = _libsbml.SBMLLocalParameterConverter_swigregister
SBMLLocalParameterConverter_swigregister(SBMLLocalParameterConverter)

def SBMLLocalParameterConverter_init():
  """SBMLLocalParameterConverter_init()"""
  return _libsbml.SBMLLocalParameterConverter_init()

class SBMLReactionConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter to replace reactions with SBML <em>rate rules</em>.

    @htmlinclude libsbml-facility-only-warning.html

    This converter will take an SBML model and replace the definitions of
    reactions in the model with definitions of SBML rate rules.  Equivalent
    RateRule objects are only created for species mentioned in reactions that
    have KineticLaw subobjects, since those are the only reactions that have
    an effect on the rates of change of species in the model; however, the
    converter removes all Reaction objects in the model after it is done.

    @section SBMLReactionConverter-usage Configuration and use of SBMLReactionConverter

    SBMLReactionConverter is enabled by creating a ConversionProperties object
    with the option @c 'replaceReactions', and passing this properties object
    to SBMLDocument.convert().  This
    converter does not offer any additional configuration options.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLReactionConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLReactionConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLReactionConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLReactionConverter
        __init__(self, SBMLReactionConverter obj) -> SBMLReactionConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLReactionConverter(SBMLReactionConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLReactionConverter
        object.

        @param obj the SBMLReactionConverter object to copy.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLReactionConverter()</pre>

        Creates a new SBMLReactionConverter object.

        """
        this = _libsbml.new_SBMLReactionConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLReactionConverter

        Creates and returns a deep copy of this SBMLReactionConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLReactionConverter_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLReactionConverter
    __del__ = lambda self : None;
    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLReactionConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLReactionConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_CONV_INVALID_SRC_DOCUMENT LIBSBML_CONV_INVALID_SRC_DOCUMENT@endlink

        """
        return _libsbml.SBMLReactionConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLReactionConverter_getDefaultProperties(self)

    def setDocument(self, *args):
        """
        setDocument(self, SBMLDocument doc) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setDocument(SBMLDocument doc)</pre>

        Sets the current SBML document to the given SBMLDocument object.

        @param doc the document to use for this conversion.

        @warning Even though the @p doc is 'const', it is immediately cast
        to a non-const version, which is then usually changed by the
        converter upon a successful conversion.  This function is here
        solely to preserve backwards compatibility.

        @return integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned ultimately depends on the specific subclass of
        SBMLConverter being used, but the default method can return the
        following values:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setDocument(SBMLDocument doc)</pre>

        Sets the current SBML document to the given SBMLDocument object.

        @param doc the document to use for this conversion.

        @return integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The set of possible values that may
        be returned ultimately depends on the specific subclass of
        SBMLConverter being used, but the default method can return the
        following values:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.SBMLReactionConverter_setDocument(self, *args)

SBMLReactionConverter_swigregister = _libsbml.SBMLReactionConverter_swigregister
SBMLReactionConverter_swigregister(SBMLReactionConverter)

def SBMLReactionConverter_init():
  """SBMLReactionConverter_init()"""
  return _libsbml.SBMLReactionConverter_init()

class SBMLRuleConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter that sorts SBML rules and assignments.

    @htmlinclude libsbml-facility-only-warning.html

    This converter reorders assignments in a model.  Specifically, it sorts
    the list of assignment rules (i.e., the AssignmentRule objects contained
    in the ListOfAssignmentRules within the Model object) and the initial
    assignments (i.e., the InitialAssignment objects contained in the
    ListOfInitialAssignments) such that, within each set, assignments that
    depend on @em prior values are placed @em after the values are set.  For
    example, if there is an assignment rule stating <i>a = b + 1</i>, and
    another rule stating <i>b = 3</i>, the list of rules is sorted and the
    rules are arranged so that the rule for <i>b = 3</i> appears @em before
    the rule for <i>a = b + 1</i>.  Similarly, if dependencies of this
    sort exist in the list of initial assignments in the model, the initial
    assignments are sorted as well.

    Beginning with SBML Level 2, assignment rules have no ordering
    required---the order in which the rules appear in an SBML file has
    no significance.  Software tools, however, may need to reorder
    assignments for purposes of evaluating them.  For example, for
    simulators that use time integration methods, it would be a good idea to
    reorder assignment rules such as the following,

    <i>b = a + 10 seconds</i><br>
    <i>a = time</i>

    so that the evaluation of the rules is independent of integrator
    step sizes. (This is due to the fact that, in this case, the order in
    which the rules are evaluated changes the result.)  SBMLRuleConverter
    can be used to reorder the SBML objects regardless of whether the
    input file contained them in the desired order.

    @note The two sets of assignments (list of assignment rules on the one
    hand, and list of initial assignments on the other hand) are handled @em
    independently.  In an SBML model, these entities are treated differently
    and no amount of sorting can deal with inter-dependencies between
    assignments of the two kinds.
    @section SBMLRuleConverter-usage Configuration and use of SBMLRuleConverter

    SBMLRuleConverter is enabled by creating a ConversionProperties object
    with the option @c 'sortRules', and passing this properties object to
    SBMLDocument.convert().  This
    converter offers no other options.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLRuleConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLRuleConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLRuleConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLRuleConverter
        __init__(self, SBMLRuleConverter obj) -> SBMLRuleConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLRuleConverter(SBMLRuleConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLLevelVersionConverter
        object.

        @param obj the SBMLLevelVersionConverter object to copy.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLRuleConverter()</pre>

        Creates a new SBMLLevelVersionConverter object.

        """
        this = _libsbml.new_SBMLRuleConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLRuleConverter

        Creates and returns a deep copy of this SBMLLevelVersionConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLRuleConverter_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLRuleConverter
    __del__ = lambda self : None;
    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLLevelVersionConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLRuleConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_CONV_INVALID_SRC_DOCUMENT LIBSBML_CONV_INVALID_SRC_DOCUMENT@endlink

        """
        return _libsbml.SBMLRuleConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLRuleConverter_getDefaultProperties(self)

SBMLRuleConverter_swigregister = _libsbml.SBMLRuleConverter_swigregister
SBMLRuleConverter_swigregister(SBMLRuleConverter)

def SBMLRuleConverter_init():
  """SBMLRuleConverter_init()"""
  return _libsbml.SBMLRuleConverter_init()

class SBMLStripPackageConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converter that removes SBML Level 3 packages.

    @htmlinclude libsbml-facility-only-warning.html

    This SBML converter takes an SBML document and removes (strips) an SBML
    Level&nbsp;3 package from it.  No conversion is performed; the package
    constructs are simply removed from the SBML document.  The package to be
    stripped is determined by the value of the option @c 'package' on the
    conversion properties.

    @section SBMLStripPackageConverter-usage Configuration and use of SBMLStripPackageConverter

    SBMLStripPackageConverter is enabled by creating a ConversionProperties
    object with the option @c 'stripPackage', and passing this properties
    object to SBMLDocument.convert().
    This converter takes one required option:

    @li @c 'package': the value of this option should be a text string, the
    nickname of the SBML Level&nbsp;3 package to be stripped from the model.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLStripPackageConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLStripPackageConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLStripPackageConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLStripPackageConverter
        __init__(self, SBMLStripPackageConverter obj) -> SBMLStripPackageConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLStripPackageConverter()</pre>

        Creates a new SBMLStripPackageConverter object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLStripPackageConverter(SBMLStripPackageConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLStripPackageConverter
        object.

        @param obj the SBMLStripPackageConverter object to copy.

        """
        this = _libsbml.new_SBMLStripPackageConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLStripPackageConverter
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLStripPackageConverter

        Creates and returns a deep copy of this SBMLStripPackageConverter
        object.

        @return the (deep) copy of this converter object.

        """
        return _libsbml.SBMLStripPackageConverter_clone(self)

    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLStripPackageConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLStripPackageConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
        @li @link libsbml#LIBSBML_CONV_PKG_CONSIDERED_UNKNOWN LIBSBML_CONV_PKG_CONSIDERED_UNKNOWN@endlink

        """
        return _libsbml.SBMLStripPackageConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLStripPackageConverter_getDefaultProperties(self)

SBMLStripPackageConverter_swigregister = _libsbml.SBMLStripPackageConverter_swigregister
SBMLStripPackageConverter_swigregister(SBMLStripPackageConverter)

def SBMLStripPackageConverter_init():
  """SBMLStripPackageConverter_init()"""
  return _libsbml.SBMLStripPackageConverter_init()

class SBMLUnitsConverter(SBMLConverter):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Converts a model's existing units to SI units.

    @htmlinclude libsbml-facility-only-warning.html

    This SBML converter converts the units in a model to base SI units, that
    is, using only the units metre, kilogram, second, ampere, kelvin, mole and
    candela.

    Unit conversion will only be performed on models that are fully unit
    consistent, meaning that all objects have units associated with them and
    there are no literal numbers with unspecified units.  In the case of an
    SBML Level&nbsp;3 model involving math expressions, this means that the @c
    timeUnits attribute on the Model object must be set, and if there are any
    reactions in the model, the @c extentUnits attribute on the Model object
    must also be set.

    @section SBMLUnitsConverter-usage Configuration and use of SBMLUnitsConverter

    SBMLUnitsConverter is enabled by creating a ConversionProperties object
    with the option @c 'units', and passing this properties object to
    SBMLDocument.convert().  This
    converter takes one optional option:

    @li @c 'removeUnusedUnits': the value of this property should be a
    Boolean.  If it is @c True, it tells the unit convert to remove any unused
    UnitDefinition objects after conversion is complete.  ('Unused' units are
    units that are not referenced by any object in the model.)  If the value
    is @c False, unused UnitDefinition objects are not removed from the model.
    The default is @c True.

    @section using-converters General information about the use of SBML converters

    The use of all the converters follows a similar approach.  First, one
    creates a ConversionProperties object and calls
    ConversionProperties.addOption()
    on this object with one arguments: a text string that identifies the desired
    converter.  (The text string is specific to each converter; consult the
    documentation for a given converter to find out how it should be enabled.)

    Next, for some converters, the caller can optionally set some
    converter-specific properties using additional calls to
    ConversionProperties.addOption().
    Many converters provide the ability to
    configure their behavior to some extent; this is realized through the use
    of properties that offer different options.  The default property values
    for each converter can be interrogated using the method
    SBMLConverter.getDefaultProperties() on the converter class in question .

    Finally, the caller should invoke the method
    SBMLDocument.convert()
    with the ConversionProperties object as an argument.

    @subsection converter-example Example of invoking an SBML converter

    The following code fragment illustrates an example using
    SBMLReactionConverter, which is invoked using the option string @c
    'replaceReactions':

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('replaceReactions');
    @endcode
    @endif
    @if python
    @code{.py}
    config = ConversionProperties()
    if config != None:
      config.addOption('replaceReactions')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties props = new ConversionProperties();
    if (props != null) {
      props.addOption('replaceReactions');
    } else {
      // Deal with error.
    }
    @endcode
    @endif

    In the case of SBMLReactionConverter, there are no options to affect
    its behavior, so the next step is simply to invoke the converter on
    an SBMLDocument object.  Continuing the example code:

    @if cpp
    @code{.cpp}
    // Assume that the variable 'document' has been set to an SBMLDocument object.
    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
      cerr << 'Unable to perform conversion due to the following:' << endl;
      document->printErrors(cerr);
    }
    @endcode
    @endif
    @if python
    @code{.py}
      # Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config)
      if status != LIBSBML_OPERATION_SUCCESS:
        # Handle error somehow.
        print('Error: conversion failed due to the following:')
        document.printErrors()
    @endcode
    @endif
    @if java
    @code{.java}
      // Assume that the variable 'document' has been set to an SBMLDocument object.
      status = document.convert(config);
      if (status != libsbml.LIBSBML_OPERATION_SUCCESS)
      {
        // Handle error somehow.
        System.out.println('Error: conversion failed due to the following:');
        document.printErrors();
      }
    @endcode
    @endif

    Here is an example of using a converter that offers an option. The
    following code invokes SBMLStripPackageConverter to remove the
    SBML Level&nbsp;3 @em %Layout package from a model.  It sets the name
    of the package to be removed by adding a value for the option named
    @c 'package' defined by that converter:

    @if cpp
    @code{.cpp}
    ConversionProperties props;
    props.addOption('stripPackage');
    props.addOption('package', 'layout');

    int status = document->convert(props);
    if (status != LIBSBML_OPERATION_SUCCESS)
    {
        cerr << 'Unable to strip the Layout package from the model';
        cerr << 'Error returned: ' << status;
    }
    @endcode
    @endif
    @if python
    @code{.py}
    def strip_layout_example(document):
      config = ConversionProperties()
      if config != None:
        config.addOption('stripPackage')
        config.addOption('package', 'layout')
        status = document.convert(config)
        if status != LIBSBML_OPERATION_SUCCESS:
          # Handle error somehow.
          print('Error: unable to strip the Layout package.')
          print('LibSBML returned error: ' + OperationReturnValue_toString(status).strip())
      else:
        # Handle error somehow.
        print('Error: unable to create ConversionProperties object')
    @endcode
    @endif
    @if java
    @code{.java}
    ConversionProperties config = new ConversionProperties();
    if (config != None) {
      config.addOption('stripPackage');
      config.addOption('package', 'layout');
      status = document.convert(config);
      if (status != LIBSBML_OPERATION_SUCCESS) {
        // Handle error somehow.
        System.out.println('Error: unable to strip the Layout package');
        document.printErrors();
      }
    } else {
      // Handle error somehow.
      System.out.println('Error: unable to create ConversionProperties object');
    }
    @endcode
    @endif

    @subsection available-converters Available SBML converters in libSBML

    LibSBML provides a number of built-in converters; by convention, their
    names end in @em Converter. The following are the built-in converters
    provided by libSBML @htmlinclude libsbml-version.html:

    @copydetails doc_list_of_libsbml_converters

    """
    __swig_setmethods__ = {}
    for _s in [SBMLConverter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLUnitsConverter, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLConverter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLUnitsConverter, name)
    __repr__ = _swig_repr
    def init():
        """init()"""
        return _libsbml.SBMLUnitsConverter_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLUnitsConverter
        __init__(self, SBMLUnitsConverter obj) -> SBMLUnitsConverter

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLUnitsConverter()</pre>

        Creates a new SBMLUnitsConverter object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLUnitsConverter(SBMLUnitsConverter obj)</pre>

        Copy constructor; creates a copy of an SBMLUnitsConverter
        object.

        @param obj the SBMLUnitsConverter object to copy.

        """
        this = _libsbml.new_SBMLUnitsConverter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLUnitsConverter
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLUnitsConverter

        Creates and returns a deep copy of this SBMLUnitsConverter
        object.

        @return a (deep) copy of this converter.

        """
        return _libsbml.SBMLUnitsConverter_clone(self)

    def matchesProperties(self, *args):
        """
        matchesProperties(self, ConversionProperties props) -> bool

        Returns @c True if this converter object's properties match the given
        properties.

        A typical use of this method involves creating a ConversionProperties
        object, setting the options desired, and then calling this method on
        an SBMLUnitsConverter object to find out if the object's
        property values match the given ones.  This method is also used by
        SBMLConverterRegistry.getConverterFor()
        to search across all registered converters for one matching particular
        properties.

        @param props the properties to match.

        @return @c True if this converter's properties match, @c False
        otherwise.

        """
        return _libsbml.SBMLUnitsConverter_matchesProperties(self, *args)

    def convert(self):
        """
        convert(self) -> int

        Perform the conversion.

        This method causes the converter to do the actual conversion work,
        that is, to convert the SBMLDocument object set by
        SBMLConverter.setDocument() and
        with the configuration options set by
        SBMLConverter.setProperties().

        @return  integer value indicating the success/failure of the operation.
        @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_CONV_CONVERSION_NOT_AVAILABLE LIBSBML_CONV_CONVERSION_NOT_AVAILABLE@endlink
        @li @link libsbml#LIBSBML_CONV_INVALID_SRC_DOCUMENT LIBSBML_CONV_INVALID_SRC_DOCUMENT@endlink

        """
        return _libsbml.SBMLUnitsConverter_convert(self)

    def getDefaultProperties(self):
        """
        getDefaultProperties(self) -> ConversionProperties

        Returns the default properties of this converter.

        A given converter exposes one or more properties that can be adjusted
        in order to influence the behavior of the converter.  This method
        returns the @em default property settings for this converter.  It is
        meant to be called in order to discover all the settings for the
        converter object.

        @return the ConversionProperties object describing the default properties
        for this converter.

        """
        return _libsbml.SBMLUnitsConverter_getDefaultProperties(self)

SBMLUnitsConverter_swigregister = _libsbml.SBMLUnitsConverter_swigregister
SBMLUnitsConverter_swigregister(SBMLUnitsConverter)

def SBMLUnitsConverter_init():
  """SBMLUnitsConverter_init()"""
  return _libsbml.SBMLUnitsConverter_init()

class SBMLValidator(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base class for SBML validators.

    @htmlinclude not-sbml-warning.html

    LibSBML implements facilities for verifying that a given SBML document
    is valid according to the SBML specifications; it also exposes the
    validation interface so that user programs and SBML Level&nbsp;3 package
    authors may use the facilities to implement new validators.  There are
    two main interfaces to libSBML's validation facilities, based on the
    classes Validator and SBMLValidator.

    The Validator class is the basis of the system for validating an SBML
    document against the validation rules defined in the SBML
    specifications.  The scheme used by Validator relies is compact and uses
    the @em visitor programming pattern, but it relies on C/C++ features and
    is not directly accessible from language bindings.  SBMLValidator offers
    a framework for straightforward class-based extensibility, so that user
    code can subclass SBMLValidator to implement new validation systems,
    different validators can be introduced or turned off at run-time, and
    interfaces can be provided in the libSBML language bindings.
    SBMLValidator can call Validator functionality internally (as is the
    case in the current implementation of SBMLInternalValidator) or use
    entirely different implementation approaches, as necessary.

    Users of libSBML may already be familiar with the facilities encompassed
    by the validation system, in the form of the consistency-checking methods
    defined on SBMLDocument.  The methods SBMLDocument.setConsistencyChecks(),
    SBMLDocument.checkConsistency(), SBMLDocument.checkInternalConsistency()
    and other method of that sort are in fact implemented via SBMLValidator,
    specifically as methods on the class SBMLInternalValidator.

    Authors may use SBMLValidator as the base class for their own validator
    extensions to libSBML.  The class SBMLInternalValidator may serve as a
    code example for how to implement such things.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLValidator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLValidator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLValidator
        __init__(self, SBMLValidator orig) -> SBMLValidator

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLValidator()</pre>

        Creates a new SBMLValidator.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLValidator(SBMLValidator orig)</pre>

        Copy constructor; creates a copy of an SBMLValidator object.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        if self.__class__ == SBMLValidator:
            _self = None
        else:
            _self = self
        this = _libsbml.new_SBMLValidator(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLValidator
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLValidator

        Creates and returns a deep copy of this SBMLValidator object.

        @return the (deep) copy of this SBMLValidator object.

        """
        return _libsbml.SBMLValidator_clone(self)

    def getDocument(self, *args):
        """
        getDocument(self) -> SBMLDocument
        getDocument(self) -> SBMLDocument

        Returns the current SBML document in use by this validator.

        @return the current SBML document

        @see setDocument()

        """
        return _libsbml.SBMLValidator_getDocument(self, *args)

    def setDocument(self, *args):
        """
        setDocument(self, SBMLDocument doc) -> int

        Sets the current SBML document to the given SBMLDocument object.

        @param doc the document to use for this validation

        @return an integer value indicating the success/failure of the
        validation.  @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values returned by this
        function are
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see getDocument()

        """
        return _libsbml.SBMLValidator_setDocument(self, *args)

    def clearFailures(self):
        """
        clearFailures(self)

        Clears this validator's list of failures.

        If you are validating multiple SBML documents with the same validator,
        call this method after you have processed the list of failures from
        the last validation run and before validating the next document.

        @if clike @see getFailures() @endif@~

        """
        return _libsbml.SBMLValidator_clearFailures(self)

    def logFailure(self, *args):
        """
        logFailure(self, SBMLError err)

        Adds the given failure to this list of Validators failures.

        @param err an SBMLError object representing an error or warning

        @if clike @see getFailures() @endif@~

        """
        return _libsbml.SBMLValidator_logFailure(self, *args)

    def validate(self, *args):
        """
        validate(self) -> unsigned int
        validate(self, SBMLDocument d) -> unsigned int
        validate(self, string filename) -> unsigned int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>validate(string filename)</pre>

        Validates the SBML document located at the given @p filename.

        This is a convenience method that saves callers the trouble of
        using SBMLReader to read the document first.

        @param filename the path to the file to be read and validated.

        @return the number of validation failures that occurred.  The objects
        describing the actual failures can be retrieved using getFailures().
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>validate()</pre>

        Runs this validator on the current SBML document.

        @return an integer value indicating the success/failure of the
        validation.  @if clike The value is drawn from the enumeration
        #OperationReturnValues_t. @endif@~ The possible values returned by this
        function are determined by the specific subclasses of this class.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>validate(SBMLDocument d)</pre>

        Validates the given SBMLDocument object.

        This is identical to calling setDocument(@if java SBMLDocument @endif)
        followed by validate().

        @param d the SBML document to validate

        @return the number of validation failures that occurred.  The objects
        describing the actual failures can be retrieved using getFailures().

        """
        return _libsbml.SBMLValidator_validate(self, *args)

    def getErrorLog(self):
        """
        getErrorLog(self) -> SBMLErrorLog

        Returns the list of errors or warnings logged during parsing,
        consistency checking, or attempted translation of this model.

        Note that this refers to the SBMLDocument object's error log (i.e.,
        the list returned by SBMLDocument.getErrorLog()).  @em That list of
        errors and warnings is @em separate from the validation failures
        tracked by this validator (i.e., the list returned by getFailures()).

        @return the SBMLErrorLog used for the SBMLDocument

        @if clike @see getFailures() @endif@~

        """
        return _libsbml.SBMLValidator_getErrorLog(self)

    def getModel(self, *args):
        """
        getModel(self) -> Model
        getModel(self) -> Model

        Returns the Model object stored in the SBMLDocument.

        It is important to note that this method <em>does not create</em> a
        Model instance.  The model in the SBMLDocument must have been created
        at some prior time, for example using SBMLDocument.createModel() 
        or SBMLDocument.setModel().
        This method returns @c None if a model does not yet exist.

        @return the Model contained in this validator's SBMLDocument object.

        @see SBMLDocument.setModel()
        @see SBMLDocument.createModel()

        """
        return _libsbml.SBMLValidator_getModel(self, *args)

    def getNumFailures(self):
        """
        getNumFailures(self) -> unsigned int

        Returns the number of failures encountered in the last validation run.

        This method returns the number of failures logged by this validator.
        This number only reflects @em this validator's actions; the number may
        not be the same as the number of errors and warnings logged on the
        SBMLDocument object's error log (i.e., the object returned by
        SBMLDocument.getErrorLog()), because other parts of libSBML may log
        errors and warnings beyond those found by this validator.

        @return the number of errors logged by this validator.

        """
        return _libsbml.SBMLValidator_getNumFailures(self)

    def getFailure(self, *args):
        """
        getFailure(self, unsigned int n) -> SBMLError

        Returns the failure object at index n in this validator's list of
        failures logged during the last run.

        Callers should use getNumFailures() first, to find out the number
        of entries in this validator's list of failures.

        @param n an integer indicating the index of the object to return from
        the failures list; index values start at 0.

        @return the failure at the given index number.

        @see getNumFailures()

        """
        return _libsbml.SBMLValidator_getFailure(self, *args)

    def __disown__(self):
        self.this.disown()
        _libsbml.disown_SBMLValidator(self)
        return weakref_proxy(self)
SBMLValidator_swigregister = _libsbml.SBMLValidator_swigregister
SBMLValidator_swigregister(SBMLValidator)

class SBMLExternalValidator(SBMLValidator):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html 
    @internal

    """
    __swig_setmethods__ = {}
    for _s in [SBMLValidator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLExternalValidator, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLValidator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLExternalValidator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SBMLExternalValidator
        __init__(self, SBMLExternalValidator arg0) -> SBMLExternalValidator

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html 
        @internal

        """
        this = _libsbml.new_SBMLExternalValidator(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBMLValidator

        @internal
        Creates and returns a deep copy of this SBMLValidator object.

        @return the (deep) copy of this SBMLValidator object.

        @internal

        """
        return _libsbml.SBMLExternalValidator_clone(self)

    __swig_destroy__ = _libsbml.delete_SBMLExternalValidator
    __del__ = lambda self : None;
    def validate(self):
        """
        validate(self) -> unsigned int

        @internal
        the actual conversion 

        @return status code represeting success/failure/conversion impossible

        @internal

        """
        return _libsbml.SBMLExternalValidator_validate(self)

    def getProgram(self):
        """
        getProgram(self) -> string

        @internal
        Returns the program name of the validator to be run

        @return the program name of the validator to be run

        @internal

        """
        return _libsbml.SBMLExternalValidator_getProgram(self)

    def setProgram(self, *args):
        """
        setProgram(self, string program)

        @internal
        Sets the name of the program to run

        @param program the program to be started

        @internal

        """
        return _libsbml.SBMLExternalValidator_setProgram(self, *args)

    def getOutputFileName(self):
        """
        getOutputFileName(self) -> string

        @internal
        Returns the output file name (this is the file the external program will write)

        @return the output file name

        @internal

        """
        return _libsbml.SBMLExternalValidator_getOutputFileName(self)

    def setOutputFileName(self, *args):
        """
        setOutputFileName(self, string outputFileName)

        @internal
        Sets the output file name

        @param outputFileName the name of the output XML file

        @internal

        """
        return _libsbml.SBMLExternalValidator_setOutputFileName(self, *args)

    def getSBMLFileName(self):
        """
        getSBMLFileName(self) -> string

        @internal
        @return the name of the SBML file (the document of this validator will be written to it)

        @internal

        """
        return _libsbml.SBMLExternalValidator_getSBMLFileName(self)

    def setSBMLFileName(self, *args):
        """
        setSBMLFileName(self, string sbmlFileName)

        @internal
        Sets the filename for the temporary file to be created

        @param sbmlFileName the temporary name

        @internal

        """
        return _libsbml.SBMLExternalValidator_setSBMLFileName(self, *args)

    def clearArguments(self):
        """
        clearArguments(self)

        @internal
        Clear all additional arguments

        @internal

        """
        return _libsbml.SBMLExternalValidator_clearArguments(self)

    def addArgument(self, *args):
        """
        addArgument(self, string arg)

        @internal
        Adds the given argument to the list of additional arguments 

        @param arg the argument

        @internal

        """
        return _libsbml.SBMLExternalValidator_addArgument(self, *args)

    def getNumArguments(self):
        """
        getNumArguments(self) -> unsigned int

        @internal
        @return the number of arguments.

        @internal

        """
        return _libsbml.SBMLExternalValidator_getNumArguments(self)

    def getArgument(self, *args):
        """
        getArgument(self, unsigned int n) -> string

        @internal
        Returns the argument for the given index. 

        @param n the zero based index of the argument. 

        @return the argument at the given index.

        @internal

        """
        return _libsbml.SBMLExternalValidator_getArgument(self, *args)

SBMLExternalValidator_swigregister = _libsbml.SBMLExternalValidator_swigregister
SBMLExternalValidator_swigregister(SBMLExternalValidator)

class XMLAttributes(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An attribute on an XML node.

    @htmlinclude not-sbml-warning.html

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLAttributes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLAttributes, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLAttributes
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLAttributes
        __init__(self, XMLAttributes orig) -> XMLAttributes

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLAttributes()</pre>

        Creates a new empty XMLAttributes set.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLAttributes(XMLAttributes orig)</pre>

        Copy constructor; creates a copy of this XMLAttributes set.

        @p orig the XMLAttributes object to copy.

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_XMLAttributes(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLAttributes

        Creates and returns a deep copy of this XMLAttributes object.

        @return the (deep) copy of this XMLAttributes object.

        """
        return _libsbml.XMLAttributes_clone(self)

    def add(self, *args):
        """
        add(self, string name, string value, string namespaceURI = "", 
            string prefix = "") -> int
        add(self, string name, string value, string namespaceURI = "") -> int
        add(self, string name, string value) -> int
        add(self, XMLTriple triple, string value) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>add( XMLTriple triple, string value)</pre>

        Adds an attribute with the given XMLTriple/value pair to this XMLAttributes set.

        @note if local name with the same namespace URI already exists in this attribute set, 
        its value and prefix will be replaced.

        @param triple an XMLTriple, the XML triple of the attribute.
        @param value a string, the value of the attribute.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>add(  string name , string value , string namespaceURI = '' , string prefix = '')</pre>

        Adds an attribute (a name/value pair) to this XMLAttributes object,
        optionally with a prefix and URI defining a namespace.

        @param name a string, the local name of the attribute.
        @param value a string, the value of the attribute.
        @param namespaceURI a string, the namespace URI of the attribute.
        @param prefix a string, the prefix of the namespace

        @return an integer code indicating the success or failure of the
        function.  The possible values returned by this
        function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @note if local name with the same namespace URI already exists in this 
        attribute set, its value and prefix will be replaced.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLAttributes_add(self, *args)

    def removeResource(self, *args):
        """
        removeResource(self, int n) -> int

        Removes an attribute with the given index from this XMLAttributes set.  

        @param n an integer the index of the resource to be deleted
        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        """
        return _libsbml.XMLAttributes_removeResource(self, *args)

    def remove(self, *args):
        """
        remove(self, int n) -> int
        remove(self, string name, string uri = "") -> int
        remove(self, string name) -> int
        remove(self, XMLTriple triple) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(XMLTriple triple)</pre>

        Removes an attribute with the given XMLTriple from this XMLAttributes set.  

        @param triple an XMLTriple, the XML triple of the attribute.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(int n)</pre>

        Removes an attribute with the given index from this XMLAttributes set.  
        (This function is an alias of XMLAttributes.removeResource() ).

        @param n an integer the index of the resource to be deleted

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string name, string uri = '')</pre>

        Removes an attribute with the given local name and namespace URI from 
        this XMLAttributes set.  

        @param name   a string, the local name of the attribute.
        @param uri    a string, the namespace URI of the attribute.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        """
        return _libsbml.XMLAttributes_remove(self, *args)

    def clear(self):
        """
        clear(self) -> int

        Clears (deletes) all attributes in this XMLAttributes object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.XMLAttributes_clear(self)

    def getIndex(self, *args):
        """
        getIndex(self, string name) -> int
        getIndex(self, string name, string uri) -> int
        getIndex(self, XMLTriple triple) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getIndex(XMLTriple triple)</pre>

        Return the index of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute for which 
        the index is required.

        @return the index of an attribute with the given XMLTriple, or -1 if not present.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getIndex(string name, string uri)</pre>

        Return the index of an attribute with the given local name and namespace URI.

        @param name a string, the local name of the attribute.
        @param uri  a string, the namespace URI of the attribute.

        @return the index of an attribute with the given local name and namespace URI, 
        or -1 if not present.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getIndex(string name)</pre>

        Return the index of an attribute with the given name.

        @note A namespace bound to the name is not checked by this function.
        Thus, if there are multiple attributes with the given local name and
        different namespaces, the smallest index among those attributes will
        be returned.  XMLAttributes.getIndex() const or
        XMLAttributes.getIndex() const should be used to get an index of an
        attribute with the given local name and namespace.

        @param name a string, the local name of the attribute for which the 
        index is required.

        @return the index of an attribute with the given local name, or -1 if not present.

        """
        return _libsbml.XMLAttributes_getIndex(self, *args)

    def getLength(self):
        """
        getLength(self) -> int

        Return the number of attributes in the set.

        @return the number of attributes in this XMLAttributes set.

        """
        return _libsbml.XMLAttributes_getLength(self)

    def getNumAttributes(self):
        """
        getNumAttributes(self) -> int

        Return the number of attributes in the set.

        @return the number of attributes in this XMLAttributes set.

        This function is an alias for getLength introduced for consistency
        with other XML classes.

        """
        return _libsbml.XMLAttributes_getNumAttributes(self)

    def getName(self, *args):
        """
        getName(self, int index) -> string

        Return the local name of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose local name is 
        required.

        @return the local name of an attribute in this list (by position).  

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes.hasAttribute() const to test for the attribute
        existence.

        """
        return _libsbml.XMLAttributes_getName(self, *args)

    def getPrefix(self, *args):
        """
        getPrefix(self, int index) -> string

        Return the prefix of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose prefix is 
        required.

        @return the namespace prefix of an attribute in this list (by
        position).  

        @note If index is out of range, an empty string will be returned. Use
        XMLAttributes.hasAttribute() const to test for the attribute
        existence.

        """
        return _libsbml.XMLAttributes_getPrefix(self, *args)

    def getPrefixedName(self, *args):
        """
        getPrefixedName(self, int index) -> string

        Return the prefixed name of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose prefixed 
        name is required.

        @return the prefixed name of an attribute in this list (by
        position).  

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes.hasAttribute() const to test for attribute existence.

        """
        return _libsbml.XMLAttributes_getPrefixedName(self, *args)

    def getURI(self, *args):
        """
        getURI(self, int index) -> string

        Return the namespace URI of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose namespace URI is 
        required.

        @return the namespace URI of an attribute in this list (by position).

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes.hasAttribute() const to test for attribute existence.

        """
        return _libsbml.XMLAttributes_getURI(self, *args)

    def getValue(self, *args):
        """
        getValue(self, int index) -> string
        getValue(self, string name) -> string
        getValue(self, string name, string uri) -> string
        getValue(self, XMLTriple triple) -> string

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getValue(XMLTriple triple)</pre>

        Return a value of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute whose 
        value is required.

        @return The attribute value as a string.  

        @note If an attribute with the given XMLTriple does not exist, an
        empty string will be returned.  Use
        XMLAttributes.hasAttribute() const to test for attribute existence.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getValue(int index)</pre>

        Return the value of an attribute in this XMLAttributes set (by position).

        @param index an integer, the position of the attribute whose value is 
        required.

        @return the value of an attribute in the list (by position).  

        @note If index is out of range, an empty string will be returned.  Use
        XMLAttributes.hasAttribute() const to test for attribute existence.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getValue(string name)</pre>

        Return an attribute's value by name.

        @param name a string, the local name of the attribute whose value is required.

        @return The attribute value as a string.  

        @note If an attribute with the given local name does not exist, an
        empty string will be returned.  Use
        XMLAttributes.hasAttribute() const
        to test for attribute existence.  A namespace bound to the local name
        is not checked by this function.  Thus, if there are multiple
        attributes with the given local name and different namespaces, the
        value of an attribute with the smallest index among those attributes
        will be returned.  XMLAttributes.getValue() const or
        XMLAttributes.getValue() const should be used to get a value of an
        attribute with the given local name and namespace.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getValue(string name, string uri)</pre>

        Return a value of an attribute with the given local name and namespace URI.

        @param name a string, the local name of the attribute whose value is required.
        @param uri  a string, the namespace URI of the attribute.

        @return The attribute value as a string.  

        @note If an attribute with the given local name and namespace URI does
        not exist, an empty string will be returned.  Use
        XMLAttributes.hasAttribute() const
        to test for attribute existence.

        """
        return _libsbml.XMLAttributes_getValue(self, *args)

    def hasAttribute(self, *args):
        """
        hasAttribute(self, int index) -> bool
        hasAttribute(self, string name, string uri = "") -> bool
        hasAttribute(self, string name) -> bool
        hasAttribute(self, XMLTriple triple) -> bool

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>hasAttribute(XMLTriple triple)</pre>

        Predicate returning @c True or @c False depending on whether
        an attribute with the given XML triple exists in this XMLAttributes.

        @param triple an XMLTriple, the XML triple of the attribute 

        @return @c True if an attribute with the given XML triple exists in this
        XMLAttributes, @c False otherwise.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>hasAttribute(int index)</pre>

        Predicate returning @c True or @c False depending on whether
        an attribute with the given index exists in this XMLAttributes.

        @param index an integer, the position of the attribute.

        @return @c True if an attribute with the given index exists in this
        XMLAttributes, @c False otherwise.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>hasAttribute(string name, string uri='')</pre>

        Predicate returning @c True or @c False depending on whether
        an attribute with the given local name and namespace URI exists in this 
        XMLAttributes.

        @param name a string, the local name of the attribute.
        @param uri  a string, the namespace URI of the attribute.

        @return @c True if an attribute with the given local name and namespace 
        URI exists in this XMLAttributes, @c False otherwise.

        """
        return _libsbml.XMLAttributes_hasAttribute(self, *args)

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLAttributes set is empty.

        @return @c True if this XMLAttributes set is empty, @c False otherwise.

        """
        return _libsbml.XMLAttributes_isEmpty(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLAttributes_swigregister = _libsbml.XMLAttributes_swigregister
XMLAttributes_swigregister(XMLAttributes)

class XMLNamespaces(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An XML Namespace.

    @htmlinclude not-sbml-warning.html

    This class serves to organize functionality for tracking XML namespaces
    in a document or data stream.  The namespace declarations are stored as
    a list of pairs of XML namespace URIs and prefix strings.  These
    correspond to the parts of a namespace declaration on an XML element.
    For example, in the following XML fragment,
    @verbatim
    <annotation>
        <mysim:nodecolors xmlns:mysim='urn:lsid:mysim.org'
             mysim:bgcolor='green' mysim:fgcolor='white'/>
    </annotation>
    @endverbatim
    there is one namespace declaration.  Its URI is
    <code>urn:lsid:mysim.org</code> and its prefix is <code>mysim</code>.
    This pair could be stored as one item in an XMLNamespaces list.

    XMLNamespaces provides various methods for manipulating the list of
    prefix-URI pairs.  Individual namespaces stored in a given XMLNamespace
    object instance can be retrieved based on their index using
    XMLNamespaces.getPrefix(), or by their characteristics such as
    their URI or position in the list.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLNamespaces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLNamespaces, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLNamespaces
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLNamespaces
        __init__(self, XMLNamespaces orig) -> XMLNamespaces

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNamespaces()</pre>

        Creates a new empty list of XML namespace declarations.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNamespaces(XMLNamespaces orig)</pre>

        Copy constructor; creates a copy of this XMLNamespaces list.

        @param orig the XMLNamespaces object to copy

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_XMLNamespaces(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLNamespaces

        Creates and returns a deep copy of this XMLNamespaces object.

        @return the (deep) copy of this XMLNamespaces object.

        """
        return _libsbml.XMLNamespaces_clone(self)

    def add(self, *args):
        """
        add(self, string uri, string prefix = "") -> int
        add(self, string uri) -> int

        Appends an XML namespace prefix and URI pair to this list of namespace
        declarations.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  If there is an XML namespace with the given @p uri prefix
        in this list, then its corresponding URI will be overwritten by the
        new @p uri unless the uri represents the core sbml namespace.
        Calling programs could use one of the other XMLNamespaces
        methods, such as
        XMLNamespaces.hasPrefix() and 
        XMLNamespaces.hasURI() to
        inquire whether a given prefix and/or URI
        is already present in this XMLNamespaces object.
        If the @p uri represents the sbml namespaces then it will not be
        overwritten, as this has potentially serious consequences. If it
        is necessary to replace the sbml namespace the namespace should be removed
        prior to adding the new namespace.

        @param uri a string, the uri for the namespace
        @param prefix a string, the prefix for the namespace

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLNamespaces_add(self, *args)

    def remove(self, *args):
        """
        remove(self, int index) -> int
        remove(self, string prefix) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(int index)</pre>

        Removes an XML Namespace stored in the given position of this list.

        @param index an integer, position of the namespace to remove.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>remove(string prefix)</pre>

        Removes an XML Namespace with the given prefix.

        @param prefix a string, prefix of the required namespace.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        @see remove()

        """
        return _libsbml.XMLNamespaces_remove(self, *args)

    def clear(self):
        """
        clear(self) -> int

        Clears (deletes) all XML namespace declarations in this XMLNamespaces
        object.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see remove()

        """
        return _libsbml.XMLNamespaces_clear(self)

    def getIndex(self, *args):
        """
        getIndex(self, string uri) -> int

        Look up the index of an XML namespace declaration by URI.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  If this XMLNamespaces object contains a pair with the given
        URI @p uri, this method returns its index in the list.

        @param uri a string, the URI of the sought-after namespace.

        @return the index of the given declaration, or <code>-1</code> if not
        present.

        """
        return _libsbml.XMLNamespaces_getIndex(self, *args)

    def containsUri(self, *args):
        """
        containsUri(self, string uri) -> bool

        Tests whether the given uri is contained in this set of namespaces.

        """
        return _libsbml.XMLNamespaces_containsUri(self, *args)

    def getIndexByPrefix(self, *args):
        """
        getIndexByPrefix(self, string prefix) -> int

        Look up the index of an XML namespace declaration by prefix.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  If this XMLNamespaces object contains a pair with the given
        prefix @p prefix, this method returns its index in the list.

        @param prefix a string, the prefix string of the sought-after
        namespace

        @return the index of the given declaration, or <code>-1</code> if not
        present.

        """
        return _libsbml.XMLNamespaces_getIndexByPrefix(self, *args)

    def getLength(self):
        """
        getLength(self) -> int

        Returns the total number of URI-and-prefix pairs stored in this
        particular XMLNamespaces instance.

        @return the number of namespaces in this list.

        """
        return _libsbml.XMLNamespaces_getLength(self)

    def getNumNamespaces(self):
        """
        getNumNamespaces(self) -> int

        Returns the total number of URI-and-prefix pairs stored in this
        particular XMLNamespaces instance.

        @return the number of namespaces in this list.

        This function is an alias for getLength introduced for consistency
        with other XML classes.

        """
        return _libsbml.XMLNamespaces_getNumNamespaces(self)

    def getPrefix(self, *args):
        """
        getPrefix(self, int index) -> string
        getPrefix(self, string uri) -> string

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getPrefix(int index)</pre>

        Look up the prefix of an XML namespace declaration by its position.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  This method returns the prefix of the <code>n</code>th
        element in that list (if it exists).  Callers should use
        XMLAttributes.getLength() first to find out how many namespaces are
        stored in the list.

        @param index an integer, position of the sought-after prefix

        @return the prefix of an XML namespace declaration in this list (by
        position), or an empty string if the @p index is out of range

        @see getLength()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getPrefix(string uri)</pre>

        Look up the prefix of an XML namespace declaration by its URI.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  This method returns the prefix for a pair that has the
        given @p uri.

        @param uri a string, the URI of the prefix being sought

        @return the prefix of an XML namespace declaration given its URI, or
        an empty string if no such @p uri exists in this XMLNamespaces object

        """
        return _libsbml.XMLNamespaces_getPrefix(self, *args)

    def getURI(self, *args):
        """
        getURI(self, int index) -> string
        getURI(self, string prefix = "") -> string
        getURI(self) -> string

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getURI(int index)</pre>

        Look up the URI of an XML namespace declaration by its position.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  This method returns the URI of the <code>n</code>th element
        in that list (if it exists).  Callers should use
        XMLAttributes.getLength() first to find out how many namespaces are
        stored in the list.

        @param index an integer, position of the required URI.

        @return the URI of an XML namespace declaration in this list (by
        position), or an empty string if the @p index is out of range.

        @see getLength()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getURI(string prefix = '')</pre>

        Look up the URI of an XML namespace declaration by its prefix.

        An XMLNamespaces object stores a list of pairs of namespaces and their
        prefixes.  This method returns the namespace URI for a pair that has
        the given @p prefix.

        @param prefix a string, the prefix of the required URI

        @return the URI of an XML namespace declaration having the given @p
        prefix, or an empty string if no such prefix-and-URI pair exists
        in this XMLNamespaces object

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see getURI()

        """
        return _libsbml.XMLNamespaces_getURI(self, *args)

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        XMLNamespaces list is empty.

        @return @c True if this XMLNamespaces list is empty, @c False otherwise.

        """
        return _libsbml.XMLNamespaces_isEmpty(self)

    def hasURI(self, *args):
        """
        hasURI(self, string uri) -> bool

        Predicate returning @c True or @c False depending on whether an XML
        Namespace with the given URI is contained in this XMLNamespaces list.

        @param uri a string, the uri for the namespace

        @return @c True if an XML Namespace with the given URI is contained in
        this XMLNamespaces list, @c False otherwise.

        """
        return _libsbml.XMLNamespaces_hasURI(self, *args)

    def hasPrefix(self, *args):
        """
        hasPrefix(self, string prefix) -> bool

        Predicate returning @c True or @c False depending on whether an XML
        Namespace with the given prefix is contained in this XMLNamespaces
        list.

        @param prefix a string, the prefix for the namespace

        @return @c True if an XML Namespace with the given URI is contained in
        this XMLNamespaces list, @c False otherwise.

        """
        return _libsbml.XMLNamespaces_hasPrefix(self, *args)

    def hasNS(self, *args):
        """
        hasNS(self, string uri, string prefix) -> bool

        Predicate returning @c True or @c False depending on whether an XML
        Namespace with the given URI and prefix pair is contained in this
        XMLNamespaces list.

        @param uri a string, the URI for the namespace
        @param prefix a string, the prefix for the namespace

        @return @c True if an XML Namespace with the given uri/prefix pair is
        contained in this XMLNamespaces list, @c False otherwise.

        """
        return _libsbml.XMLNamespaces_hasNS(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLNamespaces_swigregister = _libsbml.XMLNamespaces_swigregister
XMLNamespaces_swigregister(XMLNamespaces)

class XMLToken(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A token in libSBML's XML stream.

    @htmlinclude not-sbml-warning.html

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLToken, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLToken, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLToken
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0, unsigned int column = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, 
            unsigned int column = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0) -> XMLToken
        __init__(self, XMLTriple triple, XMLAttributes attributes) -> XMLToken
        __init__(self, XMLTriple triple, unsigned int line = 0, unsigned int column = 0) -> XMLToken
        __init__(self, XMLTriple triple, unsigned int line = 0) -> XMLToken
        __init__(self, XMLTriple triple) -> XMLToken
        __init__(self, string chars, unsigned int line = 0, unsigned int column = 0) -> XMLToken
        __init__(self, string chars, unsigned int line = 0) -> XMLToken
        __init__(self, string chars) -> XMLToken
        __init__(self, XMLToken orig) -> XMLToken

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLToken()</pre>

        Creates a new empty XMLToken.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLToken(XMLToken orig)</pre>

        Copy constructor; creates a copy of this XMLToken.

        @param orig the XMLToken object to copy.

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLToken(  XMLTriple      triple , XMLAttributes  attributes , const long    line   = 0 , const long    column = 0 )</pre>

        Creates a start element XMLToken with the given set of attributes.

        @param triple XMLTriple.
        @param attributes XMLAttributes, the attributes to set.
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLToken(  XMLTriple    triple , const long  line   = 0 , const long  column = 0 )</pre>

        Creates an end element XMLToken.

        @param triple XMLTriple.
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLToken(  XMLTriple      triple , XMLAttributes  attributes , XMLNamespaces  namespaces , const long    line   = 0 , const long    column = 0 )</pre>

        Creates a start element XMLToken with the given set of attributes and
        namespace declarations.

        @param triple XMLTriple.
        @param attributes XMLAttributes, the attributes to set.
        @param namespaces XMLNamespaces, the namespaces to set.
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLToken(  string  chars , const long  line   = 0 , const long  column = 0 )</pre>

        Creates a text XMLToken.

        @param chars a string, the text to be added to the XMLToken
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_XMLToken(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLToken

        Creates and returns a deep copy of this XMLToken object.

        @return the (deep) copy of this XMLToken object.

        """
        return _libsbml.XMLToken_clone(self)

    def getAttributes(self):
        """
        getAttributes(self) -> XMLAttributes

        Returns the attributes of this element.

        @return the XMLAttributes of this XML element.

        """
        return _libsbml.XMLToken_getAttributes(self)

    def setAttributes(self, *args):
        """
        setAttributes(self, XMLAttributes attributes) -> int

        Sets an XMLAttributes to this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @param attributes XMLAttributes to be set to this XMLToken.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note This function replaces the existing XMLAttributes with the new one.

        """
        return _libsbml.XMLToken_setAttributes(self, *args)

    def addAttr(self, *args):
        """
        addAttr(self, string name, string value, string namespaceURI = "", 
            string prefix = "") -> int
        addAttr(self, string name, string value, string namespaceURI = "") -> int
        addAttr(self, string name, string value) -> int
        addAttr(self, XMLTriple triple, string value) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addAttr( XMLTriple triple, string value)</pre>

        Adds an attribute with the given XMLTriple/value pair to the attribute set
        in this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @note if local name with the same namespace URI already exists in the 
        attribute set, its value and prefix will be replaced.

        @param triple an XMLTriple, the XML triple of the attribute.
        @param value a string, the value of the attribute.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>addAttr(  string name , string value , string namespaceURI = '' , string prefix = '')</pre>

        Adds an attribute to the attribute set in this XMLToken optionally 
        with a prefix and URI defining a namespace.
        Nothing will be done if this XMLToken is not a start element.

        @param name a string, the local name of the attribute.
        @param value a string, the value of the attribute.
        @param namespaceURI a string, the namespace URI of the attribute.
        @param prefix a string, the prefix of the namespace

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink

        @note if local name with the same namespace URI already exists in the
        attribute set, its value and prefix will be replaced.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLToken_addAttr(self, *args)

    def removeAttr(self, *args):
        """
        removeAttr(self, int n) -> int
        removeAttr(self, string name, string uri = "") -> int
        removeAttr(self, string name) -> int
        removeAttr(self, XMLTriple triple) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeAttr(XMLTriple triple)</pre>

        Removes an attribute with the given XMLTriple from the attribute set 
        in this XMLToken.  
        Nothing will be done if this XMLToken is not a start element.

        @param triple an XMLTriple, the XML triple of the attribute.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeAttr(int n)</pre>

        Removes an attribute with the given index from the attribute set in
        this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @param n an integer the index of the resource to be deleted

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeAttr(string name, string uri = '')</pre>

        Removes an attribute with the given local name and namespace URI from 
        the attribute set in this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @param name   a string, the local name of the attribute.
        @param uri    a string, the namespace URI of the attribute.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        """
        return _libsbml.XMLToken_removeAttr(self, *args)

    def clearAttributes(self):
        """
        clearAttributes(self) -> int

        Clears (deletes) all attributes in this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink

        """
        return _libsbml.XMLToken_clearAttributes(self)

    def getAttrIndex(self, *args):
        """
        getAttrIndex(self, string name, string uri = "") -> int
        getAttrIndex(self, string name) -> int
        getAttrIndex(self, XMLTriple triple) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getAttrIndex(XMLTriple triple)</pre>

        Return the index of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute for which 
        the index is required.

        @return the index of an attribute with the given XMLTriple, or <code>-1</code> if not present.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getAttrIndex(string name, string uri='')</pre>

        Return the index of an attribute with the given local name and namespace URI.

        @param name a string, the local name of the attribute.
        @param uri  a string, the namespace URI of the attribute.

        @return the index of an attribute with the given local name and namespace URI, 
        or <code>-1</code> if not present.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLToken_getAttrIndex(self, *args)

    def getAttributesLength(self):
        """
        getAttributesLength(self) -> int

        Return the number of attributes in the attributes set.

        @return the number of attributes in the attributes set in this XMLToken.

        """
        return _libsbml.XMLToken_getAttributesLength(self)

    def getAttrName(self, *args):
        """
        getAttrName(self, int index) -> string

        Return the local name of an attribute in the attributes set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose local name 
        is required.

        @return the local name of an attribute in this list (by position).  

        @note If index
        is out of range, an empty string will be returned.  Use
        XMLToken.hasAttr()
        to test for the attribute existence.

        """
        return _libsbml.XMLToken_getAttrName(self, *args)

    def getAttrPrefix(self, *args):
        """
        getAttrPrefix(self, int index) -> string

        Return the prefix of an attribute in the attribute set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose prefix is 
        required.

        @return the namespace prefix of an attribute in the attribute set
        (by position).  

        @note If index is out of range, an empty string will be returned. Use
        XMLToken.hasAttr() to test
        for the attribute existence.

        """
        return _libsbml.XMLToken_getAttrPrefix(self, *args)

    def getAttrPrefixedName(self, *args):
        """
        getAttrPrefixedName(self, int index) -> string

        Return the prefixed name of an attribute in the attribute set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose prefixed 
        name is required.

        @return the prefixed name of an attribute in the attribute set 
        (by position).  

        @note If index is out of range, an empty string will be returned.  Use
        XMLToken.hasAttr() to test
        for attribute existence.

        """
        return _libsbml.XMLToken_getAttrPrefixedName(self, *args)

    def getAttrURI(self, *args):
        """
        getAttrURI(self, int index) -> string

        Return the namespace URI of an attribute in the attribute set in this 
        XMLToken (by position).

        @param index an integer, the position of the attribute whose namespace 
        URI is required.

        @return the namespace URI of an attribute in the attribute set (by position).

        @note If index is out of range, an empty string will be returned.  Use
        XMLToken.hasAttr() to test
        for attribute existence.

        """
        return _libsbml.XMLToken_getAttrURI(self, *args)

    def getAttrValue(self, *args):
        """
        getAttrValue(self, int index) -> string
        getAttrValue(self, string name, string uri = "") -> string
        getAttrValue(self, string name) -> string
        getAttrValue(self, XMLTriple triple) -> string

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getAttrValue(XMLTriple triple)</pre>

        Return a value of an attribute with the given XMLTriple.

        @param triple an XMLTriple, the XML triple of the attribute whose 
        value is required.

        @return The attribute value as a string.  

        @note If an attribute with the
        given XMLTriple does not exist, an empty string will be returned.  
        Use XMLToken.hasAttr()
        to test for attribute existence.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getAttrValue(int index)</pre>

        Return the value of an attribute in the attribute set in this XMLToken  
        (by position).

        @param index an integer, the position of the attribute whose value is 
        required.

        @return the value of an attribute in the attribute set (by position).  

        @note If index is out of range, an empty string will be returned. Use
        XMLToken.hasAttr() to test
        for attribute existence.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getAttrValue(string name, string uri='')</pre>

        Return a value of an attribute with the given local name and namespace URI.

        @param name a string, the local name of the attribute whose value is required.
        @param uri  a string, the namespace URI of the attribute.

        @return The attribute value as a string.  

        @note If an attribute with the 
        given local name and namespace URI does not exist, an empty string will be 
        returned.  
        Use XMLToken.hasAttr()
        to test for attribute existence.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLToken_getAttrValue(self, *args)

    def hasAttr(self, *args):
        """
        hasAttr(self, int index) -> bool
        hasAttr(self, string name, string uri = "") -> bool
        hasAttr(self, string name) -> bool
        hasAttr(self, XMLTriple triple) -> bool

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>hasAttr(XMLTriple triple)</pre>

        Predicate returning @c True or @c False depending on whether
        an attribute with the given XML triple exists in the attribute set in 
        this XMLToken 

        @param triple an XMLTriple, the XML triple of the attribute 

        @return @c True if an attribute with the given XML triple exists
        in the attribute set in this XMLToken, @c False otherwise.

           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>hasAttr(int index)</pre>

        Predicate returning @c True or @c False depending on whether
        an attribute with the given index exists in the attribute set in this 
        XMLToken.

        @param index an integer, the position of the attribute.

        @return @c True if an attribute with the given index exists in the attribute 
        set in this XMLToken, @c False otherwise.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>hasAttr(string name, string uri='')</pre>

        Predicate returning @c True or @c False depending on whether
        an attribute with the given local name and namespace URI exists 
        in the attribute set in this XMLToken.

        @param name a string, the local name of the attribute.
        @param uri  a string, the namespace URI of the attribute.

        @return @c True if an attribute with the given local name and namespace 
        URI exists in the attribute set in this XMLToken, @c False otherwise.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLToken_hasAttr(self, *args)

    def isAttributesEmpty(self):
        """
        isAttributesEmpty(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        the attribute set in this XMLToken set is empty.

        @return @c True if the attribute set in this XMLToken is empty, 
        @c False otherwise.

        """
        return _libsbml.XMLToken_isAttributesEmpty(self)

    def getNamespaces(self):
        """
        getNamespaces(self) -> XMLNamespaces

        Returns the XML namespace declarations for this XML element.

        @return the XML namespace declarations for this XML element.

        """
        return _libsbml.XMLToken_getNamespaces(self)

    def setNamespaces(self, *args):
        """
        setNamespaces(self, XMLNamespaces namespaces) -> int

        Sets an XMLnamespaces to this XML element.
        Nothing will be done if this XMLToken is not a start element.

        @param namespaces XMLNamespaces to be set to this XMLToken.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @note This function replaces the existing XMLNamespaces with the new one.

        """
        return _libsbml.XMLToken_setNamespaces(self, *args)

    def addNamespace(self, *args):
        """
        addNamespace(self, string uri, string prefix = "") -> int
        addNamespace(self, string uri) -> int

        Appends an XML namespace prefix and URI pair to this XMLToken.
        If there is an XML namespace with the given prefix in this XMLToken, 
        then the existing XML namespace will be overwritten by the new one.

        Nothing will be done if this XMLToken is not a start element.

        @param uri a string, the uri for the namespace
        @param prefix a string, the prefix for the namespace

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLToken_addNamespace(self, *args)

    def removeNamespace(self, *args):
        """
        removeNamespace(self, int index) -> int
        removeNamespace(self, string prefix) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeNamespace(int index)</pre>

        Removes an XML Namespace stored in the given position of the XMLNamespaces
        of this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @param index an integer, position of the removed namespace.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>removeNamespace(string prefix)</pre>

        Removes an XML Namespace with the given prefix.
        Nothing will be done if this XMLToken is not a start element.

        @param prefix a string, prefix of the required namespace.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        """
        return _libsbml.XMLToken_removeNamespace(self, *args)

    def clearNamespaces(self):
        """
        clearNamespaces(self) -> int

        Clears (deletes) all XML namespace declarations in the XMLNamespaces of
        this XMLToken.
        Nothing will be done if this XMLToken is not a start element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink

        """
        return _libsbml.XMLToken_clearNamespaces(self)

    def getNamespaceIndex(self, *args):
        """
        getNamespaceIndex(self, string uri) -> int

        Look up the index of an XML namespace declaration by URI.

        @param uri a string, uri of the required namespace.

        @return the index of the given declaration, or <code>-1</code> if not present.

        """
        return _libsbml.XMLToken_getNamespaceIndex(self, *args)

    def getNamespaceIndexByPrefix(self, *args):
        """
        getNamespaceIndexByPrefix(self, string prefix) -> int

        Look up the index of an XML namespace declaration by prefix.

        @param prefix a string, prefix of the required namespace.

        @return the index of the given declaration, or <code>-1</code> if not present.

        """
        return _libsbml.XMLToken_getNamespaceIndexByPrefix(self, *args)

    def getNamespacesLength(self):
        """
        getNamespacesLength(self) -> int

        Returns the number of XML namespaces stored in the XMLNamespaces 
        of this XMLToken.

        @return the number of namespaces in this list.

        """
        return _libsbml.XMLToken_getNamespacesLength(self)

    def getNamespacePrefix(self, *args):
        """
        getNamespacePrefix(self, int index) -> string
        getNamespacePrefix(self, string uri) -> string

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getNamespacePrefix(int index)</pre>

        Look up the prefix of an XML namespace declaration by position.

        Callers should use getNamespacesLength() to find out how many 
        namespaces are stored in the XMLNamespaces.

        @param index an integer, position of the required prefix.

        @return the prefix of an XML namespace declaration in the XMLNamespaces 
        (by position).  

        @note If index is out of range, an empty string will be
        returned.

        @see getNamespacesLength()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getNamespacePrefix(string uri)</pre>

        Look up the prefix of an XML namespace declaration by its URI.

        @param uri a string, the URI of the prefix being sought

        @return the prefix of an XML namespace declaration given its URI.  

        @note If @p uri does not exist, an empty string will be returned.

        """
        return _libsbml.XMLToken_getNamespacePrefix(self, *args)

    def getNamespaceURI(self, *args):
        """
        getNamespaceURI(self, int index) -> string
        getNamespaceURI(self, string prefix = "") -> string
        getNamespaceURI(self) -> string

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getNamespaceURI(int index)</pre>

        Look up the URI of an XML namespace declaration by its position.

        @param index an integer, position of the required URI.

        @return the URI of an XML namespace declaration in the XMLNamespaces
        (by position).  

        @note If @p index is out of range, an empty string will be
        returned.

        @see getNamespacesLength()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getNamespaceURI(string prefix = '')</pre>

        Look up the URI of an XML namespace declaration by its prefix.

        @param prefix a string, the prefix of the required URI

        @return the URI of an XML namespace declaration given its prefix.  

        @note If @p prefix does not exist, an empty string will be returned.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLToken_getNamespaceURI(self, *args)

    def isNamespacesEmpty(self):
        """
        isNamespacesEmpty(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        the XMLNamespaces of this XMLToken is empty.

        @return @c True if the XMLNamespaces of this XMLToken is empty, 
        @c False otherwise.

        """
        return _libsbml.XMLToken_isNamespacesEmpty(self)

    def hasNamespaceURI(self, *args):
        """
        hasNamespaceURI(self, string uri) -> bool

        Predicate returning @c True or @c False depending on whether 
        an XML Namespace with the given URI is contained in the XMLNamespaces of
        this XMLToken.

        @param uri a string, the uri for the namespace

        @return @c True if an XML Namespace with the given URI is contained in the
        XMLNamespaces of this XMLToken,  @c False otherwise.

        """
        return _libsbml.XMLToken_hasNamespaceURI(self, *args)

    def hasNamespacePrefix(self, *args):
        """
        hasNamespacePrefix(self, string prefix) -> bool

        Predicate returning @c True or @c False depending on whether 
        an XML Namespace with the given prefix is contained in the XMLNamespaces of
        this XMLToken.

        @param prefix a string, the prefix for the namespace

        @return @c True if an XML Namespace with the given URI is contained in the
        XMLNamespaces of this XMLToken, @c False otherwise.

        """
        return _libsbml.XMLToken_hasNamespacePrefix(self, *args)

    def hasNamespaceNS(self, *args):
        """
        hasNamespaceNS(self, string uri, string prefix) -> bool

        Predicate returning @c True or @c False depending on whether 
        an XML Namespace with the given uri/prefix pair is contained in the 
        XMLNamespaces ofthis XMLToken.

        @param uri a string, the uri for the namespace
        @param prefix a string, the prefix for the namespace

        @return @c True if an XML Namespace with the given uri/prefix pair is 
        contained in the XMLNamespaces of this XMLToken,  @c False otherwise.

        """
        return _libsbml.XMLToken_hasNamespaceNS(self, *args)

    def setTriple(self, *args):
        """
        setTriple(self, XMLTriple triple) -> int

        Sets the XMLTripe (name, uri and prefix) of this XML element.
        Nothing will be done if this XML element is a text node.

        @param triple XMLTriple to be added to this XML element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.XMLToken_setTriple(self, *args)

    def getName(self):
        """
        getName(self) -> string

        Returns the (unqualified) name of this XML element.

        @return the (unqualified) name of this XML element.

        """
        return _libsbml.XMLToken_getName(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        Returns the namespace prefix of this XML element.

        @return the namespace prefix of this XML element.  

        @note If no prefix
        exists, an empty string will be return.

        """
        return _libsbml.XMLToken_getPrefix(self)

    def getURI(self):
        """
        getURI(self) -> string

        Returns the namespace URI of this XML element.

        @return the namespace URI of this XML element.

        """
        return _libsbml.XMLToken_getURI(self)

    def getCharacters(self):
        """
        getCharacters(self) -> string

        Returns the text of this element.

        @return the characters of this XML text.

        """
        return _libsbml.XMLToken_getCharacters(self)

    def append(self, *args):
        """
        append(self, string chars) -> int

        Appends characters to this XML text content.

        @param chars string, characters to append

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.XMLToken_append(self, *args)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        Returns the column at which this XMLToken occurred in the input
        document or data stream.

        @return the column at which this XMLToken occurred.

        """
        return _libsbml.XMLToken_getColumn(self)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        Returns the line at which this XMLToken occurred in the input document
        or data stream.

        @return the line at which this XMLToken occurred.

        """
        return _libsbml.XMLToken_getLine(self)

    def isElement(self):
        """
        isElement(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLToken is an XML element.

        @return @c True if this XMLToken is an XML element, @c False otherwise.

        """
        return _libsbml.XMLToken_isElement(self)

    def isEnd(self):
        """
        isEnd(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLToken is an XML end element.

        @return @c True if this XMLToken is an XML end element, @c False otherwise.

        """
        return _libsbml.XMLToken_isEnd(self)

    def isEndFor(self, *args):
        """
        isEndFor(self, XMLToken element) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLToken is an XML end element for the given start element.

        @param element XMLToken, element for which query is made.

        @return @c True if this XMLToken is an XML end element for the given
        XMLToken start element, @c False otherwise.

        """
        return _libsbml.XMLToken_isEndFor(self, *args)

    def isEOF(self):
        """
        isEOF(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLToken is an end of file marker.

        @return @c True if this XMLToken is an end of file (input) marker, @c False
        otherwise.

        """
        return _libsbml.XMLToken_isEOF(self)

    def isStart(self):
        """
        isStart(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLToken is an XML start element.

        @return @c True if this XMLToken is an XML start element, @c False otherwise.

        """
        return _libsbml.XMLToken_isStart(self)

    def isText(self):
        """
        isText(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLToken is an XML text element.

        @return @c True if this XMLToken is an XML text element, @c False otherwise.

        """
        return _libsbml.XMLToken_isText(self)

    def setEnd(self):
        """
        setEnd(self) -> int

        Declares this XML start element is also an end element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.XMLToken_setEnd(self)

    def setEOF(self):
        """
        setEOF(self) -> int

        Declares this XMLToken is an end-of-file (input) marker.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.XMLToken_setEOF(self)

    def unsetEnd(self):
        """
        unsetEnd(self) -> int

        Declares this XML start/end element is no longer an end element.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.XMLToken_unsetEnd(self)

    def toString(self):
        """
        toString(self) -> string

        Prints a string representation of the underlying token stream, for
        debugging purposes.

        """
        return _libsbml.XMLToken_toString(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLToken_swigregister = _libsbml.XMLToken_swigregister
XMLToken_swigregister(XMLToken)

class XMLNode(XMLToken):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A node in libSBML's XML document tree.

    Beginning with version 3.0.0, libSBML implements an XML abstraction
    layer.  This layer presents a uniform XML interface to calling programs
    regardless of which underlying XML parser libSBML has actually been
    configured to use.  The basic data object in the XML abstraction is a
    @em node, represented by XMLNode.

    An XMLNode can contain any number of children.  Each child is another
    XMLNode, thereby forming a tree.  The methods XMLNode.getNumChildren()
    and XMLNode.getChild() can be used to access the tree
    structure starting from a given node.

    Each XMLNode is subclassed from XMLToken, and thus has the same methods
    available as XMLToken.  These methods include XMLToken.getNamespaces(),
    XMLToken.getPrefix(), XMLToken.getName(), XMLToken.getURI(), and
    XMLToken.getAttributes().

    @section xmlnode-str2xmlnode Conversion between an XML string and an XMLNode

    LibSBML provides the following utility functions for converting an XML
    string (e.g., <code>&lt;annotation&gt;...&lt;/annotation&gt;</code>)
    to/from an XMLNode object.
    <ul>
    <li> XMLNode.toXMLString() returns a string representation of the XMLNode object. 

    <li> XMLNode.convertXMLNodeToString()
    (static function) returns a string representation 
    of the given XMLNode object.

    <li> XMLNode.convertStringToXMLNode()
    (static function) returns an XMLNode object converted 
    from the given XML string.
    </ul>

    The returned XMLNode object by XMLNode.convertStringToXMLNode()
    is a dummy root (container) XMLNode if the given XML string has two or
    more top-level elements (e.g.,
    &quot;<code>&lt;p&gt;...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;</code>&quot;). In the
    dummy root node, each top-level element in the given XML string is
    contained as a child XMLNode. XMLToken.isEOF() can be used to identify
    if the returned XMLNode object is a dummy node or not.  Here is an
    example: @if clike
    @verbatim
    // Checks if the XMLNode object returned by XMLNode.convertStringToXMLNode() is a dummy root node:
                                                                                             
    string str = '...'; 
    XMLNode xn = XMLNode.convertStringToXMLNode();                                      
    if ( xn == None )
    {                                                                                      
      // returned value is null (error)                                                    
      ...
    }                                                                                      
    else if ( xn->isEOF() )                                                                 
    {                                                                                      
      // root node is a dummy node                                                         
      for ( int i = 0; i < xn->getNumChildren(); i++ )                                          
      {                                                                                    
        // access to each child node of the dummy node.                                    
        XMLNode xnChild = xn->getChild(i);                                                  
        ...                                                                                
      }                                                                                    
    }                                                                                      
    else                                                                                   
    {                                                                                      
      // root node is NOT a dummy node                                                     
      ...                                                                                  
    }
    @endverbatim
    @endif@if java
    @verbatim
    // Checks if the returned XMLNode object is a dummy root node:

    String str = '...';
    XMLNode xn = XMLNode.convertStringToXMLNode(str);
    if ( xn == null )
    {
      // returned value is null (error)
      ...
    }
    else if ( xn.isEOF() )
    {
      // root node is a dummy node
      for ( int i = 0; i < xn.getNumChildren(); i++ )
      {
        // access to each child node of the dummy node.
        XMLNode xnChild = xn.getChild(i);
        ...
      }
    }
    else
    {
      // root node is NOT a dummy node
      ...
    }
    @endverbatim
    @endif@if python
    @verbatim
    xn = XMLNode.convertStringToXMLNode('<p></p>')
    if xn == None:
      # Do something to handle exceptional situation.

    elif xn.isEOF():
      # Node is a dummy node.

    else:
      # None is not a dummy node.
    @endverbatim
    @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [XMLToken]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLNode, name, value)
    __swig_getmethods__ = {}
    for _s in [XMLToken]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, XMLNode, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_XMLNode
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> XMLNode
        __init__(self, XMLToken token) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0, unsigned int column = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, 
            unsigned int line = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, 
            unsigned int column = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes, unsigned int line = 0) -> XMLNode
        __init__(self, XMLTriple triple, XMLAttributes attributes) -> XMLNode
        __init__(self, XMLTriple triple, unsigned int line = 0, unsigned int column = 0) -> XMLNode
        __init__(self, XMLTriple triple, unsigned int line = 0) -> XMLNode
        __init__(self, XMLTriple triple) -> XMLNode
        __init__(self, string chars, unsigned int line = 0, unsigned int column = 0) -> XMLNode
        __init__(self, string chars, unsigned int line = 0) -> XMLNode
        __init__(self, string chars) -> XMLNode
        __init__(self, XMLInputStream stream) -> XMLNode
        __init__(self, XMLNode orig) -> XMLNode

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode(XMLToken token)</pre>

        Creates a new XMLNode by copying token.

        @param token XMLToken to be copied to XMLNode
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode(  XMLTriple     triple , XMLAttributes attributes , XMLNamespaces namespaces , const long   line   = 0 , const long   column = 0 )</pre>

        Creates a new start element XMLNode with the given set of attributes and
        namespace declarations.

        @param triple XMLTriple.
        @param attributes XMLAttributes, the attributes to set.
        @param namespaces XMLNamespaces, the namespaces to set.
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode(XMLNode orig)</pre>

        Copy constructor; creates a copy of this XMLNode.

        @param orig the XMLNode instance to copy.

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode()</pre>

        Creates a new empty XMLNode with no children.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode(  XMLTriple      triple , XMLAttributes  attributes , const long    line   = 0 , const long    column = 0 )</pre>

        Creates a start element XMLNode with the given set of attributes.

        @param triple XMLTriple.
        @param attributes XMLAttributes, the attributes to set.
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
          

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode(  XMLTriple    triple , const long  line   = 0 , const long  column = 0 )</pre>

        Creates an end element XMLNode.

        @param triple XMLTriple.
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLNode(  string  chars , const long  line   = 0 , const long  column = 0 )</pre>

        Creates a text XMLNode.

        @param chars a string, the text to be added to the XMLToken
        @param line a long integer, the line number (default = 0).
        @param column a long integer, the column number (default = 0).

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_XMLNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLNode

        Creates and returns a deep copy of this XMLNode object.

        @return the (deep) copy of this XMLNode object.

        """
        return _libsbml.XMLNode_clone(self)

    def addChild(self, *args):
        """
        addChild(self, XMLNode node) -> int

        Adds a copy of @p node as a child of this XMLNode.

        The given @p node is added at the end of the list of children.

        @param node the XMLNode to be added as child.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION@endlink

        @note The given node is added at the end of the children list.

        """
        return _libsbml.XMLNode_addChild(self, *args)

    def insertChild(self, *args):
        """
        insertChild(self, unsigned int n, XMLNode node) -> XMLNode

        Inserts a copy of the given node as the <code>n</code>th child of this
        XMLNode.

        If the given index @p n is out of range for this XMLNode instance,
        the @p node is added at the end of the list of children.  Even in
        that situation, this method does not throw an error.

        @param n an integer, the index at which the given node is inserted
        @param node an XMLNode to be inserted as <code>n</code>th child.

        @return a reference to the newly-inserted child @p node

        """
        return _libsbml.XMLNode_insertChild(self, *args)

    def removeChild(self, *args):
        """
        removeChild(self, unsigned int n) -> XMLNode

        Removes the <code>n</code>th child of this XMLNode and returns the
        removed node.

        It is important to keep in mind that a given XMLNode may have more
        than one child.  Calling this method erases all existing references to
        child nodes @em after the given position @p n.  If the index @p n is
        greater than the number of child nodes in this XMLNode, this method
        takes no action (and returns @c None).

        @param n an integer, the index of the node to be removed

        @return the removed child, or @c None if @p n is greater than the number
        of children in this node

        @note The caller owns the returned node and is responsible for deleting it.

        """
        return _libsbml.XMLNode_removeChild(self, *args)

    def removeChildren(self):
        """
        removeChildren(self) -> int

        Removes all children from this node.
        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.XMLNode_removeChildren(self)

    def getChild(self, *args):
        """
        getChild(self, unsigned int n) -> XMLNode
        getChild(self, unsigned int n) -> XMLNode
        getChild(self, string name) -> XMLNode
        getChild(self, string name) -> XMLNode

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getChild(long n)</pre>

        Returns the  <code>n</code>th child of this XMLNode.

        If the index @p n is greater than the number of child nodes,
        this method returns an empty node.

        @param n a long integereger, the index of the node to return

        @return the <code>n</code>th child of this XMLNode.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getChild(string  name)</pre>

        Returns the first child of this XMLNode with the corresponding name.

        If no child with corrsponding name can be found, 
        this method returns an empty node.

        @param name the name of the node to return

        @return the first child of this XMLNode with given name.

        """
        return _libsbml.XMLNode_getChild(self, *args)

    def getIndex(self, *args):
        """
        getIndex(self, string name) -> int

        Return the index of the first child of this XMLNode with the given name.

        @param name a string, the name of the child for which the 
        index is required.

        @return the index of the first child of this XMLNode with the given
        name, or -1 if not present.

        """
        return _libsbml.XMLNode_getIndex(self, *args)

    def hasChild(self, *args):
        """
        hasChild(self, string name) -> bool

        Return a boolean indicating whether this XMLNode has a child with the
        given name.

        @param name a string, the name of the child to be checked.

        @return boolean indicating whether this XMLNode has a child with the
        given name.

        """
        return _libsbml.XMLNode_hasChild(self, *args)

    def equals(self, *args):
        """
        equals(self, XMLNode other, bool ignoreURI = False) -> bool
        equals(self, XMLNode other) -> bool

        Compare this XMLNode against another XMLNode returning true if both
        nodes represent the same XML tree, or false otherwise.

        @param other another XMLNode to compare against.

        @param ignoreURI whether to ignore the namespace URI when doing the
        comparison.

        @return boolean indicating whether this XMLNode represents the same XML
        tree as another.

        """
        return _libsbml.XMLNode_equals(self, *args)

    def getNumChildren(self):
        """
        getNumChildren(self) -> unsigned int

        Returns the number of children for this XMLNode.

        @return the number of children for this XMLNode.

        """
        return _libsbml.XMLNode_getNumChildren(self)

    def toXMLString(self):
        """
        toXMLString(self) -> string

        Returns a string representation of this XMLNode. 

        @return a string derived from this XMLNode.

        """
        return _libsbml.XMLNode_toXMLString(self)

    def convertXMLNodeToString(*args):
        """
        convertXMLNodeToString(XMLNode node) -> string

        Returns a string representation of a given XMLNode. 

        @param node the XMLNode to be represented as a string

        @return a string-form representation of @p node

        """
        return _libsbml.XMLNode_convertXMLNodeToString(*args)

    if _newclass:convertXMLNodeToString = staticmethod(convertXMLNodeToString)
    __swig_getmethods__["convertXMLNodeToString"] = lambda x: convertXMLNodeToString
    def convertStringToXMLNode(*args):
        """
        convertStringToXMLNode(string xmlstr, XMLNamespaces xmlns = None) -> XMLNode
        convertStringToXMLNode(string xmlstr) -> XMLNode

        Returns an XMLNode which is derived from a string containing XML
        content.

        The XML namespace must be defined using argument @p xmlns if the
        corresponding XML namespace attribute is not part of the string of the
        first argument.

        @param xmlstr string to be converted to a XML node.
        @param xmlns XMLNamespaces the namespaces to set (default value is @c None).

        @note The caller owns the returned XMLNode and is reponsible for
        deleting it.  The returned XMLNode object is a dummy root (container)
        XMLNode if the top-level element in the given XML string is NOT
        <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>,
        <code>&lt;annotation&gt;</code>, or <code>&lt;notes&gt;</code>.  In
        the dummy root node, each top-level element in the given XML string is
        contained as a child XMLNode. XMLToken.isEOF() can be used to
        identify if the returned XMLNode object is a dummy node.

        @return a XMLNode which is converted from string @p xmlstr.  If the
        conversion failed, this method returns @c None.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLNode_convertStringToXMLNode(*args)

    if _newclass:convertStringToXMLNode = staticmethod(convertStringToXMLNode)
    __swig_getmethods__["convertStringToXMLNode"] = lambda x: convertStringToXMLNode
XMLNode_swigregister = _libsbml.XMLNode_swigregister
XMLNode_swigregister(XMLNode)

def XMLNode_convertXMLNodeToString(*args):
  """
    XMLNode_convertXMLNodeToString(XMLNode node) -> string

    Returns a string representation of a given XMLNode. 

    @param node the XMLNode to be represented as a string

    @return a string-form representation of @p node

    """
  return _libsbml.XMLNode_convertXMLNodeToString(*args)

def XMLNode_convertStringToXMLNode(*args):
  """
    convertStringToXMLNode(string xmlstr, XMLNamespaces xmlns = None) -> XMLNode
    XMLNode_convertStringToXMLNode(string xmlstr) -> XMLNode

    Returns an XMLNode which is derived from a string containing XML
    content.

    The XML namespace must be defined using argument @p xmlns if the
    corresponding XML namespace attribute is not part of the string of the
    first argument.

    @param xmlstr string to be converted to a XML node.
    @param xmlns XMLNamespaces the namespaces to set (default value is @c None).

    @note The caller owns the returned XMLNode and is reponsible for
    deleting it.  The returned XMLNode object is a dummy root (container)
    XMLNode if the top-level element in the given XML string is NOT
    <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>,
    <code>&lt;annotation&gt;</code>, or <code>&lt;notes&gt;</code>.  In
    the dummy root node, each top-level element in the given XML string is
    contained as a child XMLNode. XMLToken.isEOF() can be used to
    identify if the returned XMLNode object is a dummy node.

    @return a XMLNode which is converted from string @p xmlstr.  If the
    conversion failed, this method returns @c None.

    @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

    """
  return _libsbml.XMLNode_convertStringToXMLNode(*args)

class XMLTriple(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A qualified XML name.

    @htmlinclude not-sbml-warning.html

    A 'triple' in the libSBML XML layer encapsulates the notion of qualified
    name, meaning an element name or an attribute name with an optional
    namespace qualifier.  An XMLTriple instance carries up to three data items:

    <ul>

    <li> The name of the attribute or element; that is, the attribute name
    as it appears in an XML document or data stream;

    <li> The XML namespace prefix (if any) of the attribute.  For example,
    in the following fragment of XML, the namespace prefix is the string
    <code>mysim</code> and it appears on both the element
    <code>someelement</code> and the attribute <code>attribA</code>.  When
    both the element and the attribute are stored as XMLTriple objects,
    their <i>prefix</i> is <code>mysim</code>.
    @verbatim
    <mysim:someelement mysim:attribA='value' />
    @endverbatim

    <li> The XML namespace URI with which the prefix is associated.  In
    XML, every namespace used must be declared and mapped to a URI.

    </ul>

    XMLTriple objects are the lowest-level data item in the XML layer
    of libSBML.  Other objects such as XMLToken make use of XMLTriple
    objects.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLTriple, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLTriple, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> XMLTriple
        __init__(self, string name, string uri, string prefix) -> XMLTriple
        __init__(self, string triplet, char sepchar = ' ') -> XMLTriple
        __init__(self, string triplet) -> XMLTriple
        __init__(self, XMLTriple orig) -> XMLTriple

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLTriple(  string  name , string  uri , string  prefix )</pre>

        Creates a new XMLTriple with the given @p name, @p uri and and @p
        prefix.

        @param name a string, name for the XMLTriple.
        @param uri a string, URI of the XMLTriple.
        @param prefix a string, prefix for the URI of the XMLTriple,

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLTriple(string triplet, const char sepchar = ' ')</pre>

        Creates a new XMLTriple by splitting the given @p triplet on the
        separator character @p sepchar.

        Triplet may be in one of the following formats:
        <ul>
        <li> name
        <li> URI sepchar name
        <li> URI sepchar name sepchar prefix
        </ul>
        @param triplet a string representing the triplet as above
        @param sepchar a character, the sepchar used in the triplet

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLTriple()</pre>

        Creates a new, empty XMLTriple.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLTriple(XMLTriple orig)</pre>

        Copy constructor; creates a copy of this XMLTriple set.

        @param orig the XMLTriple object to copy.

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_XMLTriple(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> XMLTriple

        Creates and returns a deep copy of this XMLTriple object.

        @return the (deep) copy of this XMLTriple object.

        """
        return _libsbml.XMLTriple_clone(self)

    def getName(self):
        """
        getName(self) -> string

        Returns the @em name portion of this XMLTriple.

        @return a string, the name from this XMLTriple.

        """
        return _libsbml.XMLTriple_getName(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        Returns the @em prefix portion of this XMLTriple.

        @return a string, the @em prefix portion of this XMLTriple.

        """
        return _libsbml.XMLTriple_getPrefix(self)

    def getURI(self):
        """
        getURI(self) -> string

        Returns the @em URI portion of this XMLTriple.

        @return URI a string, the @em prefix portion of this XMLTriple.

        """
        return _libsbml.XMLTriple_getURI(self)

    def getPrefixedName(self):
        """
        getPrefixedName(self) -> string

        Returns the prefixed name from this XMLTriple.

        @return a string, the prefixed name from this XMLTriple.

        """
        return _libsbml.XMLTriple_getPrefixedName(self)

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this XMLTriple is empty.

        @return @c True if this XMLTriple is empty, @c False otherwise.

        """
        return _libsbml.XMLTriple_isEmpty(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    __swig_destroy__ = _libsbml.delete_XMLTriple
    __del__ = lambda self : None;
XMLTriple_swigregister = _libsbml.XMLTriple_swigregister
XMLTriple_swigregister(XMLTriple)

class XMLOutputStream(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Interface to an XML output stream.

    @htmlinclude not-sbml-warning.html

    SBML content is serialized using XML; the resulting data can be stored and
    read to/from a file or data stream.  Low-level XML parsers such as Xerces
    provide facilities to read XML data.  To permit the use of different XML
    parsers (Xerces, Expat or libxml2), libSBML implements an abstraction
    layer.  XMLInputStream and XMLOutputStream are two parts of that
    abstraction layer.

    XMLOutputStream provides a wrapper above a standard ostream to facilitate
    writing XML.  XMLOutputStream keeps track of start and end elements,
    indentation, XML namespace prefixes, and more.  The interface provides
    features for converting non-text data types into appropriate textual form;
    this takes the form of overloaded <code>writeAttribute</code> methods that
    allow users to simply use the same method with any data type.  For example,
    @verbatim
    double size = 3.2;
    string id = 'id';
    @endverbatim
    can be written out using
    @verbatim
    writeAttribute('size', size);
    writeAttribute('id', id);
    @endverbatim

    Other classes in SBML take XMLOutputStream objects as arguments, and use
    that to write elements and attributes seamlessly to the XML output stream.

    It is also worth noting that unlike XMLInputStream, XMLOutputStream is
    actually independent of the underlying XML parsers.  It does not use the
    XML parser libraries at all.

    @note The convenience of the XMLInputStream and XMLOutputStream
    abstraction may be useful for developers interested in creating parsers
    for other XML formats besides SBML.  It can provide developers with a
    layer above more basic XML parsers, as well as some useful programmatic
    elements such as XMLToken, XMLError, etc.

    @see XMLInputStream

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLOutputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLOutputStream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ostream stream, string encoding = "UTF-8", bool writeXMLDecl = True, 
            string programName = "", string programVersion = "") -> XMLOutputStream
        __init__(self, ostream stream, string encoding = "UTF-8", bool writeXMLDecl = True, 
            string programName = "") -> XMLOutputStream
        __init__(self, ostream stream, string encoding = "UTF-8", bool writeXMLDecl = True) -> XMLOutputStream
        __init__(self, ostream stream, string encoding = "UTF-8") -> XMLOutputStream
        __init__(self, ostream stream) -> XMLOutputStream

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html Interface to an XML output stream.

        @htmlinclude not-sbml-warning.html

        SBML content is serialized using XML; the resulting data can be stored and
        read to/from a file or data stream.  Low-level XML parsers such as Xerces
        provide facilities to read XML data.  To permit the use of different XML
        parsers (Xerces, Expat or libxml2), libSBML implements an abstraction
        layer.  XMLInputStream and XMLOutputStream are two parts of that
        abstraction layer.

        XMLOutputStream provides a wrapper above a standard ostream to facilitate
        writing XML.  XMLOutputStream keeps track of start and end elements,
        indentation, XML namespace prefixes, and more.  The interface provides
        features for converting non-text data types into appropriate textual form;
        this takes the form of overloaded <code>writeAttribute</code> methods that
        allow users to simply use the same method with any data type.  For example,
        @verbatim
        double size = 3.2;
        string id = 'id';
        @endverbatim
        can be written out using
        @verbatim
        writeAttribute('size', size);
        writeAttribute('id', id);
        @endverbatim

        Other classes in SBML take XMLOutputStream objects as arguments, and use
        that to write elements and attributes seamlessly to the XML output stream.

        It is also worth noting that unlike XMLInputStream, XMLOutputStream is
        actually independent of the underlying XML parsers.  It does not use the
        XML parser libraries at all.

        @note The convenience of the XMLInputStream and XMLOutputStream
        abstraction may be useful for developers interested in creating parsers
        for other XML formats besides SBML.  It can provide developers with a
        layer above more basic XML parsers, as well as some useful programmatic
        elements such as XMLToken, XMLError, etc.

        @see XMLInputStream

        """
        this = _libsbml.new_XMLOutputStream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_XMLOutputStream
    __del__ = lambda self : None;
    def endElement(self, *args):
        """
        endElement(self, string name, string prefix = "")
        endElement(self, string name)
        endElement(self, XMLTriple triple)

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>endElement(XMLTriple triple)</pre>

        Writes the given element to the stream.

        @param triple the XML element to write.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>endElement(string name, string prefix = '')</pre>

        Writes the given XML end element name to this XMLOutputStream.

        @param name the name of the element.

        @param prefix an optional XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLOutputStream_endElement(self, *args)

    def setAutoIndent(self, *args):
        """
        setAutoIndent(self, bool indent)

        Turns automatic indentation on or off for this XMLOutputStream.

        @param indent if @c True, automatic indentation is turned on.

        """
        return _libsbml.XMLOutputStream_setAutoIndent(self, *args)

    def startElement(self, *args):
        """
        startElement(self, string name, string prefix = "")
        startElement(self, string name)
        startElement(self, XMLTriple triple)

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>startElement(XMLTriple triple)</pre>

        Writes the given XML start element
        <code><em>prefix</em>:<em>name</em></code> on this output stream.

        @param triple the start element to write.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>startElement(string name, string prefix = '')</pre>

        Writes the given XML start element name to this XMLOutputStream.

        @param name the name of the element.

        @param prefix an optional XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLOutputStream_startElement(self, *args)

    def startEndElement(self, *args):
        """
        startEndElement(self, string name, string prefix = "")
        startEndElement(self, string name)
        startEndElement(self, XMLTriple triple)

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>startEndElement(XMLTriple triple)</pre>

        Writes the given start element to this output stream.

        @param triple the XML element to write.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>startEndElement(string name, string prefix = '')</pre>

        Writes the given XML start and end element name to this XMLOutputStream.

        @param name the name of the element.

        @param prefix an optional XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLOutputStream_startEndElement(self, *args)

    def writeAttribute(self, *args):
        """
        writeAttribute(self, string name, string value)
        writeAttribute(self, string name, string prefix, string value)
        writeAttribute(self, XMLTriple triple, string value)
        writeAttribute(self, string name, char value)
        writeAttribute(self, string name, string prefix, char value)
        writeAttribute(self, XMLTriple triple, char value)
        writeAttribute(self, string name, bool value)
        writeAttribute(self, string name, string prefix, bool value)
        writeAttribute(self, XMLTriple triple, bool value)
        writeAttribute(self, string name, double value)
        writeAttribute(self, string name, string prefix, double value)
        writeAttribute(self, XMLTriple triple, double value)
        writeAttribute(self, string name, long value)
        writeAttribute(self, string name, string prefix, long value)
        writeAttribute(self, XMLTriple triple, long value)
        writeAttribute(self, string name, int value)
        writeAttribute(self, string name, string prefix, int value)
        writeAttribute(self, XMLTriple triple, int value)
        writeAttribute(self, string name, string prefix, unsigned int value)

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, string value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string prefix, const double& value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string prefix, string value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, const bool& value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, const double& value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, const long& value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, const double& value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, const long& value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string prefix, const long& value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string prefix, const long& value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string prefix, const int& value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, const long& value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, const int& value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, const int& value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, const bool& value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(XMLTriple triple, string value)</pre>

        Writes the given attribute and value to this output stream.

        @param triple the attribute, in the form of an XMLTriple.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, const long& value)</pre>

        Writes the given attribute and value to this output stream.

        @param name the name of the attribute.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string prefix, string value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>writeAttribute(string name, string &prefix, const bool& value)</pre>

        Writes the given namespace-prefixed attribute value to this output stream.

        @param name the name of the attribute.

        @param prefix an XML namespace prefix to write in front of the
        @p element name.  (The result has the form
        <code><em>prefix</em>:<em>name</em></code>.)  See other versions of
        this method for a variant that does not require a prefix.

        @param value the value of the attribute.

        """
        if type(args[1]) == type(True): return _libsbml.XMLOutputStream_writeAttributeBool(self, *args)


        return _libsbml.XMLOutputStream_writeAttribute(self, *args)

    def writeXMLDecl(self):
        """
        writeXMLDecl(self)

        Writes a standard XML declaration to this output stream.

        @par
        The XML declaration has the form
        @verbatim
        <?xml version='1.0' encoding='UTF-8'?>
        @endverbatim
        Note that the SBML specifications require the use of UTF-8 encoding and
        version 1.0, so for SBML documents, the above is the standard XML
        declaration.

        """
        return _libsbml.XMLOutputStream_writeXMLDecl(self)

    def writeComment(self, *args):
        """
        writeComment(self, string programName, string programVersion)

        Writes an XML comment with the name and version of this program.

        The XML comment has the following form:
        @verbatim
        <!-- Created by <program name> version <program version>
        on yyyy-MM-dd HH:mm with libSBML version <libsbml version>. -->
        @endverbatim

        See the class constructor for more information about this program
        comment.

        @param programName an optional program name to write as a comment
        in the output stream.

        @param programVersion an optional version identification string to write
        as a comment in the output stream.

        """
        return _libsbml.XMLOutputStream_writeComment(self, *args)

    def downIndent(self):
        """
        downIndent(self)

        Decreases the indentation level for this XMLOutputStream.

        """
        return _libsbml.XMLOutputStream_downIndent(self)

    def upIndent(self):
        """
        upIndent(self)

        Increases the indentation level for this XMLOutputStream.

        """
        return _libsbml.XMLOutputStream_upIndent(self)

    def getSBMLNamespaces(self):
        """
        getSBMLNamespaces(self) -> SBMLNamespaces

        Returns the SBMLNamespaces object attached to this output stream.

        @return the SBMLNamespaces object, or @c None if none has been set.

        """
        return _libsbml.XMLOutputStream_getSBMLNamespaces(self)

    def setSBMLNamespaces(self, *args):
        """
        setSBMLNamespaces(self, SBMLNamespaces sbmlns)

        Sets the SBMLNamespaces object associated with this output stream.

        @param sbmlns the namespace object.

        """
        return _libsbml.XMLOutputStream_setSBMLNamespaces(self, *args)

    def writeAttributeBool(self, *args):
        """
        writeAttributeBool(self, string name, bool value)
        writeAttributeBool(self, XMLTriple name, bool value)
        """
        return _libsbml.XMLOutputStream_writeAttributeBool(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLOutputStream_swigregister = _libsbml.XMLOutputStream_swigregister
XMLOutputStream_swigregister(XMLOutputStream)

class XMLInputStream(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An interface to an XML input stream.

    @htmlinclude not-sbml-warning.html

    SBML content is serialized using XML; the resulting data can be stored and
    read to/from a file or data stream.  Low-level XML parsers such as Xerces
    provide facilities to read XML data.  To permit the use of different XML
    parsers (Xerces, Expat or libxml2), libSBML implements an abstraction
    layer.  XMLInputStream and XMLOutputStream are two parts of that
    abstraction layer.

    XMLInputStream is an interface to a file or text string containing XML.
    It wraps the content to be read, as well as the low-level XML parser to be
    used and an XMLErrorLog to record errors and other issues (if any arise).
    Internally, the content will be in the form of either a pointer to a file
    name or a character string; XMLInputStream knows the form of the content
    and acts appropriately.  Other libSBML object classes use XMLInputStream
    as their interface for all read operations on the XML data.
    XMLInputStream provides the functionality to extract data in the form of
    XMLToken objects.  It logs any errors encountered while reading.  It also
    keeps track of whether a read operation has failed irrecoverably or
    determines whether it is safe to continue reading.

    SBMLNamespaces objects can be associated with an XMLInputStream; this
    facilitates logging errors related to reading XML attributes and elements
    that may only be relevant to particular Level and Version combinations of
    SBML.

    @note The convenience of the XMLInputStream and XMLOutputStream
    abstraction may be useful for developers interested in creating parsers
    for other XML formats besides SBML.  It can provide developers with a
    layer above more basic XML parsers, as well as some useful programmatic
    elements such as XMLToken, XMLError, etc.

    @see XMLOutputStream

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLInputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLInputStream, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, char content, bool isFile = True, string library = "", 
            XMLErrorLog errorLog = None) -> XMLInputStream
        __init__(self, char content, bool isFile = True, string library = "") -> XMLInputStream
        __init__(self, char content, bool isFile = True) -> XMLInputStream
        __init__(self, char content) -> XMLInputStream

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html An interface to an XML input stream.

        @htmlinclude not-sbml-warning.html

        SBML content is serialized using XML; the resulting data can be stored and
        read to/from a file or data stream.  Low-level XML parsers such as Xerces
        provide facilities to read XML data.  To permit the use of different XML
        parsers (Xerces, Expat or libxml2), libSBML implements an abstraction
        layer.  XMLInputStream and XMLOutputStream are two parts of that
        abstraction layer.

        XMLInputStream is an interface to a file or text string containing XML.
        It wraps the content to be read, as well as the low-level XML parser to be
        used and an XMLErrorLog to record errors and other issues (if any arise).
        Internally, the content will be in the form of either a pointer to a file
        name or a character string; XMLInputStream knows the form of the content
        and acts appropriately.  Other libSBML object classes use XMLInputStream
        as their interface for all read operations on the XML data.
        XMLInputStream provides the functionality to extract data in the form of
        XMLToken objects.  It logs any errors encountered while reading.  It also
        keeps track of whether a read operation has failed irrecoverably or
        determines whether it is safe to continue reading.

        SBMLNamespaces objects can be associated with an XMLInputStream; this
        facilitates logging errors related to reading XML attributes and elements
        that may only be relevant to particular Level and Version combinations of
        SBML.

        @note The convenience of the XMLInputStream and XMLOutputStream
        abstraction may be useful for developers interested in creating parsers
        for other XML formats besides SBML.  It can provide developers with a
        layer above more basic XML parsers, as well as some useful programmatic
        elements such as XMLToken, XMLError, etc.

        @see XMLOutputStream

        """
        this = _libsbml.new_XMLInputStream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_XMLInputStream
    __del__ = lambda self : None;
    def getEncoding(self):
        """
        getEncoding(self) -> string

        Returns the encoding of the XML stream.

        @par The @em encoding is indicated by the <code>xml</code> declaration at the
        beginning of an XML document or data stream.  The form of this declaration
        is
        @verbatim
        <?xml version='1.0' encoding='UTF-8'?>
        @endverbatim
        Note that the SBML specifications require the use of UTF-8 encoding, so
        for SBML documents, the value returned by this method will always be
        the string <code>'UTF-8'</code>. 

        @return the encoding of the XML stream.

        @see getVersion()

        """
        return _libsbml.XMLInputStream_getEncoding(self)

    def getVersion(self):
        """
        getVersion(self) -> string

        Returns the version of the XML stream.

        @par The @em version is indicated by the <code>xml</code> declaration at the
        beginning of an XML document or data stream.  The form of this declaration
        is
        @verbatim
         <?xml version='1.0' encoding='UTF-8'?>
        @endverbatim
        Note that the SBML specifications require the use of version 1.0, so
        for SBML documents, the value returned by this method will always be
        the string <code>'1.0'</code>. 

        @return the version of the XML stream.

        @see getEncoding()

        """
        return _libsbml.XMLInputStream_getVersion(self)

    def getErrorLog(self):
        """
        getErrorLog(self) -> XMLErrorLog

        Returns the XMLErrorLog used to log parsing problems.

        @return the XMLErrorLog used to log XML parse errors and other
        validation errors (and messages).

        """
        return _libsbml.XMLInputStream_getErrorLog(self)

    def isEOF(self):
        """
        isEOF(self) -> bool

        Returns @c True if end of file (stream) has been reached.

        @return @c True if end of file (stream) has been reached, @c False
        otherwise.

        """
        return _libsbml.XMLInputStream_isEOF(self)

    def isError(self):
        """
        isError(self) -> bool

        Returns @c True if a fatal error occurred while reading from this
        stream.

        @return @c True if a fatal error occurred while reading from this
        stream.

        """
        return _libsbml.XMLInputStream_isError(self)

    def isGood(self):
        """
        isGood(self) -> bool

        Returns @c True if the stream is in a good state.

        The definition of 'good state' is that isEOF() and isError() both return
        @c False.

        @return @c True if the stream is in a good state, @c False otherwise.

        """
        return _libsbml.XMLInputStream_isGood(self)

    def next(self):
        """
        next(self) -> XMLToken

        Returns the next token on this XML input stream.

        The token is consumed in the process.

        @return the next XMLToken, or an EOF token (i.e.,
        <code>XMLToken.isEOF() == true</code>).

        @see peek()

        """
        return _libsbml.XMLInputStream_next(self)

    def peek(self):
        """
        peek(self) -> XMLToken

        Returns the next token @em without consuming it.

        A subsequent call to either peek() or next() will return the same token.

        @return the next XMLToken or EOF (XMLToken.isEOF() == true).

        @see next()

        """
        return _libsbml.XMLInputStream_peek(self)

    def skipPastEnd(self, *args):
        """
        skipPastEnd(self, XMLToken element)

        Consume zero or more tokens up to and including the corresponding end
        element or EOF.

        @param element the element whose end will be sought in the input stream.

        """
        return _libsbml.XMLInputStream_skipPastEnd(self, *args)

    def skipText(self):
        """
        skipText(self)

        Consume zero or more tokens up to but not including the next XML element
        or EOF.

        """
        return _libsbml.XMLInputStream_skipText(self)

    def setErrorLog(self, *args):
        """
        setErrorLog(self, XMLErrorLog log) -> int

        Sets the XMLErrorLog this stream will use to log errors.

        @return integer value indicating success/failure of the
        operation.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this method are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.XMLInputStream_setErrorLog(self, *args)

    def toString(self):
        """
        toString(self) -> string

        Prints a string representation of the underlying token stream.

        @return a string representing the underlying XML token stream.

        @note This method is intended for debugging purposes.

        """
        return _libsbml.XMLInputStream_toString(self)

    def getSBMLNamespaces(self):
        """
        getSBMLNamespaces(self) -> SBMLNamespaces

        Returns the SBMLNamespaces object attached to this XMLInputStream.

        @return the SBMLNamespaces object or @c None if none has been set.

        """
        return _libsbml.XMLInputStream_getSBMLNamespaces(self)

    def setSBMLNamespaces(self, *args):
        """
        setSBMLNamespaces(self, SBMLNamespaces sbmlns)

        Sets the SBML namespaces associated with this XML input stream.

        This allows this stream to reference the available SBML namespaces being
        read.

        @param sbmlns the list of namespaces to use.

        """
        return _libsbml.XMLInputStream_setSBMLNamespaces(self, *args)

    def determineNumberChildren(self, elementName = ""):
        """
        determineNumberChildren(self, string elementName = "") -> unsigned int
        determineNumberChildren(self) -> unsigned int

        Returns the number of child tokens of the given element in this stream.

        This method allows information from the input stream to be determined
        without the need to actually read and consume the tokens in the stream.
        It returns the number of child elements of the element represented by
        the @p elementName, i.e., the number of child elements encountered
        before the closing tag for the @p elementName supplied.

        If no @p elementName is supplied or it is an empty string, then as a
        special case, this method assumes the element is a MathML
        <code>apply</code> element followed by a function name.

        @param elementName a string representing the name of the element for
        which the number of children are to be determined.

        @return a long integer giving the number of children of the @p
        elementName specified.

        @note This method assumes the stream has been read up to and including
        the element @p elementName.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLInputStream_determineNumberChildren(self, elementName)

    def determineNumSpecificChildren(self, *args):
        """
        determineNumSpecificChildren(self, string childName, string container) -> unsigned int

        Returns the number of child tokens of the specified type within a
        given container element.

        This method allows information from the input stream to be determined
        without the need to actually read and consume the tokens in the stream.
        It returns the number of child elements of the @p childName element
        within the element specified by @p container.  In other words, it counts
        the number of @p childName elements encountered before the closing tag
        for the @p container supplied.

        @param childName a string representing the name of the child
        element whose number is to be determined.

        @param container a string representing the name of the element
        for which the number of children are to be determined.

        @return a long integer giving the number of children of type @p
        childName within the @p container element.

        @note This method assumes the stream has been read up to and including
        the element @p container.

        """
        return _libsbml.XMLInputStream_determineNumSpecificChildren(self, *args)

XMLInputStream_swigregister = _libsbml.XMLInputStream_swigregister
XMLInputStream_swigregister(XMLInputStream)

XMLUnknownError = _libsbml.XMLUnknownError
XMLOutOfMemory = _libsbml.XMLOutOfMemory
XMLFileUnreadable = _libsbml.XMLFileUnreadable
XMLFileUnwritable = _libsbml.XMLFileUnwritable
XMLFileOperationError = _libsbml.XMLFileOperationError
XMLNetworkAccessError = _libsbml.XMLNetworkAccessError
InternalXMLParserError = _libsbml.InternalXMLParserError
UnrecognizedXMLParserCode = _libsbml.UnrecognizedXMLParserCode
XMLTranscoderError = _libsbml.XMLTranscoderError
MissingXMLDecl = _libsbml.MissingXMLDecl
MissingXMLEncoding = _libsbml.MissingXMLEncoding
BadXMLDecl = _libsbml.BadXMLDecl
BadXMLDOCTYPE = _libsbml.BadXMLDOCTYPE
InvalidCharInXML = _libsbml.InvalidCharInXML
BadlyFormedXML = _libsbml.BadlyFormedXML
UnclosedXMLToken = _libsbml.UnclosedXMLToken
InvalidXMLConstruct = _libsbml.InvalidXMLConstruct
XMLTagMismatch = _libsbml.XMLTagMismatch
DuplicateXMLAttribute = _libsbml.DuplicateXMLAttribute
UndefinedXMLEntity = _libsbml.UndefinedXMLEntity
BadProcessingInstruction = _libsbml.BadProcessingInstruction
BadXMLPrefix = _libsbml.BadXMLPrefix
BadXMLPrefixValue = _libsbml.BadXMLPrefixValue
MissingXMLRequiredAttribute = _libsbml.MissingXMLRequiredAttribute
XMLAttributeTypeMismatch = _libsbml.XMLAttributeTypeMismatch
XMLBadUTF8Content = _libsbml.XMLBadUTF8Content
MissingXMLAttributeValue = _libsbml.MissingXMLAttributeValue
BadXMLAttributeValue = _libsbml.BadXMLAttributeValue
BadXMLAttribute = _libsbml.BadXMLAttribute
UnrecognizedXMLElement = _libsbml.UnrecognizedXMLElement
BadXMLComment = _libsbml.BadXMLComment
BadXMLDeclLocation = _libsbml.BadXMLDeclLocation
XMLUnexpectedEOF = _libsbml.XMLUnexpectedEOF
BadXMLIDValue = _libsbml.BadXMLIDValue
BadXMLIDRef = _libsbml.BadXMLIDRef
UninterpretableXMLContent = _libsbml.UninterpretableXMLContent
BadXMLDocumentStructure = _libsbml.BadXMLDocumentStructure
InvalidAfterXMLContent = _libsbml.InvalidAfterXMLContent
XMLExpectedQuotedString = _libsbml.XMLExpectedQuotedString
XMLEmptyValueNotPermitted = _libsbml.XMLEmptyValueNotPermitted
XMLBadNumber = _libsbml.XMLBadNumber
XMLBadColon = _libsbml.XMLBadColon
MissingXMLElements = _libsbml.MissingXMLElements
XMLContentEmpty = _libsbml.XMLContentEmpty
XMLErrorCodesUpperBound = _libsbml.XMLErrorCodesUpperBound
LIBSBML_CAT_INTERNAL = _libsbml.LIBSBML_CAT_INTERNAL
LIBSBML_CAT_SYSTEM = _libsbml.LIBSBML_CAT_SYSTEM
LIBSBML_CAT_XML = _libsbml.LIBSBML_CAT_XML
LIBSBML_SEV_INFO = _libsbml.LIBSBML_SEV_INFO
LIBSBML_SEV_WARNING = _libsbml.LIBSBML_SEV_WARNING
LIBSBML_SEV_ERROR = _libsbml.LIBSBML_SEV_ERROR
LIBSBML_SEV_FATAL = _libsbml.LIBSBML_SEV_FATAL
LIBSBML_OVERRIDE_DISABLED = _libsbml.LIBSBML_OVERRIDE_DISABLED
LIBSBML_OVERRIDE_DONT_LOG = _libsbml.LIBSBML_OVERRIDE_DONT_LOG
LIBSBML_OVERRIDE_WARNING = _libsbml.LIBSBML_OVERRIDE_WARNING
class XMLError(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html XML-level errors, warnings and other diagnostics.

    @htmlinclude not-sbml-warning.html

    LibSBML can be configured to use any of a number of XML parsers; at the
    time of this writing, libSBML supports Xerces versions 2.4 through 3.1,
    Expat version 1.95.x and higher, and libxml2 version 2.6.16 and higher.
    These parsers each report different status codes for the various
    exceptions that can occur during XML processing.  The XMLError object
    class abstracts away from the particular diagnostics reported by the
    different parsers and presents a single uniform interface and set of
    status codes, along with operations for manipulating the error objects.

    When the libSBML XML parser layer encounters an error in the XML content
    being processed, or when there is something else wrong (such as an
    out-of-memory condition), the problems are reported as XMLError objects.
    Each XMLError object instance has an identification number that
    identifies the nature of the problem.
    @if clike This error identifier will be up to five digits 
    long and drawn from the enumeration <a class='el'
    href='#error-codes'>XMLErrorCode_t</a>.  Applications can use the
    error identifiers as a means of recognizing the error encountered and
    changing their behavior if desired. @else This
    error identifier is one of the constants listed in the next section below.
    Applications can use the error identifiers as a means of recognizing the
    error encountered and changing their behavior if desired.  @endif@~

    Integer error codes are useful for software, but not so much for telling
    humans what happened.  For this reason, XMLError also provides two text
    messages describing the nature of the error.  These messages are
    accessible by means of the methods XMLError.getShortMessage() and
    XMLError.getMessage().  The method XMLError.getShortMessage() returns
    a very brief synopsis of the warning or error condition, whereas
    XMLError.getMessage() returns a longer explanation.  These text strings
    are suitable for displaying to human users.

    Each XMLError object also contains a category code; its value may be
    retrieved using the method XMLError.getCategory().  Category values
    are drawn from @if clike the enumeration <a class='el' href='#XMLErrorCategory_t'>XMLErrorCategory_t</a> described below.@else a
    set of constants whose names begin with the characters @c LIBSBML_CAT_, described below.@endif@~ &nbsp;Categories
    are used by libSBML to provide more information to calling programs about
    the nature of a given error.  

    In addition to category codes, each XMLError object also has a severity
    code; its value may be retrieved using the method
    XMLError.getSeverity().  Severity code values are drawn from
    @if clike the enumeration <a class='el' href='#XMLErrorSeverity_t'>XMLErrorSeverity_t</a>@else a
    set of constants whose names begin with the characters @c LIBSBML_SEV_@endif,
    described below. Severity levels range from informational
    (@link libsbml#LIBSBML_SEV_INFO LIBSBML_SEV_INFO@endlink) to
    fatal errors (@link libsbml#LIBSBML_SEV_FATAL LIBSBML_SEV_FATAL@endlink).

    Finally, XMLError objects record the line and column near where the
    problem occurred in the XML content.  The values can be retrieved using
    the methods XMLError.getLine() and XMLError.getColumn().  We say 'near
    where the problem occurred', because many factors affect how accurate
    the line/column information ultimately is.  For example, sometimes, the
    underlying XML parsers can only report such information for the parent
    XML element where an error occurs, and not for the specific point where
    the problem occurs.  In other situations, some parsers report invalid
    line and/or column numbers altogether.  If this occurs, libSBML sets the
    line and/or column number in the XMLError object to either
    <code>0</code> or the value of the maximum unsigned long integer
    representable on the platform where libSBML is running.  The probability
    that a true line or column number in an SBML model would equal this
    value is vanishingly small; thus, if an application encounters these
    values in an XMLError object, it can assume no valid line/column number
    could be provided by libSBML in that situation.

    @if clike
    <h3><a class='anchor' name='error-codes'>XMLErrorCode_t</a></h3>

    This is an enumeration of all the error and warning codes returned by
    the XML layer in libSBML.  Each code is an integer with a 4-digit value
    less than 10000.  The following table lists each possible value and a
    brief description of its meaning.
    @endif@if java <h3><a class='anchor' 
    name='error-codes'>Error codes associated with XMLError objects</a></h3>

    The error and warning codes returned by the XML layer in libSBML are
    listed in the table below.  In the libSBML Java language interface,
    these error identifiers are currently implemented as static integer
    constants defined in the interface class <code><a
    href='libsbmlConstants.html'>libsbmlConstants</a></code>.  This is
    admittedly not an ideal approach from the standpoint of modern Java
    programming, but it was necessary to work around the lack of
    enumerations in Java prior to JDK 1.5.  Future versions of libSBML may
    use a proper Java enumeration type to define the error
    identifiers. @endif@if csharp <h3><a class='anchor' 
    name='error-codes'>Error codes associated with XMLError objects</a></h3>

    The error and warning codes returned by the XML layer in libSBML are
    listed in the table below.  In the libSBML C# language interface,
    these error identifiers are currently implemented as static integer
    constants defined in the interface class @link libsbmlcs.libsbml@endlink.@endif@~

    <center>
    <table cellspacing='1' cellpadding='1' border='0' width='95%'
              class='text-table normal-font alt-row-colors'>
    <caption>Possible XMLError error codes.  Depending on the programming
    language in use, the <em>Enumerator</em> values will be defined either
    as a value from the enumeration XMLErrorCode_t or as integer constants.
    To make this table more compact, we have shortened the identifiers for
    the category and severity codes to their essential parts.  To get the
    actual names of the constants, prepend <code>LIBSBML_CAT_</code> to the
    category names and <code>LIBSBML_SEV_</code> to the severity names
    shown in the two right-hand columns.
    </caption>
    <tr style='background: lightgray' class='normal-font'>
    <th style='text-align: left'>Enumerator</th>
    <th>Meaning</th>
    <th width='90' style='text-align: left'>Category</th>
    <th width='90' style='text-align: left'>Severity</th>
    </tr>
    <tr><td>@link libsbml#XMLUnknownError XMLUnknownError@endlink</td><td>Unrecognized error encountered internally</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td>@link libsbml#XMLOutOfMemory XMLOutOfMemory@endlink</td> <td>Out of memory</td><td>SYSTEM</td><td>FATAL</td></tr>
    <tr><td>@link libsbml#XMLFileUnreadable XMLFileUnreadable@endlink</td> <td>File unreadable</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLFileUnwritable XMLFileUnwritable@endlink</td> <td>File unwritable</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLFileOperationError XMLFileOperationError@endlink</td><td>Error encountered while attempting file operation</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLNetworkAccessError XMLNetworkAccessError@endlink</td><td>Network access error</td><td>SYSTEM</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#InternalXMLParserError InternalXMLParserError@endlink</td><td>Internal XML parser state error</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td>@link libsbml#UnrecognizedXMLParserCode UnrecognizedXMLParserCode@endlink</td><td>XML parser returned an unrecognized error code</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td>@link libsbml#XMLTranscoderError XMLTranscoderError@endlink</td><td>Character transcoder error</td><td>INTERNAL</td><td>FATAL</td></tr>
    <tr><td>@link libsbml#MissingXMLDecl MissingXMLDecl@endlink</td><td>Missing XML declaration at beginning of XML input</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#MissingXMLEncoding MissingXMLEncoding@endlink</td><td>Missing encoding attribute in XML declaration</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLDecl BadXMLDecl@endlink</td><td>Invalid or unrecognized XML declaration or XML encoding</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLDOCTYPE BadXMLDOCTYPE@endlink</td><td>Invalid, malformed or unrecognized XML DOCTYPE declaration</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#InvalidCharInXML InvalidCharInXML@endlink</td><td>Invalid character in XML content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadlyFormedXML BadlyFormedXML@endlink</td><td>XML content is not well-formed</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#UnclosedXMLToken UnclosedXMLToken@endlink</td><td>Unclosed XML token</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#InvalidXMLConstruct InvalidXMLConstruct@endlink</td><td>XML construct is invalid or not permitted</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLTagMismatch XMLTagMismatch@endlink</td><td>Element tag mismatch or missing tag</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#DuplicateXMLAttribute DuplicateXMLAttribute@endlink</td><td>Duplicate XML attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#UndefinedXMLEntity UndefinedXMLEntity@endlink</td><td>Undefined XML entity</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadProcessingInstruction BadProcessingInstruction@endlink</td><td>Invalid, malformed or unrecognized XML processing instruction</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLPrefix BadXMLPrefix@endlink</td><td>Invalid or undefined XML namespace prefix</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLPrefixValue BadXMLPrefixValue@endlink</td><td>Invalid XML namespace prefix value</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#MissingXMLRequiredAttribute MissingXMLRequiredAttribute@endlink</td><td>Missing a required XML attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLAttributeTypeMismatch XMLAttributeTypeMismatch@endlink</td><td>Data type mismatch for the value of an attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLBadUTF8Content XMLBadUTF8Content@endlink</td><td>Invalid UTF8 content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#MissingXMLAttributeValue MissingXMLAttributeValue@endlink</td><td>Missing or improperly formed attribute value</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLAttributeValue BadXMLAttributeValue@endlink</td><td>Invalid or unrecognizable attribute value</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLAttribute BadXMLAttribute@endlink</td><td>Invalid, unrecognized or malformed attribute</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#UnrecognizedXMLElement UnrecognizedXMLElement@endlink</td><td>Element either not recognized or not permitted</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLComment BadXMLComment@endlink</td><td>Badly formed XML comment</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLDeclLocation BadXMLDeclLocation@endlink</td><td>XML declaration not permitted in this location</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLUnexpectedEOF XMLUnexpectedEOF@endlink</td><td>Reached end of input unexpectedly</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLIDValue BadXMLIDValue@endlink</td><td>Value is invalid for XML ID, or has already been used</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLIDRef BadXMLIDRef@endlink</td><td>XML ID value was never declared</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#UninterpretableXMLContent UninterpretableXMLContent@endlink</td><td>Unable to interpret content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#BadXMLDocumentStructure BadXMLDocumentStructure@endlink</td><td>Bad XML document structure</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#InvalidAfterXMLContent InvalidAfterXMLContent@endlink</td><td>Encountered invalid content after expected content</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLExpectedQuotedString XMLExpectedQuotedString@endlink</td><td>Expected to find a quoted string</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLEmptyValueNotPermitted XMLEmptyValueNotPermitted@endlink</td><td>An empty value is not permitted in this context</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLBadNumber XMLBadNumber@endlink</td><td>Invalid or unrecognized number</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLBadColon XMLBadColon@endlink</td><td>Colon characters are invalid in this context</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#MissingXMLElements MissingXMLElements@endlink</td><td>One or more expected elements are missing</td><td>XML</td><td>ERROR</td></tr>
    <tr><td>@link libsbml#XMLContentEmpty XMLContentEmpty@endlink</td><td>Main XML content is empty</td><td>XML</td><td>ERROR</td></tr>
    </table>
    </center>


    @if clike
    <h3><a class='anchor' name='error-categories'>XMLErrorCategory_t</a></h3>

    As discussed above, each XMLError object contains a value for a category
    identifier, describing the type of issue that the XMLError object
    represents.  The category can be retrieved from an XMLError object using
    the method XMLError.getCategory().  The value is chosen from the
    enumeration of category codes <a class='el' href='#XMLErrorCategory_t'>
    XMLErrorCategory_t</a>.  The following table
    lists each possible value and a brief description of its meaning.
    @endif@if java <h3><a class='anchor'
    name='error-categories'>Category codes associated with XMLError objects</a></h3>

    As discussed above, each XMLError object contains a value for a category
    identifier, describing the type of issue that the XMLError object represents.
    The category can be retrieved from an XMLError object using the method
    XMLError.getCategory(). The following table lists each possible value
    and a brief description of its meaning.

    As is the case with the error codes, in the libSBML Java language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface class
    <code>libsbmlConstants</code> in the file '<a
    href='libsbmlConstants.html'>libsbmlConstants.java</a>'.
    @endif@if csharp <h3><a class='anchor'
    name='error-categories'>Category codes associated with XMLError objects</a></h3>

    As discussed above, each XMLError object contains a value for a category
    identifier, describing the type of issue that the XMLError object represents.
    The category can be retrieved from an XMLError object using the method
    XMLError.getCategory(). The following table lists each possible value
    and a brief description of its meaning.

    As is the case with the error codes, in the libSBML C# language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface
    class @link libsbmlcs.libsbml@endlink. @endif@~

    <center>
    <table width='95%' cellspacing='1' cellpadding='1' border='0'
    class='text-table normal-font alt-row-colors'>
    <tr style='background: lightgray' class='normal-font'>
    <th style='text-align: left'>Enumerator</th>
    <th>Meaning</th>
    </tr>
    <tr><td>@link libsbml#LIBSBML_CAT_INTERNAL LIBSBML_CAT_INTERNAL@endlink</td>
    <td>A problem involving the libSBML
    software itself or the underlying XML parser.  This almost certainly
    indicates a software defect (i.e., bug) in libSBML.  Please report
    instances of this to the libSBML developers.</td></tr>
    <tr><td>@link libsbml#LIBSBML_CAT_SYSTEM LIBSBML_CAT_SYSTEM@endlink</td>
    <td>A problem reported by the operating
    system, such as an inability to read or write a file.  This indicates
    something that is not a program error but is outside of the control of
    libSBML.</td></tr>
    <tr><td>@link libsbml#LIBSBML_CAT_XML LIBSBML_CAT_XML@endlink</td>
    <td>A problem in the XML content itself.  This
    usually arises from malformed XML or the use of
    constructs not permitted in SBML.</td></tr>
    </table>
    </center>


    @if clike
    <h3><a class='anchor' name='error-severities'>XMLErrorSeverity_t</a></h3>

    As described above, each XMLError object contains a value for a severity
    code, describing how critical is the issue that the XMLError object
    represents.  The severity can be retrieved from an XMLError object using
    the method XMLError.getSeverity().  The value is chosen from the
    enumeration of category codes <a class='el' href='#XMLErrorSeverity_t'>
    XMLErrorSeverity_t</a>.  The following table
    lists each possible value and a brief description of its meaning.
    @endif@if java <h3><a class='anchor'
    name='error-severities'>Severity codes associated with XMLError objects</a></h3>

    As described above, each XMLError object contains a value for a severity
    code, describing how severe is the issue that the XMLError object
    represents.  The severity be retrieved from an XMLError object using the
    method XMLError.getSeverity(). The following table lists each possible
    value and a brief description of its meaning.

    As is the case with the category codes, in the libSBML Java language
    interface, these severity codes are currently
    implemented as static integer constants defined in the interface class
    <code>libsbmlConstants</code> in the file '<a
    href='libsbmlConstants.html'>libsbmlConstants.java</a>'.  This
    is admittedly not an ideal approach from the standpoint of modern Java
    programming, but it was necessary to work around the lack of
    enumerations in Java prior to JDK 1.5.  Future versions of libSBML may
    use a proper Java enumeration type to define the severity
    codes. @endif@if csharp <h3><a class='anchor'
    name='error-severities'>Severity codes associated with XMLError objects</a></h3>

    As described above, each XMLError object contains a value for a severity
    code, describing how severe is the issue that the XMLError object
    represents.  The severity be retrieved from an XMLError object using the
    method XMLError.getSeverity(). The following table lists each possible
    value and a brief description of its meaning.

    As is the case with the category codes, in the libSBML C# language
    interface, these severity codes are currently
    implemented as static integer constants defined in the interface class
    @link libsbmlcs.libsbml@endlink.@endif@~

    <center>
    <table width='95%' cellspacing='1' cellpadding='1' border='0'
    class='text-table normal-font alt-row-colors'>
    <tr style='background: lightgray' class='normal-font'>
    <th style='text-align: left'>Enumerator</th>
    <th>Meaning</th>
    </tr>
    <tr><td>@link libsbml#LIBSBML_SEV_INFO LIBSBML_SEV_INFO@endlink</td>
    <td>The error is actually informational and
    not necessarily a serious problem.</td></tr>
    <tr><td>@link libsbml#LIBSBML_SEV_WARNING LIBSBML_SEV_WARNING@endlink</td>
    <td>The error object represents a problem
    that is not serious enough to necessarily stop the problem, but
    applications should take note of the problem and evaluate what its
    implications may be.</td></tr>
    <tr><td>@link libsbml#LIBSBML_SEV_ERROR LIBSBML_SEV_ERROR@endlink</td>
    <td>The error object represents a serious
    error.  The application may continue running but it is unlikely to be
    able to continue processing the same XML file or data stream.</td></tr>
    <tr><td>@link libsbml#LIBSBML_SEV_FATAL LIBSBML_SEV_FATAL@endlink</td>
    <td>A serious error occurred, such as an
    out-of-memory condition, and the software should terminate
    immediately.</td></tr>
    </table>
    </center>

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL, 
            unsigned int category = LIBSBML_CAT_INTERNAL) -> XMLError
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL) -> XMLError
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0, 
            unsigned int column = 0) -> XMLError
        __init__(self, int errorId = 0, string details = "", unsigned int line = 0) -> XMLError
        __init__(self, int errorId = 0, string details = "") -> XMLError
        __init__(self, int errorId = 0) -> XMLError
        __init__(self) -> XMLError
        __init__(self, XMLError orig) -> XMLError

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLError(XMLError orig)</pre>

        Copy constructor; creates a copy of this XMLError.

        @p orig the XMLError object to copy.

        @throws XMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>XMLError( const int errorId           = 0 , string details  = '' , const long line     = 0 , const long column   = 0 , const long severity = LIBSBML_SEV_FATAL , const long category = LIBSBML_CAT_INTERNAL )</pre>

        Creates a new XMLError to report that something occurred during XML
        processing.

        XMLError objects have identification numbers to indicate the nature of
        the exception.  @if clike These numbers are drawn from
        the enumeration <a class='el'
        href='#error-codes'>XMLErrorCode_t</a>.
        @else These numbers are defined as longeger constants in the file
        'libsbmlConstants.java'.  See the <a class='el'
        href='#error-codes'>top of this documentation</a> for a table
        listing the possible values and their meanings. @endif@~ The argument @p
        errorId to this constructor @em can be (but does not have to be) a
        value from this @if clike enumeration. If it is a value
        from <a class='el' href='#error-codes'>XMLErrorCode_t</a>, the
        XMLError class assumes the error is a low-level system or XML layer
        error and <em>prepends</em> a built-in, predefined error message to
        any string passed in the argument @p details to this constructor.  In
        addition, all <a class='el' href='#error-codes'>XMLErrorCode_t</a>
        errors have associated values for the @p severity and @p category
        codes, and these fields are filled-in as well from the enumerations <a
        class='el' href='#error-severities'>XMLErrorSeverity_t</a> and <a
        class='el' href='#error-categories'>XMLErrorCategory_t</a>,
        respectively. @else set of constants.  If it is
        one of the predefined error identifiers, the XMLError class assumes
        the error is a low-level system or XML layer error and
        <em>prepends</em> a built-in, predefined error message to any string
        passed in the argument @p details to this constructor.  In addition,
        all the predefined error identifiers have associated values for the @p
        severity and @p category codes, and these fields are filled-in as
        well. @endif@~

        If the error identifier @p errorId is a number greater than 9999, this
        constructor assumes that the error was generated from another part of
        the software, and does not do additional filling in of values beyond
        the defaults in the constructor itself.  This allows XMLError to serve
        as a base class for other errors (and is used in this way elsewhere in
        libSBML).  Callers should fill in all the parameters with suitable
        values if generating errors with codes greater than 9999 to make
        maximum use of the XMLError facilities.

        @if clike As mentioned above, there are two other
        enumerations, <a class='el'
        href='#error-severities'>XMLErrorSeverity_t</a> and <a class='el'
        href='#error-categories'>XMLErrorCategory_t</a>, used for indicating
        the severity and category of error for the predefined XMLError codes.
        The values passed in @p severity and @p category override the defaults
        assigned based on the error code.  If the value of @p errorId is a
        value from <a class='el' href='#error-codes'>XMLErrorCode_t</a>,
        callers do not need to fill in @p severity and @p category.
        Conversely, if @p errorId is not a value from <a class='el'
        href='#error-codes'>XMLErrorCode_t</a>, callers can use other
        values (not just those from <a class='el'
        href='#error-severities'>XMLErrorSeverity_t</a> and <a class='el'
        href='#error-categories'>XMLErrorCategory_t</a>, but their own
        special values) for @p severity and @p
        category. @else As mentioned above, 
        there are additional constants defined for <a class='el'
        href='#error-severities'>standard severity</a> and <a class='el'
        href='#error-categories'>standard category</a> codes, and every predefined 
        error in libSBML has an associated value for severity and category taken
        from these predefined sets.  These constants have symbol names
        prefixed with <code>LIBSBML_SEV_</code> and <code>LIBSBML_CAT_</code>,
        respectively.  If the value of @p errorId is one of the standard error
        codes, callers do not need to fill in @p severity and @p category in a
        call to this constructor.  Conversely, if @p errorId is not an existing
        XML-level error code, callers can use other values for @p severity and
        @p category. @endif@~

        @param errorId a long integer, the identification number of the error.

        @param details a string containing additional details about the error.
        If the error code in @p errorId is one that is recognized by XMLError,
        the given message is @em appended to a predefined message associated
        with the given code.  If the error code is not recognized, the message
        is stored as-is as the text of the error.

        @param line a long integer, the line number at which the error occured.

        @param column a long integer, the column number at which the error occured.

        @param severity an integer indicating severity of the error.

        @param category an integer indicating the category to which the error
        belongs.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_XMLError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_XMLError
    __del__ = lambda self : None;
    def getErrorId(self):
        """
        getErrorId(self) -> unsigned int

        Returns the identifier of this error.

        @return the error code for this error.

        @see getMessage()
        @see getShortMessage()
        @see getCategory()
        @see getSeverity()

        """
        return _libsbml.XMLError_getErrorId(self)

    def getMessage(self):
        """
        getMessage(self) -> string

        Returns the message text of this error.

        The message associated with an error object describes the nature of
        the problem.  The message returned by this method is generally longer
        and clearer than the message returned by XMLError.getShortMessage(),
        but not in all cases.

        Callers may use XMLError.getCategory() and XMLError.getSeverity() to
        obtain additional information about the nature and severity of the
        problem.

        @return the message text

        @see getErrorId()
        @see getShortMessage()
        @see getCategory()
        @see getSeverity()

        """
        return _libsbml.XMLError_getMessage(self)

    def getShortMessage(self):
        """
        getShortMessage(self) -> string

        Returns a brief message for this error.

        This is an alternative error message that, in general, is as short as
        the authors could make it.  However, brevity is often inversely
        proportional to clarity, so this short message may not be sufficiently
        informative to understand the nature of the error.  Calling
        applications may wish to check XMLError.getMessage() in addition or
        instead.

        @return the short error message text

        @see getErrorId()
        @see getMessage()
        @see getCategory()
        @see getSeverity()

        """
        return _libsbml.XMLError_getShortMessage(self)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        Returns the line number in the XML input near where the error, warning
        or other diagnostic occurred.

        We say 'near where the problem occurred', because many factors affect
        how accurate the line/column information ultimately is.  For example,
        sometimes, the underlying XML parsers can only report such information
        for the parent XML element where an error occurs, and not for the
        specific point where the problem occurs.  In other situations, some
        parsers report invalid line and/or column numbers altogether.  If this
        occurs, libSBML sets the line and/or column number in the XMLError
        object to either <code>0</code> or the value of the maximum unsigned
        long integer representable on the platform where libSBML is running.
        The probability that a true line or column number in an SBML model
        would equal this value is vanishingly small; thus, if an application
        encounters these values in an XMLError object, it can assume no valid
        line/column number could be provided by libSBML in that situation.

        @return the line number

        @see getColumn()

        """
        return _libsbml.XMLError_getLine(self)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        Returns the column number in the XML input near where the error,
        warning or other diagnostic occurred.

        We say 'near where the problem occurred', because many factors affect
        how accurate the line/column information ultimately is.  For example,
        sometimes, the underlying XML parsers can only report such information
        for the parent XML element where an error occurs, and not for the
        specific point where the problem occurs.  In other situations, some
        parsers report invalid line and/or column numbers altogether.  If this
        occurs, libSBML sets the line and/or column number in the XMLError
        object to either <code>0</code> or the value of the maximum unsigned
        long integer representable on the platform where libSBML is running.
        The probability that a true line or column number in an SBML model
        would equal this value is vanishingly small; thus, if an application
        encounters these values in an XMLError object, it can assume no valid
        line/column number could be provided by libSBML in that situation.

        @return the column number

        @see getLine()

        """
        return _libsbml.XMLError_getColumn(self)

    def getSeverity(self):
        """
        getSeverity(self) -> unsigned int

        Returns the severity of this error.

        XMLError defines an enumeration of severity codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own severity codes with numbers higher than those in the predefined
        set of severity codes.

        @return the severity of this XMLError.

        @see getSeverityAsString()
        @see getCategory()

        """
        return _libsbml.XMLError_getSeverity(self)

    def getSeverityAsString(self):
        """
        getSeverityAsString(self) -> string

        Returns a string describing the severity level of this error.

        XMLError defines an enumeration of severity codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own severity codes with numbers higher than those in the predefined
        set of severity codes.

        @return string representing the severity of this XMLError.

        @see getSeverity()
        @see getCategoryAsString()

        """
        return _libsbml.XMLError_getSeverityAsString(self)

    def getCategory(self):
        """
        getCategory(self) -> unsigned int

        Returns the category of this error.

        XMLError defines an enumeration of category codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own categories with numbers higher than those in the predefined
        set of category codes.

        Categories can be used to partition errors into distinct groups.
        Among other things, this can be used to prevent id conflicts by
        uniquely identifying an XMLError by both id and category.

        @return the category of this XMLError.

        @see getSeverity()
        @see getCategoryAsString()

        """
        return _libsbml.XMLError_getCategory(self)

    def getCategoryAsString(self):
        """
        getCategoryAsString(self) -> string

        Returns a string describing the category of this error.

        XMLError defines an enumeration of category codes for the XML layer.
        Applications that build on XMLError by subclassing it may add their
        own categories with numbers higher than those in the predefined
        set of category codes.

        Categories can be used to partition errors into distinct groups.
        Among other things, this can be used to prevent id conflicts by
        uniquely identifying an XMLError by both id and category.

        @return string representing the category of this XMLError.

        @see getCategory()
        @see getSeverityAsString()

        """
        return _libsbml.XMLError_getCategoryAsString(self)

    def isInfo(self):
        """
        isInfo(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error object is for information purposes only.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError.getSeverity()) and then comparing it to the
        value @link libsbml#LIBSBML_SEV_INFO LIBSBML_SEV_INFO@endlink from the
        @if clike enumeration #XMLErrorSeverity_t. @else set of predefined
        severity codes.@endif@~

        @return @c True if this XMLError is for informational purposes only,
        @c False otherwise.

        @see isWarning()
        @see isError()
        @see isFatal()

        """
        return _libsbml.XMLError_isInfo(self)

    def isWarning(self):
        """
        isWarning(self) -> bool

        Predicate returning @c True or @c False depending on whether 
        this error object is a warning.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError.getSeverity()) and then comparing it to the
        value @link libsbml#LIBSBML_SEV_WARNING LIBSBML_SEV_WARNING@endlink from the
        @if clike enumeration #XMLErrorSeverity_t. @else set of predefined
        severity codes.@endif@~

        @return @c True if this error is a warning, @c False otherwise.

        @see isInfo()
        @see isError()
        @see isFatal()

        """
        return _libsbml.XMLError_isWarning(self)

    def isError(self):
        """
        isError(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error is a significant error.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError.getSeverity()) and then comparing it to the
        value @link libsbml#LIBSBML_SEV_ERROR LIBSBML_SEV_ERROR@endlink from the
        @if clike enumeration #XMLErrorSeverity_t. @else set of predefined
        severity codes.@endif@~

        @return @c True if this error is an error, @c False otherwise.

        @see isInfo()
        @see isWarning()
        @see isFatal()

        """
        return _libsbml.XMLError_isError(self)

    def isFatal(self):
        """
        isFatal(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error is a fatal run-time error.

        This is equivalent to obtaining the severity code from an XMLError
        object (via XMLError.getSeverity()) and then comparing it to the
        value @link libsbml#LIBSBML_SEV_FATAL LIBSBML_SEV_FATAL@endlink from the
        @if clike enumeration #XMLErrorSeverity_t. @else set of predefined severity codes.@endif@~

        @return @c True if this error is a fatal error, @c False otherwise.

        @see isInfo()
        @see isWarning()
        @see isError()

        """
        return _libsbml.XMLError_isFatal(self)

    def isInternal(self):
        """
        isInternal(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error resulted from an internal program error.

        This is equivalent to obtaining the category identifier from an
        XMLError object (via XMLError.getCategory()) and then comparing it to
        the value @link libsbml#LIBSBML_CAT_INTERNAL LIBSBML_CAT_INTERNAL@endlink from the
        @if clike enumeration #XMLErrorCategory_t. @else set of predefined category codes.@endif@~

        @return @c True or @c False

        @see isSystem()
        @see isXML()

        """
        return _libsbml.XMLError_isInternal(self)

    def isSystem(self):
        """
        isSystem(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error was generated by the operating system.

        This is equivalent to obtaining the category identifier from an
        XMLError object (via XMLError.getCategory()) and then comparing it to
        the value @link libsbml#LIBSBML_CAT_SYSTEM LIBSBML_CAT_SYSTEM@endlink from the
        @if clike enumeration #XMLErrorCategory_t. @else set of predefined category codes.@endif@~

        @return @c True or @c False

        @see isInternal()
        @see isXML()

        """
        return _libsbml.XMLError_isSystem(self)

    def isXML(self):
        """
        isXML(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error resulted from a problem in the XML input (e.g., an XML syntax
        error).

        This is equivalent to obtaining the category identifier from an
        XMLError object (via XMLError.getCategory()) and then comparing it to
        the value @link libsbml#LIBSBML_CAT_XML LIBSBML_CAT_XML@endlink from the
        @if clike enumeration #XMLErrorCategory_t. @else set of predefined category codes.@endif@~

        @return @c True or @c False

        @see isInternal()
        @see isSystem()

        """
        return _libsbml.XMLError_isXML(self)

    def isValid(self):
        """
        isValid(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        error resulted from a problem or whether it was logged as an unknown
        error.

        This is equivalent to obtaining the error identifier from an
        XMLError object (via XMLError.getErrorId()) and then comparing it to
        the value XMLUnknownError or UnknownError from the
        @if clike enumeration #XMLErrorCode_t. @else set of predefined error codes.@endif@~

        @return @c True or @c False

        """
        return _libsbml.XMLError_isValid(self)

    def setLine(self, *args):
        """
        setLine(self, unsigned int line) -> int

        Sets the line number where this error occurred.

        @param line a long integer, the line number to set.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see setColumn()

        """
        return _libsbml.XMLError_setLine(self, *args)

    def setColumn(self, *args):
        """
        setColumn(self, unsigned int column) -> int

        Sets the column number where this error occurred.

        @param column a long integer, the column number to set.

        @return integer value indicating success/failure of the
        function.   The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see setLine()

        """
        return _libsbml.XMLError_setColumn(self, *args)

    def getStandardMessage(*args):
        """
        getStandardMessage(int code) -> string

        Returns a copy of the message string associated with the given
        predefined XMLError code.

        @param code the error code whose message is sought; it must be a
        predefined value from @if clike <a class='el' href='#error-codes'>
        XMLErrorCode_t</a>. @else <a class='el' href='#error-codes'>the set
        of predefined error identifiers</a>.@endif@~

        """
        return _libsbml.XMLError_getStandardMessage(*args)

    if _newclass:getStandardMessage = staticmethod(getStandardMessage)
    __swig_getmethods__["getStandardMessage"] = lambda x: getStandardMessage
    def getPackage(self):
        """
        getPackage(self) -> string

        Returns the SBML Level&nbsp;3 package extension (if any) that logged
        this error.

        Each error logged by an libSBML extension for SBML Level&nbsp;3 packages
        includes a record of the package that logged it.  The field is a simple
        text string.  If the string is empty or has the value @c 'core', then
        the error came from libSBML core; otherwise, the string will be the
        short-form name of the package (e.g., @c 'comp' for the Hierarchical
        Model Composition package).

        @return a string representing the name of the package that logged this
        error.  If the error did not come from a package extension, the value
        will be the empty string or @c 'core'.

        """
        return _libsbml.XMLError_getPackage(self)

    def getErrorIdOffset(self):
        """
        getErrorIdOffset(self) -> unsigned int

        Returns libSBML's internal numerical offset for the error code
        associated with this error.

        In the SBML Level&nbsp;3 package specifications, package validation
        rules are identified by 5-digit numbers prefixed with the nickname of
        the package itself---e.g., &ldquo;comp-10101&rdquo;,
        &ldquo;fbc-20301&rdquo;, etc.  Historically, libSBML reported error
        codes as pure integers, and some application software systems make
        decisions based on the numerical values of the error codes.  To permit
        these applications to continue to function in this fashion, libSBML
        internally continues to maintain error identifiers as pure integers.  To
        handle the possibility that errors may come from package extensions,
        libSBML uses numerical offsets added to the internal error codes.  These
        offsets add two leading digits to the regular 5-digit error codes; for
        example, &ldquo;comp&rdquo; error codes are stored as 1010101, 1020102,
        etc.  The offset in this case is 1000000.  Another package will have the
        offset 2000000, yet another will have 3000000, etc.

        This method returns the integer offset in this error's error code.
        Calling applications can get the 5-digit package-specific number for a
        given error code by subtracting the offset from the value reported by
        getErrorId():
        @verbatim
         getErrorId() - getErrorIdOffset()
         @endverbatim
        When libSBML produces error messages, it combines the text string
        returned by getPackage() with the subtracted value of the error code,
        to produce a text string of the form &ldquo;comp-10101&rdquo;.

        @see getErrorId()
        @see getPackage()

        """
        return _libsbml.XMLError_getErrorIdOffset(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLError_swigregister = _libsbml.XMLError_swigregister
XMLError_swigregister(XMLError)

def XMLError_getStandardMessage(*args):
  """
    XMLError_getStandardMessage(int code) -> string

    Returns a copy of the message string associated with the given
    predefined XMLError code.

    @param code the error code whose message is sought; it must be a
    predefined value from @if clike <a class='el' href='#error-codes'>
    XMLErrorCode_t</a>. @else <a class='el' href='#error-codes'>the set
    of predefined error identifiers</a>.@endif@~

    """
  return _libsbml.XMLError_getStandardMessage(*args)

class XMLErrorLog(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Log of diagnostics reported during XML processing.

    @htmlinclude not-sbml-warning.html

    The error log is a list.  The XML layer of libSBML maintains an error
    log associated with a given XML document or data stream.  When an
    operation results in an error, or when there is something wrong with the
    XML content, the problem is reported as an XMLError object stored in the
    XMLErrorLog list.  Potential problems range from low-level issues (such
    as the inability to open a file) to XML syntax errors (such as
    mismatched tags or other problems).

    A typical approach for using this error log is to first use
    @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif@~
    to inquire how many XMLError object instances it contains, and then to
    iterate over the list of objects one at a time using
    getError(long n) const.  Indexing in the list begins at 0.

    In normal circumstances, programs using libSBML will actually obtain an
    SBMLErrorLog rather than an XMLErrorLog.  The former is subclassed from
    XMLErrorLog and simply wraps commands for working with SBMLError objects
    rather than the low-level XMLError objects.  Classes such as
    SBMLDocument use the higher-level SBMLErrorLog.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLErrorLog, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLErrorLog, name)
    __repr__ = _swig_repr
    def getNumErrors(self):
        """
        getNumErrors(self) -> unsigned int

        Returns the number of errors that have been logged.

        To retrieve individual errors from the log, callers may use
        @if clike getError() @else XMLErrorLog.getError() @endif.

        @return the number of errors that have been logged.

        """
        return _libsbml.XMLErrorLog_getNumErrors(self)

    def getError(self, *args):
        """
        getError(self, unsigned int n) -> XMLError

        Returns the <i>n</i>th XMLError object in this log.

        Index @p n is counted from 0.  Callers should first inquire about the
        number of items in the log by using the method
        @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif.
        Attempts to use an error index number that exceeds the actual number
        of errors in the log will result in a @c None being returned.

        @param n the index number of the error to retrieve (with 0 being the
        first error).

        @return the <i>n</i>th XMLError in this log, or @c None if @p n is
        greater than or equal to
        @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif.

        @see getNumErrors()

        """
        return _libsbml.XMLErrorLog_getError(self, *args)

    def clearLog(self):
        """
        clearLog(self)

        Deletes all errors from this log.

        """
        return _libsbml.XMLErrorLog_clearLog(self)

    def __init__(self, *args): 
        """
        __init__(self) -> XMLErrorLog
        __init__(self, XMLErrorLog other) -> XMLErrorLog

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html Log of diagnostics reported during XML processing.

        @htmlinclude not-sbml-warning.html

        The error log is a list.  The XML layer of libSBML maintains an error
        log associated with a given XML document or data stream.  When an
        operation results in an error, or when there is something wrong with the
        XML content, the problem is reported as an XMLError object stored in the
        XMLErrorLog list.  Potential problems range from low-level issues (such
        as the inability to open a file) to XML syntax errors (such as
        mismatched tags or other problems).

        A typical approach for using this error log is to first use
        @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif@~
        to inquire how many XMLError object instances it contains, and then to
        iterate over the list of objects one at a time using
        getError(long n) const.  Indexing in the list begins at 0.

        In normal circumstances, programs using libSBML will actually obtain an
        SBMLErrorLog rather than an XMLErrorLog.  The former is subclassed from
        XMLErrorLog and simply wraps commands for working with SBMLError objects
        rather than the low-level XMLError objects.  Classes such as
        SBMLDocument use the higher-level SBMLErrorLog.

        """
        this = _libsbml.new_XMLErrorLog(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_XMLErrorLog
    __del__ = lambda self : None;
    def add(self, *args):
        """
        add(self, XMLError error)
        add(self, std::vector<(p.XMLError)> errors)
        """
        return _libsbml.XMLErrorLog_add(self, *args)

    def toString(self):
        """
        toString(self) -> string

        Writes all errors contained in this log to a string and returns it.

        This method uses printErrors() to format the diagnostic messages.
        Please consult that method for information about the organization
        of the messages in the string returned by this method.

        @return a string containing all logged errors and warnings.

        @see printErrors()

        """
        return _libsbml.XMLErrorLog_toString(self)

    def printErrors(self, *args):
        """
        printErrors(self, ostream stream = cerr)
        printErrors(self)

        Prints all the errors or warnings stored in this error log.

        This method prints the text to the stream given by the optional
        parameter @p stream.  If no stream is given, the method prints the
        output to the standard error stream.

        The format of the output is:
        @verbatim
           N error(s):
             line NNN: (id) message
         @endverbatim
        If no errors have occurred, i.e.,
        <code>getNumErrors() == 0</code>, then no output will be produced.
        @param stream the ostream or ostringstream object indicating where
        the output should be printed.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        return _libsbml.XMLErrorLog_printErrors(self, *args)

    def isSeverityOverridden(self):
        """
        isSeverityOverridden(self) -> bool

        Returns a boolean indicating whether or not the severity has been
        overridden.

        @par
        The <em>severity override</em> mechanism in XMLErrorLog is intended to help
        applications handle error conditions in ways that may be more convenient
        for those applications.  It is possible to use the mechanism to override
        the severity code of errors logged by libSBML, and even to disable error
        logging completely.  An override stays in effect until the override is
        changed again by the calling application.

        @return @c True if an error severity override has been set, @c False
        otherwise.

        @see getSeverityOverride()
        @see setSeverityOverride()
        @see unsetSeverityOverride()
        @see changeErrorSeverity()

        """
        return _libsbml.XMLErrorLog_isSeverityOverridden(self)

    def unsetSeverityOverride(self):
        """
        unsetSeverityOverride(self)

        Usets an existing override.

        @par
        The <em>severity override</em> mechanism in XMLErrorLog is intended to help
        applications handle error conditions in ways that may be more convenient
        for those applications.  It is possible to use the mechanism to override
        the severity code of errors logged by libSBML, and even to disable error
        logging completely.  An override stays in effect until the override is
        changed again by the calling application.

        @see getSeverityOverride()
        @see setSeverityOverride()
        @see isSeverityOverridden()
        @see changeErrorSeverity()

        """
        return _libsbml.XMLErrorLog_unsetSeverityOverride(self)

    def getSeverityOverride(self):
        """
        getSeverityOverride(self) -> XMLErrorSeverityOverride_t

        Returns the current override.

        @par
        The <em>severity override</em> mechanism in XMLErrorLog is intended to help
        applications handle error conditions in ways that may be more convenient
        for those applications.  It is possible to use the mechanism to override
        the severity code of errors logged by libSBML, and even to disable error
        logging completely.  An override stays in effect until the override is
        changed again by the calling application.

        @return a severity override code.  The possible values are @if clike drawn
        from the enumeration #XMLErrorSeverityOverride_t@endif:
        @li @link libsbml#LIBSBML_OVERRIDE_DISABLED LIBSBML_OVERRIDE_DISABLED@endlink
        @li @link libsbml#LIBSBML_OVERRIDE_DONT_LOG LIBSBML_OVERRIDE_DONT_LOG@endlink
        @li @link libsbml#LIBSBML_OVERRIDE_WARNING LIBSBML_OVERRIDE_WARNING@endlink

        @see isSeverityOverridden()
        @see setSeverityOverride()
        @see unsetSeverityOverride()
        @see changeErrorSeverity()

        """
        return _libsbml.XMLErrorLog_getSeverityOverride(self)

    def setSeverityOverride(self, *args):
        """
        setSeverityOverride(self, XMLErrorSeverityOverride_t severity)

        Set the severity override.

        @par
        The <em>severity override</em> mechanism in XMLErrorLog is intended to help
        applications handle error conditions in ways that may be more convenient
        for those applications.  It is possible to use the mechanism to override
        the severity code of errors logged by libSBML, and even to disable error
        logging completely.  An override stays in effect until the override is
        changed again by the calling application.

        @param severity an override code indicating what to do.  If the value is
        @link libsbml#LIBSBML_OVERRIDE_DISABLED LIBSBML_OVERRIDE_DISABLED@endlink
        (the default setting) all errors logged will be given the severity
        specified in their usual definition.   If the value is
        @link libsbml#LIBSBML_OVERRIDE_WARNING LIBSBML_OVERRIDE_WARNING@endlink,
        then all errors will be logged as warnings.  If the value is 
        @link libsbml#LIBSBML_OVERRIDE_DONT_LOG LIBSBML_OVERRIDE_DONT_LOG@endlink,
        no error will be logged, regardless of their severity.

        @see isSeverityOverridden()
        @see getSeverityOverride()
        @see unsetSeverityOverride()
        @see changeErrorSeverity()

        """
        return _libsbml.XMLErrorLog_setSeverityOverride(self, *args)

    def changeErrorSeverity(self, *args):
        """
        changeErrorSeverity(self, XMLErrorSeverity_t originalSeverity, XMLErrorSeverity_t targetSeverity, 
            string package = "all")
        changeErrorSeverity(self, XMLErrorSeverity_t originalSeverity, XMLErrorSeverity_t targetSeverity)

        Changes the severity override for errors in the log that have a given
        severity.

        This method searches through the list of errors in the log, comparing
        each one's severity to the value of @p originalSeverity.  For each error
        encountered with that severity logged by the named @p package, the
        severity of the error is reset to @p targetSeverity.

        @par
        The <em>severity override</em> mechanism in XMLErrorLog is intended to help
        applications handle error conditions in ways that may be more convenient
        for those applications.  It is possible to use the mechanism to override
        the severity code of errors logged by libSBML, and even to disable error
        logging completely.  An override stays in effect until the override is
        changed again by the calling application.

        @param originalSeverity the severity code to match

        @param targetSeverity the severity code to use as the new severity

        @param package a string, the name of an SBML Level&nbsp;3 package
        extension to use to narrow the search for errors.  A value of @c 'all'
        signifies to match against errors logged from any package; a value of a
        package nickname such as @c 'comp' signifies to limit consideration to
        errors from just that package.  If no value is provided, @c 'all' is the
        default.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see isSeverityOverridden()
        @see getSeverityOverride()
        @see setSeverityOverride()
        @see unsetSeverityOverride()

        """
        return _libsbml.XMLErrorLog_changeErrorSeverity(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

XMLErrorLog_swigregister = _libsbml.XMLErrorLog_swigregister
XMLErrorLog_swigregister(XMLErrorLog)

class SBMLErrorLog(XMLErrorLog):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Log of diagnostics reported during processing.

    @htmlinclude not-sbml-warning.html

    The error log is a list.  Each SBMLDocument maintains its own
    SBMLErrorLog.  When a libSBML operation on SBML content results in an
    error, or when there is something worth noting about the SBML content,
    the issue is reported as an SBMLError object stored in the SBMLErrorLog
    list.

    SBMLErrorLog is derived from XMLErrorLog, an object class that serves
    exactly the same purpose but for the XML parsing layer.  XMLErrorLog
    provides crucial methods such as
    @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif@~
    for determining how many SBMLError or XMLError objects are in the log.
    SBMLErrorLog inherits these methods.

    The general approach to working with SBMLErrorLog in user programs
    involves first obtaining a pointer to a log from a libSBML object such
    as SBMLDocument.  Callers should then use
    @if java XMLErrorLog.getNumErrors()@else getNumErrors() @endif@~ to inquire how
    many objects there are in the list.  (The answer may be 0.)  If there is
    at least one SBMLError object in the SBMLErrorLog instance, callers can
    then iterate over the list using
    SBMLErrorLog.getError()@if clike const@endif,
    using methods provided by the SBMLError class to find out the error code
    and associated information such as the error severity, the message, and
    the line number in the input.

    If you wish to simply print the error strings for a human to read, an
    easier and more direct way might be to use SBMLDocument.printErrors().

    @see SBMLError
    @see XMLErrorLog
    @see XMLError

    """
    __swig_setmethods__ = {}
    for _s in [XMLErrorLog]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLErrorLog, name, value)
    __swig_getmethods__ = {}
    for _s in [XMLErrorLog]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLErrorLog, name)
    __repr__ = _swig_repr
    def getError(self, *args):
        """
        getError(self, unsigned int n) -> SBMLError

        Returns the <i>n</i>th SBMLError object in this log.

        Index @p n is counted from 0.  Callers should first inquire about the
        number of items in the log by using the
        @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif@~ method.
        Attempts to use an error index number that exceeds the actual number
        of errors in the log will result in a @c None being returned.

        @param n the index number of the error to retrieve (with 0 being the
        first error).

        @return the <i>n</i>th SBMLError in this log, or @c None if @p n is
        greater than or equal to
        @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif.

        @see getNumErrors()

        """
        return _libsbml.SBMLErrorLog_getError(self, *args)

    def getNumFailsWithSeverity(self, *args):
        """
        getNumFailsWithSeverity(self, unsigned int severity) -> unsigned int
        getNumFailsWithSeverity(self, unsigned int severity) -> unsigned int

        Returns the number of errors that have been logged with the given
        severity code.

        @par
        LibSBML associates severity levels with every SBMLError object to
        provide an indication of how serious the problem is.  Severities range
        from informational diagnostics to fatal (irrecoverable) errors.  Given
        an SBMLError object instance, a caller can interrogate it for its
        severity level using methods such as SBMLError.getSeverity(),
        SBMLError.isFatal(), and so on.  The present method encapsulates
        iteration and interrogation of all objects in an SBMLErrorLog, making
        it easy to check for the presence of error objects with specific
        severity levels.

        @if clike @param severity a value from
        #SBMLErrorSeverity_t @endif@if java @param severity a
        value from the set of <code>LIBSBML_SEV_</code> constants defined by
        the interface class <code><a
        href='libsbmlConstants.html'>libsbmlConstants</a></code> @endif@if python @param severity a
        value from the set of <code>LIBSBML_SEV_</code> constants defined by
        the interface class @link libsbml libsbml@endlink. @endif@~

        @return a count of the number of errors with the given severity code.

        @see getNumErrors()

        """
        return _libsbml.SBMLErrorLog_getNumFailsWithSeverity(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> SBMLErrorLog
        __init__(self, SBMLErrorLog other) -> SBMLErrorLog

        @sbmlpackage{core}

        @htmlinclude pkg-marker-core.html Log of diagnostics reported during processing.

        @htmlinclude not-sbml-warning.html

        The error log is a list.  Each SBMLDocument maintains its own
        SBMLErrorLog.  When a libSBML operation on SBML content results in an
        error, or when there is something worth noting about the SBML content,
        the issue is reported as an SBMLError object stored in the SBMLErrorLog
        list.

        SBMLErrorLog is derived from XMLErrorLog, an object class that serves
        exactly the same purpose but for the XML parsing layer.  XMLErrorLog
        provides crucial methods such as
        @if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif@~
        for determining how many SBMLError or XMLError objects are in the log.
        SBMLErrorLog inherits these methods.

        The general approach to working with SBMLErrorLog in user programs
        involves first obtaining a pointer to a log from a libSBML object such
        as SBMLDocument.  Callers should then use
        @if java XMLErrorLog.getNumErrors()@else getNumErrors() @endif@~ to inquire how
        many objects there are in the list.  (The answer may be 0.)  If there is
        at least one SBMLError object in the SBMLErrorLog instance, callers can
        then iterate over the list using
        SBMLErrorLog.getError()@if clike const@endif,
        using methods provided by the SBMLError class to find out the error code
        and associated information such as the error severity, the message, and
        the line number in the input.

        If you wish to simply print the error strings for a human to read, an
        easier and more direct way might be to use SBMLDocument.printErrors().

        @see SBMLError
        @see XMLErrorLog
        @see XMLError

        """
        this = _libsbml.new_SBMLErrorLog(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLErrorLog
    __del__ = lambda self : None;
    def logError(self, *args):
        """
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_ERROR, 
            unsigned int category = LIBSBML_CAT_SBML)
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_ERROR)
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0)
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0)
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "")
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION)
        logError(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL)
        logError(self, unsigned int errorId = 0)
        logError(self)

        @internal
        Convenience function that combines creating an SBMLError object and
        adding it to the log.

        @param errorId a long integer, the identification number of the error.

        @param level a long integer, the SBML Level

        @param version a long integer, the SBML Level's Version

        @param details a string containing additional details about the error.
        If the error code in @p errorId is one that is recognized by SBMLError,
        the given message is @em appended to a predefined message associated
        with the given code.  If the error code is not recognized, the message
        is stored as-is as the text of the error.

        @param line a long integer, the line number at which the error occured.

        @param column a long integer, the column number at which the error occured.

        @param severity an integer indicating severity of the error.

        @param category an integer indicating the category to which the error
        belongs.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @internal

        """
        return _libsbml.SBMLErrorLog_logError(self, *args)

    def logPackageError(self, *args):
        """
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", 
            unsigned int line = 0, unsigned int column = 0, 
            unsigned int severity = LIBSBML_SEV_ERROR, 
            unsigned int category = LIBSBML_CAT_SBML)
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", 
            unsigned int line = 0, unsigned int column = 0, 
            unsigned int severity = LIBSBML_SEV_ERROR)
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", 
            unsigned int line = 0, unsigned int column = 0)
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", 
            unsigned int line = 0)
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "")
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION)
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1, unsigned int level = SBML_DEFAULT_LEVEL)
        logPackageError(self, string package = "core", unsigned int errorId = 0, 
            unsigned int pkgVersion = 1)
        logPackageError(self, string package = "core", unsigned int errorId = 0)
        logPackageError(self, string package = "core")
        logPackageError(self)

        @internal

        @internal

        """
        return _libsbml.SBMLErrorLog_logPackageError(self, *args)

    def add(self, *args):
        """add(self, SBMLError error)"""
        return _libsbml.SBMLErrorLog_add(self, *args)

    def remove(self, *args):
        """
        remove(self, unsigned int errorId)

        Removes an error having errorId from the SBMLError list.

        Only the first item will be removed if there are multiple errors
        with the given errorId.

        @param errorId the error identifier of the error to be removed.

        """
        return _libsbml.SBMLErrorLog_remove(self, *args)

    def contains(self, *args):
        """
        contains(self, unsigned int errorId) -> bool

        Returns true if SBMLErrorLog contains an errorId

        @param errorId the error identifier of the error to be found.

        """
        return _libsbml.SBMLErrorLog_contains(self, *args)

SBMLErrorLog_swigregister = _libsbml.SBMLErrorLog_swigregister
SBMLErrorLog_swigregister(SBMLErrorLog)

UnknownError = _libsbml.UnknownError
NotUTF8 = _libsbml.NotUTF8
UnrecognizedElement = _libsbml.UnrecognizedElement
NotSchemaConformant = _libsbml.NotSchemaConformant
L3NotSchemaConformant = _libsbml.L3NotSchemaConformant
InvalidMathElement = _libsbml.InvalidMathElement
DisallowedMathMLSymbol = _libsbml.DisallowedMathMLSymbol
DisallowedMathMLEncodingUse = _libsbml.DisallowedMathMLEncodingUse
DisallowedDefinitionURLUse = _libsbml.DisallowedDefinitionURLUse
BadCsymbolDefinitionURLValue = _libsbml.BadCsymbolDefinitionURLValue
DisallowedMathTypeAttributeUse = _libsbml.DisallowedMathTypeAttributeUse
DisallowedMathTypeAttributeValue = _libsbml.DisallowedMathTypeAttributeValue
LambdaOnlyAllowedInFunctionDef = _libsbml.LambdaOnlyAllowedInFunctionDef
BooleanOpsNeedBooleanArgs = _libsbml.BooleanOpsNeedBooleanArgs
NumericOpsNeedNumericArgs = _libsbml.NumericOpsNeedNumericArgs
ArgsToEqNeedSameType = _libsbml.ArgsToEqNeedSameType
PiecewiseNeedsConsistentTypes = _libsbml.PiecewiseNeedsConsistentTypes
PieceNeedsBoolean = _libsbml.PieceNeedsBoolean
ApplyCiMustBeUserFunction = _libsbml.ApplyCiMustBeUserFunction
ApplyCiMustBeModelComponent = _libsbml.ApplyCiMustBeModelComponent
KineticLawParametersAreLocalOnly = _libsbml.KineticLawParametersAreLocalOnly
MathResultMustBeNumeric = _libsbml.MathResultMustBeNumeric
OpsNeedCorrectNumberOfArgs = _libsbml.OpsNeedCorrectNumberOfArgs
InvalidNoArgsPassedToFunctionDef = _libsbml.InvalidNoArgsPassedToFunctionDef
DisallowedMathUnitsUse = _libsbml.DisallowedMathUnitsUse
InvalidUnitsValue = _libsbml.InvalidUnitsValue
DuplicateComponentId = _libsbml.DuplicateComponentId
DuplicateUnitDefinitionId = _libsbml.DuplicateUnitDefinitionId
DuplicateLocalParameterId = _libsbml.DuplicateLocalParameterId
MultipleAssignmentOrRateRules = _libsbml.MultipleAssignmentOrRateRules
MultipleEventAssignmentsForId = _libsbml.MultipleEventAssignmentsForId
EventAndAssignmentRuleForId = _libsbml.EventAndAssignmentRuleForId
DuplicateMetaId = _libsbml.DuplicateMetaId
InvalidSBOTermSyntax = _libsbml.InvalidSBOTermSyntax
InvalidMetaidSyntax = _libsbml.InvalidMetaidSyntax
InvalidIdSyntax = _libsbml.InvalidIdSyntax
InvalidUnitIdSyntax = _libsbml.InvalidUnitIdSyntax
InvalidNameSyntax = _libsbml.InvalidNameSyntax
MissingAnnotationNamespace = _libsbml.MissingAnnotationNamespace
DuplicateAnnotationNamespaces = _libsbml.DuplicateAnnotationNamespaces
SBMLNamespaceInAnnotation = _libsbml.SBMLNamespaceInAnnotation
MultipleAnnotations = _libsbml.MultipleAnnotations
InconsistentArgUnits = _libsbml.InconsistentArgUnits
InconsistentKineticLawUnitsL3 = _libsbml.InconsistentKineticLawUnitsL3
AssignRuleCompartmentMismatch = _libsbml.AssignRuleCompartmentMismatch
AssignRuleSpeciesMismatch = _libsbml.AssignRuleSpeciesMismatch
AssignRuleParameterMismatch = _libsbml.AssignRuleParameterMismatch
AssignRuleStoichiometryMismatch = _libsbml.AssignRuleStoichiometryMismatch
InitAssignCompartmenMismatch = _libsbml.InitAssignCompartmenMismatch
InitAssignSpeciesMismatch = _libsbml.InitAssignSpeciesMismatch
InitAssignParameterMismatch = _libsbml.InitAssignParameterMismatch
InitAssignStoichiometryMismatch = _libsbml.InitAssignStoichiometryMismatch
RateRuleCompartmentMismatch = _libsbml.RateRuleCompartmentMismatch
RateRuleSpeciesMismatch = _libsbml.RateRuleSpeciesMismatch
RateRuleParameterMismatch = _libsbml.RateRuleParameterMismatch
RateRuleStoichiometryMismatch = _libsbml.RateRuleStoichiometryMismatch
KineticLawNotSubstancePerTime = _libsbml.KineticLawNotSubstancePerTime
SpeciesInvalidExtentUnits = _libsbml.SpeciesInvalidExtentUnits
DelayUnitsNotTime = _libsbml.DelayUnitsNotTime
EventAssignCompartmentMismatch = _libsbml.EventAssignCompartmentMismatch
EventAssignSpeciesMismatch = _libsbml.EventAssignSpeciesMismatch
EventAssignParameterMismatch = _libsbml.EventAssignParameterMismatch
EventAssignStoichiometryMismatch = _libsbml.EventAssignStoichiometryMismatch
PriorityUnitsNotDimensionless = _libsbml.PriorityUnitsNotDimensionless
UpperUnitBound = _libsbml.UpperUnitBound
OverdeterminedSystem = _libsbml.OverdeterminedSystem
InvalidModelSBOTerm = _libsbml.InvalidModelSBOTerm
InvalidFunctionDefSBOTerm = _libsbml.InvalidFunctionDefSBOTerm
InvalidParameterSBOTerm = _libsbml.InvalidParameterSBOTerm
InvalidInitAssignSBOTerm = _libsbml.InvalidInitAssignSBOTerm
InvalidRuleSBOTerm = _libsbml.InvalidRuleSBOTerm
InvalidConstraintSBOTerm = _libsbml.InvalidConstraintSBOTerm
InvalidReactionSBOTerm = _libsbml.InvalidReactionSBOTerm
InvalidSpeciesReferenceSBOTerm = _libsbml.InvalidSpeciesReferenceSBOTerm
InvalidKineticLawSBOTerm = _libsbml.InvalidKineticLawSBOTerm
InvalidEventSBOTerm = _libsbml.InvalidEventSBOTerm
InvalidEventAssignmentSBOTerm = _libsbml.InvalidEventAssignmentSBOTerm
InvalidCompartmentSBOTerm = _libsbml.InvalidCompartmentSBOTerm
InvalidSpeciesSBOTerm = _libsbml.InvalidSpeciesSBOTerm
InvalidCompartmentTypeSBOTerm = _libsbml.InvalidCompartmentTypeSBOTerm
InvalidSpeciesTypeSBOTerm = _libsbml.InvalidSpeciesTypeSBOTerm
InvalidTriggerSBOTerm = _libsbml.InvalidTriggerSBOTerm
InvalidDelaySBOTerm = _libsbml.InvalidDelaySBOTerm
NotesNotInXHTMLNamespace = _libsbml.NotesNotInXHTMLNamespace
NotesContainsXMLDecl = _libsbml.NotesContainsXMLDecl
NotesContainsDOCTYPE = _libsbml.NotesContainsDOCTYPE
InvalidNotesContent = _libsbml.InvalidNotesContent
OnlyOneNotesElementAllowed = _libsbml.OnlyOneNotesElementAllowed
InvalidNamespaceOnSBML = _libsbml.InvalidNamespaceOnSBML
MissingOrInconsistentLevel = _libsbml.MissingOrInconsistentLevel
MissingOrInconsistentVersion = _libsbml.MissingOrInconsistentVersion
PackageNSMustMatch = _libsbml.PackageNSMustMatch
LevelPositiveInteger = _libsbml.LevelPositiveInteger
VersionPositiveInteger = _libsbml.VersionPositiveInteger
AllowedAttributesOnSBML = _libsbml.AllowedAttributesOnSBML
L3PackageOnLowerSBML = _libsbml.L3PackageOnLowerSBML
MissingModel = _libsbml.MissingModel
IncorrectOrderInModel = _libsbml.IncorrectOrderInModel
EmptyListElement = _libsbml.EmptyListElement
NeedCompartmentIfHaveSpecies = _libsbml.NeedCompartmentIfHaveSpecies
OneOfEachListOf = _libsbml.OneOfEachListOf
OnlyFuncDefsInListOfFuncDefs = _libsbml.OnlyFuncDefsInListOfFuncDefs
OnlyUnitDefsInListOfUnitDefs = _libsbml.OnlyUnitDefsInListOfUnitDefs
OnlyCompartmentsInListOfCompartments = _libsbml.OnlyCompartmentsInListOfCompartments
OnlySpeciesInListOfSpecies = _libsbml.OnlySpeciesInListOfSpecies
OnlyParametersInListOfParameters = _libsbml.OnlyParametersInListOfParameters
OnlyInitAssignsInListOfInitAssigns = _libsbml.OnlyInitAssignsInListOfInitAssigns
OnlyRulesInListOfRules = _libsbml.OnlyRulesInListOfRules
OnlyConstraintsInListOfConstraints = _libsbml.OnlyConstraintsInListOfConstraints
OnlyReactionsInListOfReactions = _libsbml.OnlyReactionsInListOfReactions
OnlyEventsInListOfEvents = _libsbml.OnlyEventsInListOfEvents
L3ConversionFactorOnModel = _libsbml.L3ConversionFactorOnModel
L3TimeUnitsOnModel = _libsbml.L3TimeUnitsOnModel
L3VolumeUnitsOnModel = _libsbml.L3VolumeUnitsOnModel
L3AreaUnitsOnModel = _libsbml.L3AreaUnitsOnModel
L3LengthUnitsOnModel = _libsbml.L3LengthUnitsOnModel
L3ExtentUnitsOnModel = _libsbml.L3ExtentUnitsOnModel
AllowedAttributesOnModel = _libsbml.AllowedAttributesOnModel
AllowedAttributesOnListOfFuncs = _libsbml.AllowedAttributesOnListOfFuncs
AllowedAttributesOnListOfUnitDefs = _libsbml.AllowedAttributesOnListOfUnitDefs
AllowedAttributesOnListOfComps = _libsbml.AllowedAttributesOnListOfComps
AllowedAttributesOnListOfSpecies = _libsbml.AllowedAttributesOnListOfSpecies
AllowedAttributesOnListOfParams = _libsbml.AllowedAttributesOnListOfParams
AllowedAttributesOnListOfInitAssign = _libsbml.AllowedAttributesOnListOfInitAssign
AllowedAttributesOnListOfRules = _libsbml.AllowedAttributesOnListOfRules
AllowedAttributesOnListOfConstraints = _libsbml.AllowedAttributesOnListOfConstraints
AllowedAttributesOnListOfReactions = _libsbml.AllowedAttributesOnListOfReactions
AllowedAttributesOnListOfEvents = _libsbml.AllowedAttributesOnListOfEvents
FunctionDefMathNotLambda = _libsbml.FunctionDefMathNotLambda
InvalidApplyCiInLambda = _libsbml.InvalidApplyCiInLambda
RecursiveFunctionDefinition = _libsbml.RecursiveFunctionDefinition
InvalidCiInLambda = _libsbml.InvalidCiInLambda
InvalidFunctionDefReturnType = _libsbml.InvalidFunctionDefReturnType
OneMathElementPerFunc = _libsbml.OneMathElementPerFunc
AllowedAttributesOnFunc = _libsbml.AllowedAttributesOnFunc
InvalidUnitDefId = _libsbml.InvalidUnitDefId
InvalidSubstanceRedefinition = _libsbml.InvalidSubstanceRedefinition
InvalidLengthRedefinition = _libsbml.InvalidLengthRedefinition
InvalidAreaRedefinition = _libsbml.InvalidAreaRedefinition
InvalidTimeRedefinition = _libsbml.InvalidTimeRedefinition
InvalidVolumeRedefinition = _libsbml.InvalidVolumeRedefinition
VolumeLitreDefExponentNotOne = _libsbml.VolumeLitreDefExponentNotOne
VolumeMetreDefExponentNot3 = _libsbml.VolumeMetreDefExponentNot3
EmptyListOfUnits = _libsbml.EmptyListOfUnits
InvalidUnitKind = _libsbml.InvalidUnitKind
OffsetNoLongerValid = _libsbml.OffsetNoLongerValid
CelsiusNoLongerValid = _libsbml.CelsiusNoLongerValid
EmptyUnitListElement = _libsbml.EmptyUnitListElement
OneListOfUnitsPerUnitDef = _libsbml.OneListOfUnitsPerUnitDef
OnlyUnitsInListOfUnits = _libsbml.OnlyUnitsInListOfUnits
AllowedAttributesOnUnitDefinition = _libsbml.AllowedAttributesOnUnitDefinition
AllowedAttributesOnListOfUnits = _libsbml.AllowedAttributesOnListOfUnits
AllowedAttributesOnUnit = _libsbml.AllowedAttributesOnUnit
ZeroDimensionalCompartmentSize = _libsbml.ZeroDimensionalCompartmentSize
ZeroDimensionalCompartmentUnits = _libsbml.ZeroDimensionalCompartmentUnits
ZeroDimensionalCompartmentConst = _libsbml.ZeroDimensionalCompartmentConst
UndefinedOutsideCompartment = _libsbml.UndefinedOutsideCompartment
RecursiveCompartmentContainment = _libsbml.RecursiveCompartmentContainment
ZeroDCompartmentContainment = _libsbml.ZeroDCompartmentContainment
Invalid1DCompartmentUnits = _libsbml.Invalid1DCompartmentUnits
Invalid2DCompartmentUnits = _libsbml.Invalid2DCompartmentUnits
Invalid3DCompartmentUnits = _libsbml.Invalid3DCompartmentUnits
InvalidCompartmentTypeRef = _libsbml.InvalidCompartmentTypeRef
OneDimensionalCompartmentUnits = _libsbml.OneDimensionalCompartmentUnits
TwoDimensionalCompartmentUnits = _libsbml.TwoDimensionalCompartmentUnits
ThreeDimensionalCompartmentUnits = _libsbml.ThreeDimensionalCompartmentUnits
AllowedAttributesOnCompartment = _libsbml.AllowedAttributesOnCompartment
NoUnitsOnCompartment = _libsbml.NoUnitsOnCompartment
InvalidSpeciesCompartmentRef = _libsbml.InvalidSpeciesCompartmentRef
HasOnlySubsNoSpatialUnits = _libsbml.HasOnlySubsNoSpatialUnits
NoSpatialUnitsInZeroD = _libsbml.NoSpatialUnitsInZeroD
NoConcentrationInZeroD = _libsbml.NoConcentrationInZeroD
SpatialUnitsInOneD = _libsbml.SpatialUnitsInOneD
SpatialUnitsInTwoD = _libsbml.SpatialUnitsInTwoD
SpatialUnitsInThreeD = _libsbml.SpatialUnitsInThreeD
InvalidSpeciesSusbstanceUnits = _libsbml.InvalidSpeciesSusbstanceUnits
BothAmountAndConcentrationSet = _libsbml.BothAmountAndConcentrationSet
NonBoundarySpeciesAssignedAndUsed = _libsbml.NonBoundarySpeciesAssignedAndUsed
NonConstantSpeciesUsed = _libsbml.NonConstantSpeciesUsed
InvalidSpeciesTypeRef = _libsbml.InvalidSpeciesTypeRef
MultSpeciesSameTypeInCompartment = _libsbml.MultSpeciesSameTypeInCompartment
MissingSpeciesCompartment = _libsbml.MissingSpeciesCompartment
SpatialSizeUnitsRemoved = _libsbml.SpatialSizeUnitsRemoved
SubstanceUnitsOnSpecies = _libsbml.SubstanceUnitsOnSpecies
ConversionFactorOnSpecies = _libsbml.ConversionFactorOnSpecies
AllowedAttributesOnSpecies = _libsbml.AllowedAttributesOnSpecies
InvalidParameterUnits = _libsbml.InvalidParameterUnits
ParameterUnits = _libsbml.ParameterUnits
ConversionFactorMustConstant = _libsbml.ConversionFactorMustConstant
AllowedAttributesOnParameter = _libsbml.AllowedAttributesOnParameter
InvalidInitAssignSymbol = _libsbml.InvalidInitAssignSymbol
MultipleInitAssignments = _libsbml.MultipleInitAssignments
InitAssignmentAndRuleForSameId = _libsbml.InitAssignmentAndRuleForSameId
OneMathElementPerInitialAssign = _libsbml.OneMathElementPerInitialAssign
AllowedAttributesOnInitialAssign = _libsbml.AllowedAttributesOnInitialAssign
InvalidAssignRuleVariable = _libsbml.InvalidAssignRuleVariable
InvalidRateRuleVariable = _libsbml.InvalidRateRuleVariable
AssignmentToConstantEntity = _libsbml.AssignmentToConstantEntity
RateRuleForConstantEntity = _libsbml.RateRuleForConstantEntity
RepeatedRule10304 = _libsbml.RepeatedRule10304
CircularRuleDependency = _libsbml.CircularRuleDependency
OneMathElementPerRule = _libsbml.OneMathElementPerRule
AllowedAttributesOnAssignRule = _libsbml.AllowedAttributesOnAssignRule
AllowedAttributesOnRateRule = _libsbml.AllowedAttributesOnRateRule
AllowedAttributesOnAlgRule = _libsbml.AllowedAttributesOnAlgRule
ConstraintMathNotBoolean = _libsbml.ConstraintMathNotBoolean
IncorrectOrderInConstraint = _libsbml.IncorrectOrderInConstraint
ConstraintNotInXHTMLNamespace = _libsbml.ConstraintNotInXHTMLNamespace
ConstraintContainsXMLDecl = _libsbml.ConstraintContainsXMLDecl
ConstraintContainsDOCTYPE = _libsbml.ConstraintContainsDOCTYPE
InvalidConstraintContent = _libsbml.InvalidConstraintContent
OneMathElementPerConstraint = _libsbml.OneMathElementPerConstraint
OneMessageElementPerConstraint = _libsbml.OneMessageElementPerConstraint
AllowedAttributesOnConstraint = _libsbml.AllowedAttributesOnConstraint
NoReactantsOrProducts = _libsbml.NoReactantsOrProducts
IncorrectOrderInReaction = _libsbml.IncorrectOrderInReaction
EmptyListInReaction = _libsbml.EmptyListInReaction
InvalidReactantsProductsList = _libsbml.InvalidReactantsProductsList
InvalidModifiersList = _libsbml.InvalidModifiersList
OneSubElementPerReaction = _libsbml.OneSubElementPerReaction
CompartmentOnReaction = _libsbml.CompartmentOnReaction
AllowedAttributesOnReaction = _libsbml.AllowedAttributesOnReaction
InvalidSpeciesReference = _libsbml.InvalidSpeciesReference
RepeatedRule20611 = _libsbml.RepeatedRule20611
BothStoichiometryAndMath = _libsbml.BothStoichiometryAndMath
AllowedAttributesOnSpeciesReference = _libsbml.AllowedAttributesOnSpeciesReference
AllowedAttributesOnModifier = _libsbml.AllowedAttributesOnModifier
UndeclaredSpeciesRef = _libsbml.UndeclaredSpeciesRef
IncorrectOrderInKineticLaw = _libsbml.IncorrectOrderInKineticLaw
EmptyListInKineticLaw = _libsbml.EmptyListInKineticLaw
NonConstantLocalParameter = _libsbml.NonConstantLocalParameter
SubsUnitsNoLongerValid = _libsbml.SubsUnitsNoLongerValid
TimeUnitsNoLongerValid = _libsbml.TimeUnitsNoLongerValid
OneListOfPerKineticLaw = _libsbml.OneListOfPerKineticLaw
OnlyLocalParamsInListOfLocalParams = _libsbml.OnlyLocalParamsInListOfLocalParams
AllowedAttributesOnListOfLocalParam = _libsbml.AllowedAttributesOnListOfLocalParam
OneMathPerKineticLaw = _libsbml.OneMathPerKineticLaw
UndeclaredSpeciesInStoichMath = _libsbml.UndeclaredSpeciesInStoichMath
AllowedAttributesOnKineticLaw = _libsbml.AllowedAttributesOnKineticLaw
AllowedAttributesOnListOfSpeciesRef = _libsbml.AllowedAttributesOnListOfSpeciesRef
AllowedAttributesOnListOfMods = _libsbml.AllowedAttributesOnListOfMods
AllowedAttributesOnLocalParameter = _libsbml.AllowedAttributesOnLocalParameter
MissingTriggerInEvent = _libsbml.MissingTriggerInEvent
TriggerMathNotBoolean = _libsbml.TriggerMathNotBoolean
MissingEventAssignment = _libsbml.MissingEventAssignment
TimeUnitsEvent = _libsbml.TimeUnitsEvent
IncorrectOrderInEvent = _libsbml.IncorrectOrderInEvent
ValuesFromTriggerTimeNeedDelay = _libsbml.ValuesFromTriggerTimeNeedDelay
DelayNeedsValuesFromTriggerTime = _libsbml.DelayNeedsValuesFromTriggerTime
OneMathPerTrigger = _libsbml.OneMathPerTrigger
OneMathPerDelay = _libsbml.OneMathPerDelay
InvalidEventAssignmentVariable = _libsbml.InvalidEventAssignmentVariable
EventAssignmentForConstantEntity = _libsbml.EventAssignmentForConstantEntity
OneMathPerEventAssignment = _libsbml.OneMathPerEventAssignment
AllowedAttributesOnEventAssignment = _libsbml.AllowedAttributesOnEventAssignment
OnlyOneDelayPerEvent = _libsbml.OnlyOneDelayPerEvent
OneListOfEventAssignmentsPerEvent = _libsbml.OneListOfEventAssignmentsPerEvent
OnlyEventAssignInListOfEventAssign = _libsbml.OnlyEventAssignInListOfEventAssign
AllowedAttributesOnListOfEventAssign = _libsbml.AllowedAttributesOnListOfEventAssign
AllowedAttributesOnEvent = _libsbml.AllowedAttributesOnEvent
AllowedAttributesOnTrigger = _libsbml.AllowedAttributesOnTrigger
AllowedAttributesOnDelay = _libsbml.AllowedAttributesOnDelay
PersistentNotBoolean = _libsbml.PersistentNotBoolean
InitialValueNotBoolean = _libsbml.InitialValueNotBoolean
OnlyOnePriorityPerEvent = _libsbml.OnlyOnePriorityPerEvent
OneMathPerPriority = _libsbml.OneMathPerPriority
AllowedAttributesOnPriority = _libsbml.AllowedAttributesOnPriority
GeneralWarningNotSpecified = _libsbml.GeneralWarningNotSpecified
CompartmentShouldHaveSize = _libsbml.CompartmentShouldHaveSize
SpeciesShouldHaveValue = _libsbml.SpeciesShouldHaveValue
ParameterShouldHaveUnits = _libsbml.ParameterShouldHaveUnits
LocalParameterShadowsId = _libsbml.LocalParameterShadowsId
LibSBMLAdditionalCodesLowerBound = _libsbml.LibSBMLAdditionalCodesLowerBound
CannotConvertToL1V1 = _libsbml.CannotConvertToL1V1
NoEventsInL1 = _libsbml.NoEventsInL1
NoFunctionDefinitionsInL1 = _libsbml.NoFunctionDefinitionsInL1
NoConstraintsInL1 = _libsbml.NoConstraintsInL1
NoInitialAssignmentsInL1 = _libsbml.NoInitialAssignmentsInL1
NoSpeciesTypesInL1 = _libsbml.NoSpeciesTypesInL1
NoCompartmentTypeInL1 = _libsbml.NoCompartmentTypeInL1
NoNon3DCompartmentsInL1 = _libsbml.NoNon3DCompartmentsInL1
NoFancyStoichiometryMathInL1 = _libsbml.NoFancyStoichiometryMathInL1
NoNonIntegerStoichiometryInL1 = _libsbml.NoNonIntegerStoichiometryInL1
NoUnitMultipliersOrOffsetsInL1 = _libsbml.NoUnitMultipliersOrOffsetsInL1
SpeciesCompartmentRequiredInL1 = _libsbml.SpeciesCompartmentRequiredInL1
NoSpeciesSpatialSizeUnitsInL1 = _libsbml.NoSpeciesSpatialSizeUnitsInL1
NoSBOTermsInL1 = _libsbml.NoSBOTermsInL1
StrictUnitsRequiredInL1 = _libsbml.StrictUnitsRequiredInL1
ConversionFactorNotInL1 = _libsbml.ConversionFactorNotInL1
CompartmentNotOnL1Reaction = _libsbml.CompartmentNotOnL1Reaction
ExtentUnitsNotSubstance = _libsbml.ExtentUnitsNotSubstance
GlobalUnitsNotDeclared = _libsbml.GlobalUnitsNotDeclared
HasOnlySubstanceUnitsNotinL1 = _libsbml.HasOnlySubstanceUnitsNotinL1
AvogadroNotSupported = _libsbml.AvogadroNotSupported
NoConstraintsInL2v1 = _libsbml.NoConstraintsInL2v1
NoInitialAssignmentsInL2v1 = _libsbml.NoInitialAssignmentsInL2v1
NoSpeciesTypeInL2v1 = _libsbml.NoSpeciesTypeInL2v1
NoCompartmentTypeInL2v1 = _libsbml.NoCompartmentTypeInL2v1
NoSBOTermsInL2v1 = _libsbml.NoSBOTermsInL2v1
NoIdOnSpeciesReferenceInL2v1 = _libsbml.NoIdOnSpeciesReferenceInL2v1
NoDelayedEventAssignmentInL2v1 = _libsbml.NoDelayedEventAssignmentInL2v1
StrictUnitsRequiredInL2v1 = _libsbml.StrictUnitsRequiredInL2v1
IntegerSpatialDimensions = _libsbml.IntegerSpatialDimensions
StoichiometryMathNotYetSupported = _libsbml.StoichiometryMathNotYetSupported
PriorityLostFromL3 = _libsbml.PriorityLostFromL3
NonPersistentNotSupported = _libsbml.NonPersistentNotSupported
InitialValueFalseEventNotSupported = _libsbml.InitialValueFalseEventNotSupported
SBOTermNotUniversalInL2v2 = _libsbml.SBOTermNotUniversalInL2v2
NoUnitOffsetInL2v2 = _libsbml.NoUnitOffsetInL2v2
NoKineticLawTimeUnitsInL2v2 = _libsbml.NoKineticLawTimeUnitsInL2v2
NoKineticLawSubstanceUnitsInL2v2 = _libsbml.NoKineticLawSubstanceUnitsInL2v2
NoDelayedEventAssignmentInL2v2 = _libsbml.NoDelayedEventAssignmentInL2v2
ModelSBOBranchChangedBeyondL2v2 = _libsbml.ModelSBOBranchChangedBeyondL2v2
StrictUnitsRequiredInL2v2 = _libsbml.StrictUnitsRequiredInL2v2
StrictSBORequiredInL2v2 = _libsbml.StrictSBORequiredInL2v2
DuplicateAnnotationInvalidInL2v2 = _libsbml.DuplicateAnnotationInvalidInL2v2
NoUnitOffsetInL2v3 = _libsbml.NoUnitOffsetInL2v3
NoKineticLawTimeUnitsInL2v3 = _libsbml.NoKineticLawTimeUnitsInL2v3
NoKineticLawSubstanceUnitsInL2v3 = _libsbml.NoKineticLawSubstanceUnitsInL2v3
NoSpeciesSpatialSizeUnitsInL2v3 = _libsbml.NoSpeciesSpatialSizeUnitsInL2v3
NoEventTimeUnitsInL2v3 = _libsbml.NoEventTimeUnitsInL2v3
NoDelayedEventAssignmentInL2v3 = _libsbml.NoDelayedEventAssignmentInL2v3
ModelSBOBranchChangedBeyondL2v3 = _libsbml.ModelSBOBranchChangedBeyondL2v3
StrictUnitsRequiredInL2v3 = _libsbml.StrictUnitsRequiredInL2v3
StrictSBORequiredInL2v3 = _libsbml.StrictSBORequiredInL2v3
DuplicateAnnotationInvalidInL2v3 = _libsbml.DuplicateAnnotationInvalidInL2v3
NoUnitOffsetInL2v4 = _libsbml.NoUnitOffsetInL2v4
NoKineticLawTimeUnitsInL2v4 = _libsbml.NoKineticLawTimeUnitsInL2v4
NoKineticLawSubstanceUnitsInL2v4 = _libsbml.NoKineticLawSubstanceUnitsInL2v4
NoSpeciesSpatialSizeUnitsInL2v4 = _libsbml.NoSpeciesSpatialSizeUnitsInL2v4
NoEventTimeUnitsInL2v4 = _libsbml.NoEventTimeUnitsInL2v4
ModelSBOBranchChangedInL2v4 = _libsbml.ModelSBOBranchChangedInL2v4
DuplicateAnnotationInvalidInL2v4 = _libsbml.DuplicateAnnotationInvalidInL2v4
NoSpeciesTypeInL3v1 = _libsbml.NoSpeciesTypeInL3v1
NoCompartmentTypeInL3v1 = _libsbml.NoCompartmentTypeInL3v1
NoUnitOffsetInL3v1 = _libsbml.NoUnitOffsetInL3v1
NoKineticLawTimeUnitsInL3v1 = _libsbml.NoKineticLawTimeUnitsInL3v1
NoKineticLawSubstanceUnitsInL3v1 = _libsbml.NoKineticLawSubstanceUnitsInL3v1
NoSpeciesSpatialSizeUnitsInL3v1 = _libsbml.NoSpeciesSpatialSizeUnitsInL3v1
NoEventTimeUnitsInL3v1 = _libsbml.NoEventTimeUnitsInL3v1
ModelSBOBranchChangedInL3v1 = _libsbml.ModelSBOBranchChangedInL3v1
DuplicateAnnotationInvalidInL3v1 = _libsbml.DuplicateAnnotationInvalidInL3v1
NoCompartmentOutsideInL3v1 = _libsbml.NoCompartmentOutsideInL3v1
NoStoichiometryMathInL3v1 = _libsbml.NoStoichiometryMathInL3v1
InvalidSBMLLevelVersion = _libsbml.InvalidSBMLLevelVersion
AnnotationNotesNotAllowedLevel1 = _libsbml.AnnotationNotesNotAllowedLevel1
InvalidRuleOrdering = _libsbml.InvalidRuleOrdering
RequiredPackagePresent = _libsbml.RequiredPackagePresent
UnrequiredPackagePresent = _libsbml.UnrequiredPackagePresent
PackageRequiredShouldBeFalse = _libsbml.PackageRequiredShouldBeFalse
SubsUnitsAllowedInKL = _libsbml.SubsUnitsAllowedInKL
TimeUnitsAllowedInKL = _libsbml.TimeUnitsAllowedInKL
FormulaInLevel1KL = _libsbml.FormulaInLevel1KL
L3SubstanceUnitsOnModel = _libsbml.L3SubstanceUnitsOnModel
TimeUnitsRemoved = _libsbml.TimeUnitsRemoved
BadMathML = _libsbml.BadMathML
FailedMathMLReadOfDouble = _libsbml.FailedMathMLReadOfDouble
FailedMathMLReadOfInteger = _libsbml.FailedMathMLReadOfInteger
FailedMathMLReadOfExponential = _libsbml.FailedMathMLReadOfExponential
FailedMathMLReadOfRational = _libsbml.FailedMathMLReadOfRational
BadMathMLNodeType = _libsbml.BadMathMLNodeType
InvalidMathMLAttribute = _libsbml.InvalidMathMLAttribute
NoTimeSymbolInFunctionDef = _libsbml.NoTimeSymbolInFunctionDef
NoBodyInFunctionDef = _libsbml.NoBodyInFunctionDef
DanglingUnitSIdRef = _libsbml.DanglingUnitSIdRef
RDFMissingAboutTag = _libsbml.RDFMissingAboutTag
RDFEmptyAboutTag = _libsbml.RDFEmptyAboutTag
RDFAboutTagNotMetaid = _libsbml.RDFAboutTagNotMetaid
RDFNotCompleteModelHistory = _libsbml.RDFNotCompleteModelHistory
RDFNotModelHistory = _libsbml.RDFNotModelHistory
AnnotationNotElement = _libsbml.AnnotationNotElement
InconsistentArgUnitsWarnings = _libsbml.InconsistentArgUnitsWarnings
InconsistentPowerUnitsWarnings = _libsbml.InconsistentPowerUnitsWarnings
InconsistentExponUnitsWarnings = _libsbml.InconsistentExponUnitsWarnings
UndeclaredUnits = _libsbml.UndeclaredUnits
UndeclaredTimeUnitsL3 = _libsbml.UndeclaredTimeUnitsL3
UndeclaredExtentUnitsL3 = _libsbml.UndeclaredExtentUnitsL3
UndeclaredObjectUnitsL3 = _libsbml.UndeclaredObjectUnitsL3
UnrecognisedSBOTerm = _libsbml.UnrecognisedSBOTerm
ObseleteSBOTerm = _libsbml.ObseleteSBOTerm
IncorrectCompartmentSpatialDimensions = _libsbml.IncorrectCompartmentSpatialDimensions
CompartmentTypeNotValidAttribute = _libsbml.CompartmentTypeNotValidAttribute
ConstantNotValidAttribute = _libsbml.ConstantNotValidAttribute
MetaIdNotValidAttribute = _libsbml.MetaIdNotValidAttribute
SBOTermNotValidAttributeBeforeL2V3 = _libsbml.SBOTermNotValidAttributeBeforeL2V3
InvalidL1CompartmentUnits = _libsbml.InvalidL1CompartmentUnits
L1V1CompartmentVolumeReqd = _libsbml.L1V1CompartmentVolumeReqd
CompartmentTypeNotValidComponent = _libsbml.CompartmentTypeNotValidComponent
ConstraintNotValidComponent = _libsbml.ConstraintNotValidComponent
EventNotValidComponent = _libsbml.EventNotValidComponent
SBOTermNotValidAttributeBeforeL2V2 = _libsbml.SBOTermNotValidAttributeBeforeL2V2
FuncDefNotValidComponent = _libsbml.FuncDefNotValidComponent
InitialAssignNotValidComponent = _libsbml.InitialAssignNotValidComponent
VariableNotValidAttribute = _libsbml.VariableNotValidAttribute
UnitsNotValidAttribute = _libsbml.UnitsNotValidAttribute
ConstantSpeciesNotValidAttribute = _libsbml.ConstantSpeciesNotValidAttribute
SpatialSizeUnitsNotValidAttribute = _libsbml.SpatialSizeUnitsNotValidAttribute
SpeciesTypeNotValidAttribute = _libsbml.SpeciesTypeNotValidAttribute
HasOnlySubsUnitsNotValidAttribute = _libsbml.HasOnlySubsUnitsNotValidAttribute
IdNotValidAttribute = _libsbml.IdNotValidAttribute
NameNotValidAttribute = _libsbml.NameNotValidAttribute
SpeciesTypeNotValidComponent = _libsbml.SpeciesTypeNotValidComponent
StoichiometryMathNotValidComponent = _libsbml.StoichiometryMathNotValidComponent
MultiplierNotValidAttribute = _libsbml.MultiplierNotValidAttribute
OffsetNotValidAttribute = _libsbml.OffsetNotValidAttribute
L3SpatialDimensionsUnset = _libsbml.L3SpatialDimensionsUnset
UnknownCoreAttribute = _libsbml.UnknownCoreAttribute
UnknownPackageAttribute = _libsbml.UnknownPackageAttribute
PackageConversionNotSupported = _libsbml.PackageConversionNotSupported
InvalidTargetLevelVersion = _libsbml.InvalidTargetLevelVersion
L3NotSupported = _libsbml.L3NotSupported
SBMLCodesUpperBound = _libsbml.SBMLCodesUpperBound
LIBSBML_CAT_SBML = _libsbml.LIBSBML_CAT_SBML
LIBSBML_CAT_SBML_L1_COMPAT = _libsbml.LIBSBML_CAT_SBML_L1_COMPAT
LIBSBML_CAT_SBML_L2V1_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V1_COMPAT
LIBSBML_CAT_SBML_L2V2_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V2_COMPAT
LIBSBML_CAT_GENERAL_CONSISTENCY = _libsbml.LIBSBML_CAT_GENERAL_CONSISTENCY
LIBSBML_CAT_IDENTIFIER_CONSISTENCY = _libsbml.LIBSBML_CAT_IDENTIFIER_CONSISTENCY
LIBSBML_CAT_UNITS_CONSISTENCY = _libsbml.LIBSBML_CAT_UNITS_CONSISTENCY
LIBSBML_CAT_MATHML_CONSISTENCY = _libsbml.LIBSBML_CAT_MATHML_CONSISTENCY
LIBSBML_CAT_SBO_CONSISTENCY = _libsbml.LIBSBML_CAT_SBO_CONSISTENCY
LIBSBML_CAT_OVERDETERMINED_MODEL = _libsbml.LIBSBML_CAT_OVERDETERMINED_MODEL
LIBSBML_CAT_SBML_L2V3_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V3_COMPAT
LIBSBML_CAT_MODELING_PRACTICE = _libsbml.LIBSBML_CAT_MODELING_PRACTICE
LIBSBML_CAT_INTERNAL_CONSISTENCY = _libsbml.LIBSBML_CAT_INTERNAL_CONSISTENCY
LIBSBML_CAT_SBML_L2V4_COMPAT = _libsbml.LIBSBML_CAT_SBML_L2V4_COMPAT
LIBSBML_CAT_SBML_L3V1_COMPAT = _libsbml.LIBSBML_CAT_SBML_L3V1_COMPAT
LIBSBML_SEV_SCHEMA_ERROR = _libsbml.LIBSBML_SEV_SCHEMA_ERROR
LIBSBML_SEV_GENERAL_WARNING = _libsbml.LIBSBML_SEV_GENERAL_WARNING
LIBSBML_SEV_NOT_APPLICABLE = _libsbml.LIBSBML_SEV_NOT_APPLICABLE
class SBMLError(XMLError):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html An error, warning or other diagnostic.

    @htmlinclude not-sbml-warning.html

    When a libSBML operation on SBML content results in an error, or when
    there is something wrong with the SBML content, the problems are
    reported as SBMLError objects.  These are generally stored in an
    SBMLErrorLog object; this log object, in turn, is kept in the
    SBMLDocument object containing the SBML content.  Applications can
    obtain the list of logged errors using SBMLDocument.getErrorLog() and
    then use the methods provided by SBMLErrorLog to access individual
    SBMLError objects.  (Note that despite the word 'error' in the name,
    SBMLError objects are used to represent not only 'true' errors, but also
    warnings and some informational diagnostics.  The name is a historical
    hold-over from early versions of libSBML, in which the object really was
    only used to report errors.)

    @if clike
    Each SBMLError object instance has an identification number that
    identifies the nature of the problem.  This 'error id' number will be up
    to five digits long, and it will be listed in one of two enumerations:
    <a class='el' href='#SBMLErrorCode_t'> SBMLErrorCode_t</a> (described <a
    class='el' href='#SBMLErrorCode_t'> below</a>) or @link
    XMLError::XMLErrorCode_t XMLErrorCode_t@endlink (described in the
    documentation for the class XMLError).  The former enumeration contains
    all the SBML validation rule numbers listed in the appendices of the
    SBML specification documents, as well as some additional
    libSBML-specific error codes.
    @endif@if java
    Each SBMLError object instance has an identification number that
    identifies the nature of the problem.  This 'error id' number will be up
    to five digits long, and it will come from one of two sets of static
    integer constants defined in the interface class <code><a
    href='libsbmlConstants.html'> libsbmlConstants</a></code>: either the
    SBML error identifiers <a class='el' href='#SBMLErrorCode_t'> (described
    below)</a> or the XML error identifiers (described in the documentation
    for the class <code><a href='XMLError.html'> XMLError</a></code>).  The
    former set of constants includes all the SBML validation rule numbers
    listed in the appendices of the SBML specification documents, as well as
    some additional libSBML-specific error codes.
    @endif@if python
    Each SBMLError object instance has an identification number that
    identifies the nature of the problem.  This 'error id' number will be up
    to five digits long, and it will come from one
    of two sets of static integer constants defined in
    the interface class @link libsbml libsbml@endlink: either the SBML
    error identifiers <a
    class='el' href='#SBMLErrorCode_t'> (described below)</a> or the XML
    error identifiers (described in the documentation for the class XMLError).
    The former set of constants
    includes all the SBML validation rule numbers listed in the appendices
    of the SBML specification documents, as well as some additional
    libSBML-specific error codes.
    @endif@~

    Error codes are useful mainly for software.  For human readers,
    SBMLError also includes text messages that describe the nature of a
    given problem.  The messages can be accessed using
    SBMLError.getShortMessage() and SBMLError.getMessage().  The former
    provides a brief one-line description of the issue, while
    SBMLError.getMessage() provides a more detailed text, including (if
    appropriate) references to sections of the SBML specifications where
    relevant topics are discussed.  These text strings are suitable for
    displaying to human users.

    @if clike
    An SBMLError object also contains a category code; its value may be
    retrieved using the method SBMLError.getCategory().  Category values
    are drawn from the enumeration <a class='el'
    href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a> described below.
    Categories are used to partition errors into distinct conceptual groups.
    This is principally used by the libSBML validation system to group
    classes of validation checks.  For example, 
    @link libsbml#LIBSBML_CAT_IDENTIFIER_CONSISTENCY LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink
    is the category for tests that check identifier consistency;
    @link libsbml#LIBSBML_CAT_MATHML_CONSISTENCY LIBSBML_CAT_MATHML_CONSISTENCY@endlink
    is the category for MathML consistency checking; and
    so on.
    @endif@if java
    An SBMLError object also contains a category code; its value may be
    retrieved using the method SBMLError.getCategory().  Category values
    are drawn from a set of static integer constants
    defined in <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>,
    and having names beginning with the characters
    <code>LIBSBML_CAT_</code>.  The list of possible codes is described in a
    separate section below.  Categories are used to partition errors into
    distinct conceptual groups.  This is principally used by the libSBML
    validation system to group classes of validation checks.  For example,
    @link libsbml#LIBSBML_CAT_IDENTIFIER_CONSISTENCY LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink
    is the category for tests that check identifier consistency;
    @link libsbml#LIBSBML_CAT_MATHML_CONSISTENCY LIBSBML_CAT_MATHML_CONSISTENCY@endlink
    is the category for MathML consistency checking; and
    so on.
    @endif@if python
    An SBMLError object also contains a category code; its value may be
    retrieved using the method SBMLError.getCategory().  Category values
    are drawn from a set of static integer constants
    defined in @link libsbml libsbml@endlink and having names beginning with the characters
    <code>LIBSBML_CAT_</code>.  The list of possible codes is described in a
    separate section below.  Categories are used to partition errors into
    distinct conceptual groups.  This is principally used by the libSBML
    validation system to group classes of validation checks.  For example,
    @link libsbml#LIBSBML_CAT_IDENTIFIER_CONSISTENCY LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink
    is the category for tests that check identifier consistency;
    @link libsbml#LIBSBML_CAT_MATHML_CONSISTENCY LIBSBML_CAT_MATHML_CONSISTENCY@endlink
    is the category for MathML consistency checking; and
    so on.
    @endif@~

    In addition, SBMLError also has a severity code.  Its value may be
    retrieved using the method SBMLError.getSeverity().  The possible
    severity values are the same as those reported by @if clike XMLError.@endif@if python XMLError.@endif@if java <code><a href='XMLError.html'>XMLError</a></code>.@endif@~ 
    Severity levels currently range from informational
    (@link libsbml#LIBSBML_SEV_INFO LIBSBML_SEV_INFO@endlink)
    to fatal errors
    (@link libsbml#LIBSBML_SEV_FATAL LIBSBML_SEV_FATAL@endlink).
    They can be
    used by an application to evaluate how serious a given problem
    is. 

    SBMLError also tracks the Level&nbsp;3 package extension, if any, was
    responsible for a given warning or error.  Each diagnostic code logged by
    an libSBML extension for SBML Level&nbsp;3 packages includes a record of
    the package that logged it.  It can be retrieved using
    SBMLError.getPackage().  The information is a simple text string; the
    string will be the nickname of the package, such as @c 'comp' for the
    Hierarchical %Model Composition package, @c 'fbc' for the Flux Balance
    Constraints package, and so on.  If the value returned by
    SBMLError.getPackage() is an empty string or has the value @c 'core',
    then the error came from libSBML core.

    Finally, SBMLError records the line and column near where the problem
    occurred in the SBML content.  The values may be retrieved using the
    methods SBMLError.getLine() and SBMLError.getColumn().  We say 'near',
    because a lot of factors affect how accurate the line/column information
    ultimately is.  For example, different XML parsers have different
    conventions for which line and column number they report for a
    particular problem (which makes a difference when a problem involves an
    opening XML tag on one line and a closing tag on another line).  In some
    situations, some parsers report invalid line and/or column numbers
    altogether.  If this occurs, libSBML sets the line and/or column number
    in the SBMLError object to the the value of the maximum unsigned long
    integer representable on the platform where libSBML is running.  (This
    is equal to the constant named <code>ULONG_MAX</code> in C and C++.)
    The probability that a true line or column number in an SBML model would
    equal this value is vanishingly small; thus, if an application
    encounters these values in an XMLError object, it can assume no valid
    line/column number could be provided by libSBML in that situation.

    @if clike
    <h3><a class='anchor' name='SBMLErrorCode_t'>SBMLErrorCode_t</a></h3>

    SBMLErrorCode_t is an enumeration of all SBML-level error, warning and
    informational diagnostic codes.  Every SBMLError object has an error
    code value that can be either a value from this enumeration, or a value
    from the @link XMLError::XMLErrorCode_t XMLErrorCode_t@endlink
    enumeration (see the documentation for XMLError).  The latter values
    apply when the error or warning signifies a basic XML issue rather than
    an SBML issue per se.  The values of SBMLErrorCode_t are distinguished
    from those of @link XMLError::XMLErrorCode_t XMLErrorCode_t@endlink by
    being numbered 10000 and higher, while the XML layer's codes are 9999 and
    lower.  The method SBMLError.getErrorId() returns the error code of a
    given SBMLError object instance.

    The following is a table of the symbolic names of SBMLErrorCode_t values
    and the meaning of each code.  In this table, the right-hand columns
    titled 'L1V1', 'L1V2', etc. refer to Levels and Versions of the SBML
    specifications, and the entries in each column refer to whether the
    severity of the condition in that particular Level+Version of SBML.
    The codes stand for the following:

    @endif@if java <h3><a class='anchor' 
    name='SBMLErrorCode_t'>Error codes associated with SBMLError objects</a></h3>

    The error and warning codes returned by libSBML are listed in the table
    below.  The method SBMLError.getErrorId() returns the error code of a
    given SBMLError object instance.  In the libSBML Java language
    interface, these error identifiers are currently
    implemented as static integer constants defined in the interface class
    <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>.  This
    is admittedly not an ideal approach from the standpoint of modern Java
    programming, but it was necessary to work around the lack of
    enumerations in Java prior to JDK 1.5.  Future versions of libSBML may
    use a proper Java enumeration type to define the error identifiers.

    In this table, the right-hand columns titled 'L1V1', 'L1V2', etc. refer
    to Levels and Versions of the SBML specifications, and the entries in
    each column refer to whether the severity of the condition in that
    particular Level+Version of SBML.  The codes stand for the following:

    @endif@if python <h3><a class='anchor' 
    name='SBMLErrorCode_t'>Error codes associated with SBMLError objects</a></h3>

    The error and warning codes returned by libSBML are listed in the table
    below.  The method SBMLError.getErrorId() returns the error code of a
    given SBMLError object instance.  In the libSBML Python language
    interface, these error identifiers are currently
    implemented as static integer constants defined in the interface class
    @link libsbml libsbml@endlink. 

    In this table, the right-hand columns titled 'L1V1', 'L1V2', etc. refer
    to Levels and Versions of the SBML specifications, and the entries in
    each column refer to whether the severity of the condition in that
    particular Level+Version of SBML.  The codes stand for the following:

    @endif@~

    <table cellspacing='1' cellpadding='2' border='0' class='normal-font'>
    <tr><td class='s-na'></td><td>= Not applicable</td></tr>
    <tr><td class='s-warning'></td><td>= Warning</td></tr>
    <tr><td class='s-error'></td><td>= Error</td></tr>
    <tr><td class='s-fatal'></td><td>= Fatal</td></tr>
    </table>

    The text shown in the 'Meaning' is the text returned by the
    SBMLError.getShortMessage() method on a given SBMLError object.  A
    longer and (hopefully) clearer explanation of the issue is returned by
    SBMLError.getMessage().

    The error codes come from different lists depending on whether they're
    from libSBML core or from an SBML Level&nbsp;3 package extension.
    @if clike The errors below come from #XMLErrorCode_t and #SBMLErrorCode_t
    (for core), and #CompSBMLErrorCode_t, #FbcSBMLErrorCode_t,
    #LayoutSBMLErrorCode_t, and #QualSBMLErrorCode_t (for packages).@endif
    @ifnot clike However, in the language interfaces other than C++, all
    libSBML error codes are ultimately represented as integer constants rather
    than separate enumerations lists, and they are all stored in a single
    interface class.  Codes from different libSBML extensions have names that
    begin with the package's nickname, such as <code>Qual</code> for
    the Qualitative Models package, <code>Layout</code> for the Layout
    package, and so on.  If the name of a code does not begin with one of
    the package nicknames (<code>%Layout</code>, <code>Fbc</code>,
    <code>Comp</code>, <code>Qual</code>, etc.), then it is a code
    from libSBML core.@endif

    @par
    <table id='sbmlerror-table'
           class='text-table small-font alt-row-colors'
           width='95%' cellspacing='1' cellpadding='2' border='0'>
     <tr style='background: lightgray' class='normal-font'>
         <th valign='bottom'><strong>Enumerator</strong></th>
         <th valign='bottom'><strong>Meaning</strong></th>
         <th align='center' width='10'>L1 V1</th>
         <th align='center' width='10'>L1 V2</th>
         <th align='center' width='10'>L2 V1</th>
         <th align='center' width='10'>L2 V2</th>
         <th align='center' width='10'>L2 V3</th>
         <th align='center' width='10'>L2 V4</th>
         <th align='center' width='10'>L3 V1</th>
     </tr>
    <tr><td class='code'>@link libsbml#XMLUnknownError XMLUnknownError@endlink</td>
    <td class='meaning'>Unknown error</td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLOutOfMemory XMLOutOfMemory@endlink</td>
    <td class='meaning'>Out of memory</td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLFileUnreadable XMLFileUnreadable@endlink</td>
    <td class='meaning'>File unreadable</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLFileUnwritable XMLFileUnwritable@endlink</td>
    <td class='meaning'>File unwritable</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLFileOperationError XMLFileOperationError@endlink</td>
    <td class='meaning'>File operation error</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLNetworkAccessError XMLNetworkAccessError@endlink</td>
    <td class='meaning'>Network access error</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InternalXMLParserError InternalXMLParserError@endlink</td>
    <td class='meaning'>Internal XML parser error</td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnrecognizedXMLParserCode UnrecognizedXMLParserCode@endlink</td>
    <td class='meaning'>Unrecognized XML parser code</td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLTranscoderError XMLTranscoderError@endlink</td>
    <td class='meaning'>Transcoder error</td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingXMLDecl MissingXMLDecl@endlink</td>
    <td class='meaning'>Missing XML declaration</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingXMLEncoding MissingXMLEncoding@endlink</td>
    <td class='meaning'>Missing XML encoding attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLDecl BadXMLDecl@endlink</td>
    <td class='meaning'>Bad XML declaration</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLDOCTYPE BadXMLDOCTYPE@endlink</td>
    <td class='meaning'>Bad XML DOCTYPE</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidCharInXML InvalidCharInXML@endlink</td>
    <td class='meaning'>Invalid character</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadlyFormedXML BadlyFormedXML@endlink</td>
    <td class='meaning'>Badly formed XML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnclosedXMLToken UnclosedXMLToken@endlink</td>
    <td class='meaning'>Unclosed token</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidXMLConstruct InvalidXMLConstruct@endlink</td>
    <td class='meaning'>Invalid XML construct</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLTagMismatch XMLTagMismatch@endlink</td>
    <td class='meaning'>XML tag mismatch</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateXMLAttribute DuplicateXMLAttribute@endlink</td>
    <td class='meaning'>Duplicate attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndefinedXMLEntity UndefinedXMLEntity@endlink</td>
    <td class='meaning'>Undefined XML entity</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadProcessingInstruction BadProcessingInstruction@endlink</td>
    <td class='meaning'>Bad XML processing instruction</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLPrefix BadXMLPrefix@endlink</td>
    <td class='meaning'>Bad XML prefix</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLPrefixValue BadXMLPrefixValue@endlink</td>
    <td class='meaning'>Bad XML prefix value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingXMLRequiredAttribute MissingXMLRequiredAttribute@endlink</td>
    <td class='meaning'>Missing required attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLAttributeTypeMismatch XMLAttributeTypeMismatch@endlink</td>
    <td class='meaning'>Attribute type mismatch</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLBadUTF8Content XMLBadUTF8Content@endlink</td>
    <td class='meaning'>Bad UTF8 content</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingXMLAttributeValue MissingXMLAttributeValue@endlink</td>
    <td class='meaning'>Missing attribute value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLAttributeValue BadXMLAttributeValue@endlink</td>
    <td class='meaning'>Bad attribute value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLAttribute BadXMLAttribute@endlink</td>
    <td class='meaning'>Bad XML attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnrecognizedXMLElement UnrecognizedXMLElement@endlink</td>
    <td class='meaning'>Unrecognized XML element</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLComment BadXMLComment@endlink</td>
    <td class='meaning'>Bad XML comment</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLDeclLocation BadXMLDeclLocation@endlink</td>
    <td class='meaning'>Bad XML declaration location</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLUnexpectedEOF XMLUnexpectedEOF@endlink</td>
    <td class='meaning'>Unexpected EOF</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLIDValue BadXMLIDValue@endlink</td>
    <td class='meaning'>Bad XML ID value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLIDRef BadXMLIDRef@endlink</td>
    <td class='meaning'>Bad XML IDREF</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UninterpretableXMLContent UninterpretableXMLContent@endlink</td>
    <td class='meaning'>Uninterpretable XML content</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadXMLDocumentStructure BadXMLDocumentStructure@endlink</td>
    <td class='meaning'>Bad XML document structure</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidAfterXMLContent InvalidAfterXMLContent@endlink</td>
    <td class='meaning'>Invalid content after XML content</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLExpectedQuotedString XMLExpectedQuotedString@endlink</td>
    <td class='meaning'>Expected quoted string</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLEmptyValueNotPermitted XMLEmptyValueNotPermitted@endlink</td>
    <td class='meaning'>Empty value not permitted</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLBadNumber XMLBadNumber@endlink</td>
    <td class='meaning'>Bad number</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLBadColon XMLBadColon@endlink</td>
    <td class='meaning'>Colon character not permitted</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingXMLElements MissingXMLElements@endlink</td>
    <td class='meaning'>Missing XML elements</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#XMLContentEmpty XMLContentEmpty@endlink</td>
    <td class='meaning'>Empty XML content</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnknownError UnknownError@endlink</td>
    <td class='meaning'>Encountered unknown internal libSBML error</td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    <td class='s-fatal'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NotUTF8 NotUTF8@endlink</td>
    <td class='meaning'>File does not use UTF-8 encoding</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnrecognizedElement UnrecognizedElement@endlink</td>
    <td class='meaning'>Encountered unrecognized element</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NotSchemaConformant NotSchemaConformant@endlink</td>
    <td class='meaning'>Document does not conform to the SBML XML schema</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3NotSchemaConformant L3NotSchemaConformant@endlink</td>
    <td class='meaning'>Document is not well-formed XML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidMathElement InvalidMathElement@endlink</td>
    <td class='meaning'>Invalid MathML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DisallowedMathMLSymbol DisallowedMathMLSymbol@endlink</td>
    <td class='meaning'>Disallowed MathML symbol found</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DisallowedMathMLEncodingUse DisallowedMathMLEncodingUse@endlink</td>
    <td class='meaning'>Use of the MathML 'encoding' attribute is not allowed on this element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DisallowedDefinitionURLUse DisallowedDefinitionURLUse@endlink</td>
    <td class='meaning'>Use of the MathML 'definitionURL' attribute is not allowed on this element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadCsymbolDefinitionURLValue BadCsymbolDefinitionURLValue@endlink</td>
    <td class='meaning'>Invalid <code>&lt;csymbol&gt;</code> 'definitionURL' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DisallowedMathTypeAttributeUse DisallowedMathTypeAttributeUse@endlink</td>
    <td class='meaning'>Use of the MathML 'type' attribute is not allowed on this element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DisallowedMathTypeAttributeValue DisallowedMathTypeAttributeValue@endlink</td>
    <td class='meaning'>Disallowed MathML 'type' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LambdaOnlyAllowedInFunctionDef LambdaOnlyAllowedInFunctionDef@endlink</td>
    <td class='meaning'>Use of <code>&lt;lambda&gt;</code> not permitted outside of FunctionDefinition objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BooleanOpsNeedBooleanArgs BooleanOpsNeedBooleanArgs@endlink</td>
    <td class='meaning'>Non-Boolean argument given to Boolean operator</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NumericOpsNeedNumericArgs NumericOpsNeedNumericArgs@endlink</td>
    <td class='meaning'>Non-numerical argument given to numerical operator</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ArgsToEqNeedSameType ArgsToEqNeedSameType@endlink</td>
    <td class='meaning'>Arguments to <code>&lt;eq&gt;</code> and <code>&lt;neq&gt;</code> must have the same data types</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PiecewiseNeedsConsistentTypes PiecewiseNeedsConsistentTypes@endlink</td>
    <td class='meaning'>Terms in a <code>&lt;piecewise&gt;</code> expression must have consistent data types</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PieceNeedsBoolean PieceNeedsBoolean@endlink</td>
    <td class='meaning'>The second argument of a <code>&lt;piece&gt;</code> expression must yield a Boolean value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ApplyCiMustBeUserFunction ApplyCiMustBeUserFunction@endlink</td>
    <td class='meaning'>A <code>&lt;ci&gt;</code> element in this context must refer to a function definition</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ApplyCiMustBeModelComponent ApplyCiMustBeModelComponent@endlink</td>
    <td class='meaning'>A <code>&lt;ci&gt;</code> element in this context must refer to a model component</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#KineticLawParametersAreLocalOnly KineticLawParametersAreLocalOnly@endlink</td>
    <td class='meaning'>Cannot use a KineticLaw local parameter outside of its local scope</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MathResultMustBeNumeric MathResultMustBeNumeric@endlink</td>
    <td class='meaning'>A formula's result in this context must be a numerical value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OpsNeedCorrectNumberOfArgs OpsNeedCorrectNumberOfArgs@endlink</td>
    <td class='meaning'>Incorrect number of arguments given to MathML operator</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidNoArgsPassedToFunctionDef InvalidNoArgsPassedToFunctionDef@endlink</td>
    <td class='meaning'>Incorrect number of arguments given to function invocation</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DisallowedMathUnitsUse DisallowedMathUnitsUse@endlink</td>
    <td class='meaning'>Attribute 'units' is only permitted on <code>&lt;cn&gt;</code> elements</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidUnitsValue InvalidUnitsValue@endlink</td>
    <td class='meaning'>Invalid value given for the 'units' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateComponentId DuplicateComponentId@endlink</td>
    <td class='meaning'>Duplicate 'id' attribute value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateUnitDefinitionId DuplicateUnitDefinitionId@endlink</td>
    <td class='meaning'>Duplicate unit definition 'id' attribute value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateLocalParameterId DuplicateLocalParameterId@endlink</td>
    <td class='meaning'>Duplicate local parameter 'id' attribute value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MultipleAssignmentOrRateRules MultipleAssignmentOrRateRules@endlink</td>
    <td class='meaning'>Multiple rules for the same variable are not allowed</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MultipleEventAssignmentsForId MultipleEventAssignmentsForId@endlink</td>
    <td class='meaning'>Multiple event assignments for the same variable are not allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventAndAssignmentRuleForId EventAndAssignmentRuleForId@endlink</td>
    <td class='meaning'>An event assignment and an assignment rule must not have the same value for 'variable'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateMetaId DuplicateMetaId@endlink</td>
    <td class='meaning'>Duplicate 'metaid' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSBOTermSyntax InvalidSBOTermSyntax@endlink</td>
    <td class='meaning'>Invalid syntax for an 'sboTerm' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidMetaidSyntax InvalidMetaidSyntax@endlink</td>
    <td class='meaning'>Invalid syntax for a 'metaid' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidIdSyntax InvalidIdSyntax@endlink</td>
    <td class='meaning'>Invalid syntax for an 'id' attribute value</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidUnitIdSyntax InvalidUnitIdSyntax@endlink</td>
    <td class='meaning'>Invalid syntax for the identifier of a unit</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidNameSyntax InvalidNameSyntax@endlink</td>
    <td class='meaning'>Invalid syntax for a 'name' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingAnnotationNamespace MissingAnnotationNamespace@endlink</td>
    <td class='meaning'>Missing declaration of the XML namespace for the annotation</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateAnnotationNamespaces DuplicateAnnotationNamespaces@endlink</td>
    <td class='meaning'>Multiple annotations using the same XML namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SBMLNamespaceInAnnotation SBMLNamespaceInAnnotation@endlink</td>
    <td class='meaning'>The SBML XML namespace cannot be used in an Annotation object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MultipleAnnotations MultipleAnnotations@endlink</td>
    <td class='meaning'>Only one Annotation object is permitted under a given SBML object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InconsistentArgUnits InconsistentArgUnits@endlink</td>
    <td class='meaning'>The units of the function call's arguments are not consistent with its definition</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InconsistentKineticLawUnitsL3 InconsistentKineticLawUnitsL3@endlink</td>
    <td class='meaning'>The kinetic law's units are inconsistent with those of other kinetic laws in the model</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AssignRuleCompartmentMismatch AssignRuleCompartmentMismatch@endlink</td>
    <td class='meaning'>Mismatched units in assignment rule for compartment</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AssignRuleSpeciesMismatch AssignRuleSpeciesMismatch@endlink</td>
    <td class='meaning'>Mismatched units in assignment rule for species</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AssignRuleParameterMismatch AssignRuleParameterMismatch@endlink</td>
    <td class='meaning'>Mismatched units in assignment rule for parameter</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AssignRuleStoichiometryMismatch AssignRuleStoichiometryMismatch@endlink</td>
    <td class='meaning'>Mismatched units in assignment rule for stoichiometry</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitAssignCompartmenMismatch InitAssignCompartmenMismatch@endlink</td>
    <td class='meaning'>Mismatched units in initial assignment to compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitAssignSpeciesMismatch InitAssignSpeciesMismatch@endlink</td>
    <td class='meaning'>Mismatched units in initial assignment to species</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitAssignParameterMismatch InitAssignParameterMismatch@endlink</td>
    <td class='meaning'>Mismatched units in initial assignment to parameter</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitAssignStoichiometryMismatch InitAssignStoichiometryMismatch@endlink</td>
    <td class='meaning'>Mismatched units in initial assignment to stoichiometry</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RateRuleCompartmentMismatch RateRuleCompartmentMismatch@endlink</td>
    <td class='meaning'>Mismatched units in rate rule for compartment</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RateRuleSpeciesMismatch RateRuleSpeciesMismatch@endlink</td>
    <td class='meaning'>Mismatched units in rate rule for species</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RateRuleParameterMismatch RateRuleParameterMismatch@endlink</td>
    <td class='meaning'>Mismatched units in rate rule for parameter</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RateRuleStoichiometryMismatch RateRuleStoichiometryMismatch@endlink</td>
    <td class='meaning'>Mismatched units in rate rule for stoichiometry</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#KineticLawNotSubstancePerTime KineticLawNotSubstancePerTime@endlink</td>
    <td class='meaning'>The units of the kinetic law are not 'substance'/'time'</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpeciesInvalidExtentUnits SpeciesInvalidExtentUnits@endlink</td>
    <td class='meaning'>The species' units are not consistent with units of extent</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DelayUnitsNotTime DelayUnitsNotTime@endlink</td>
    <td class='meaning'>The units of the delay expression are not units of time</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventAssignCompartmentMismatch EventAssignCompartmentMismatch@endlink</td>
    <td class='meaning'>Mismatched units in event assignment for compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventAssignSpeciesMismatch EventAssignSpeciesMismatch@endlink</td>
    <td class='meaning'>Mismatched units in event assignment for species</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventAssignParameterMismatch EventAssignParameterMismatch@endlink</td>
    <td class='meaning'>Mismatched units in event assignment for parameter</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventAssignStoichiometryMismatch EventAssignStoichiometryMismatch@endlink</td>
    <td class='meaning'>Mismatched units in event assignment for stoichiometry</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PriorityUnitsNotDimensionless PriorityUnitsNotDimensionless@endlink</td>
    <td class='meaning'>The units of a priority expression must be 'dimensionless'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OverdeterminedSystem OverdeterminedSystem@endlink</td>
    <td class='meaning'>The model is overdetermined</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidModelSBOTerm InvalidModelSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Model object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidFunctionDefSBOTerm InvalidFunctionDefSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a FunctionDefinition object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidParameterSBOTerm InvalidParameterSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Parameter object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidInitAssignSBOTerm InvalidInitAssignSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for an InitialAssignment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidRuleSBOTerm InvalidRuleSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Rule object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidConstraintSBOTerm InvalidConstraintSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Constraint object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidReactionSBOTerm InvalidReactionSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Reaction object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesReferenceSBOTerm InvalidSpeciesReferenceSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a SpeciesReference object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidKineticLawSBOTerm InvalidKineticLawSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a KineticLaw object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidEventSBOTerm InvalidEventSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for an Event object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidEventAssignmentSBOTerm InvalidEventAssignmentSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for an EventAssignment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidCompartmentSBOTerm InvalidCompartmentSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Compartment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesSBOTerm InvalidSpeciesSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a Species object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidCompartmentTypeSBOTerm InvalidCompartmentTypeSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a CompartmentType object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesTypeSBOTerm InvalidSpeciesTypeSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for a SpeciesType object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidTriggerSBOTerm InvalidTriggerSBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for an Event Trigger object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidDelaySBOTerm InvalidDelaySBOTerm@endlink</td>
    <td class='meaning'>Invalid 'sboTerm' attribute value for an Event Delay object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NotesNotInXHTMLNamespace NotesNotInXHTMLNamespace@endlink</td>
    <td class='meaning'>Notes must be placed in the XHTML XML namespace</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NotesContainsXMLDecl NotesContainsXMLDecl@endlink</td>
    <td class='meaning'>XML declarations are not permitted in Notes objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NotesContainsDOCTYPE NotesContainsDOCTYPE@endlink</td>
    <td class='meaning'>XML DOCTYPE elements are not permitted in Notes objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidNotesContent InvalidNotesContent@endlink</td>
    <td class='meaning'>Invalid notes content found</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyOneNotesElementAllowed OnlyOneNotesElementAllowed@endlink</td>
    <td class='meaning'>Only one Notes subobject is permitted on a given SBML object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidNamespaceOnSBML InvalidNamespaceOnSBML@endlink</td>
    <td class='meaning'>Invalid XML namespace for the SBML container element</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingOrInconsistentLevel MissingOrInconsistentLevel@endlink</td>
    <td class='meaning'>Missing or inconsistent value for the 'level' attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingOrInconsistentVersion MissingOrInconsistentVersion@endlink</td>
    <td class='meaning'>Missing or inconsistent value for the 'version' attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PackageNSMustMatch PackageNSMustMatch@endlink</td>
    <td class='meaning'>Inconsistent or invalid SBML Level/Version for the package namespace declaration</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LevelPositiveInteger LevelPositiveInteger@endlink</td>
    <td class='meaning'>The 'level' attribute must have a positive integer value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#VersionPositiveInteger VersionPositiveInteger@endlink</td>
    <td class='meaning'>The 'version' attribute must have a positive integer value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnSBML AllowedAttributesOnSBML@endlink</td>
    <td class='meaning'>Invalid attribute found on the SBML container element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3PackageOnLowerSBML L3PackageOnLowerSBML@endlink</td>
    <td class='meaning'>An L3 package ns found on the SBML container element</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingModel MissingModel@endlink</td>
    <td class='meaning'>No model definition found</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IncorrectOrderInModel IncorrectOrderInModel@endlink</td>
    <td class='meaning'>Incorrect ordering of components within the Model object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EmptyListElement EmptyListElement@endlink</td>
    <td class='meaning'>Empty ListOf___ object found</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NeedCompartmentIfHaveSpecies NeedCompartmentIfHaveSpecies@endlink</td>
    <td class='meaning'>The presence of a species requires a compartment</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneOfEachListOf OneOfEachListOf@endlink</td>
    <td class='meaning'>Only one of each kind of ListOf___ object is allowed inside a Model object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyFuncDefsInListOfFuncDefs OnlyFuncDefsInListOfFuncDefs@endlink</td>
    <td class='meaning'>Only FunctionDefinition, Notes and Annotation objects are allowed in ListOfFunctionDefinitions</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyUnitDefsInListOfUnitDefs OnlyUnitDefsInListOfUnitDefs@endlink</td>
    <td class='meaning'>Only UnitDefinition, Notes and Annotation objects are allowed in ListOfUnitDefinitions objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyCompartmentsInListOfCompartments OnlyCompartmentsInListOfCompartments@endlink</td>
    <td class='meaning'>Only Compartment, Notes and Annotation objects are allowed in ListOfCompartments objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlySpeciesInListOfSpecies OnlySpeciesInListOfSpecies@endlink</td>
    <td class='meaning'>Only Species, Notes and Annotation objects are allowed in ListOfSpecies objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyParametersInListOfParameters OnlyParametersInListOfParameters@endlink</td>
    <td class='meaning'>Only Parameter, Notes and Annotation objects are allowed in ListOfParameters objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyInitAssignsInListOfInitAssigns OnlyInitAssignsInListOfInitAssigns@endlink</td>
    <td class='meaning'>Only InitialAssignment, Notes and Annotation objects are allowed in ListOfInitialAssignments objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyRulesInListOfRules OnlyRulesInListOfRules@endlink</td>
    <td class='meaning'>Only Rule, Notes and Annotation objects are allowed in ListOfRules objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyConstraintsInListOfConstraints OnlyConstraintsInListOfConstraints@endlink</td>
    <td class='meaning'>Only Constraint, Notes and Annotation objects are allowed in ListOfConstraints objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyReactionsInListOfReactions OnlyReactionsInListOfReactions@endlink</td>
    <td class='meaning'>Only Reaction, Notes and Annotation objects are allowed in ListOfReactions objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyEventsInListOfEvents OnlyEventsInListOfEvents@endlink</td>
    <td class='meaning'>Only Event, Notes and Annotation objects are allowed in ListOfEvents objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3ConversionFactorOnModel L3ConversionFactorOnModel@endlink</td>
    <td class='meaning'>A 'conversionFactor' attribute value must reference a Parameter object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3TimeUnitsOnModel L3TimeUnitsOnModel@endlink</td>
    <td class='meaning'>Invalid 'timeUnits' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3VolumeUnitsOnModel L3VolumeUnitsOnModel@endlink</td>
    <td class='meaning'>Invalid 'volumeUnits' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3AreaUnitsOnModel L3AreaUnitsOnModel@endlink</td>
    <td class='meaning'>Invalid 'areaUnits' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3LengthUnitsOnModel L3LengthUnitsOnModel@endlink</td>
    <td class='meaning'>Invalid 'lengthUnits' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3ExtentUnitsOnModel L3ExtentUnitsOnModel@endlink</td>
    <td class='meaning'>Invalid 'extentUnits' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnModel AllowedAttributesOnModel@endlink</td>
    <td class='meaning'>Invalid attribute found on the Model object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfFuncs AllowedAttributesOnListOfFuncs@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfFunctionDefinitions object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfUnitDefs AllowedAttributesOnListOfUnitDefs@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfUnitDefinitions object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfComps AllowedAttributesOnListOfComps@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfCompartments object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfSpecies AllowedAttributesOnListOfSpecies@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfSpecies object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfParams AllowedAttributesOnListOfParams@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfParameters object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfInitAssign AllowedAttributesOnListOfInitAssign@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfInitialAssignments object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfRules AllowedAttributesOnListOfRules@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfRules object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfConstraints AllowedAttributesOnListOfConstraints@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfConstraints object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfReactions AllowedAttributesOnListOfReactions@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfReactions object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfEvents AllowedAttributesOnListOfEvents@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfEvents object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FunctionDefMathNotLambda FunctionDefMathNotLambda@endlink</td>
    <td class='meaning'>Invalid expression found in the function definition</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidApplyCiInLambda InvalidApplyCiInLambda@endlink</td>
    <td class='meaning'>Invalid forward reference in the MathML <code>&lt;apply&gt;</code><code>&lt;ci&gt;</code>...<code>&lt;/ci&gt;</code><code>&lt;/apply&gt;</code> expression</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RecursiveFunctionDefinition RecursiveFunctionDefinition@endlink</td>
    <td class='meaning'>Recursive function definitions are not permitted</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidCiInLambda InvalidCiInLambda@endlink</td>
    <td class='meaning'>Invalid <code>&lt;ci&gt;</code> reference found inside the <code>&lt;lambda&gt;</code> mathematical formula</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidFunctionDefReturnType InvalidFunctionDefReturnType@endlink</td>
    <td class='meaning'>A function's return type must be either a number or a Boolean</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathElementPerFunc OneMathElementPerFunc@endlink</td>
    <td class='meaning'>A FunctionDefinition object must contain one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnFunc AllowedAttributesOnFunc@endlink</td>
    <td class='meaning'>Invalid attribute found on the FunctionDefinition object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidUnitDefId InvalidUnitDefId@endlink</td>
    <td class='meaning'>Invalid 'id' attribute value for a UnitDefinition object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSubstanceRedefinition InvalidSubstanceRedefinition@endlink</td>
    <td class='meaning'>Invalid redefinition of built-in type 'substance'</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidLengthRedefinition InvalidLengthRedefinition@endlink</td>
    <td class='meaning'>Invalid redefinition of built-in type 'length'</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidAreaRedefinition InvalidAreaRedefinition@endlink</td>
    <td class='meaning'>Invalid redefinition of built-in type name 'area'</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidTimeRedefinition InvalidTimeRedefinition@endlink</td>
    <td class='meaning'>Invalid redefinition of built-in type name 'time'</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidVolumeRedefinition InvalidVolumeRedefinition@endlink</td>
    <td class='meaning'>Invalid redefinition of built-in type name 'volume'</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#VolumeLitreDefExponentNotOne VolumeLitreDefExponentNotOne@endlink</td>
    <td class='meaning'>Must use 'exponent'=1 when defining 'volume' in terms of litres</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#VolumeMetreDefExponentNot3 VolumeMetreDefExponentNot3@endlink</td>
    <td class='meaning'>Must use 'exponent'=3 when defining 'volume' in terms of metres</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EmptyListOfUnits EmptyListOfUnits@endlink</td>
    <td class='meaning'>An empty list of Unit objects is not permitted in a UnitDefinition object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidUnitKind InvalidUnitKind@endlink</td>
    <td class='meaning'>Invalid value for the 'kind' attribute of a UnitDefinition object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OffsetNoLongerValid OffsetNoLongerValid@endlink</td>
    <td class='meaning'>Unit attribute 'offset' is not supported in this Level+Version of SBML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CelsiusNoLongerValid CelsiusNoLongerValid@endlink</td>
    <td class='meaning'>Unit name 'Celsius' is not defined in this Level+Version of SBML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EmptyUnitListElement EmptyUnitListElement@endlink</td>
    <td class='meaning'>A ListOfUnits object must not be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneListOfUnitsPerUnitDef OneListOfUnitsPerUnitDef@endlink</td>
    <td class='meaning'>At most one ListOfUnits object is allowed inside a UnitDefinition object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyUnitsInListOfUnits OnlyUnitsInListOfUnits@endlink</td>
    <td class='meaning'>Only Unit, Notes and Annotation objects are allowed in ListOfUnits objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnUnitDefinition AllowedAttributesOnUnitDefinition@endlink</td>
    <td class='meaning'>Invalid attribute found on the UnitDefinition object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfUnits AllowedAttributesOnListOfUnits@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfUnits object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnUnit AllowedAttributesOnUnit@endlink</td>
    <td class='meaning'>Invalid attribute found on the Unit object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ZeroDimensionalCompartmentSize ZeroDimensionalCompartmentSize@endlink</td>
    <td class='meaning'>Invalid use of the 'size' attribute for a zero-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ZeroDimensionalCompartmentUnits ZeroDimensionalCompartmentUnits@endlink</td>
    <td class='meaning'>Invalid use of the 'units' attribute for a zero-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ZeroDimensionalCompartmentConst ZeroDimensionalCompartmentConst@endlink</td>
    <td class='meaning'>Zero-dimensional compartments must be defined to be constant</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndefinedOutsideCompartment UndefinedOutsideCompartment@endlink</td>
    <td class='meaning'>Invalid value for the 'outside' attribute of a Compartment object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RecursiveCompartmentContainment RecursiveCompartmentContainment@endlink</td>
    <td class='meaning'>Recursive nesting of compartments via the 'outside' attribute is not permitted</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ZeroDCompartmentContainment ZeroDCompartmentContainment@endlink</td>
    <td class='meaning'>Invalid nesting of zero-dimensional compartments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#Invalid1DCompartmentUnits Invalid1DCompartmentUnits@endlink</td>
    <td class='meaning'>Invalid value for the 'units' attribute of a one-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#Invalid2DCompartmentUnits Invalid2DCompartmentUnits@endlink</td>
    <td class='meaning'>Invalid value for the 'units' attribute of a two-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#Invalid3DCompartmentUnits Invalid3DCompartmentUnits@endlink</td>
    <td class='meaning'>Invalid value for the 'units' attribute of a three-dimensional compartment</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidCompartmentTypeRef InvalidCompartmentTypeRef@endlink</td>
    <td class='meaning'>Invalid value for the 'compartmentType' attribute of a compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneDimensionalCompartmentUnits OneDimensionalCompartmentUnits@endlink</td>
    <td class='meaning'>No units defined for 1-D compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#TwoDimensionalCompartmentUnits TwoDimensionalCompartmentUnits@endlink</td>
    <td class='meaning'>No units defined for 2-D compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ThreeDimensionalCompartmentUnits ThreeDimensionalCompartmentUnits@endlink</td>
    <td class='meaning'>No units defined for 3-D Compartment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnCompartment AllowedAttributesOnCompartment@endlink</td>
    <td class='meaning'>Invalid attribute found on Compartment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoUnitsOnCompartment NoUnitsOnCompartment@endlink</td>
    <td class='meaning'>No units defined for Compartment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesCompartmentRef InvalidSpeciesCompartmentRef@endlink</td>
    <td class='meaning'>Invalid value found for Species 'compartment' attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#HasOnlySubsNoSpatialUnits HasOnlySubsNoSpatialUnits@endlink</td>
    <td class='meaning'>Attribute 'spatialSizeUnits' must not be set if 'hasOnlySubstanceUnits'='true'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpatialUnitsInZeroD NoSpatialUnitsInZeroD@endlink</td>
    <td class='meaning'>Attribute 'spatialSizeUnits' must not be set if the compartment is zero-dimensional</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoConcentrationInZeroD NoConcentrationInZeroD@endlink</td>
    <td class='meaning'>Attribute 'initialConcentration' must not be set if the compartment is zero-dimensional</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpatialUnitsInOneD SpatialUnitsInOneD@endlink</td>
    <td class='meaning'>Invalid value for 'spatialSizeUnits' attribute of a one-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpatialUnitsInTwoD SpatialUnitsInTwoD@endlink</td>
    <td class='meaning'>Invalid value for the 'spatialSizeUnits' attribute of a two-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpatialUnitsInThreeD SpatialUnitsInThreeD@endlink</td>
    <td class='meaning'>Invalid value for the 'spatialSizeUnits' attribute of a three-dimensional compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesSusbstanceUnits InvalidSpeciesSusbstanceUnits@endlink</td>
    <td class='meaning'>Invalid value for a Species 'units' attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BothAmountAndConcentrationSet BothAmountAndConcentrationSet@endlink</td>
    <td class='meaning'>Cannot set both 'initialConcentration' and 'initialAmount' attributes simultaneously</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NonBoundarySpeciesAssignedAndUsed NonBoundarySpeciesAssignedAndUsed@endlink</td>
    <td class='meaning'>Cannot use a non-boundary species in both reactions and rules simultaneously</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NonConstantSpeciesUsed NonConstantSpeciesUsed@endlink</td>
    <td class='meaning'>Cannot use a constant, non-boundary species as a reactant or product</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesTypeRef InvalidSpeciesTypeRef@endlink</td>
    <td class='meaning'>Invalid value for the 'speciesType' attribute of a species</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MultSpeciesSameTypeInCompartment MultSpeciesSameTypeInCompartment@endlink</td>
    <td class='meaning'>Cannot have multiple species of the same species type in the same compartment</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingSpeciesCompartment MissingSpeciesCompartment@endlink</td>
    <td class='meaning'>Missing value for the 'compartment' attribute</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpatialSizeUnitsRemoved SpatialSizeUnitsRemoved@endlink</td>
    <td class='meaning'>Attribute 'spatialSizeUnits' is not supported in this Level+Version of SBML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SubstanceUnitsOnSpecies SubstanceUnitsOnSpecies@endlink</td>
    <td class='meaning'>No substance units defined for the species</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConversionFactorOnSpecies ConversionFactorOnSpecies@endlink</td>
    <td class='meaning'>Invalid value for the 'conversionFactor' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnSpecies AllowedAttributesOnSpecies@endlink</td>
    <td class='meaning'>Invalid attribute found on Species object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidParameterUnits InvalidParameterUnits@endlink</td>
    <td class='meaning'>Invalid value for the 'units' attribute of a Parameter object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ParameterUnits ParameterUnits@endlink</td>
    <td class='meaning'>No units defined for the parameter</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConversionFactorMustConstant ConversionFactorMustConstant@endlink</td>
    <td class='meaning'>A conversion factor must reference a Parameter object declared to be a constant</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnParameter AllowedAttributesOnParameter@endlink</td>
    <td class='meaning'>Invalid attribute found on Parameter object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidInitAssignSymbol InvalidInitAssignSymbol@endlink</td>
    <td class='meaning'>Invalid value for the 'symbol' attribute of an InitialAssignment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MultipleInitAssignments MultipleInitAssignments@endlink</td>
    <td class='meaning'>Multiple initial assignments for the same 'symbol' value are not allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitAssignmentAndRuleForSameId InitAssignmentAndRuleForSameId@endlink</td>
    <td class='meaning'>Cannot set a value using both an initial assignment and an assignment rule simultaneously</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathElementPerInitialAssign OneMathElementPerInitialAssign@endlink</td>
    <td class='meaning'>An InitialAssignment object must contain one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnInitialAssign AllowedAttributesOnInitialAssign@endlink</td>
    <td class='meaning'>Invalid attribute found on an InitialAssignment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidAssignRuleVariable InvalidAssignRuleVariable@endlink</td>
    <td class='meaning'>Invalid value for the 'variable' attribute of an AssignmentRule object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidRateRuleVariable InvalidRateRuleVariable@endlink</td>
    <td class='meaning'>Invalid value for the 'variable' attribute of a RateRule object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AssignmentToConstantEntity AssignmentToConstantEntity@endlink</td>
    <td class='meaning'>An assignment rule cannot assign an entity declared to be constant</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RateRuleForConstantEntity RateRuleForConstantEntity@endlink</td>
    <td class='meaning'>A rate rule cannot assign an entity declared to be constant</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CircularRuleDependency CircularRuleDependency@endlink</td>
    <td class='meaning'>Circular dependencies involving rules and reactions are not permitted</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathElementPerRule OneMathElementPerRule@endlink</td>
    <td class='meaning'>A rule object must contain one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnAssignRule AllowedAttributesOnAssignRule@endlink</td>
    <td class='meaning'>Invalid attribute found on an AssignmentRule object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnRateRule AllowedAttributesOnRateRule@endlink</td>
    <td class='meaning'>Invalid attribute found on a RateRule object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnAlgRule AllowedAttributesOnAlgRule@endlink</td>
    <td class='meaning'>Invalid attribute found on an AlgebraicRule object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstraintMathNotBoolean ConstraintMathNotBoolean@endlink</td>
    <td class='meaning'>A Constraint object's <code>&lt;math&gt;</code> must evaluate to a Boolean value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IncorrectOrderInConstraint IncorrectOrderInConstraint@endlink</td>
    <td class='meaning'>Subobjects inside the Constraint object are not in the prescribed order</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstraintNotInXHTMLNamespace ConstraintNotInXHTMLNamespace@endlink</td>
    <td class='meaning'>A Constraint's Message subobject must be in the XHTML XML namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstraintContainsXMLDecl ConstraintContainsXMLDecl@endlink</td>
    <td class='meaning'>XML declarations are not permitted within Constraint's Message objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstraintContainsDOCTYPE ConstraintContainsDOCTYPE@endlink</td>
    <td class='meaning'>XML DOCTYPE elements are not permitted within Constraint's Message objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidConstraintContent InvalidConstraintContent@endlink</td>
    <td class='meaning'>Invalid content for a Constraint object's Message object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathElementPerConstraint OneMathElementPerConstraint@endlink</td>
    <td class='meaning'>A Constraint object must contain one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMessageElementPerConstraint OneMessageElementPerConstraint@endlink</td>
    <td class='meaning'>A Constraint object must contain one Message subobject</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnConstraint AllowedAttributesOnConstraint@endlink</td>
    <td class='meaning'>Invalid attribute found on Constraint object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoReactantsOrProducts NoReactantsOrProducts@endlink</td>
    <td class='meaning'>Cannot have a reaction with neither reactants nor products</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IncorrectOrderInReaction IncorrectOrderInReaction@endlink</td>
    <td class='meaning'>Subobjects inside the Reaction object are not in the prescribed order</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EmptyListInReaction EmptyListInReaction@endlink</td>
    <td class='meaning'>Reaction components, if present, cannot be empty</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidReactantsProductsList InvalidReactantsProductsList@endlink</td>
    <td class='meaning'>Invalid object found in the list of reactants or products</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidModifiersList InvalidModifiersList@endlink</td>
    <td class='meaning'>Invalid object found in the list of modifiers</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneSubElementPerReaction OneSubElementPerReaction@endlink</td>
    <td class='meaning'>A Reaction object can only contain one of each allowed type of object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompartmentOnReaction CompartmentOnReaction@endlink</td>
    <td class='meaning'>Invalid value for the Reaction 'compartment' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnReaction AllowedAttributesOnReaction@endlink</td>
    <td class='meaning'>Invalid attribute for a Reaction object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSpeciesReference InvalidSpeciesReference@endlink</td>
    <td class='meaning'>Invalid 'species' attribute value in SpeciesReference object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BothStoichiometryAndMath BothStoichiometryAndMath@endlink</td>
    <td class='meaning'>The 'stoichiometry' attribute and StoichiometryMath subobject are mutually exclusive</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnSpeciesReference AllowedAttributesOnSpeciesReference@endlink</td>
    <td class='meaning'>Invalid attribute found on the SpeciesReference object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnModifier AllowedAttributesOnModifier@endlink</td>
    <td class='meaning'>Invalid attribute found on the ModifierSpeciesReference object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndeclaredSpeciesRef UndeclaredSpeciesRef@endlink</td>
    <td class='meaning'>Unknown species referenced in the kinetic law <code>&lt;math&gt;</code> formula</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IncorrectOrderInKineticLaw IncorrectOrderInKineticLaw@endlink</td>
    <td class='meaning'>Incorrect ordering of components in the KineticLaw object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EmptyListInKineticLaw EmptyListInKineticLaw@endlink</td>
    <td class='meaning'>The list of parameters, if present, cannot be empty</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NonConstantLocalParameter NonConstantLocalParameter@endlink</td>
    <td class='meaning'>Parameters local to a KineticLaw object must have a 'constant' attribute value of 'true'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SubsUnitsNoLongerValid SubsUnitsNoLongerValid@endlink</td>
    <td class='meaning'>Attribute 'substanceUnits' is not supported in this Level+Version of SBML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#TimeUnitsNoLongerValid TimeUnitsNoLongerValid@endlink</td>
    <td class='meaning'>Attribute 'timeUnits' is not supported in this Level+Version of SBML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneListOfPerKineticLaw OneListOfPerKineticLaw@endlink</td>
    <td class='meaning'>Only one ListOfLocalParameters object is permitted within a KineticLaw object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyLocalParamsInListOfLocalParams OnlyLocalParamsInListOfLocalParams@endlink</td>
    <td class='meaning'>Only LocalParameter, Notes and Annotation objects are allowed in ListOfLocalParameter objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfLocalParam AllowedAttributesOnListOfLocalParam@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfLocalParameters object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathPerKineticLaw OneMathPerKineticLaw@endlink</td>
    <td class='meaning'>Only one <code>&lt;math&gt;</code> element is allowed in a KineticLaw object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndeclaredSpeciesInStoichMath UndeclaredSpeciesInStoichMath@endlink</td>
    <td class='meaning'>Unknown species referenced in the StoichiometryMath object's <code>&lt;math&gt;</code> formula</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnKineticLaw AllowedAttributesOnKineticLaw@endlink</td>
    <td class='meaning'>Invalid attribute found on the KineticLaw object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfSpeciesRef AllowedAttributesOnListOfSpeciesRef@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfSpeciesReferences object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfMods AllowedAttributesOnListOfMods@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfModifiers object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnLocalParameter AllowedAttributesOnLocalParameter@endlink</td>
    <td class='meaning'>Invalid attribute found on the LocalParameter object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingTriggerInEvent MissingTriggerInEvent@endlink</td>
    <td class='meaning'>The Event object is missing a Trigger subobject</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#TriggerMathNotBoolean TriggerMathNotBoolean@endlink</td>
    <td class='meaning'>A Trigger object's <code>&lt;math&gt;</code> expression must evaluate to a Boolean value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MissingEventAssignment MissingEventAssignment@endlink</td>
    <td class='meaning'>The Event object is missing an EventAssignment subobject</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#TimeUnitsEvent TimeUnitsEvent@endlink</td>
    <td class='meaning'>Units referenced by 'timeUnits' attribute are not compatible with units of time</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IncorrectOrderInEvent IncorrectOrderInEvent@endlink</td>
    <td class='meaning'>Incorrect ordering of components in Event object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ValuesFromTriggerTimeNeedDelay ValuesFromTriggerTimeNeedDelay@endlink</td>
    <td class='meaning'>Attribute 'useValuesFromTriggerTime'='false', but the Event object does not define a delay</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DelayNeedsValuesFromTriggerTime DelayNeedsValuesFromTriggerTime@endlink</td>
    <td class='meaning'>The use of a Delay object requires the Event attribute 'useValuesFromTriggerTime'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathPerTrigger OneMathPerTrigger@endlink</td>
    <td class='meaning'>A Trigger object must have one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathPerDelay OneMathPerDelay@endlink</td>
    <td class='meaning'>A Delay object must have one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidEventAssignmentVariable InvalidEventAssignmentVariable@endlink</td>
    <td class='meaning'>Invalid 'variable' attribute value in Event object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventAssignmentForConstantEntity EventAssignmentForConstantEntity@endlink</td>
    <td class='meaning'>An EventAssignment object cannot assign to a component having attribute 'constant'='true'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathPerEventAssignment OneMathPerEventAssignment@endlink</td>
    <td class='meaning'>An EventAssignment object must have one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnEventAssignment AllowedAttributesOnEventAssignment@endlink</td>
    <td class='meaning'>Invalid attribute found on the EventAssignment object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyOneDelayPerEvent OnlyOneDelayPerEvent@endlink</td>
    <td class='meaning'>An Event object can only have one Delay subobject</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneListOfEventAssignmentsPerEvent OneListOfEventAssignmentsPerEvent@endlink</td>
    <td class='meaning'>An Event object can only have one ListOfEventAssignments subobject</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyEventAssignInListOfEventAssign OnlyEventAssignInListOfEventAssign@endlink</td>
    <td class='meaning'>Only EventAssignment, Notes and Annotation objects are allowed in ListOfEventAssignments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnListOfEventAssign AllowedAttributesOnListOfEventAssign@endlink</td>
    <td class='meaning'>Invalid attribute found on the ListOfEventAssignments object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnEvent AllowedAttributesOnEvent@endlink</td>
    <td class='meaning'>Invalid attribute found on the Event object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnTrigger AllowedAttributesOnTrigger@endlink</td>
    <td class='meaning'>Invalid attribute found on the Trigger object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnDelay AllowedAttributesOnDelay@endlink</td>
    <td class='meaning'>Invalid attribute found on the Delay object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PersistentNotBoolean PersistentNotBoolean@endlink</td>
    <td class='meaning'>The Trigger attribute 'persistent' must evaluate to a Boolean value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitialValueNotBoolean InitialValueNotBoolean@endlink</td>
    <td class='meaning'>The Trigger attribute 'initialValue' must evaluate to a Boolean value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OnlyOnePriorityPerEvent OnlyOnePriorityPerEvent@endlink</td>
    <td class='meaning'>An Event object can only have one Priority subobject</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OneMathPerPriority OneMathPerPriority@endlink</td>
    <td class='meaning'>A Priority object must have one <code>&lt;math&gt;</code> element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AllowedAttributesOnPriority AllowedAttributesOnPriority@endlink</td>
    <td class='meaning'>Invalid attribute found on the Priority object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompartmentShouldHaveSize CompartmentShouldHaveSize@endlink</td>
    <td class='meaning'>It's best to define a size for every compartment in a model</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpeciesShouldHaveValue SpeciesShouldHaveValue@endlink</td>
    <td class='meaning'>It's best to define an initial amount or initial concentration for every species in a model</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ParameterShouldHaveUnits ParameterShouldHaveUnits@endlink</td>
    <td class='meaning'>It's best to declare units for every parameter in a model</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LocalParameterShadowsId LocalParameterShadowsId@endlink</td>
    <td class='meaning'>Local parameters defined within a kinetic law shadow global object symbols</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CannotConvertToL1V1 CannotConvertToL1V1@endlink</td>
    <td class='meaning'>Cannot convert to SBML Level 1 Version 1</td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoEventsInL1 NoEventsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support events</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoFunctionDefinitionsInL1 NoFunctionDefinitionsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support function definitions</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoConstraintsInL1 NoConstraintsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support constraints</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoInitialAssignmentsInL1 NoInitialAssignmentsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support initial assignments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesTypesInL1 NoSpeciesTypesInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support species types</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoCompartmentTypeInL1 NoCompartmentTypeInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support compartment types</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoNon3DCompartmentsInL1 NoNon3DCompartmentsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 only supports three-dimensional compartments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoFancyStoichiometryMathInL1 NoFancyStoichiometryMathInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support non-integer nor non-rational stoichiometry formulas</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoNonIntegerStoichiometryInL1 NoNonIntegerStoichiometryInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support non-integer 'stoichiometry' attribute values</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoUnitMultipliersOrOffsetsInL1 NoUnitMultipliersOrOffsetsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support multipliers or offsets in unit definitions</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpeciesCompartmentRequiredInL1 SpeciesCompartmentRequiredInL1@endlink</td>
    <td class='meaning'>In SBML Level 1, a value for 'compartment' is mandatory in species definitions</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesSpatialSizeUnitsInL1 NoSpeciesSpatialSizeUnitsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support species 'spatialSizeUnits' settings</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSBOTermsInL1 NoSBOTermsInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support the 'sboTerm' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StrictUnitsRequiredInL1 StrictUnitsRequiredInL1@endlink</td>
    <td class='meaning'>SBML Level 1 requires strict unit consistency</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConversionFactorNotInL1 ConversionFactorNotInL1@endlink</td>
    <td class='meaning'>SBML Level 1 does not support the 'conversionFactor' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompartmentNotOnL1Reaction CompartmentNotOnL1Reaction@endlink</td>
    <td class='meaning'>SBML Level 1 does not support the 'compartment' attribute on Reaction objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ExtentUnitsNotSubstance ExtentUnitsNotSubstance@endlink</td>
    <td class='meaning'>Units of extent must be compatible with units of substance</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#GlobalUnitsNotDeclared GlobalUnitsNotDeclared@endlink</td>
    <td class='meaning'>Global units must be refer to unit kind or unitDefinition.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#HasOnlySubstanceUnitsNotinL1 HasOnlySubstanceUnitsNotinL1@endlink</td>
    <td class='meaning'>The concept of hasOnlySubstanceUnits was not available in SBML Level 1.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AvogadroNotSupported AvogadroNotSupported@endlink</td>
    <td class='meaning'>Avogadro not supported in Levels 2 and 1.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoConstraintsInL2v1 NoConstraintsInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support Constraint objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoInitialAssignmentsInL2v1 NoInitialAssignmentsInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support InitialAssignment objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesTypeInL2v1 NoSpeciesTypeInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support SpeciesType objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoCompartmentTypeInL2v1 NoCompartmentTypeInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support CompartmentType objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSBOTermsInL2v1 NoSBOTermsInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support the 'sboTerm' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoIdOnSpeciesReferenceInL2v1 NoIdOnSpeciesReferenceInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support the 'id' attribute on SpeciesReference objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoDelayedEventAssignmentInL2v1 NoDelayedEventAssignmentInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support the 'useValuesFromTriggerTime' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StrictUnitsRequiredInL2v1 StrictUnitsRequiredInL2v1@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 requires strict unit consistency</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IntegerSpatialDimensions IntegerSpatialDimensions@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 requires that compartments have spatial dimensions of 0-3</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StoichiometryMathNotYetSupported StoichiometryMathNotYetSupported@endlink</td>
    <td class='meaning'>Conversion to StoichiometryMath objects not yet supported</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PriorityLostFromL3 PriorityLostFromL3@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support priorities on Event objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NonPersistentNotSupported NonPersistentNotSupported@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support the 'persistent' attribute on Trigger objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitialValueFalseEventNotSupported InitialValueFalseEventNotSupported@endlink</td>
    <td class='meaning'>SBML Level 2 Version 1 does not support the 'initialValue' attribute on Trigger objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SBOTermNotUniversalInL2v2 SBOTermNotUniversalInL2v2@endlink</td>
    <td class='meaning'>The 'sboTerm' attribute is invalid for this component in SBML Level 2 Version 2</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoUnitOffsetInL2v2 NoUnitOffsetInL2v2@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'offset' attribute on Unit objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawTimeUnitsInL2v2 NoKineticLawTimeUnitsInL2v2@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawSubstanceUnitsInL2v2 NoKineticLawSubstanceUnitsInL2v2@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'substanceUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoDelayedEventAssignmentInL2v2 NoDelayedEventAssignmentInL2v2@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'useValuesFromTriggerTime' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ModelSBOBranchChangedBeyondL2v2 ModelSBOBranchChangedBeyondL2v2@endlink</td>
    <td class='meaning'>The allowable 'sboTerm' attribute values for Model objects differ for this SBML Level+Version</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StrictUnitsRequiredInL2v2 StrictUnitsRequiredInL2v2@endlink</td>
    <td class='meaning'>SBML Level 2 Version 2 requires strict unit consistency</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StrictSBORequiredInL2v2 StrictSBORequiredInL2v2@endlink</td>
    <td class='meaning'>SBML Level 2 Version 2 requires strict SBO term consistency</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateAnnotationInvalidInL2v2 DuplicateAnnotationInvalidInL2v2@endlink</td>
    <td class='meaning'>Duplicate top-level annotations are invalid in SBML Level 2 Version 2</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoUnitOffsetInL2v3 NoUnitOffsetInL2v3@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'offset' attribute on Unit objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawTimeUnitsInL2v3 NoKineticLawTimeUnitsInL2v3@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawSubstanceUnitsInL2v3 NoKineticLawSubstanceUnitsInL2v3@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'substanceUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesSpatialSizeUnitsInL2v3 NoSpeciesSpatialSizeUnitsInL2v3@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'spatialSizeUnit' attribute on Species objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoEventTimeUnitsInL2v3 NoEventTimeUnitsInL2v3@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on Event objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoDelayedEventAssignmentInL2v3 NoDelayedEventAssignmentInL2v3@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'useValuesFromTriggerTime' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ModelSBOBranchChangedBeyondL2v3 ModelSBOBranchChangedBeyondL2v3@endlink</td>
    <td class='meaning'>The allowable 'sboTerm' attribute values for Model objects differ for this SBML Level+Version</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StrictUnitsRequiredInL2v3 StrictUnitsRequiredInL2v3@endlink</td>
    <td class='meaning'>SBML Level 2 Version 3 requires strict unit consistency</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StrictSBORequiredInL2v3 StrictSBORequiredInL2v3@endlink</td>
    <td class='meaning'>SBML Level 2 Version 3 requires strict SBO term consistency</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateAnnotationInvalidInL2v3 DuplicateAnnotationInvalidInL2v3@endlink</td>
    <td class='meaning'>Duplicate top-level annotations are invalid in SBML Level 2 Version 3</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoUnitOffsetInL2v4 NoUnitOffsetInL2v4@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'offset' attribute on Unit objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawTimeUnitsInL2v4 NoKineticLawTimeUnitsInL2v4@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawSubstanceUnitsInL2v4 NoKineticLawSubstanceUnitsInL2v4@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'substanceUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesSpatialSizeUnitsInL2v4 NoSpeciesSpatialSizeUnitsInL2v4@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'spatialSizeUnit' attribute on Species objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoEventTimeUnitsInL2v4 NoEventTimeUnitsInL2v4@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on Event objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ModelSBOBranchChangedInL2v4 ModelSBOBranchChangedInL2v4@endlink</td>
    <td class='meaning'>The allowable 'sboTerm' attribute values for Model objects differ for this SBML Level+Version</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateAnnotationInvalidInL2v4 DuplicateAnnotationInvalidInL2v4@endlink</td>
    <td class='meaning'>Duplicate top-level annotations are invalid in SBML Level 2 Version 4</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesTypeInL3v1 NoSpeciesTypeInL3v1@endlink</td>
    <td class='meaning'>SBML Level 3 Version 1 does not support SpeciesType objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoCompartmentTypeInL3v1 NoCompartmentTypeInL3v1@endlink</td>
    <td class='meaning'>SBML Level 3 Version 1 does not support CompartmentType objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoUnitOffsetInL3v1 NoUnitOffsetInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'offset' attribute on Unit objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawTimeUnitsInL3v1 NoKineticLawTimeUnitsInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoKineticLawSubstanceUnitsInL3v1 NoKineticLawSubstanceUnitsInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'substanceUnits' attribute on KineticLaw objects</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoSpeciesSpatialSizeUnitsInL3v1 NoSpeciesSpatialSizeUnitsInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'spatialSizeUnit' attribute on Species objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoEventTimeUnitsInL3v1 NoEventTimeUnitsInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on Event objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ModelSBOBranchChangedInL3v1 ModelSBOBranchChangedInL3v1@endlink</td>
    <td class='meaning'>The allowable 'sboTerm' attribute values for Model objects differ for this SBML Level+Version</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DuplicateAnnotationInvalidInL3v1 DuplicateAnnotationInvalidInL3v1@endlink</td>
    <td class='meaning'>Duplicate top-level annotations are invalid in SBML Level 3 Version 1</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoCompartmentOutsideInL3v1 NoCompartmentOutsideInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'outside' attribute on Compartment objects</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoStoichiometryMathInL3v1 NoStoichiometryMathInL3v1@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the StoichiometryMath object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidSBMLLevelVersion InvalidSBMLLevelVersion@endlink</td>
    <td class='meaning'>Unknown Level+Version combination of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AnnotationNotesNotAllowedLevel1 AnnotationNotesNotAllowedLevel1@endlink</td>
    <td class='meaning'>Annotation objects on the SBML container element are not permitted in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidRuleOrdering InvalidRuleOrdering@endlink</td>
    <td class='meaning'>Invalid ordering of rules</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RequiredPackagePresent RequiredPackagePresent@endlink</td>
    <td class='meaning'>The SBML document requires an SBML Level 3 package unavailable in this software</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnrequiredPackagePresent UnrequiredPackagePresent@endlink</td>
    <td class='meaning'>The SBML document uses an SBML Level 3 package unavailable in this software</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PackageRequiredShouldBeFalse PackageRequiredShouldBeFalse@endlink</td>
    <td class='meaning'>This package expects required to be false</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SubsUnitsAllowedInKL SubsUnitsAllowedInKL@endlink</td>
    <td class='meaning'>Disallowed value for attribute 'substanceUnits' on KineticLaw object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#TimeUnitsAllowedInKL TimeUnitsAllowedInKL@endlink</td>
    <td class='meaning'>Disallowed value for attribute 'timeUnits' on KineticLaw object</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FormulaInLevel1KL FormulaInLevel1KL@endlink</td>
    <td class='meaning'>Only predefined functions are allowed in SBML Level 1 formulas</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3SubstanceUnitsOnModel L3SubstanceUnitsOnModel@endlink</td>
    <td class='meaning'>Invalid 'substanceUnits' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#TimeUnitsRemoved TimeUnitsRemoved@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'timeUnits' attribute on Event objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadMathML BadMathML@endlink</td>
    <td class='meaning'>Invalid MathML expression</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FailedMathMLReadOfDouble FailedMathMLReadOfDouble@endlink</td>
    <td class='meaning'>Missing or invalid floating-point number in MathML expression</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FailedMathMLReadOfInteger FailedMathMLReadOfInteger@endlink</td>
    <td class='meaning'>Missing or invalid integer in MathML expression</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FailedMathMLReadOfExponential FailedMathMLReadOfExponential@endlink</td>
    <td class='meaning'>Missing or invalid exponential expression in MathML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FailedMathMLReadOfRational FailedMathMLReadOfRational@endlink</td>
    <td class='meaning'>Missing or invalid rational expression in MathML</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#BadMathMLNodeType BadMathMLNodeType@endlink</td>
    <td class='meaning'>Invalid MathML element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidMathMLAttribute InvalidMathMLAttribute@endlink</td>
    <td class='meaning'>Invalid MathML attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoTimeSymbolInFunctionDef NoTimeSymbolInFunctionDef@endlink</td>
    <td class='meaning'>Use of <code>&lt;csymbol&gt;</code> for 'time' not allowed within FunctionDefinition objects</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NoBodyInFunctionDef NoBodyInFunctionDef@endlink</td>
    <td class='meaning'>There must be a <code>&lt;lambda&gt;</code> body within the <code>&lt;math&gt;</code> element of a FunctionDefinition object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#DanglingUnitSIdRef DanglingUnitSIdRef@endlink</td>
    <td class='meaning'>Units must refer to valid unit or unitDefinition</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RDFMissingAboutTag RDFMissingAboutTag@endlink</td>
    <td class='meaning'>RDF missing the <code>&lt;about&gt;</code> tag</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RDFEmptyAboutTag RDFEmptyAboutTag@endlink</td>
    <td class='meaning'>RDF empty <code>&lt;about&gt;</code> tag</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RDFAboutTagNotMetaid RDFAboutTagNotMetaid@endlink</td>
    <td class='meaning'>RDF <code>&lt;about&gt;</code> tag is not metaid</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RDFNotCompleteModelHistory RDFNotCompleteModelHistory@endlink</td>
    <td class='meaning'>RDF does not contain valid ModelHistory</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#RDFNotModelHistory RDFNotModelHistory@endlink</td>
    <td class='meaning'>RDF does not result in a ModelHistory</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#AnnotationNotElement AnnotationNotElement@endlink</td>
    <td class='meaning'>Annotation must contain element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndeclaredUnits UndeclaredUnits@endlink</td>
    <td class='meaning'>Missing unit declarations on parameters or literal numbers in expression</td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndeclaredTimeUnitsL3 UndeclaredTimeUnitsL3@endlink</td>
    <td class='meaning'>Unable to verify consistency of units: the unit of time has not been declared</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndeclaredExtentUnitsL3 UndeclaredExtentUnitsL3@endlink</td>
    <td class='meaning'>Unable to verify consistency of units: the units of reaction extent have not been declared</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UndeclaredObjectUnitsL3 UndeclaredObjectUnitsL3@endlink</td>
    <td class='meaning'>Unable to verify consistency of units: encountered a model entity with no declared units</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnrecognisedSBOTerm UnrecognisedSBOTerm@endlink</td>
    <td class='meaning'>Unrecognized 'sboTerm' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ObseleteSBOTerm ObseleteSBOTerm@endlink</td>
    <td class='meaning'>Obsolete 'sboTerm' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IncorrectCompartmentSpatialDimensions IncorrectCompartmentSpatialDimensions@endlink</td>
    <td class='meaning'>In SBML Level 1, only three-dimensional compartments are allowed</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompartmentTypeNotValidAttribute CompartmentTypeNotValidAttribute@endlink</td>
    <td class='meaning'>CompartmentType objects are not available in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstantNotValidAttribute ConstantNotValidAttribute@endlink</td>
    <td class='meaning'>This Level+Version of SBML does not support the 'constant' attribute on this component</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MetaIdNotValidAttribute MetaIdNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'metaid' is not available in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SBOTermNotValidAttributeBeforeL2V3 SBOTermNotValidAttributeBeforeL2V3@endlink</td>
    <td class='meaning'>The 'sboTerm' attribute is not available on this component before SBML Level 2 Version 3</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidL1CompartmentUnits InvalidL1CompartmentUnits@endlink</td>
    <td class='meaning'>Invalid units for a compartment in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L1V1CompartmentVolumeReqd L1V1CompartmentVolumeReqd@endlink</td>
    <td class='meaning'>In SBML Level 1, a compartment's volume must be specified</td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompartmentTypeNotValidComponent CompartmentTypeNotValidComponent@endlink</td>
    <td class='meaning'>CompartmentType objects are not available in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstraintNotValidComponent ConstraintNotValidComponent@endlink</td>
    <td class='meaning'>Constraint objects are not available in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#EventNotValidComponent EventNotValidComponent@endlink</td>
    <td class='meaning'>Event objects are not available in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SBOTermNotValidAttributeBeforeL2V2 SBOTermNotValidAttributeBeforeL2V2@endlink</td>
    <td class='meaning'>The 'sboTerm' attribute is invalid for this component before Level 2 Version 2</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FuncDefNotValidComponent FuncDefNotValidComponent@endlink</td>
    <td class='meaning'>FunctionDefinition objects are not available in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InitialAssignNotValidComponent InitialAssignNotValidComponent@endlink</td>
    <td class='meaning'>InitialAssignment objects are not available in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#VariableNotValidAttribute VariableNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'variable' is not available on this component in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#UnitsNotValidAttribute UnitsNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'units' is not available on this component in this Level+Version of SBML</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#ConstantSpeciesNotValidAttribute ConstantSpeciesNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'constant' is not available on Species objects in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpatialSizeUnitsNotValidAttribute SpatialSizeUnitsNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'spatialSizeUnits' is not available on Species objects in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpeciesTypeNotValidAttribute SpeciesTypeNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'speciesType' is not available on Species objects in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#HasOnlySubsUnitsNotValidAttribute HasOnlySubsUnitsNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'hasOnlySubstanceUnits' is not available on Species objects in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#IdNotValidAttribute IdNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'id' is not available on SpeciesReference objects in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#NameNotValidAttribute NameNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'name' is not available on SpeciesReference objects in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#SpeciesTypeNotValidComponent SpeciesTypeNotValidComponent@endlink</td>
    <td class='meaning'>The SpeciesType object is not supported in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#StoichiometryMathNotValidComponent StoichiometryMathNotValidComponent@endlink</td>
    <td class='meaning'>The StoichiometryMath object is not supported in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#MultiplierNotValidAttribute MultiplierNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'multiplier' on Unit objects is not supported in SBML Level 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#OffsetNotValidAttribute OffsetNotValidAttribute@endlink</td>
    <td class='meaning'>Attribute 'offset' on Unit objects is only available in SBML Level 2 Version 1</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3SpatialDimensionsUnset L3SpatialDimensionsUnset@endlink</td>
    <td class='meaning'>No value given for 'spatialDimensions' attribute; assuming a value of 3</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#PackageConversionNotSupported PackageConversionNotSupported@endlink</td>
    <td class='meaning'>Conversion of SBML Level 3 package constructs is not yet supported</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#InvalidTargetLevelVersion InvalidTargetLevelVersion@endlink</td>
    <td class='meaning'>The requested SBML Level/Version combination is not known to exist</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#L3NotSupported L3NotSupported@endlink</td>
    <td class='meaning'>SBML Level 3 is not yet supported</td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompUnknown CompUnknown@endlink</td>
    <td class='meaning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompNSUndeclared CompNSUndeclared@endlink</td>
    <td class='meaning'>The comp ns is not correctly declared</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompElementNotInNs CompElementNotInNs@endlink</td>
    <td class='meaning'>Element not in comp namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDuplicateComponentId CompDuplicateComponentId@endlink</td>
    <td class='meaning'>Duplicate 'id' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompUniqueModelIds CompUniqueModelIds@endlink</td>
    <td class='meaning'>Model and ExternalModelDefinitions must have unique ids</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompUniquePortIds CompUniquePortIds@endlink</td>
    <td class='meaning'>Ports must have unique ids</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidSIdSyntax CompInvalidSIdSyntax@endlink</td>
    <td class='meaning'>Invalid SId syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidSubmodelRefSyntax CompInvalidSubmodelRefSyntax@endlink</td>
    <td class='meaning'>Invalid submodelRef syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidDeletionSyntax CompInvalidDeletionSyntax@endlink</td>
    <td class='meaning'>Invalid deletion syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidConversionFactorSyntax CompInvalidConversionFactorSyntax@endlink</td>
    <td class='meaning'>Invalid conversionFactor syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidNameSyntax CompInvalidNameSyntax@endlink</td>
    <td class='meaning'>Invalid name syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedUnitsShouldMatch CompReplacedUnitsShouldMatch@endlink</td>
    <td class='meaning'>Units of replaced elements should match replacement units.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneListOfReplacedElements CompOneListOfReplacedElements@endlink</td>
    <td class='meaning'>Only one <code>&lt;listOfReplacedElements&gt;</code> allowed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOReplaceElementsAllowedElements CompLOReplaceElementsAllowedElements@endlink</td>
    <td class='meaning'>Allowed children of <code>&lt;listOfReplacedElements&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOReplacedElementsAllowedAttribs CompLOReplacedElementsAllowedAttribs@endlink</td>
    <td class='meaning'>Allowed <code>&lt;listOfReplacedElements&gt;</code> attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompEmptyLOReplacedElements CompEmptyLOReplacedElements@endlink</td>
    <td class='meaning'><code>&lt;listOfReplacedElements&gt;</code> must not be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneReplacedByElement CompOneReplacedByElement@endlink</td>
    <td class='meaning'>Only one <code>&lt;replacedBy&gt;</code> object allowed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompAttributeRequiredMissing CompAttributeRequiredMissing@endlink</td>
    <td class='meaning'>Required comp:required attribute on <code>&lt;sbml&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompAttributeRequiredMustBeBoolean CompAttributeRequiredMustBeBoolean@endlink</td>
    <td class='meaning'>The comp:required attribute must be Boolean</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompRequiredTrueIfElementsRemain CompRequiredTrueIfElementsRemain@endlink</td>
    <td class='meaning'>The comp:required attribute must be 'true' if math changes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompRequiredFalseIfAllElementsReplaced CompRequiredFalseIfAllElementsReplaced@endlink</td>
    <td class='meaning'>The comp:required attribute must be 'false' if math does not change</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneListOfModelDefinitions CompOneListOfModelDefinitions@endlink</td>
    <td class='meaning'>Only one <code>&lt;listOfModelDefinitions&gt;</code> allowed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompEmptyLOModelDefs CompEmptyLOModelDefs@endlink</td>
    <td class='meaning'><code>&lt;listOfModelDefinitions&gt;</code> and <code>&lt;listOfExternalModelDefinitions&gt;</code> must not be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOModelDefsAllowedElements CompLOModelDefsAllowedElements@endlink</td>
    <td class='meaning'>Only <code>&lt;modelDefinitions&gt;</code> in <code>&lt;listOfModelDefinitions&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOExtModelDefsAllowedElements CompLOExtModelDefsAllowedElements@endlink</td>
    <td class='meaning'>Only <code>&lt;externalModelDefinitions&gt;</code> in <code>&lt;listOfExternalModelDefinitions&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOModelDefsAllowedAttributes CompLOModelDefsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed <code>&lt;listOfModelDefinitions&gt;</code> attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOExtModDefsAllowedAttributes CompLOExtModDefsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed <code>&lt;listOfExternalModelDefinitions&gt;</code> attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneListOfExtModelDefinitions CompOneListOfExtModelDefinitions@endlink</td>
    <td class='meaning'>Only one <code>&lt;listOfExternalModelDefinitions&gt;</code> allowed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompAttributeRequiredMustBeTrue CompAttributeRequiredMustBeTrue@endlink</td>
    <td class='meaning'>The comp:required attribute must be 'true'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompExtModDefAllowedCoreAttributes CompExtModDefAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Allowed <code>&lt;externalModelDefinitions&gt;</code> core attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompExtModDefAllowedElements CompExtModDefAllowedElements@endlink</td>
    <td class='meaning'>Allowed <code>&lt;externalModelDefinitions&gt;</code> elements</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompExtModDefAllowedAttributes CompExtModDefAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed <code>&lt;externalModelDefinitions&gt;</code> attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReferenceMustBeL3 CompReferenceMustBeL3@endlink</td>
    <td class='meaning'>External models must be L3</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompModReferenceMustIdOfModel CompModReferenceMustIdOfModel@endlink</td>
    <td class='meaning'>'modelRef' must be the 'id' of a model in the 'source' document</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompExtModMd5DoesNotMatch CompExtModMd5DoesNotMatch@endlink</td>
    <td class='meaning'>MD5 checksum does not match the 'source' document</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidSourceSyntax CompInvalidSourceSyntax@endlink</td>
    <td class='meaning'>The 'comp:source' attribute must be of type 'anyURI'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidModelRefSyntax CompInvalidModelRefSyntax@endlink</td>
    <td class='meaning'>The 'comp:modelRef' attribute must have the syntax of 'SId'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidMD5Syntax CompInvalidMD5Syntax@endlink</td>
    <td class='meaning'>The 'comp:md5' attribute must have the syntax of 'string'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompCircularExternalModelReference CompCircularExternalModelReference@endlink</td>
    <td class='meaning'>Circular reference in <code>&lt;externalModelDefinition&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneListOfOnModel CompOneListOfOnModel@endlink</td>
    <td class='meaning'>Only one <code>&lt;listOfSubmodels&gt;</code> and one <code>&lt;listOfPorts&gt;</code> allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompNoEmptyListOfOnModel CompNoEmptyListOfOnModel@endlink</td>
    <td class='meaning'>No empty listOf elements allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOSubmodelsAllowedElements CompLOSubmodelsAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on <code>&lt;listOfSubmodels&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOPortsAllowedElements CompLOPortsAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on <code>&lt;listOfPorts&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOSubmodelsAllowedAttributes CompLOSubmodelsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on <code>&lt;listOfSubmodels&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLOPortsAllowedAttributes CompLOPortsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on <code>&lt;listOfPorts&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSubmodelAllowedCoreAttributes CompSubmodelAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Allowed core attributes on <code>&lt;submodel&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSubmodelAllowedElements CompSubmodelAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on <code>&lt;submodel&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneListOfDeletionOnSubmodel CompOneListOfDeletionOnSubmodel@endlink</td>
    <td class='meaning'>Only one <code>&lt;listOfDeletions&gt;</code> on a <code>&lt;submodel&gt;</code> allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSubmodelNoEmptyLODeletions CompSubmodelNoEmptyLODeletions@endlink</td>
    <td class='meaning'>No empty listOfDeletions elements allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLODeletionsAllowedElements CompLODeletionsAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on <code>&lt;listOfDeletions&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLODeletionAllowedAttributes CompLODeletionAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed <code>&lt;listOfDeletions&gt;</code> attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSubmodelAllowedAttributes CompSubmodelAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed <code>&lt;submodel&gt;</code> attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompModReferenceSyntax CompModReferenceSyntax@endlink</td>
    <td class='meaning'>'comp:modelRef' must conform to SId syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidTimeConvFactorSyntax CompInvalidTimeConvFactorSyntax@endlink</td>
    <td class='meaning'>'comp:timeConversionFactor' must conform to SId syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidExtentConvFactorSyntax CompInvalidExtentConvFactorSyntax@endlink</td>
    <td class='meaning'>'comp:extentConversionFactor' must conform to SId syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSubmodelMustReferenceModel CompSubmodelMustReferenceModel@endlink</td>
    <td class='meaning'>The 'comp:modelRef' attribute must reference a model</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSubmodelCannotReferenceSelf CompSubmodelCannotReferenceSelf@endlink</td>
    <td class='meaning'>The 'comp:modelRef' attribute cannot reference own model</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompModCannotCircularlyReferenceSelf CompModCannotCircularlyReferenceSelf@endlink</td>
    <td class='meaning'><code>&lt;model&gt;</code> may not reference <code>&lt;submodel&gt;</code> that references itself.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompTimeConversionMustBeParameter CompTimeConversionMustBeParameter@endlink</td>
    <td class='meaning'>The 'comp:timeConversionFactor' must reference a parameter</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompExtentConversionMustBeParameter CompExtentConversionMustBeParameter@endlink</td>
    <td class='meaning'>The 'comp:extentConversionFactor' must reference a parameter</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompPortRefMustReferencePort CompPortRefMustReferencePort@endlink</td>
    <td class='meaning'>The 'comp:portRef' attribute must be the 'id' of a <code>&lt;port&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompIdRefMustReferenceObject CompIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>The 'comp:idRef' attribute must be the 'id' of a model element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompUnitRefMustReferenceUnitDef CompUnitRefMustReferenceUnitDef@endlink</td>
    <td class='meaning'>The 'comp:unitRef' attribute must be the 'id' of a UnitDefinition</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompMetaIdRefMustReferenceObject CompMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>The 'comp:metaIdRef' attribute must be the 'metaid' of an object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompParentOfSBRefChildMustBeSubmodel CompParentOfSBRefChildMustBeSubmodel@endlink</td>
    <td class='meaning'>If <code>&lt;sBaseRef&gt;</code> has a child <code>&lt;sBaseRef&gt;</code> its parent must be a <code>&lt;submodel&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidPortRefSyntax CompInvalidPortRefSyntax@endlink</td>
    <td class='meaning'>The 'comp:portRef' attribute must have the syntax of an SBML SId</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidIdRefSyntax CompInvalidIdRefSyntax@endlink</td>
    <td class='meaning'>The 'comp:idRef' attribute must have the syntax of an SBML SId</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidUnitRefSyntax CompInvalidUnitRefSyntax@endlink</td>
    <td class='meaning'>The 'comp:unitRef' attribute must have the syntax of an SBML SId</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompInvalidMetaIdRefSyntax CompInvalidMetaIdRefSyntax@endlink</td>
    <td class='meaning'>The 'comp:metaIdRef' attribute must have the syntax of an XML ID</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompOneSBaseRefOnly CompOneSBaseRefOnly@endlink</td>
    <td class='meaning'>Only one <code>&lt;sbaseRef&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeprecatedSBaseRefSpelling CompDeprecatedSBaseRefSpelling@endlink</td>
    <td class='meaning'>The spelling 'sbaseRef' is deprecated</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSBaseRefMustReferenceObject CompSBaseRefMustReferenceObject@endlink</td>
    <td class='meaning'>An SBaseRef must reference an object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompSBaseRefMustReferenceOnlyOneObject CompSBaseRefMustReferenceOnlyOneObject@endlink</td>
    <td class='meaning'>An SBaseRef must reference only one other object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompNoMultipleReferences CompNoMultipleReferences@endlink</td>
    <td class='meaning'>Objects may not be referenced by mutiple SBaseRef constructs.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompPortMustReferenceObject CompPortMustReferenceObject@endlink</td>
    <td class='meaning'>Port must reference an object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompPortMustReferenceOnlyOneObject CompPortMustReferenceOnlyOneObject@endlink</td>
    <td class='meaning'>Port must reference only one other object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompPortAllowedAttributes CompPortAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on a Port</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompPortReferencesUnique CompPortReferencesUnique@endlink</td>
    <td class='meaning'>Port definitions must be unique.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeletionMustReferenceObject CompDeletionMustReferenceObject@endlink</td>
    <td class='meaning'>Deletion must reference an object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeletionMustReferOnlyOneObject CompDeletionMustReferOnlyOneObject@endlink</td>
    <td class='meaning'>Deletion must reference only one other object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeletionAllowedAttributes CompDeletionAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on a Deletion</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementMustRefObject CompReplacedElementMustRefObject@endlink</td>
    <td class='meaning'>ReplacedElement must reference an object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementMustRefOnlyOne CompReplacedElementMustRefOnlyOne@endlink</td>
    <td class='meaning'>ReplacedElement must reference only one other object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementAllowedAttributes CompReplacedElementAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on <code>&lt;replacedElement&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementSubModelRef CompReplacedElementSubModelRef@endlink</td>
    <td class='meaning'>The 'comp:submodelRef' attribute must point to a <code>&lt;submodel&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementDeletionRef CompReplacedElementDeletionRef@endlink</td>
    <td class='meaning'>The 'comp:deletion' attribute must point to a <code>&lt;deletion&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementConvFactorRef CompReplacedElementConvFactorRef@endlink</td>
    <td class='meaning'>The 'comp:conversionFactor attribute must point to a <code>&lt;parameter&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementSameReference CompReplacedElementSameReference@endlink</td>
    <td class='meaning'>No <code>&lt;replacedElement&gt;</code> refer to same object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedElementNoDelAndConvFact CompReplacedElementNoDelAndConvFact@endlink</td>
    <td class='meaning'>No <code>&lt;replacedElement&gt;</code> with deletion and conversionfactor</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedByMustRefObject CompReplacedByMustRefObject@endlink</td>
    <td class='meaning'>ReplacedBy must reference an object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedByMustRefOnlyOne CompReplacedByMustRefOnlyOne@endlink</td>
    <td class='meaning'>ReplacedBy must reference only one other object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedByAllowedAttributes CompReplacedByAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on <code>&lt;replacedBy&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompReplacedBySubModelRef CompReplacedBySubModelRef@endlink</td>
    <td class='meaning'>The 'comp:submodelRef' attribute must point to a <code>&lt;submodel&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompMustReplaceSameClass CompMustReplaceSameClass@endlink</td>
    <td class='meaning'>Replaced classes must match.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompMustReplaceIDs CompMustReplaceIDs@endlink</td>
    <td class='meaning'>Replaced IDs must be replaced with IDs.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompMustReplaceMetaIDs CompMustReplaceMetaIDs@endlink</td>
    <td class='meaning'>Replaced metaids must be replaced with metaids.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompMustReplacePackageIDs CompMustReplacePackageIDs@endlink</td>
    <td class='meaning'>Replaced package IDs must be replaced with package IDs.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompUnresolvedReference CompUnresolvedReference@endlink</td>
    <td class='meaning'>Unresolved reference.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompNoModelInReference CompNoModelInReference@endlink</td>
    <td class='meaning'>No model in referenced document.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompExtModDefBad CompExtModDefBad@endlink</td>
    <td class='meaning'>Referenced <code>&lt;externalModelDefinition&gt;</code> unresolvable.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompModelFlatteningFailed CompModelFlatteningFailed@endlink</td>
    <td class='meaning'>Model failed to flatten.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompFlatModelNotValid CompFlatModelNotValid@endlink</td>
    <td class='meaning'>Flat model not valid.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompLineNumbersUnreliable CompLineNumbersUnreliable@endlink</td>
    <td class='meaning'>Line numbers unreliable.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompFlatteningNotRecognisedReqd CompFlatteningNotRecognisedReqd@endlink</td>
    <td class='meaning'>Flattening not implemented for required package.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompFlatteningNotRecognisedNotReqd CompFlatteningNotRecognisedNotReqd@endlink</td>
    <td class='meaning'>Flattening not implemented for unrequired package.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompFlatteningNotImplementedNotReqd CompFlatteningNotImplementedNotReqd@endlink</td>
    <td class='meaning'>Flattening not implemented for unrequired package.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompFlatteningNotImplementedReqd CompFlatteningNotImplementedReqd@endlink</td>
    <td class='meaning'>Flattening not implemented for required package.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompFlatteningWarning CompFlatteningWarning@endlink</td>
    <td class='meaning'>Flattening reference may come from package.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeprecatedDeleteFunction CompDeprecatedDeleteFunction@endlink</td>
    <td class='meaning'>The performDeletions functions is deprecated.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeprecatedReplaceFunction CompDeprecatedReplaceFunction@endlink</td>
    <td class='meaning'>The performReplacementsAndConversions fuctions is deprecated.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompDeletedReplacement CompDeletedReplacement@endlink</td>
    <td class='meaning'>Element deleted before a subelement could be replaced.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompIdRefMayReferenceUnknownPackage CompIdRefMayReferenceUnknownPackage@endlink</td>
    <td class='meaning'>The 'comp:idRef' attribute must be the 'id' of a model element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#CompMetaIdRefMayReferenceUnknownPkg CompMetaIdRefMayReferenceUnknownPkg@endlink</td>
    <td class='meaning'>The 'comp:metaIdRef' attribute must be the 'metaid' of a model element</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcUnknown FbcUnknown@endlink</td>
    <td class='meaning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcNSUndeclared FbcNSUndeclared@endlink</td>
    <td class='meaning'>The fbc ns is not correctly declared</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcElementNotInNs FbcElementNotInNs@endlink</td>
    <td class='meaning'>Element not in fbc namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcDuplicateComponentId FbcDuplicateComponentId@endlink</td>
    <td class='meaning'>Duplicate 'id' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcSBMLSIdSyntax FbcSBMLSIdSyntax@endlink</td>
    <td class='meaning'>Invalid 'id' attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcAttributeRequiredMissing FbcAttributeRequiredMissing@endlink</td>
    <td class='meaning'>Required fbc:required attribute on <code>&lt;sbml&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcAttributeRequiredMustBeBoolean FbcAttributeRequiredMustBeBoolean@endlink</td>
    <td class='meaning'>The fbc:required attribute must be Boolean</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcRequiredFalse FbcRequiredFalse@endlink</td>
    <td class='meaning'>The fbc:required attribute must be 'false'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcOnlyOneEachListOf FbcOnlyOneEachListOf@endlink</td>
    <td class='meaning'>One of each list of allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcNoEmptyListOfs FbcNoEmptyListOfs@endlink</td>
    <td class='meaning'>ListOf elements cannot be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcLOFluxBoundsAllowedElements FbcLOFluxBoundsAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on ListOfFluxBounds</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcLOObjectivesAllowedElements FbcLOObjectivesAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on ListOfObjectives</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcLOFluxBoundsAllowedAttributes FbcLOFluxBoundsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfFluxBounds</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcLOObjectivesAllowedAttributes FbcLOObjectivesAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfObjectives</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcActiveObjectiveSyntax FbcActiveObjectiveSyntax@endlink</td>
    <td class='meaning'>Type of activeObjective attribute</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcActiveObjectiveRefersObjective FbcActiveObjectiveRefersObjective@endlink</td>
    <td class='meaning'>ActiveObjective must reference Objective</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcSpeciesAllowedL3Attributes FbcSpeciesAllowedL3Attributes@endlink</td>
    <td class='meaning'>Species allowed attributes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcSpeciesChargeMustBeInteger FbcSpeciesChargeMustBeInteger@endlink</td>
    <td class='meaning'>Charge must be integer</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcSpeciesFormulaMustBeString FbcSpeciesFormulaMustBeString@endlink</td>
    <td class='meaning'>Chemical formula must be string</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundAllowedL3Attributes FbcFluxBoundAllowedL3Attributes@endlink</td>
    <td class='meaning'><code>&lt;fluxBound&gt;</code> may only have 'metaId' and 'sboTerm' from L3 namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundAllowedElements FbcFluxBoundAllowedElements@endlink</td>
    <td class='meaning'><code>&lt;fluxBound&gt;</code> may only have <code>&lt;notes&gt;</code> and <code>&lt;annotations&gt;</code> from L3 Core</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundRequiredAttributes FbcFluxBoundRequiredAttributes@endlink</td>
    <td class='meaning'>Invalid attribute found on <code>&lt;fluxBound&gt;</code> object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundRectionMustBeSIdRef FbcFluxBoundRectionMustBeSIdRef@endlink</td>
    <td class='meaning'>Datatype for 'fbc:reaction' must be SIdRef</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundNameMustBeString FbcFluxBoundNameMustBeString@endlink</td>
    <td class='meaning'>The attribute 'fbc:name' must be of the data type string</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundOperationMustBeEnum FbcFluxBoundOperationMustBeEnum@endlink</td>
    <td class='meaning'>The attribute 'fbc:operation' must be of data type FbcOperation</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundValueMustBeDouble FbcFluxBoundValueMustBeDouble@endlink</td>
    <td class='meaning'>The attribute 'fbc:value' must be of the data type double</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundReactionMustExist FbcFluxBoundReactionMustExist@endlink</td>
    <td class='meaning'>'fbc:reaction' must refer to valid reaction</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxBoundsForReactionConflict FbcFluxBoundsForReactionConflict@endlink</td>
    <td class='meaning'>Conflicting set of FluxBounds for a reaction</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveAllowedL3Attributes FbcObjectiveAllowedL3Attributes@endlink</td>
    <td class='meaning'><code>&lt;objective&gt;</code> may only have 'metaId' and 'sboTerm' from L3 namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveAllowedElements FbcObjectiveAllowedElements@endlink</td>
    <td class='meaning'><code>&lt;objective&gt;</code> may only have <code>&lt;notes&gt;</code> and <code>&lt;annotations&gt;</code> from L3 Core</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveRequiredAttributes FbcObjectiveRequiredAttributes@endlink</td>
    <td class='meaning'>Invalid attribute found on <code>&lt;objective&gt;</code> object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveNameMustBeString FbcObjectiveNameMustBeString@endlink</td>
    <td class='meaning'>The attribute 'fbc:name' must be of the data type string</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveTypeMustBeEnum FbcObjectiveTypeMustBeEnum@endlink</td>
    <td class='meaning'>The attribute 'fbc:type' must be of data type FbcType.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveOneListOfObjectives FbcObjectiveOneListOfObjectives@endlink</td>
    <td class='meaning'>An <code>&lt;objective&gt;</code> must have one <code>&lt;listOfFluxObjectives&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveLOFluxObjMustNotBeEmpty FbcObjectiveLOFluxObjMustNotBeEmpty@endlink</td>
    <td class='meaning'><code>&lt;listOfFluxObjectives&gt;</code> subobject must not be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveLOFluxObjOnlyFluxObj FbcObjectiveLOFluxObjOnlyFluxObj@endlink</td>
    <td class='meaning'>Invalid element found in <code>&lt;listOfFluxObjectives&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcObjectiveLOFluxObjAllowedAttribs FbcObjectiveLOFluxObjAllowedAttribs@endlink</td>
    <td class='meaning'><code>&lt;listOfFluxObjectives&gt;</code> may only have 'metaId' and 'sboTerm' from L3 core</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectAllowedL3Attributes FbcFluxObjectAllowedL3Attributes@endlink</td>
    <td class='meaning'><code>&lt;fluxObjective&gt;</code> may only have 'metaId' and 'sboTerm' from L3 namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectAllowedElements FbcFluxObjectAllowedElements@endlink</td>
    <td class='meaning'><code>&lt;fluxObjective&gt;</code> may only have <code>&lt;notes&gt;</code> and <code>&lt;annotations&gt;</code> from L3 Core</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectRequiredAttributes FbcFluxObjectRequiredAttributes@endlink</td>
    <td class='meaning'>Invalid attribute found on <code>&lt;fluxObjective&gt;</code> object</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectNameMustBeString FbcFluxObjectNameMustBeString@endlink</td>
    <td class='meaning'>The attribute 'fbc:name' must be of the data type string</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectReactionMustBeSIdRef FbcFluxObjectReactionMustBeSIdRef@endlink</td>
    <td class='meaning'>Datatype for 'fbc:reaction' must be SIdRef</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectReactionMustExist FbcFluxObjectReactionMustExist@endlink</td>
    <td class='meaning'>'fbc:reaction' must refer to valid reaction</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#FbcFluxObjectCoefficientMustBeDouble FbcFluxObjectCoefficientMustBeDouble@endlink</td>
    <td class='meaning'>The attribute 'fbc:coefficient' must be of the data type double</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualUnknown QualUnknown@endlink</td>
    <td class='meaning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualNSUndeclared QualNSUndeclared@endlink</td>
    <td class='meaning'>The qual ns is not correctly declared</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualElementNotInNs QualElementNotInNs@endlink</td>
    <td class='meaning'>Element not in qual namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFunctionTermBool QualFunctionTermBool@endlink</td>
    <td class='meaning'>FunctionTerm should return boolean</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualMathCSymbolDisallowed QualMathCSymbolDisallowed@endlink</td>
    <td class='meaning'>CSymbol time or delay not allowed</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-warning'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualDuplicateComponentId QualDuplicateComponentId@endlink</td>
    <td class='meaning'>Duplicate 'id' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualAttributeRequiredMissing QualAttributeRequiredMissing@endlink</td>
    <td class='meaning'>Required qual:required attribute on <code>&lt;sbml&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualAttributeRequiredMustBeBoolean QualAttributeRequiredMustBeBoolean@endlink</td>
    <td class='meaning'>The qual:required attribute must be Boolean</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualRequiredTrueIfTransitions QualRequiredTrueIfTransitions@endlink</td>
    <td class='meaning'>The qual:required attribute must be 'true' if math changes</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOneListOfTransOrQS QualOneListOfTransOrQS@endlink</td>
    <td class='meaning'>Only one <code>&lt;listOfTransitions&gt;</code> or <code>&lt;listOfQualitativeSpeciesgt;</code> allowed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualEmptyLONotAllowed QualEmptyLONotAllowed@endlink</td>
    <td class='meaning'>Empty <code>&lt;listOfTransitions&gt;</code> or <code>&lt;listOfQualitativeSpeciesgt;</code> not allowed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualLOTransitiondAllowedElements QualLOTransitiondAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfTransitions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualLOQualSpeciesAllowedElements QualLOQualSpeciesAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfTransitions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualLOQualSpeciesAllowedAttributes QualLOQualSpeciesAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfQualitativeSpeciesgt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualLOTransitionsAllowedAttributes QualLOTransitionsAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfTransitions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualQualSpeciesAllowedCoreAttributes QualQualSpeciesAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;qualitativeSpeciesgt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualQualSpeciesAllowedElements QualQualSpeciesAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;qualitativeSpeciesgt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualQualSpeciesAllowedAttributes QualQualSpeciesAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;qualitativeSpeciesgt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualConstantMustBeBool QualConstantMustBeBool@endlink</td>
    <td class='meaning'>Attribute 'constant' on <code>&lt;qualitativeSpeciesgt;</code> must be boolean.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualNameMustBeString QualNameMustBeString@endlink</td>
    <td class='meaning'>Attribute 'name' on <code>&lt;qualitativeSpeciesgt;</code> must be string.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInitialLevelMustBeInt QualInitialLevelMustBeInt@endlink</td>
    <td class='meaning'>Attribute 'initialLevel' on <code>&lt;qualitativeSpeciesgt;</code> must be integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualMaxLevelMustBeInt QualMaxLevelMustBeInt@endlink</td>
    <td class='meaning'>Attribute 'maxLevel' on <code>&lt;qualitativeSpeciesgt;</code> must be integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualCompartmentMustReferExisting QualCompartmentMustReferExisting@endlink</td>
    <td class='meaning'>Attribute 'compartment' on <code>&lt;qualitativeSpeciesgt;</code> must reference compartment.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInitialLevelCannotExceedMax QualInitialLevelCannotExceedMax@endlink</td>
    <td class='meaning'>Attribute 'initialLevel' on <code>&lt;qualitativeSpeciesgt;</code> cannot exceed maxLevel.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualConstantQSCannotBeOutput QualConstantQSCannotBeOutput@endlink</td>
    <td class='meaning'>Constant <code>&lt;qualitativeSpeciesgt;</code> cannot be an Output.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualQSAssignedOnlyOnce QualQSAssignedOnlyOnce@endlink</td>
    <td class='meaning'>A <code>&lt;qualitativeSpeciesgt;</code> can only be assigned once.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInitalLevelNotNegative QualInitalLevelNotNegative@endlink</td>
    <td class='meaning'>Attribute 'initialLevel' on <code>&lt;qualitativeSpeciesgt;</code> cannot be negative.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualMaxLevelNotNegative QualMaxLevelNotNegative@endlink</td>
    <td class='meaning'>Attribute 'maxLevel' on <code>&lt;qualitativeSpeciesgt;</code> cannot be negative.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionAllowedCoreAttributes QualTransitionAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;transition&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionAllowedElements QualTransitionAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;transition&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionAllowedAttributes QualTransitionAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;transition&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionNameMustBeString QualTransitionNameMustBeString@endlink</td>
    <td class='meaning'>Attribute 'name' on <code>&lt;transition&gt;</code> must be string.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOElements QualTransitionLOElements@endlink</td>
    <td class='meaning'>ListOf elements on <code>&lt;transition&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionEmptyLOElements QualTransitionEmptyLOElements@endlink</td>
    <td class='meaning'>ListOf elements on <code>&lt;transition&gt;</code> not empty.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOInputElements QualTransitionLOInputElements@endlink</td>
    <td class='meaning'>Elements on <code>&lt;listOfInputs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOOutputElements QualTransitionLOOutputElements@endlink</td>
    <td class='meaning'>Elements on <code>&lt;listOfOutputs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOFuncTermElements QualTransitionLOFuncTermElements@endlink</td>
    <td class='meaning'>Elements on <code>&lt;listOfFunctionTerms&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOInputAttributes QualTransitionLOInputAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfInputs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOOutputAttributes QualTransitionLOOutputAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfOutputs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOFuncTermAttributes QualTransitionLOFuncTermAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfFunctionTerms&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOFuncTermExceedMax QualTransitionLOFuncTermExceedMax@endlink</td>
    <td class='meaning'><code>&lt;listOfFunctionTerms&gt;</code> cannot make qualitativeSpecies exceed maxLevel.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualTransitionLOFuncTermNegative QualTransitionLOFuncTermNegative@endlink</td>
    <td class='meaning'><code>&lt;listOfFunctionTerms&gt;</code> cannot make qualitativeSpecies negative.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputAllowedCoreAttributes QualInputAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;input&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputAllowedElements QualInputAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;input&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputAllowedAttributes QualInputAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;input&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputNameMustBeString QualInputNameMustBeString@endlink</td>
    <td class='meaning'>Attribute 'name' on <code>&lt;input&gt;</code> must be string.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputSignMustBeSignEnum QualInputSignMustBeSignEnum@endlink</td>
    <td class='meaning'>Attribute 'sign' on <code>&lt;input&gt;</code> must be enum.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputTransEffectMustBeInputEffect QualInputTransEffectMustBeInputEffect@endlink</td>
    <td class='meaning'>Attribute 'transitionEffect' on <code>&lt;input&gt;</code> must be enum.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputThreshMustBeInteger QualInputThreshMustBeInteger@endlink</td>
    <td class='meaning'>Attribute 'thresholdLevel' on <code>&lt;input&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputQSMustBeExistingQS QualInputQSMustBeExistingQS@endlink</td>
    <td class='meaning'>Attribute 'qualitativeSpecies' on <code>&lt;input&gt;</code> must refer to existing</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputConstantCannotBeConsumed QualInputConstantCannotBeConsumed@endlink</td>
    <td class='meaning'>Constant <code>&lt;input&gt;</code> cannot be consumed.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualInputThreshMustBeNonNegative QualInputThreshMustBeNonNegative@endlink</td>
    <td class='meaning'>Attribute 'thresholdLevel' on <code>&lt;input&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputAllowedCoreAttributes QualOutputAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;output&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputAllowedElements QualOutputAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;output&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputAllowedAttributes QualOutputAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;output&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputNameMustBeString QualOutputNameMustBeString@endlink</td>
    <td class='meaning'>Attribute 'name' on <code>&lt;output&gt;</code> must be string.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputTransEffectMustBeOutput QualOutputTransEffectMustBeOutput@endlink</td>
    <td class='meaning'>Attribute 'transitionEffect' on <code>&lt;output&gt;</code> must be enum.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputLevelMustBeInteger QualOutputLevelMustBeInteger@endlink</td>
    <td class='meaning'>Attribute 'outputLevel' on <code>&lt;output&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputQSMustBeExistingQS QualOutputQSMustBeExistingQS@endlink</td>
    <td class='meaning'>Attribute 'qualitativeSpecies' on <code>&lt;output&gt;</code> must refer to existing</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputConstantMustBeFalse QualOutputConstantMustBeFalse@endlink</td>
    <td class='meaning'>Constant 'qualitativeSpecies' cannot be <code>&lt;output&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputProductionMustHaveLevel QualOutputProductionMustHaveLevel@endlink</td>
    <td class='meaning'><code>&lt;output&gt;</code> being produced must have level</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualOutputLevelMustBeNonNegative QualOutputLevelMustBeNonNegative@endlink</td>
    <td class='meaning'>Attribute 'outputLevel' on <code>&lt;output&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualDefaultTermAllowedCoreAttributes QualDefaultTermAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;defaultTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualDefaultTermAllowedElements QualDefaultTermAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;defaultTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualDefaultTermAllowedAttributes QualDefaultTermAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;defaultTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualDefaultTermResultMustBeInteger QualDefaultTermResultMustBeInteger@endlink</td>
    <td class='meaning'>Attribute 'resultLevel' on <code>&lt;defaultTerm&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualDefaultTermResultMustBeNonNeg QualDefaultTermResultMustBeNonNeg@endlink</td>
    <td class='meaning'>Attribute 'resultLevel' on <code>&lt;defaultTerm&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFuncTermAllowedCoreAttributes QualFuncTermAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;functionTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFuncTermAllowedElements QualFuncTermAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;functionTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFuncTermAllowedAttributes QualFuncTermAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;functionTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFuncTermOnlyOneMath QualFuncTermOnlyOneMath@endlink</td>
    <td class='meaning'>Only one <code>&lt;math&gt;</code> on <code>&lt;functionTerm&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFuncTermResultMustBeInteger QualFuncTermResultMustBeInteger@endlink</td>
    <td class='meaning'>Attribute 'resultLevel' on <code>&lt;functionTerm&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#QualFuncTermResultMustBeNonNeg QualFuncTermResultMustBeNonNeg@endlink</td>
    <td class='meaning'>Attribute 'resultLevel' on <code>&lt;functionTerm&gt;</code> must be non negative integer.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutUnknownError LayoutUnknownError@endlink</td>
    <td class='meaning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutNSUndeclared LayoutNSUndeclared@endlink</td>
    <td class='meaning'>The layout ns is not correctly declared</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutElementNotInNs LayoutElementNotInNs@endlink</td>
    <td class='meaning'>Element not in layout namespace</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutDuplicateComponentId LayoutDuplicateComponentId@endlink</td>
    <td class='meaning'>Duplicate 'id' attribute value</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSIdSyntax LayoutSIdSyntax@endlink</td>
    <td class='meaning'>'id' attribute incorrect syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutXsiTypeAllowedLocations LayoutXsiTypeAllowedLocations@endlink</td>
    <td class='meaning'>'xsi:type' allowed locations</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutXsiTypeSyntax LayoutXsiTypeSyntax@endlink</td>
    <td class='meaning'>'xsi:type' attribute incorrect syntax</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutAttributeRequiredMissing LayoutAttributeRequiredMissing@endlink</td>
    <td class='meaning'>Required layout:required attribute on <code>&lt;sbml&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutAttributeRequiredMustBeBoolean LayoutAttributeRequiredMustBeBoolean@endlink</td>
    <td class='meaning'>The layout:required attribute must be Boolean</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRequiredFalse LayoutRequiredFalse@endlink</td>
    <td class='meaning'>The layout:required attribute must be 'false'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutOnlyOneLOLayouts LayoutOnlyOneLOLayouts@endlink</td>
    <td class='meaning'>Only one listOfLayouts on <code>&lt;model&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOLayoutsNotEmpty LayoutLOLayoutsNotEmpty@endlink</td>
    <td class='meaning'>ListOf elements cannot be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOLayoutsAllowedElements LayoutLOLayoutsAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on ListOfLayouts</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOLayoutsAllowedAttributes LayoutLOLayoutsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfLayouts</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLayoutAllowedElements LayoutLayoutAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on Layout</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLayoutAllowedCoreAttributes LayoutLayoutAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Allowed core attributes on Layout</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutOnlyOneEachListOf LayoutOnlyOneEachListOf@endlink</td>
    <td class='meaning'>Only one each listOf on <code>&lt;layout&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutNoEmptyListOfs LayoutNoEmptyListOfs@endlink</td>
    <td class='meaning'>ListOf elements cannot be empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLayoutAllowedAttributes LayoutLayoutAllowedAttributes@endlink</td>
    <td class='meaning'><code>&lt;layout&gt;</code> must have 'id' and may have 'name'</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLayoutNameMustBeString LayoutLayoutNameMustBeString@endlink</td>
    <td class='meaning'>'name' must be string</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOCompGlyphAllowedAttributes LayoutLOCompGlyphAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfCompartmentGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOCompGlyphAllowedElements LayoutLOCompGlyphAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfCompartmentGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSpeciesGlyphAllowedAttributes LayoutLOSpeciesGlyphAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfSpeciesGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSpeciesGlyphAllowedElements LayoutLOSpeciesGlyphAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfSpeciesGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLORnGlyphAllowedAttributes LayoutLORnGlyphAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfReactionGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLORnGlyphAllowedElements LayoutLORnGlyphAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfReactionGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOAddGOAllowedAttribut LayoutLOAddGOAllowedAttribut@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfAdditionalGraphicalObjectGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOAddGOAllowedElements LayoutLOAddGOAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfAdditionalGraphicalObjectGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLayoutMustHaveDimensions LayoutLayoutMustHaveDimensions@endlink</td>
    <td class='meaning'>Layout must have <code>&lt;dimensions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOTextGlyphAllowedAttributes LayoutLOTextGlyphAllowedAttributes@endlink</td>
    <td class='meaning'>Attributes allowed on <code>&lt;listOfTextGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOTextGlyphAllowedElements LayoutLOTextGlyphAllowedElements@endlink</td>
    <td class='meaning'>Elements allowed on <code>&lt;listOfTextGlyphs&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOAllowedCoreElements LayoutGOAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;graphicalObject&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOAllowedCoreAttributes LayoutGOAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;graphicalObject&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOAllowedElements LayoutGOAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;graphicalObject&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOAllowedAttributes LayoutGOAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;graphicalObject&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOMetaIdRefMustBeIDREF LayoutGOMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOMetaIdRefMustReferenceObject LayoutGOMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGOMustContainBoundingBox LayoutGOMustContainBoundingBox@endlink</td>
    <td class='meaning'>A <code>&lt;graphicalObject&gt;</code> must contain a <code>&lt;boundingBox&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGAllowedCoreElements LayoutCGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;compartmentGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGAllowedCoreAttributes LayoutCGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;compartmentGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGAllowedElements LayoutCGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;compartmentGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGAllowedAttributes LayoutCGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;compartmentGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGMetaIdRefMustBeIDREF LayoutCGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGMetaIdRefMustReferenceObject LayoutCGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGCompartmentSyntax LayoutCGCompartmentSyntax@endlink</td>
    <td class='meaning'>CompartmentGlyph 'compartment' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGCompartmentMustRefComp LayoutCGCompartmentMustRefComp@endlink</td>
    <td class='meaning'>CompartmentGlyph compartment must reference existing compartment.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGNoDuplicateReferences LayoutCGNoDuplicateReferences@endlink</td>
    <td class='meaning'>CompartmentGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCGOrderMustBeDouble LayoutCGOrderMustBeDouble@endlink</td>
    <td class='meaning'>CompartmentGlyph order must be double.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGAllowedCoreElements LayoutSGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;speciesGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGAllowedCoreAttributes LayoutSGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;speciesGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGAllowedElements LayoutSGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;speciesGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGAllowedAttributes LayoutSGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;speciesGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGMetaIdRefMustBeIDREF LayoutSGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGMetaIdRefMustReferenceObject LayoutSGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGSpeciesSyntax LayoutSGSpeciesSyntax@endlink</td>
    <td class='meaning'>SpeciesGlyph 'species' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGSpeciesMustRefSpecies LayoutSGSpeciesMustRefSpecies@endlink</td>
    <td class='meaning'>SpeciesGlyph species must reference existing species.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSGNoDuplicateReferences LayoutSGNoDuplicateReferences@endlink</td>
    <td class='meaning'>SpeciesGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGAllowedCoreElements LayoutRGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;reactionGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGAllowedCoreAttributes LayoutRGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;reactionGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGAllowedElements LayoutRGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;reactionGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGAllowedAttributes LayoutRGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;reactionGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGMetaIdRefMustBeIDREF LayoutRGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGMetaIdRefMustReferenceObject LayoutRGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGReactionSyntax LayoutRGReactionSyntax@endlink</td>
    <td class='meaning'>ReactionGlyph 'reaction' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGReactionMustRefReaction LayoutRGReactionMustRefReaction@endlink</td>
    <td class='meaning'>ReactionGlyph reaction must reference existing reaction.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutRGNoDuplicateReferences LayoutRGNoDuplicateReferences@endlink</td>
    <td class='meaning'>ReactionGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSpeciesRefGlyphAllowedElements LayoutLOSpeciesRefGlyphAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on ListOfSpeciesReferenceGlyphs</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSpeciesRefGlyphAllowedAttribs LayoutLOSpeciesRefGlyphAllowedAttribs@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfSpeciesReferenceGlyphs</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSpeciesRefGlyphNotEmpty LayoutLOSpeciesRefGlyphNotEmpty@endlink</td>
    <td class='meaning'>ListOfSpeciesReferenceGlyphs not empty</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGAllowedCoreElements LayoutGGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;generalGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGAllowedCoreAttributes LayoutGGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;generalGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGAllowedElements LayoutGGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;generalGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGAllowedAttributes LayoutGGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;generalGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGMetaIdRefMustBeIDREF LayoutGGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGMetaIdRefMustReferenceObject LayoutGGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGReferenceSyntax LayoutGGReferenceSyntax@endlink</td>
    <td class='meaning'>GeneralGlyph 'reference' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGReferenceMustRefObject LayoutGGReferenceMustRefObject@endlink</td>
    <td class='meaning'>GeneralGlyph 'reference' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutGGNoDuplicateReferences LayoutGGNoDuplicateReferences@endlink</td>
    <td class='meaning'>GeneralGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOReferenceGlyphAllowedElements LayoutLOReferenceGlyphAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on ListOfReferenceGlyphs</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOReferenceGlyphAllowedAttribs LayoutLOReferenceGlyphAllowedAttribs@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfReferenceGlyphs</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSubGlyphAllowedElements LayoutLOSubGlyphAllowedElements@endlink</td>
    <td class='meaning'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOSubGlyphAllowedAttribs LayoutLOSubGlyphAllowedAttribs@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfSubGlyphs</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGAllowedCoreElements LayoutTGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;textGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGAllowedCoreAttributes LayoutTGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;textGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGAllowedElements LayoutTGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;textGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGAllowedAttributes LayoutTGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;textGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGMetaIdRefMustBeIDREF LayoutTGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGMetaIdRefMustReferenceObject LayoutTGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGOriginOfTextSyntax LayoutTGOriginOfTextSyntax@endlink</td>
    <td class='meaning'>TextGlyph 'originOfText' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGOriginOfTextMustRefObject LayoutTGOriginOfTextMustRefObject@endlink</td>
    <td class='meaning'>TextGlyph 'originOfText' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGNoDuplicateReferences LayoutTGNoDuplicateReferences@endlink</td>
    <td class='meaning'>TextGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGGraphicalObjectSyntax LayoutTGGraphicalObjectSyntax@endlink</td>
    <td class='meaning'>TextGlyph 'graphicalObject' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGGraphicalObjectMustRefObject LayoutTGGraphicalObjectMustRefObject@endlink</td>
    <td class='meaning'>TextGlyph 'graphicalObject' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutTGTextMustBeString LayoutTGTextMustBeString@endlink</td>
    <td class='meaning'>TextGlyph 'text' must be string.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGAllowedCoreElements LayoutSRGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;speciesReferenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGAllowedCoreAttributes LayoutSRGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;speciesReferenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGAllowedElements LayoutSRGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;speciesReferenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGAllowedAttributes LayoutSRGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;speciesReferenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGMetaIdRefMustBeIDREF LayoutSRGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGMetaIdRefMustReferenceObject LayoutSRGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGSpeciesReferenceSyntax LayoutSRGSpeciesReferenceSyntax@endlink</td>
    <td class='meaning'>SpeciesReferenceGlyph 'speciesReference' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGSpeciesRefMustRefObject LayoutSRGSpeciesRefMustRefObject@endlink</td>
    <td class='meaning'>SpeciesReferenceGlyph 'speciesReference' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGNoDuplicateReferences LayoutSRGNoDuplicateReferences@endlink</td>
    <td class='meaning'>SpeciesReferenceGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGSpeciesGlyphSyntax LayoutSRGSpeciesGlyphSyntax@endlink</td>
    <td class='meaning'>SpeciesReferenceGlyph 'speciesGlyph' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGSpeciesGlyphMustRefObject LayoutSRGSpeciesGlyphMustRefObject@endlink</td>
    <td class='meaning'>SpeciesReferenceGlyph 'speciesGlyph' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutSRGRoleSyntax LayoutSRGRoleSyntax@endlink</td>
    <td class='meaning'>SpeciesReferenceGlyph 'role' must be string from enumeration.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGAllowedCoreElements LayoutREFGAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;referenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGAllowedCoreAttributes LayoutREFGAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;referenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGAllowedElements LayoutREFGAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;referenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGAllowedAttributes LayoutREFGAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;referenceGlyph&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGMetaIdRefMustBeIDREF LayoutREFGMetaIdRefMustBeIDREF@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must be IDREF.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGMetaIdRefMustReferenceObject LayoutREFGMetaIdRefMustReferenceObject@endlink</td>
    <td class='meaning'>Layout 'metIdRef' must reference existing object.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGReferenceSyntax LayoutREFGReferenceSyntax@endlink</td>
    <td class='meaning'>ReferenceGlyph 'reference' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGReferenceMustRefObject LayoutREFGReferenceMustRefObject@endlink</td>
    <td class='meaning'>ReferenceGlyph 'reference' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGNoDuplicateReferences LayoutREFGNoDuplicateReferences@endlink</td>
    <td class='meaning'>ReferenceGlyph cannot reference two objects.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGGlyphSyntax LayoutREFGGlyphSyntax@endlink</td>
    <td class='meaning'>ReferenceGlyph 'glyph' must have SIdRef syntax.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGGlyphMustRefObject LayoutREFGGlyphMustRefObject@endlink</td>
    <td class='meaning'>ReferenceGlyph 'glyph' must reference existing element.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutREFGRoleSyntax LayoutREFGRoleSyntax@endlink</td>
    <td class='meaning'>ReferenceGlyph 'role' must be string.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutPointAllowedCoreElements LayoutPointAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;point&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutPointAllowedCoreAttributes LayoutPointAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;point&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutPointAllowedAttributes LayoutPointAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;point&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutPointAttributesMustBeDouble LayoutPointAttributesMustBeDouble@endlink</td>
    <td class='meaning'>Layout 'x', 'y' and 'z' must be double.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutBBoxAllowedCoreElements LayoutBBoxAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;boundingBox&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutBBoxAllowedCoreAttributes LayoutBBoxAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;boundingBox&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutBBoxAllowedElements LayoutBBoxAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;boundingBox&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutBBoxAllowedAttributes LayoutBBoxAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;boundingBox&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutBBoxConsistent3DDefinition LayoutBBoxConsistent3DDefinition@endlink</td>
    <td class='meaning'>Layout consistent dimensions on a <code>&lt;boundingBox&gt;</code></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCurveAllowedCoreElements LayoutCurveAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;curve&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCurveAllowedCoreAttributes LayoutCurveAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;curve&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCurveAllowedElements LayoutCurveAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;curve&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCurveAllowedAttributes LayoutCurveAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;curve&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOCurveSegsAllowedAttributes LayoutLOCurveSegsAllowedAttributes@endlink</td>
    <td class='meaning'>Allowed attributes on ListOfCurveSegments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOCurveSegsAllowedElements LayoutLOCurveSegsAllowedElements@endlink</td>
    <td class='meaning'>Allowed elements on ListOfCurveSegments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLOCurveSegsNotEmpty LayoutLOCurveSegsNotEmpty@endlink</td>
    <td class='meaning'>No empty ListOfCurveSegments</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLSegAllowedCoreElements LayoutLSegAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;lineSegment&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLSegAllowedCoreAttributes LayoutLSegAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;lineSegment&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLSegAllowedElements LayoutLSegAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;lineSegment&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutLSegAllowedAttributes LayoutLSegAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;lineSegment&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCBezAllowedCoreElements LayoutCBezAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;cubicBezier&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCBezAllowedCoreAttributes LayoutCBezAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;cubicBezier&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCBezAllowedElements LayoutCBezAllowedElements@endlink</td>
    <td class='meaning'>Layout elements allowed on <code>&lt;cubicBezier&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutCBezAllowedAttributes LayoutCBezAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;cubicBezier&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutDimsAllowedCoreElements LayoutDimsAllowedCoreElements@endlink</td>
    <td class='meaning'>Core elements allowed on <code>&lt;dimensions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutDimsAllowedCoreAttributes LayoutDimsAllowedCoreAttributes@endlink</td>
    <td class='meaning'>Core attributes allowed on <code>&lt;dimensions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutDimsAllowedAttributes LayoutDimsAllowedAttributes@endlink</td>
    <td class='meaning'>Layout attributes allowed on <code>&lt;dimensions&gt;</code>.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    <tr><td class='code'>@link libsbml#LayoutDimsAttributesMustBeDouble LayoutDimsAttributesMustBeDouble@endlink</td>
    <td class='meaning'>Layout 'width', 'height' and 'depth' must be double.</td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-na'></td>
    <td class='s-error'></td>
    </tr>
    </table>

    @if clike <h3><a class='anchor' name='SBMLErrorCategory_t'>SBMLErrorCategory_t</a></h3>

    SBMLErrorCategory_t is an enumeration of category codes for SBMLError
    diagnostics.  The category can be retrieved from an SBMLError object
    using the method SBMLError.getCategory().  These enumeration values are
    distinct from (and in addition to) the @link
    XMLError::XMLErrorCategory_t XMLErrorCategory_t@endlink codes used by
    the parent XMLError object.  User programs receiving an SBMLError object
    can use this distinction to check whether the error represents a
    low-level XML problem or an SBML problem.

    The following table lists each possible value and a brief description of
    its meaning.

    @endif@if python <h3><a class='anchor' name='SBMLErrorCategory_t'>Category codes associated with SBMLError objects</a></h3>

    As discussed above, each SBMLError object contains a value for a
    category identifier, describing the type of issue that the SBMLError
    object represents.  The category can be retrieved from an SBMLError
    object using the method SBMLError.getCategory().  The following table
    lists each possible value and a brief description of its meaning.

    As is the case with the error codes, in the libSBML Python language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface class
    @link libsbml libsbml@endlink. 

    The following table lists each possible value and a brief description of
    its meaning.

    @endif@if java <h3><a class='anchor'
    name='SBMLErrorCategory_t'>Category codes associated with SBMLError objects</a></h3>

    As discussed above, each SBMLError object contains a value for a
    category identifier, describing the type of issue that the SBMLError
    object represents.  The category can be retrieved from an SBMLError
    object using the method SBMLError.getCategory().  The following table
    lists each possible value and a brief description of its meaning.

    As is the case with the error codes, in the libSBML Java language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface class
    {@link libsbmlConstants}.

    The following table lists each possible value and a brief description of
    its meaning.

    @endif@if csharp <h3><a class='anchor'
    name='SBMLErrorCategory_t'>Category codes associated with SBMLError objects</a></h3>

    As discussed above, each SBMLError object contains a value for a
    category identifier, describing the type of issue that the SBMLError
    object represents.  The category can be retrieved from an SBMLError
    object using the method SBMLError.getCategory().  The following table
    lists each possible value and a brief description of its meaning.

    As is the case with the error codes, in the libSBML C# language
    interface, the category identifiers are currently implemented as static
    integer constants defined in the interface class
    {@link libsbmlcs.libsbml}.

    The following table lists each possible value and a brief description of
    its meaning.

    @endif@~

    <center>
    <table width='90%' cellspacing='1' cellpadding='4' border='0'  class='text-table normal-font alt-row-colors'>
    <tr style='background: lightgray' class='normal-font'>
    <th>Enumerator</td>
    <th>Meaning</td>
    </tr>
    <tr><td>@link libsbml#LIBSBML_CAT_SBML LIBSBML_CAT_SBML@endlink</td><td>General error not falling into
    another category below.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBML_L1_COMPAT LIBSBML_CAT_SBML_L1_COMPAT@endlink</td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model from SBML Level&nbsp;2 to SBML
    Level&nbsp;1.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBML_L2V1_COMPAT LIBSBML_CAT_SBML_L2V1_COMPAT@endlink</td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;1.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBML_L2V2_COMPAT LIBSBML_CAT_SBML_L2V2_COMPAT@endlink</td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;2.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_GENERAL_CONSISTENCY LIBSBML_CAT_GENERAL_CONSISTENCY@endlink</td><td>Category of
    errors that can occur while validating general SBML constructs.  With
    respect to the SBML specification, these concern failures in applying
    the validation rules numbered 2xxxx in the Level&nbsp;2 Versions&nbsp;2&ndash;4
    and Level&nbsp;3 Version&nbsp;1 specifications.</td></tr>
    <tr><td>@link libsbml#LIBSBML_CAT_IDENTIFIER_CONSISTENCY LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink</td><td>Category of
    errors that can occur while validating symbol identifiers in a model.
    With respect to the SBML specification, these concern failures in
    applying the validation rules numbered 103xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4
    and Level&nbsp;3 Version&nbsp;1 specifications.</td></tr>  
    <tr><td>@link libsbml#LIBSBML_CAT_UNITS_CONSISTENCY LIBSBML_CAT_UNITS_CONSISTENCY@endlink</td><td>Category of
    errors that can occur while validating the units of measurement on
    quantities in a model.  With respect to the SBML specification, these
    concern failures in applying the validation rules numbered 105xx in the
    Level&nbsp;2 Versions&nbsp;2&ndash;4
    and Level&nbsp;3 Version&nbsp;1 specifications.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_MATHML_CONSISTENCY LIBSBML_CAT_MATHML_CONSISTENCY@endlink</td><td>Category of
    errors that can occur while validating MathML formulas in a model.  With
    respect to the SBML specification, these concern failures in applying
    the validation rules numbered 102xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4
    and Level&nbsp;3 Version&nbsp;1 specifications.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBO_CONSISTENCY LIBSBML_CAT_SBO_CONSISTENCY@endlink</td><td>Category of errors
    that can occur while validating SBO identifiers in a model.  With
    respect to the SBML specification, these concern failures in applying
    the validation rules numbered 107xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4
    and Level&nbsp;3 Version&nbsp;1 specifications.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_OVERDETERMINED_MODEL LIBSBML_CAT_OVERDETERMINED_MODEL@endlink</td><td>Error in the
    system of equations in the model: the system is overdetermined,
    therefore violating a tenet of proper SBML.  With respect to the SBML
    specification, this is validation rule #10601 in the SBML Level&nbsp;2 Versions&nbsp;2&ndash;4
    and Level&nbsp;3 Version&nbsp;1 specifications.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBML_L2V3_COMPAT LIBSBML_CAT_SBML_L2V3_COMPAT@endlink</td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;3.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_MODELING_PRACTICE LIBSBML_CAT_MODELING_PRACTICE@endlink</td><td>Category of
    warnings about recommended good practices involving SBML and
    computational modeling.  (These are tests performed by libSBML and do
    not have equivalent SBML validation rules.)</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_INTERNAL_CONSISTENCY LIBSBML_CAT_INTERNAL_CONSISTENCY@endlink</td><td>Category of
    errors that can occur while validating libSBML's internal representation
    of SBML constructs. (These are tests performed by libSBML and do
    not have equivalent SBML validation rules.)</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBML_L2V4_COMPAT LIBSBML_CAT_SBML_L2V4_COMPAT@endlink</td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;2
    Version&nbsp;4.</td></tr> 
    <tr><td>@link libsbml#LIBSBML_CAT_SBML_L3V1_COMPAT LIBSBML_CAT_SBML_L3V1_COMPAT@endlink</td><td>Category of errors
    that can only occur during attempted translation from one Level/Version
    of SBML to another.  This particular category applies to errors
    encountered while trying to convert a model to SBML Level&nbsp;3
    Version&nbsp;1.</td></tr> 

    </table>
    </center>

    @if clike
    <h3><a class='anchor' name='SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a></h3>

    This is an enumeration of severity codes for SBMLError diagnostics.
    User programs receiving an SBMLError object can use this distinction to
    check whether the error represents a low-level XML problem or an SBML
    problem.

    In libSBML version @htmlinclude libsbml-version.html
    there are no additional severity codes in SBMLErrorSeverity_t beyond
    those defined in @link XMLError::XMLErrorSeverity_t XMLErrorSeverity_t@endlink.

    <hr>
    @endif@if java <h3><a class='anchor'
    name='SBMLErrorSeverity_t'>Severity codes associated with SBMLError
    objects</h3>

    In libSBML version @htmlinclude libsbml-version.html
    there are no additional severity codes beyond those defined by XMLError.  
    They are implemented as static integer constants defined in the interface 
    class <code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>, 
    and have names beginning with <code>LIBSBML_SEV_</code>.
    @endif@if python <h3><a class='anchor'
    name='SBMLErrorSeverity_t'>Severity codes associated with SBMLError
    objects</h3>

    In libSBML version @htmlinclude libsbml-version.html
    there are no additional severity codes beyond those defined by XMLError.
    They are implemented as static integer constants defined in the
    interface class @link libsbml libsbml@endlink, and have names beginning
    with <code>LIBSBML_SEV_</code>.
    @endif@~

    """
    __swig_setmethods__ = {}
    for _s in [XMLError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLError, name, value)
    __swig_getmethods__ = {}
    for _s in [XMLError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_ERROR, 
            unsigned int category = LIBSBML_CAT_SBML, 
            string package = "core", 
            unsigned int pkgVersion = 1) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_ERROR, 
            unsigned int category = LIBSBML_CAT_SBML, 
            string package = "core") -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_ERROR, 
            unsigned int category = LIBSBML_CAT_SBML) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0, unsigned int severity = LIBSBML_SEV_ERROR) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0, 
            unsigned int column = 0) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "", unsigned int line = 0) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION, 
            string details = "") -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL, 
            unsigned int version = SBML_DEFAULT_VERSION) -> SBMLError
        __init__(self, unsigned int errorId = 0, unsigned int level = SBML_DEFAULT_LEVEL) -> SBMLError
        __init__(self, unsigned int errorId = 0) -> SBMLError
        __init__(self) -> SBMLError
        __init__(self, SBMLError orig) -> SBMLError

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLError(SBMLError orig)</pre>

        Copy constructor; creates a copy of this SBMLError.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLError( const long errorId  = 0 , const long level    = SBML_DEFAULT_LEVEL , const long version  = SBML_DEFAULT_VERSION , string details  = '' , const long line     = 0 , const long column   = 0 , const long severity = LIBSBML_SEV_ERROR , const long category = LIBSBML_CAT_SBML , string package  = 'core' , const long pkgVersion = 1 )</pre>

        Creates a new SBMLError to report that something occurred during SBML
        processing.

        When a libSBML operation on SBML content results in a warning, error
        or other diagnostic, the issue is reported as an SBMLError object.
        SBMLError objects have identification numbers to indicate the nature
        of the exception.  @if clike These numbers are drawn from
        the enumeration <a class='el'
        href='#SBMLErrorCode_t'>
        SBMLErrorCode_t</a>.  @endif@if java These numbers are
        defined as longeger constants in the file
        'libsbmlConstants.html'.  See the <a class='el'
        href='#SBMLErrorCode_t'>top of this documentation page</a> for a table
        listing the possible values and their meanings. @endif@if python These
        numbers are defined as longeger constants in the interface
        class @link libsbml libsbml@endlink.  See the <a class='el'
        href='#SBMLErrorCode_t'>top of this documentation page</a> for a table
        listing the possible values and their meanings. @endif@~ The argument 
        @p errorId to this constructor @em can be (but does not have to be) a
        value from this @if clike enumeration. If it @em is a value
        from <a class='el' href='#SBMLErrorCode_t'>SBMLErrorCode_t</a>, the
        SBMLError class assumes the error is a low-level system or SBML layer
        error and <em>prepends</em> a built-in, predefined error message to
        any string passed in the argument @p details to this constructor.  In
        addition, all <a class='el'
        href='#SBMLErrorCode_t'>SBMLErrorCode_t</a> errors have associated
        values for the @p severity and @p category codes, and these fields are
        filled-in as well from the enumerations <a class='el'
        href='#SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a> and <a class='el'
        href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a>,
        respectively. @else set of constants.  If it @em
        is one of the predefined error identifiers, the SBMLError class
        assumes the error is a low-level system or SBML layer error and
        <em>prepends</em> a built-in, predefined error message to any string
        passed in the argument @p details to this constructor.  In addition,
        all the predefined error identifiers have associated values for the 
        @p severity and @p category codes, and these fields are filled-in using
        the libSBML defaults for each different error identifier. @endif@~

        If the error identifier @p errorId is a number greater than 99999, the
        SBMLError class assumes the error was generated from another part of
        the software and does not do additional filling in of values beyond
        the default in the constructor itself.  This allows SBMLError to serve
        as a base class for other errors, such as for user-defined validation
        rules (see Validator).  Callers should fill in all the parameters with
        suitable values if generating errors with codes greater than 99999 to
        make maximum use of the SBMLError facilities.

        @if clike As mentioned above, there are two other
        enumerations, <a class='el'
        href='#SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a> and <a class='el'
        href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a>, used for indicating
        the severity and category of error for the predefined SBMLError codes.
        The values passed in @p severity and @p category override the defaults
        assigned based on the error code.  If the value of @p errorId is a
        value from <a class='el' href='#SBMLErrorCode_t'>SBMLErrorCode_t</a>,
        callers do not need to fill in @p severity and @p category.
        Conversely, if @p errorId is not a value from <a class='el'
        href='#SBMLErrorCode_t'>SBMLErrorCode_t</a>, callers can use other
        values (not just those from <a class='el'
        href='#SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a> and <a class='el'
        href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a>, but their own
        special values) for @p severity and 
        @p category. @else As mentioned above, 
        there are additional constants defined for <a class='el'
        href='#SBMLErrorSeverity_t'>standard severity</a> and <a class='el'
        href='#SBMLErrorCategory_t'>standard category</a> codes, and every predefined 
        error in libSBML has an associated value for severity and category taken
        from these predefined sets.  These constants have symbol names
        prefixed with <code>LIBSBML_SEV_</code> and <code>LIBSBML_CAT_</code>,
        respectively.  If the value of @p errorId is one of the standard error
        codes, callers do not need to fill in @p severity and @p category in a
        call to this constructor.  Conversely, if @p errorId is not an existing
        SBML-level error code, callers can use other values for @p severity and
        @p category. @endif@~

        Please see the top of the documentation for SBMLError for a longer
        discussion of the possible error codes, their meanings, and their
        applicability to different combinations of Level+Version of SBML.

        @param errorId a long integer, the identification number of the error.

        @param level the SBML Level of the SBML model

        @param version the SBML Version within the Level of the SBML model

        @param details a string containing additional details about the error.
        If the error code in @p errorId is one that is recognized by SBMLError,
        the given message is @em appended to a predefined message associated
        with the given code.  If the error code is not recognized, the message
        is stored as-is as the text of the error.

        @param line a long integer, the line number at which the error occured.

        @param column a long integer, the column number at which the error occured.

        @param severity an integer indicating severity of the error.

        @param category an integer indicating the category to which the error
        belongs.

        @param package the SBML Level package involved.

        @param pkgVersion the version of the @p package.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_SBMLError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLError
    __del__ = lambda self : None;
SBMLError_swigregister = _libsbml.SBMLError_swigregister
SBMLError_swigregister(SBMLError)

MODEL_QUALIFIER = _libsbml.MODEL_QUALIFIER
BIOLOGICAL_QUALIFIER = _libsbml.BIOLOGICAL_QUALIFIER
UNKNOWN_QUALIFIER = _libsbml.UNKNOWN_QUALIFIER
BQM_IS = _libsbml.BQM_IS
BQM_IS_DESCRIBED_BY = _libsbml.BQM_IS_DESCRIBED_BY
BQM_IS_DERIVED_FROM = _libsbml.BQM_IS_DERIVED_FROM
BQM_UNKNOWN = _libsbml.BQM_UNKNOWN
BQB_IS = _libsbml.BQB_IS
BQB_HAS_PART = _libsbml.BQB_HAS_PART
BQB_IS_PART_OF = _libsbml.BQB_IS_PART_OF
BQB_IS_VERSION_OF = _libsbml.BQB_IS_VERSION_OF
BQB_HAS_VERSION = _libsbml.BQB_HAS_VERSION
BQB_IS_HOMOLOG_TO = _libsbml.BQB_IS_HOMOLOG_TO
BQB_IS_DESCRIBED_BY = _libsbml.BQB_IS_DESCRIBED_BY
BQB_IS_ENCODED_BY = _libsbml.BQB_IS_ENCODED_BY
BQB_ENCODES = _libsbml.BQB_ENCODES
BQB_OCCURS_IN = _libsbml.BQB_OCCURS_IN
BQB_HAS_PROPERTY = _libsbml.BQB_HAS_PROPERTY
BQB_IS_PROPERTY_OF = _libsbml.BQB_IS_PROPERTY_OF
BQB_UNKNOWN = _libsbml.BQB_UNKNOWN
class CVTerm(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A MIRIAM-compliant controlled vocabulary term.

    @htmlinclude not-sbml-warning.html

    The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple
    format for annotating models when (a) referring to controlled vocabulary
    terms and database identifiers that define and describe biological and
    biochemical entities, and (b) describing the creator of a model and the
    model's modification history.  This SBML format is a concrete syntax that
    conforms to the guidelines of MIRIAM (<a target='_blank'
    href='http://www.nature.com/nbt/journal/v23/n12/abs/nbt1156.html'>'Minimum
    Information Requested in the Annotation of biochemical Models'</a>,
    <i>Nature Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  The format uses
    a subset of W3C RDF (<a target='_blank'
    href='http://www.w3.org/RDF/'>Resource Description Format</a>).  In order
    to help application developers work with annotations in this format,
    libSBML provides several helper classes that provide higher-level
    interfaces to the data elements; these classes include CVTerm,
    ModelCreator, ModelHistory, RDFAnnotationParser, and Date.

    @section annotation-parts Components of an SBML annotation

    The SBML annotation format consists of RDF-based content placed inside
    an <code>&lt;annotation&gt;</code> element attached to an SBML component
    such as Species, Compartment, etc.  The following template illustrates
    the different parts of SBML annotations in XML form:

     <pre class='fragment'>
     &lt;<span style='background-color: #bbb'>SBML_ELEMENT</span> <span style='background-color: #d0eed0'>+++</span> metaid=&quot;<span style='border-bottom: 1px solid black'>meta id</span>&quot; <span style='background-color: #d0eed0'>+++</span>&gt;
       <span style='background-color: #d0eed0'>+++</span>
       &lt;annotation&gt;
         <span style='background-color: #d0eed0'>+++</span>
         &lt;rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
                  xmlns:dc='http://purl.org/dc/elements/1.1/'
                  xmlns:dcterm='http://purl.org/dc/terms/'
                  xmlns:vcard='http://www.w3.org/2001/vcard-rdf/3.0#'
                  xmlns:bqbiol='http://biomodels.net/biology-qualifiers/'
                  xmlns:bqmodel='http://biomodels.net/model-qualifiers/' &gt;
           &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
             <span style='background-color: #e0e0e0; border-bottom: 2px dotted #888'>HISTORY</span>
             &lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
               &lt;rdf:Bag&gt;
                 &lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>URI</span>&quot; /&gt;
                 <span style='background-color: #edd'>...</span>
               &lt;/rdf:Bag&gt;
             &lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
             <span style='background-color: #edd'>...</span>
           &lt;/rdf:Description&gt;
           <span style='background-color: #d0eed0'>+++</span>
         &lt;/rdf:RDF&gt;
         <span style='background-color: #d0eed0'>+++</span>
       &lt;/annotation&gt;
       <span style='background-color: #d0eed0'>+++</span>
     &lt;/<span style='background-color: #bbb'>SBML_ELEMENT</span>&gt;
     </pre>

    In the template above, the placeholder
    <span class='code' style='background-color: #bbb'>SBML_ELEMENT</span> stands for
    the XML tag name of an SBML model component (e.g., <code>model</code>,
    <code>reaction</code>, etc.) and the placeholder 
    <span class='code' style='border-bottom: 1px solid black'>meta id</span>
    stands for the element's meta identifier, which is a field available
    on all SBML components derived from the SBase base object class.
    The <span style='border-bottom: 2px dotted #888'>dotted</span>
    portions are optional, the symbol
    <span class='code' style='background-color: #d0eed0'>+++</span> is a placeholder
    for either no content or valid XML content that is not defined by
    this annotation scheme, and the ellipses
    <span class='code' style='background-color: #edd'>...</span>
    are placeholders for zero or more elements of the same form as the
    immediately preceding element.  The optional content
    <span class='code' style='background-color: #e0e0e0; border-bottom: 2px dotted #888'>HISTORY</span>
    is a creation and modification history; in libSBML, this is stored
    using ModelHistory objects.

    The placeholder <span class='code' style='background-color:
    #bbb'>RELATION_ELEMENT</span> refers to a BioModels.net qualifier element
    name.  This is an element in either the XML namespace
    <code>'http://biomodels.net/model-qualifiers'</code> (for model
    qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code> (for
    biological qualifier).  Note that these namespace URIs are only labels,
    and not actual Web locations, which means you cannot visit an address such
    as <code>'http://biomodels.net/model-qualifiers'</code> in your browser or
    try to have your application access it.  @if Refer instead to the enumerations
    #ModelQualifierType_t and #BiolQualifierType_t for a list of the available
    relationship elements that can be used for <span class='code'
    style='background-color: #bbb'>RELATION_ELEMENT</span>.@endif@~

    The <span class='code' style='background-color: #d0d0ee'>URI</span> is a
    required data value that uniquely identifies a resource and data within
    that resource to which the annotation refers.  Again, being URIs, these do
    not refer to physical Web locations; nevertheless, applications will often
    want a means of finding the resource to which a given <span class='code'
    style='background-color: #d0d0ee'>URI</span> refers.  Providing the
    facilities for this task is the purpose of MIRIAM Resources, described in
    detail online at <a target='_blank'
    href='http://biomodels.net/miriam'>http://biomodels.net/miriam</a>) and
    also in the paper <a target='_blank'
    href='http://www.biomedcentral.com/1752-0509/1/58'>'MIRIAM Resources: tools to generate and
    resolve robust cross-references in Systems Biology'</a>, <i>BMC Systems
    Biology</i>, 58(1), 2007.

    The relation-resource pairs above are the 'controlled vocabulary' terms
    that which CVTerm is designed to store and manipulate.  The next section
    describes these parts in more detail.  For more information about
    SBML annotations in general, please refer to Section&nbsp;6 in the
    SBML Level&nbsp;2 (Versions 2&ndash;4) or Level&nbsp;3 specification
    documents.


    @section cvterm-parts The parts of a CVTerm

    Annotations that refer to controlled vocabularies are managed in libSBML
    using CVTerm objects.  A set of RDF-based annotations attached to a
    given SBML <code>&lt;annotation&gt;</code> element are read by
    RDFAnnotationParser and converted into a list of these CVTerm objects.
    Each CVTerm object instance stores the following components of an
    annotation:

    <ul>

    <li>The @em qualifier, which can be a BioModels.net 'biological
    qualifier', a BioModels.net 'model qualifier', or an unknown qualifier
    (as far as the CVTerm class is concerned).  Qualifiers are used in
    MIRIAM to indicate the nature of the relationship between the object
    being annotated and the resource.  In CVTerm, the qualifiers can be
    manipulated using the methods CVTerm.getQualifierType(),
    CVTerm.setQualifierType(), and related methods.

    <li>The @em resource, represented by a URI (which, we must remind
    developers, is not the same as a URL).  In the CVTerm class, the
    resource component can be manipulated using the methods
    CVTerm.addResource() and
    CVTerm.removeResource().

    </ul>

    Note that a CVTerm contains a single qualifier, but possibly more than
    one resource.  This corresponds to the possibility of an annotation that
    points to multiple resources, all of which are qualified by the same
    BioModels.net qualifier.  The CVTerm object class supports this by
    supporting a list of resources.

    Detailed explanations of the qualifiers defined by BioModels.net can be
    found at <a target='_blank'
    href='http://biomodels.net/qualifiers'>http://biomodels.net/qualifiers</a>.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CVTerm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CVTerm, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_CVTerm
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, QualifierType_t type = UNKNOWN_QUALIFIER) -> CVTerm
        __init__(self) -> CVTerm
        __init__(self, XMLNode node) -> CVTerm
        __init__(self, CVTerm orig) -> CVTerm

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>CVTerm(CVTerm orig)</pre>

        Copy constructor; creates a copy of a CVTerm object.

        @param orig the CVTerm instance to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>CVTerm(const XMLNode node)</pre>

        Creates a new CVTerm from the given XMLNode.

        @par
        The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple
        format for annotating models when (a) referring to controlled
        vocabulary terms and database identifiers that define and describe
        biological and other entities, and (b) describing the creator of a
        model and the model's modification history.  The annotation content is
        stored in <code>&lt;annotation&gt;</code> elements attached to
        individual SBML elements.  The format for storing the content inside
        SBML <code>&lt;annotation&gt;</code> elements is a subset of W3C RDF
        (<a target='_blank' href='http://www.w3.org/RDF/'>Resource Description
        Format</a>) expressed in XML.  The CVTerm class provides a programming
        interface for working directly with controlled vocabulary term ('CV
        term') objects without having to deal directly with the XML form.
        When libSBML reads in an SBML model containing RDF annotations, it
        parses those annotations into a list of CVTerm objects, and when
        writing a model, it parses the CVTerm objects back into the
        appropriate SBML <code>&lt;annotation&gt;</code> structure. 

        This method creates a CVTerm object from the given XMLNode object @p
        node.  XMLNode is libSBML's representation of a node in an XML tree of
        elements, and each such element can be placed in a namespace.  This
        constructor looks for the element to be in the XML namespaces
        <code>'http://biomodels.net/model-qualifiers'</code> (for
        model qualifiers) and
        <code>'http://biomodels.net/biology-qualifiers'</code> (for
        biological qualifier), and if they are, creates CVTerm objects for
        the result.

        @param node an %XMLNode representing a CVTerm.

        @note This method assumes that the given XMLNode object @p node is of
        the correct structural form.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>CVTerm(QualifierType_t type = UNKNOWN_QUALIFIER)</pre>

        Creates an empty CVTerm, optionally with the given
        @if clike #QualifierType_t value@else qualifier@endif@~ @p type.

        @par
        The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple
        format for annotating models when (a) referring to controlled
        vocabulary terms and database identifiers that define and describe
        biological and other entities, and (b) describing the creator of a
        model and the model's modification history.  The annotation content is
        stored in <code>&lt;annotation&gt;</code> elements attached to
        individual SBML elements.  The format for storing the content inside
        SBML <code>&lt;annotation&gt;</code> elements is a subset of W3C RDF
        (<a target='_blank' href='http://www.w3.org/RDF/'>Resource Description
        Format</a>) expressed in XML.  The CVTerm class provides a programming
        interface for working directly with controlled vocabulary term ('CV
        term') objects without having to deal directly with the XML form.
        When libSBML reads in an SBML model containing RDF annotations, it
        parses those annotations into a list of CVTerm objects, and when
        writing a model, it parses the CVTerm objects back into the
        appropriate SBML <code>&lt;annotation&gt;</code> structure. 

        This method creates an empty CVTerm object.  The possible qualifier
        types usable as values of @p type are @link libsbml#MODEL_QUALIFIER MODEL_QUALIFIER@endlink and @link libsbml#BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink.  If
        an explicit value for @p type is not given, this method defaults to
        using @link libsbml#UNKNOWN_QUALIFIER UNKNOWN_QUALIFIER@endlink.  The @if clike #QualifierType_t value@else qualifier type@endif@~ 
        can be set later using the
        CVTerm.setQualifierType() method.

        Different BioModels.net qualifier elements encode different types of
        relationships.  Please refer to the SBML specification or the <a
        target='_blank' href='http://biomodels.net/qualifiers/'>BioModels.net
        qualifiers web page</a> for an explanation of the meaning of these
        different qualifiers.

        @param type a @if clike #QualifierType_t value@else qualifier type@endif@~

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_CVTerm(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> CVTerm

        Creates and returns a deep copy of this CVTerm object.

        @return the (deep) copy of this CVTerm object.

        """
        return _libsbml.CVTerm_clone(self)

    def getQualifierType(self):
        """
        getQualifierType(self) -> QualifierType_t

        Returns the qualifier type of this CVTerm object.

        @par
        The RDF element used in the SBML format for referring to external entities
        is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element inside of it containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  The following template illustrates
        the structure:
        <pre class='fragment'>
        &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
        &nbsp;&nbsp;<span style='background-color: #ddd; border-bottom: 2px dotted #888'>HISTORY</span>
        &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;
        &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &lt;/rdf:Description&gt;
        </pre>
        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code' style='background-color:
        #edd'>...</span> are placeholders for zero or more elements of the same
        form as the immediately preceding element.

        The placeholder <span class='code' style='background-color: #bbb'>
        RELATION_ELEMENT</span> refers to a BioModels.net qualifier
        element name.  This is an element in either the XML namespace
        <code>'http://biomodels.net/model-qualifiers'</code> (for model
        qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>
        (for biological qualifier).  The present method returns a code
        identifying which one of these two relationship namespaces is being
        used; any other qualifier in libSBML is considered unknown (as far as
        the CVTerm class is concerned).  Consequently, this method will return
        one of the following values:

        @li @link libsbml#MODEL_QUALIFIER MODEL_QUALIFIER@endlink
        @li @link libsbml#BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink
        @li @link libsbml#UNKNOWN_QUALIFIER UNKNOWN_QUALIFIER@endlink

        The specific relationship of this CVTerm to the enclosing SBML object
        can be determined using the CVTerm methods such as
        getModelQualifierType() and getBiologicalQualifierType().  Callers
        will typically want to use the present method to find out which one of
        the @em other two methods to call to find out the specific
        relationship.

        @return the @if clike #QualifierType_t value@else qualifier type@endif@~
        of this object or @link libsbml#UNKNOWN_QUALIFIER UNKNOWN_QUALIFIER@endlink
        (the default).

        @see getResources()
        @see getModelQualifierType()
        @see getBiologicalQualifierType()

        """
        return _libsbml.CVTerm_getQualifierType(self)

    def getModelQualifierType(self):
        """
        getModelQualifierType(self) -> ModelQualifierType_t

        Returns the model qualifier type of this CVTerm object.

        @par
        The RDF element used in the SBML format for referring to external entities
        is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element inside of it containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  The following template illustrates
        the structure:
        <pre class='fragment'>
        &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
        &nbsp;&nbsp;<span style='background-color: #ddd; border-bottom: 2px dotted #888'>HISTORY</span>
        &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;
        &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &lt;/rdf:Description&gt;
        </pre>
        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code' style='background-color:
        #edd'>...</span> are placeholders for zero or more elements of the same
        form as the immediately preceding element.

        The placeholder <span class='code' style='background-color: #bbb'>
        RELATION_ELEMENT</span> refers to a BioModels.net qualifier
        element name.  This is an element in either the XML namespace
        <code>'http://biomodels.net/model-qualifiers'</code> (for model
        qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>
        (for biological qualifier).  Callers will typically use
        getQualifierType() to find out the type of qualifier relevant to this
        particular CVTerm object, then if it is a @em model qualifier, use the
        present method to determine the specific qualifier.

        Annotations with model qualifiers express a relationship between an
        annotation resource and the <em>modeling concept</em> represented by a
        given object in the model.  The diagram below illustrates the
        relationship in this case:

        @image html model-qualifiers.png 'Relationship expressed by model qualifiers'
        @image latex model-qualifiers.png 'Relationship expressed by model qualifiers'

        <br> The set of known model qualifiers is, at the time of this libSBML
        release, the following:

        @li @link libsbml#BQM_IS BQM_IS@endlink
        @li @link libsbml#BQM_IS_DESCRIBED_BY BQM_IS_DESCRIBED_BY@endlink
        @li @link libsbml#BQM_IS_DERIVED_FROM BQM_IS_DERIVED_FROM@endlink

        Any other BioModels.net qualifier found in the model is considered
        unknown by libSBML and reported as
        @link libsbml#BQM_UNKNOWN BQM_UNKNOWN@endlink.

        @return the @if clike #ModelQualifierType_t value@else model qualifier type@endif@~
        of this object or @link libsbml#BQM_UNKNOWN BQM_UNKNOWN@endlink
        (the default).

        """
        return _libsbml.CVTerm_getModelQualifierType(self)

    def getBiologicalQualifierType(self):
        """
        getBiologicalQualifierType(self) -> BiolQualifierType_t

        Returns the biological qualifier type of this CVTerm object.

        @par
        The RDF element used in the SBML format for referring to external entities
        is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element inside of it containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  The following template illustrates
        the structure:
        <pre class='fragment'>
        &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
        &nbsp;&nbsp;<span style='background-color: #ddd; border-bottom: 2px dotted #888'>HISTORY</span>
        &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;
        &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &lt;/rdf:Description&gt;
        </pre>
        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code' style='background-color:
        #edd'>...</span> are placeholders for zero or more elements of the same
        form as the immediately preceding element.

        The placeholder <span class='code' style='background-color: #bbb'>
        RELATION_ELEMENT</span> refers to a BioModels.net qualifier
        element name.  This is an element in either the XML namespace
        <code>'http://biomodels.net/model-qualifiers'</code> (for model
        qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>
        (for biological qualifier).  Callers will typically use
        getQualifierType() to find out the type of qualifier relevant to this
        particular CVTerm object, then if it is a @em biological qualifier,
        use the present method to determine the specific qualifier.

        Annotations with biological qualifiers express a relationship between an
        annotation resource and the <em>biological concept</em> represented by a
        given object in the model.    The diagram
        below illustrates the relationship in this case:

        @image html biology-qualifiers.png 'Relationship expressed by biological qualifiers'
        @image latex biology-qualifiers.png 'Relationship expressed by biological qualifiers'

        <br> The set of known biological qualifiers is, at the time of this
        libSBML release, the following:

        @li @link libsbml#BQB_IS BQB_IS@endlink
        @li @link libsbml#BQB_HAS_PART BQB_HAS_PART@endlink
        @li @link libsbml#BQB_IS_PART_OF BQB_IS_PART_OF@endlink
        @li @link libsbml#BQB_IS_VERSION_OF BQB_IS_VERSION_OF@endlink
        @li @link libsbml#BQB_HAS_VERSION BQB_HAS_VERSION@endlink
        @li @link libsbml#BQB_IS_HOMOLOG_TO BQB_IS_HOMOLOG_TO@endlink
        @li @link libsbml#BQB_IS_DESCRIBED_BY BQB_IS_DESCRIBED_BY@endlink
        @li @link libsbml#BQB_IS_ENCODED_BY BQB_IS_ENCODED_BY@endlink
        @li @link libsbml#BQB_ENCODES BQB_ENCODES@endlink
        @li @link libsbml#BQB_OCCURS_IN BQB_OCCURS_IN@endlink
        @li @link libsbml#BQB_HAS_PROPERTY BQB_HAS_PROPERTY@endlink
        @li @link libsbml#BQB_IS_PROPERTY_OF BQB_IS_PROPERTY_OF@endlink

        Any other BioModels.net qualifier found in the model is considered
        unknown by libSBML and reported as
        @link libsbml#BQB_UNKNOWN BQB_UNKNOWN@endlink.

        @return the @if clike #BiolQualifierType_t value@else biology qualifier type@endif@~
        of this object or @link libsbml#BQB_UNKNOWN BQB_UNKNOWN@endlink
        (the default).

        """
        return _libsbml.CVTerm_getBiologicalQualifierType(self)

    def getResources(self, *args):
        """
        getResources(self) -> XMLAttributes
        getResources(self) -> XMLAttributes

        Returns the resource references for this CVTerm object.

        @par
        The RDF element used in the SBML format for referring to external entities
        is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element inside of it containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  The following template illustrates
        the structure:
        <pre class='fragment'>
        &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
        &nbsp;&nbsp;<span style='background-color: #ddd; border-bottom: 2px dotted #888'>HISTORY</span>
        &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;
        &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &lt;/rdf:Description&gt;
        </pre>
        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code' style='background-color:
        #edd'>...</span> are placeholders for zero or more elements of the same
        form as the immediately preceding element.

        The <span class='code' style='background-color: #d0d0ee'>resource
        URI</span> values shown in the template above are stored internally in
        CVTerm objects using an XMLAttributes object.  Each attribute stored
        inside the XMLAttributes will have the same name (specifically,
        &quot;<code>rdf:resource</code>&quot;) but a different value, and the
        value will be a <span class='code' style='background-color: #d0d0ee'>
        resource URI</span> shown in the XML template above.

        A valid CVTerm entity must always have at least one resource and
        a value for the relationship qualifier.

        @return the XMLAttributes that store the resources of this CVTerm.

        @see getQualifierType()
        @see addResource()
        @see getResourceURI()

        """
        return _libsbml.CVTerm_getResources(self, *args)

    def getNumResources(self):
        """
        getNumResources(self) -> unsigned int

        Returns the number of resources for this CVTerm object.

        @par
        The RDF element used in the SBML format for referring to external entities
        is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element inside of it containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  The following template illustrates
        the structure:
        <pre class='fragment'>
        &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
        &nbsp;&nbsp;<span style='background-color: #ddd; border-bottom: 2px dotted #888'>HISTORY</span>
        &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;
        &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &lt;/rdf:Description&gt;
        </pre>
        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code' style='background-color:
        #edd'>...</span> are placeholders for zero or more elements of the same
        form as the immediately preceding element.

        The fragment above illustrates that there can be more than one
        resource referenced by a given relationship annotation (i.e., the
        <span class='code' style='background-color: #d0d0ee'>resource
        URI</span> values associated with a particular <span class='code'
        style='background-color: #bbb'>RELATION_ELEMENT</span>).  The present
        method returns a count of the resources stored in this CVTerm object.

        @return the number of resources in the set of XMLAttributes
        of this CVTerm.

        @see getResources()
        @see getResourceURI()

        """
        return _libsbml.CVTerm_getNumResources(self)

    def getResourceURI(self, *args):
        """
        getResourceURI(self, unsigned int n) -> string

        Returns the value of the <em>n</em>th resource for this CVTerm object.

        @par
        The RDF element used in the SBML format for referring to external entities
        is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element inside of it containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  The following template illustrates
        the structure:
        <pre class='fragment'>
        &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
        &nbsp;&nbsp;<span style='background-color: #ddd; border-bottom: 2px dotted #888'>HISTORY</span>
        &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
        &nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;
        &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
        &nbsp;&nbsp;<span style='background-color: #edd'>...</span>
        &lt;/rdf:Description&gt;
        </pre>
        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code' style='background-color:
        #edd'>...</span> are placeholders for zero or more elements of the same
        form as the immediately preceding element.

        The fragment above illustrates that there can be more than one
        resource referenced by a given relationship annotation (i.e., the
        <span class='code' style='background-color: #d0d0ee'>resource
        URI</span> values associated with a particular <span class='code'
        style='background-color: #bbb'>RELATION_ELEMENT</span>).  LibSBML
        stores all resource URIs in a single CVTerm object for a given
        relationship.  Callers can use getNumResources() to find out how many
        resources are stored in this CVTerm object, then call this method to
        retrieve the <em>n</em>th resource URI.

        @param n the index of the resource to query

        @return string representing the value of the nth resource
        in the set of XMLAttributes of this CVTerm.

        @see getNumResources()
        @see getQualifierType()

        """
        return _libsbml.CVTerm_getResourceURI(self, *args)

    def setQualifierType(self, *args):
        """
        setQualifierType(self, QualifierType_t type) -> int

        Sets the @if clike #QualifierType_t@else qualifier code@endif@~ of this
        CVTerm object.

        @param type the @if clike #QualifierType_t value@else qualifier type@endif.
        The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see getQualifierType()

        """
        return _libsbml.CVTerm_setQualifierType(self, *args)

    def setModelQualifierType(self, *args):
        """
        setModelQualifierType(self, ModelQualifierType_t type) -> int
        setModelQualifierType(self, string qualifier) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setModelQualifierType(string qualifier)</pre>

        Sets the @if clike #ModelQualifierType_t@endif@if java model qualifier type code@endif@~ value of this CVTerm object.

        @param qualifier the string representing a model qualifier

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note If the Qualifier Type of this object is not
        @link libsbml#MODEL_QUALIFIER MODEL_QUALIFIER@endlink, 
        then the ModelQualifierType_t value will default to
        @link libsbml#BQM_UNKNOWN BQM_UNKNOWN@endlink.

        @see getQualifierType()
        @see setQualifierType()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setModelQualifierType(ModelQualifierType_t type)</pre>

        Sets the @if clike #ModelQualifierType_t value@else model qualifier type@endif@~
        of this CVTerm object.

        @param type the @if clike #ModelQualifierType_t value@else model qualifier type@endif@~

        @return integer value indicating success/failure of the
        function. The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note If the Qualifier Type of this object is not
        @link libsbml#MODEL_QUALIFIER MODEL_QUALIFIER@endlink, 
        then the ModelQualifierType_t value will default to
        @link libsbml#BQM_UNKNOWN BQM_UNKNOWN@endlink.

        @see getQualifierType()
        @see setQualifierType()

        """
        return _libsbml.CVTerm_setModelQualifierType(self, *args)

    def setBiologicalQualifierType(self, *args):
        """
        setBiologicalQualifierType(self, BiolQualifierType_t type) -> int
        setBiologicalQualifierType(self, string qualifier) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setBiologicalQualifierType(string qualifier)</pre>

        Sets the @if clike #BiolQualifierType_t@endif@if java biology qualifier
        type code@endif@~ of this CVTerm object.

        @param qualifier the string representing a biology qualifier

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note If the Qualifier Type of this object is not
        @link libsbml#BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink,
        then the @if clike #BiolQualifierType_t@endif@if java biology qualifier type code@endif@~ value will default
        to @link libsbml#BQB_UNKNOWN BQB_UNKNOWN@endlink.

        @see getQualifierType()
        @see setQualifierType()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setBiologicalQualifierType(BiolQualifierType_t type)</pre>

        Sets the @if clike #BiolQualifierType_t value@else biology qualifier type@endif@~
        of this CVTerm object.

        @param type the @if clike #BiolQualifierType_t value@else biology qualifier type@endif.

        @return integer value indicating success/failure of the
        function. The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note If the Qualifier Type of this object is not
        @link libsbml#BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink,
        then the @if clike #BiolQualifierType_t value@else biology qualifier type@endif@~ will default
        to @link libsbml#BQB_UNKNOWN BQB_UNKNOWN@endlink.

        @see getQualifierType()
        @see setQualifierType()

        """
        return _libsbml.CVTerm_setBiologicalQualifierType(self, *args)

    def addResource(self, *args):
        """
        addResource(self, string resource) -> int

        Adds a resource reference to this CVTerm object.

        @par
        The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple
        format for annotating models when (a) referring to controlled
        vocabulary terms and database identifiers that define and describe
        biological and other entities, and (b) describing the creator of a
        model and the model's modification history.  The annotation content is
        stored in <code>&lt;annotation&gt;</code> elements attached to
        individual SBML elements.  The format for storing the content inside
        SBML <code>&lt;annotation&gt;</code> elements is a subset of W3C RDF
        (<a target='_blank' href='http://www.w3.org/RDF/'>Resource Description
        Format</a>) expressed in XML.  The CVTerm class provides a programming
        interface for working directly with controlled vocabulary term ('CV
        term') objects without having to deal directly with the XML form.
        When libSBML reads in an SBML model containing RDF annotations, it
        parses those annotations into a list of CVTerm objects, and when
        writing a model, it parses the CVTerm objects back into the
        appropriate SBML <code>&lt;annotation&gt;</code> structure. 

        The specific RDF element used in this SBML format for referring to
        external entities is <code>&lt;rdf:Description&gt;</code>, with a
        <code>&lt;rdf:Bag&gt;</code> element containing one or more
        <code>&lt;rdf:li&gt;</code> elements.  Each such element refers to a
        data item in an external resource; the resource and data item are
        together identified uniquely using a URI.  The following template
        illustrates the structure:

           <pre class='fragment'>
           &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;
             <span style='background-color: #e0e0e0; border-bottom: 2px dotted #888'>HISTORY</span>
             &lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
               &lt;rdf:Bag&gt;
                 &lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;
                 <span style='background-color: #edd'>...</span>
               &lt;/rdf:Bag&gt;
             &lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;
             <span style='background-color: #edd'>...</span>
           &lt;/rdf:Description&gt;
           </pre>

        In the template above, the placeholder <span class='code'
        style='border-bottom: 1px solid black'>meta id</span> stands for the
        element's meta identifier, which is a field available on all SBML
        components derived from the SBase base object class.  The <span
        style='border-bottom: 2px dotted #888'>dotted</span> portions are
        optional, and the ellipses <span class='code'
        style='background-color: #edd'>...</span> are placeholders for zero or
        more elements of the same form as the immediately preceding element.
        The placeholder <span class='code' style='background-color: #bbb'>
        RELATION_ELEMENT</span> refers to a BioModels.net qualifier element
        name.  This is an element in either the XML namespace
        <code>'http://biomodels.net/model-qualifiers'</code> (for model
        qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>
        (for biological qualifier).

        The <span class='code' style='background-color: #d0d0ee'>resource
        URI</span> is a required data value that uniquely identifies a
        resource and data within that resource to which the annotation refers.
        The present method allows callers to add a reference to a resource URI
        with the same relationship to the enclosing SBML object.  (In other
        words, the argument to this method is a <span class='code'
        style='background-color: #d0d0ee'>resource URI</span> as shown in the
        XML fragment above.)  Resources are stored in this CVTerm object
        within an XMLAttributes object.

        The relationship of this CVTerm to the enclosing SBML object can be
        determined using the CVTerm methods such as getModelQualifierType()
        and getBiologicalQualifierType().

        @param resource a string representing the URI of the resource and data
        item being referenced; e.g.,
        <code>'http://www.geneontology.org/#GO:0005892'</code>.

        @return integer value indicating success/failure of the call. The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see getResources()
        @see removeResource()
        @see getQualifierType()
        @see getModelQualifierType()
        @see getBiologicalQualifierType()

        """
        return _libsbml.CVTerm_addResource(self, *args)

    def removeResource(self, *args):
        """
        removeResource(self, string resource) -> int

        Removes a resource URI from the set of resources stored in this CVTerm
        object.

        @param resource a string representing the resource URI to remove;
        e.g., <code>'http://www.geneontology.org/#GO:0005892'</code>.

        @return integer value indicating success/failure of the
        function. The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @see addResource()

        """
        return _libsbml.CVTerm_removeResource(self, *args)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required elements for this
        CVTerm object have been set.

        @note The required attributes for a CVTerm are:
        @li a <em>qualifier type</em>, which can be either a model qualifier or a biological qualifier
        @li at least one resource

        """
        return _libsbml.CVTerm_hasRequiredAttributes(self)

    def hasBeenModified(self):
        """
        hasBeenModified(self) -> bool

        @internal

        @internal

        """
        return _libsbml.CVTerm_hasBeenModified(self)

    def resetModifiedFlags(self):
        """
        resetModifiedFlags(self)

        @internal

        @internal

        """
        return _libsbml.CVTerm_resetModifiedFlags(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

CVTerm_swigregister = _libsbml.CVTerm_swigregister
CVTerm_swigregister(CVTerm)

class Date(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A MIRIAM-compliant date representation.

    @htmlinclude not-sbml-warning.html

    A Date object stores a reasonably complete representation of date and
    time.  Its purpose is to serve as a way to store dates to be read and
    written in the <a target='_blank'
    href='http://www.w3.org/TR/NOTE-datetime'>W3C date format</a> used in
    RDF Dublin Core annotations within SBML.  The W3C date format is a
    restricted form of <a target='_blank'
    href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601</a>, the
    international standard for the representation of dates and times.  A
    time and date value in this W3C format takes the form
    YYYY-MM-DDThh:mm:ssXHH:ZZ (e.g., <code>1997-07-16T19:20:30+01:00</code>)
    where XHH:ZZ is the time zone offset.  The libSBML Date object contains
    the following fields to represent these values:

    @li @em year: a long integer representing the year.  This should be a
    four-digit number such as @c 2011.

    @li @em month: a long integer representing the month, with a range of
    values of 1&ndash;12.  The value @c 1 represents January, and so on.

    @li @em day: a long integer representing the day of the month, with a
    range of values of 1&ndash;31.

    @li @em hour: a long integer representing the hour on a 24-hour clock,
    with a range of values of 0&ndash;23.

    @li @em minute: a long integer representing the minute, with a range
    of 0&ndash;59.

    @li @em second: a long integer representing the second, with a range
    of 0&ndash;59.

    @li @em sign: a long integer representing the sign of the offset (@c 0
    signifying @c + and @c 1 signifying @c -).  See the paragraph below for
    further explanations.

    @li @em hours offset: a long integer representing the time zone's hour
    offset from GMT.

    @li @em minute offset: a long integer representing the time zone's
    minute offset from GMT.

    To illustrate the time zone offset, a value of <code>-05:00</code> would
    correspond to USA Eastern Standard Time.  In the Date object, this would
    require a value of @c 1 for the sign field, @c 5 for the hour offset and
    @c 0 for the minutes offset.

    In the restricted RDF annotations used in SBML, described in
    Section&nbsp;6 of the SBML Level&nbsp;2 and Level&nbsp;3 specification
    documents, date/time stamps can be used to indicate the time of
    creation and modification of a model.  The following SBML model fragment
    illustrates this:
    @verbatim
    <model metaid='_180340' id='GMO' name='Goldbeter1991_MinMitOscil'>
        <annotation>
            <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
                     xmlns:dc='http://purl.org/dc/elements/1.1/'
                     xmlns:dcterms='http://purl.org/dc/terms/'
                     xmlns:vCard='http://www.w3.org/2001/vcard-rdf/3.0#' >
                <rdf:Description rdf:about='#_180340'>
                    <dc:creator>
                        <rdf:Bag>
                            <rdf:li rdf:parseType='Resource'>
                                <vCard:N rdf:parseType='Resource'>
                                    <vCard:Family>Shapiro</vCard:Family>
                                    <vCard:Given>Bruce</vCard:Given>
                                </vCard:N>
                                <vCard:EMAIL>bshapiro@jpl.nasa.gov</vCard:EMAIL>
                                <vCard:ORG rdf:parseType='Resource'>
                                    <vCard:Orgname>NASA Jet Propulsion Laboratory</vCard:Orgname>
                                </vCard:ORG>
                            </rdf:li>
                        </rdf:Bag>
                    </dc:creator>
                    <dcterms:created rdf:parseType='Resource'>
                        <dcterms:W3CDTF>2005-02-06T23:39:40+00:00</dcterms:W3CDTF>
                    </dcterms:created>
                    <dcterms:modified rdf:parseType='Resource'>
                        <dcterms:W3CDTF>2005-09-13T13:24:56+00:00</dcterms:W3CDTF>
                    </dcterms:modified>
                </rdf:Description>
            </rdf:RDF>
        </annotation>
    </model>
    @endverbatim

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Date, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Date, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_Date
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0, 
            unsigned int sign = 0, unsigned int hoursOffset = 0, 
            unsigned int minutesOffset = 0) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0, 
            unsigned int sign = 0, unsigned int hoursOffset = 0) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0, 
            unsigned int sign = 0) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0, 
            unsigned int second = 0) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0, unsigned int minute = 0) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, 
            unsigned int hour = 0) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1) -> Date
        __init__(self, unsigned int year = 2000, unsigned int month = 1) -> Date
        __init__(self, unsigned int year = 2000) -> Date
        __init__(self) -> Date
        __init__(self, string date) -> Date
        __init__(self, Date orig) -> Date

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Date(string date)</pre>

        Creates a Date object from a string expressing a date and time value.

        This constructor expects its argument to be in the <a target='_blank'
        href='http://www.w3.org/TR/NOTE-datetime'>W3C date format with time
        zone offset</a>, used in RDF Dublin Core annotations within SBML.

        @par
        The date format expresses a date and time value as a string of the form
        YYYY-MM-DDThh:mm:ssXHH:ZZ, where

        @li @em YYYY is a four-digit integer representing the year.  This
        should be a four-digit number such as @c 2011.

        @li @em MM is a two-digit integer representing the month, with a range
        of values of 01&ndash;12.  The value @c 1 represents January, and so
        on.

        @li @em DD is a two-digit integer representing the day of the month,
        with a range of values of 01&ndash;31.

        @li @em hh is a two-digit integer representing the hour on a 24-hour
        clock, with a range of values of 00&ndash;23.

        @li @em mm is a two-digit integer representing the minute, with a
        range of 00&ndash;59.

        @li @em ss is a two-digit integer representing the second, with a
        range of 0&ndash;59.

        @li @em X is the the sign of the time zone offset, either @c + or
        <code>-</code>.

        @li @em HH is a two-digit integer representing the hour of the time
        zone offset, with a range of 00&ndash;23.

        @li @em ZZ is a two-digit integer representing the minutes of the time
        zone offset, with a range of 00&ndash;59.

        In the string format above, it is important not to forget the literal
        character @c T in the string.  Here is an example date/time string:
        <code>1997-07-16T19:20:30+01:00</code>, which would represent July 16,
        1997, at 19:20:30 in Central European Time (which is UTC +1:00). 

        If this constructor is given a @c None argument or a string of length
        zero, it constructs a Date object with the value of January 1, 2000,
        at time 00:00 UTC.  Otherwise, the argument @em must be in the
        complete format described above, or unpredictable results will happen.

        @param date a string representing the date.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Date(long year = 2000, long month = 1, long day = 1, long hour = 0, long minute = 0, long second = 0, long sign = 0, long hoursOffset = 0, long minutesOffset = 0)</pre>

        Creates a time and date representation for use in model annotations
        and elsewhere.

        The following is the complete set of possible arguments to this
        constructor, with default values as indicated:

        @param year a long integereger representing the year.  This should be
        a four-digit number such as @c 2011.  (Default value used if this
        argument is not given: @c 2000.)

        @param month a long integereger representing the month, with a range
        of values of 1&ndash;12.  The value @c 1 represents January, and so
        on.  (Default value used if this argument is not given: @c 1.)

        @param day a long integereger representing the day of the month, with
        a range of values of 1&ndash;31.  (Default value used if this argument
        is not given: @c 1.)

        @param hour a long integereger representing the hour on a 24-hour
        clock, with a range of values of 0&ndash;23.  (Default value used if
        this argument is not given: @c 0.)

        @param minute a long integereger representing the minute, with a
        range of 0&ndash;59.  (Default value used if this argument is not
        given: @c 0.)

        @param second a long integereger representing the second, with a
        range of 0&ndash;59.  (Default value used if this argument is not
        given: @c 0.)

        @param sign a long integereger representing the sign of the offset
        (@c 0 signifying @c + and @c 1 signifying @c -).  See the paragraph
        below for further explanations.  (Default value used if this argument
        is not given: @c 0.)

        @param hoursOffset a long integereger representing the time zone's
        hour offset from GMT.  (Default value used if this argument is not
        given: @c 0.)

        @param minutesOffset a long integereger representing the time zone's
        minute offset from GMT.  (Default value used if this argument is not
        given: @c 0.)

        To illustrate the time zone offset, a value of <code>-05:00</code>
        would correspond to USA Eastern Standard Time.  In the Date object,
        this would require a value of @c 1 for the sign field, @c 5 for the
        hour offset and @c 0 for the minutes offset.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>Date(Date orig)</pre>

        Copy constructor; creates a copy of this Date.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_Date(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> Date

        Creates and returns a deep copy of this Date object.

        @return the (deep) copy of this Date object.

        """
        return _libsbml.Date_clone(self)

    def getYear(self):
        """
        getYear(self) -> unsigned int

        Returns the year from this Date.

        @return the year from this Date.

        """
        return _libsbml.Date_getYear(self)

    def getMonth(self):
        """
        getMonth(self) -> unsigned int

        Returns the month from this Date.

        @return the month from this Date.

        """
        return _libsbml.Date_getMonth(self)

    def getDay(self):
        """
        getDay(self) -> unsigned int

        Returns the day from this Date.

        @return the day from this Date.

        """
        return _libsbml.Date_getDay(self)

    def getHour(self):
        """
        getHour(self) -> unsigned int

        Returns the hour from this Date.

        @return the hour from this Date.

        """
        return _libsbml.Date_getHour(self)

    def getMinute(self):
        """
        getMinute(self) -> unsigned int

        Returns the minute from this Date.

        @return the minute from this Date.

        """
        return _libsbml.Date_getMinute(self)

    def getSecond(self):
        """
        getSecond(self) -> unsigned int

        Returns the seconds from this Date.

        @return the seconds from this Date.

        """
        return _libsbml.Date_getSecond(self)

    def getSignOffset(self):
        """
        getSignOffset(self) -> unsigned int

        Returns the sign of the time zone offset from this Date.

        @return the sign of the offset from this Date.

        """
        return _libsbml.Date_getSignOffset(self)

    def getHoursOffset(self):
        """
        getHoursOffset(self) -> unsigned int

        Returns the hours of the time zone offset from this Date.

        @return the hours of the offset from this Date.

        """
        return _libsbml.Date_getHoursOffset(self)

    def getMinutesOffset(self):
        """
        getMinutesOffset(self) -> unsigned int

        Returns the minutes of the time zone offset from this Date.

        @return the minutes of the offset from this Date.

        """
        return _libsbml.Date_getMinutesOffset(self)

    def getDateAsString(self):
        """
        getDateAsString(self) -> string

        Returns the current Date value in text-string form.

        The string returned will be in the <a target='_blank'
        href='http://www.w3.org/TR/NOTE-datetime'>W3C date format with time
        zone offset</a>, used in RDF Dublin Core annotations within SBML.

        @par
        The date format expresses a date and time value as a string of the form
        YYYY-MM-DDThh:mm:ssXHH:ZZ, where

        @li @em YYYY is a four-digit integer representing the year.  This
        should be a four-digit number such as @c 2011.

        @li @em MM is a two-digit integer representing the month, with a range
        of values of 01&ndash;12.  The value @c 1 represents January, and so
        on.

        @li @em DD is a two-digit integer representing the day of the month,
        with a range of values of 01&ndash;31.

        @li @em hh is a two-digit integer representing the hour on a 24-hour
        clock, with a range of values of 00&ndash;23.

        @li @em mm is a two-digit integer representing the minute, with a
        range of 00&ndash;59.

        @li @em ss is a two-digit integer representing the second, with a
        range of 0&ndash;59.

        @li @em X is the the sign of the time zone offset, either @c + or
        <code>-</code>.

        @li @em HH is a two-digit integer representing the hour of the time
        zone offset, with a range of 00&ndash;23.

        @li @em ZZ is a two-digit integer representing the minutes of the time
        zone offset, with a range of 00&ndash;59.

        In the string format above, it is important not to forget the literal
        character @c T in the string.  Here is an example date/time string:
        <code>1997-07-16T19:20:30+01:00</code>, which would represent July 16,
        1997, at 19:20:30 in Central European Time (which is UTC +1:00). 

        @return the date as a string.

        """
        return _libsbml.Date_getDateAsString(self)

    def setYear(self, *args):
        """
        setYear(self, unsigned int year) -> int

        Sets the value of the year of this Date object.

        The value given as argument must be between 1000 and 9999 inclusive.
        (In the millennium during which this libSBML documentation is being
        written, a typical value is @c 2011, but we hope that SBML will
        continue to be used for a long time.)

        @param year a long integer representing the year.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setYear(self, *args)

    def setMonth(self, *args):
        """
        setMonth(self, unsigned int month) -> int

        Sets the value of the month of this Date object.

        @param month a long integer representing the month; it must be in the
        range 1&ndash;12 or an error will be signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setMonth(self, *args)

    def setDay(self, *args):
        """
        setDay(self, unsigned int day) -> int

        Sets the value of the day of this Date object.

        @param day a long integer representing the day; it must be in the
        range 0&ndash;31 or an error will be signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setDay(self, *args)

    def setHour(self, *args):
        """
        setHour(self, unsigned int hour) -> int

        Sets the value of the hour of this Date object.

        @param hour a long integer representing the hour to set; it must be
        in the range 0&ndash;23 or an error will be signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setHour(self, *args)

    def setMinute(self, *args):
        """
        setMinute(self, unsigned int minute) -> int

        Sets the value of the minute of this Date object.

        @param minute a long integer representing the minute to set; it must
        be in the range 0&ndash;59 or an error will be signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setMinute(self, *args)

    def setSecond(self, *args):
        """
        setSecond(self, unsigned int second) -> int

        Sets the value of the second of the Date object.

        @param second a long integer representing the seconds; it must
        be in the range 0&ndash;59 or an error will be signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setSecond(self, *args)

    def setSignOffset(self, *args):
        """
        setSignOffset(self, unsigned int sign) -> int

        Sets the value of the sign of the time zone offset of this Date object.

        The only permissible values are @c 0 and @c 1.

        @param sign a long integer representing the sign of the offset, with
        @c 0 signifying @c + and @c 1 signifying @c -.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setSignOffset(self, *args)

    def setHoursOffset(self, *args):
        """
        setHoursOffset(self, unsigned int hoursOffset) -> int

        Sets the value of this Date object's time zone hour offset.

        @param hoursOffset a long integer representing the hours of the
        offset; it must be in the range 0&ndash;23 or an error will be
        signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setHoursOffset(self, *args)

    def setMinutesOffset(self, *args):
        """
        setMinutesOffset(self, unsigned int minutesOffset) -> int

        Sets the value of this Date object's time zone minutes offset.

        @param minutesOffset a long integer representing the minutes of the
        offset; it must be in the range 0&ndash;59 or an error will be
        signaled.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setMinutesOffset(self, *args)

    def setDateAsString(self, *args):
        """
        setDateAsString(self, string date) -> int

        Sets the value of this Date object using a date and time value
        expressed as a text string.

        This method expects its argument to be in the <a target='_blank'
        href='http://www.w3.org/TR/NOTE-datetime'>W3C date format with time
        zone offset</a>, used in RDF Dublin Core annotations within SBML.

        @par
        The date format expresses a date and time value as a string of the form
        YYYY-MM-DDThh:mm:ssXHH:ZZ, where

        @li @em YYYY is a four-digit integer representing the year.  This
        should be a four-digit number such as @c 2011.

        @li @em MM is a two-digit integer representing the month, with a range
        of values of 01&ndash;12.  The value @c 1 represents January, and so
        on.

        @li @em DD is a two-digit integer representing the day of the month,
        with a range of values of 01&ndash;31.

        @li @em hh is a two-digit integer representing the hour on a 24-hour
        clock, with a range of values of 00&ndash;23.

        @li @em mm is a two-digit integer representing the minute, with a
        range of 00&ndash;59.

        @li @em ss is a two-digit integer representing the second, with a
        range of 0&ndash;59.

        @li @em X is the the sign of the time zone offset, either @c + or
        <code>-</code>.

        @li @em HH is a two-digit integer representing the hour of the time
        zone offset, with a range of 00&ndash;23.

        @li @em ZZ is a two-digit integer representing the minutes of the time
        zone offset, with a range of 00&ndash;59.

        In the string format above, it is important not to forget the literal
        character @c T in the string.  Here is an example date/time string:
        <code>1997-07-16T19:20:30+01:00</code>, which would represent July 16,
        1997, at 19:20:30 in Central European Time (which is UTC +1:00). 

        If this method is given a @c None argument or a string of length zero,
        it constructs a Date object with the value of January 1, 2000, at time
        00:00 UTC.  Otherwise, the argument @em must be in the complete format
        described above, or unpredictable results will happen.

        @param date a string representing the date.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.Date_setDateAsString(self, *args)

    def representsValidDate(self):
        """
        representsValidDate(self) -> bool

        Returns true or false depending on whether this date object represents
        a valid date and time value.

        This method verifies that the date/time value stored in this object is
        well-formed and represents plausible values.  A time and date value in
        the W3C format takes the form YYYY-MM-DDThh:mm:ssXHH:ZZ (e.g.,
        <code>1997-07-16T19:20:30+01:00</code>) where XHH:ZZ is the time zone
        offset.  This method checks such things as whether the value of the
        month number is less than or equal to 12, whether the value of the
        minutes number is less than or equal to 59, whether a time zone offset
        is set, etc.

        @return @c True if the date is valid, @c False otherwise.

        """
        return _libsbml.Date_representsValidDate(self)

    def hasBeenModified(self):
        """
        hasBeenModified(self) -> bool

        @internal

        @internal

        """
        return _libsbml.Date_hasBeenModified(self)

    def resetModifiedFlags(self):
        """
        resetModifiedFlags(self)

        @internal

        @internal

        """
        return _libsbml.Date_resetModifiedFlags(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

Date_swigregister = _libsbml.Date_swigregister
Date_swigregister(Date)

class ModelCreator(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html MIRIAM-compliant data about a model's creator.

    @htmlinclude not-sbml-warning.html

    The SBML specification beginning with Level&nbsp;2 Version&nbsp;2
    defines a standard approach to recording model history and model creator
    information in a form that complies with MIRIAM ('Minimum Information
    Requested in the Annotation of biochemical Models', <i>Nature
    Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  For the model creator,
    this form involves the use of parts of the <a target='_blank'
    href='http://en.wikipedia.org/wiki/VCard'>vCard</a> representation.
    LibSBML provides the ModelCreator class as a convenience high-level
    interface for working with model creator data.  Objects of class
    ModelCreator can be used to store and carry around creator data within a
    program, and the various methods in this object class let callers
    manipulate the different parts of the model creator representation.

    @section parts The different parts of a model creator definition

    The ModelCreator class mirrors the structure of the MIRIAM model creator
    annotations in SBML.  The following template illustrates these different
    fields when they are written in XML form:

     <pre class='fragment'>
     &lt;vCard:N rdf:parseType='Resource'&gt;
       &lt;vCard:Family&gt;<span style='background-color: #bbb'>family name</span>&lt;/vCard:Family&gt;
       &lt;vCard:Given&gt;<span style='background-color: #bbb'>given name</span>&lt;/vCard:Given&gt;
     &lt;/vCard:N&gt;
     ...
     &lt;vCard:EMAIL&gt;<span style='background-color: #bbb'>email address</span>&lt;/vCard:EMAIL&gt;
     ...
     &lt;vCard:ORG rdf:parseType='Resource'&gt;
       &lt;vCard:Orgname&gt;<span style='background-color: #bbb'>organization</span>&lt;/vCard:Orgname&gt;
     &lt;/vCard:ORG&gt;
     </pre>

    Each of the separate data values
    <span class='code' style='background-color: #bbb'>family name</span>,
    <span class='code' style='background-color: #bbb'>given name</span>,
    <span class='code' style='background-color: #bbb'>email address</span>, and
    <span class='code' style='background-color: #bbb'>organization</span> can
    be set and retrieved via corresponding methods in the ModelCreator 
    class.  These methods are documented in more detail below.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelCreator, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ModelCreator
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> ModelCreator
        __init__(self, XMLNode creator) -> ModelCreator
        __init__(self, ModelCreator orig) -> ModelCreator

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModelCreator(const XMLNode creator)</pre>

        Creates a new ModelCreator from an XMLNode.

        @param creator the XMLNode from which to create the ModelCreator.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModelCreator()</pre>

        Creates a new ModelCreator object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModelCreator(ModelCreator orig)</pre>

        Copy constructor; creates a copy of the ModelCreator.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.

        """
        this = _libsbml.new_ModelCreator(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ModelCreator

        Creates and returns a deep copy of this ModelCreator object.

        @return the (deep) copy of this ModelCreator object.

        """
        return _libsbml.ModelCreator_clone(self)

    def getFamilyName(self):
        """
        getFamilyName(self) -> string

        Returns the 'family name' stored in this ModelCreator object.

        @return the 'family name' portion of the ModelCreator object.

        """
        return _libsbml.ModelCreator_getFamilyName(self)

    def getGivenName(self):
        """
        getGivenName(self) -> string

        Returns the 'given name' stored in this ModelCreator object.

        @return the 'given name' portion of the ModelCreator object.

        """
        return _libsbml.ModelCreator_getGivenName(self)

    def getEmail(self):
        """
        getEmail(self) -> string

        Returns the 'email' stored in this ModelCreator object.

        @return email from the ModelCreator.

        """
        return _libsbml.ModelCreator_getEmail(self)

    def getOrganization(self):
        """
        getOrganization(self) -> string

        Returns the 'organization' stored in this ModelCreator object.

        @return organization from the ModelCreator.

        """
        return _libsbml.ModelCreator_getOrganization(self)

    def getOrganisation(self):
        """
        getOrganisation(self) -> string

        (Alternate spelling) Returns the 'organization' stored in this
        ModelCreator object.

        @note This function is an alias of getOrganization().

        @return organization from the ModelCreator.

        @see getOrganization()

        """
        return _libsbml.ModelCreator_getOrganisation(self)

    def isSetFamilyName(self):
        """
        isSetFamilyName(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        ModelCreator's 'family name' part is set.

        @return @c True if the familyName of this ModelCreator is set, @c False otherwise.

        """
        return _libsbml.ModelCreator_isSetFamilyName(self)

    def isSetGivenName(self):
        """
        isSetGivenName(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        ModelCreator's 'given name' part is set.

        @return @c True if the givenName of this ModelCreator is set, @c False otherwise.

        """
        return _libsbml.ModelCreator_isSetGivenName(self)

    def isSetEmail(self):
        """
        isSetEmail(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        ModelCreator's 'email' part is set.

        @return @c True if the email of this ModelCreator is set, @c False otherwise.

        """
        return _libsbml.ModelCreator_isSetEmail(self)

    def isSetOrganization(self):
        """
        isSetOrganization(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        ModelCreator's 'organization' part is set.

        @return @c True if the organization of this ModelCreator is set, @c False otherwise.

        """
        return _libsbml.ModelCreator_isSetOrganization(self)

    def isSetOrganisation(self):
        """
        isSetOrganisation(self) -> bool

        (Alternate spelling) Predicate returning @c True or @c False depending
        on whether this ModelCreator's 'organization' part is set.

        @note This function is an alias of isSetOrganization().

        @return @c True if the organization of this ModelCreator is set, @c False otherwise.

        @see isSetOrganization()

        """
        return _libsbml.ModelCreator_isSetOrganisation(self)

    def setFamilyName(self, *args):
        """
        setFamilyName(self, string familyName) -> int

        Sets the 'family name' portion of this ModelCreator object.

        @param familyName a string representing the familyName of the ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ModelCreator_setFamilyName(self, *args)

    def setGivenName(self, *args):
        """
        setGivenName(self, string givenName) -> int

        Sets the 'given name' portion of this ModelCreator object.

        @param givenName a string representing the givenName of the ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ModelCreator_setGivenName(self, *args)

    def setEmail(self, *args):
        """
        setEmail(self, string email) -> int

        Sets the 'email' portion of this ModelCreator object.

        @param email a string representing the email of the ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ModelCreator_setEmail(self, *args)

    def setOrganization(self, *args):
        """
        setOrganization(self, string organization) -> int

        Sets the 'organization' portion of this ModelCreator object.

        @param organization a string representing the organization of the 
        ModelCreator. 

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ModelCreator_setOrganization(self, *args)

    def setOrganisation(self, *args):
        """
        setOrganisation(self, string organization) -> int

        (Alternate spelling) Sets the 'organization' portion of this
        ModelCreator object.

        @param organization a string representing the organization of the
        ModelCreator.

        @note This function is an alias of setOrganization(string organization).

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see setOrganization()

        """
        return _libsbml.ModelCreator_setOrganisation(self, *args)

    def unsetFamilyName(self):
        """
        unsetFamilyName(self) -> int

        Unsets the 'family name' portion of this ModelCreator object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ModelCreator_unsetFamilyName(self)

    def unsetGivenName(self):
        """
        unsetGivenName(self) -> int

        Unsets the 'given name' portion of this ModelCreator object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ModelCreator_unsetGivenName(self)

    def unsetEmail(self):
        """
        unsetEmail(self) -> int

        Unsets the 'email' portion of this ModelCreator object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ModelCreator_unsetEmail(self)

    def unsetOrganization(self):
        """
        unsetOrganization(self) -> int

        Unsets the 'organization' portion of this ModelCreator object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ModelCreator_unsetOrganization(self)

    def unsetOrganisation(self):
        """
        unsetOrganisation(self) -> int

        (Alternate spelling) Unsets the 'organization' portion of this ModelCreator object.

        @note This function is an alias of unsetOrganization().

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see unsetOrganization()

        """
        return _libsbml.ModelCreator_unsetOrganisation(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required elements for this
        ModelCreator object have been set.

        The only required elements for a ModelCreator object are the 'family
        name' and 'given name'.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.ModelCreator_hasRequiredAttributes(self)

    def hasBeenModified(self):
        """
        hasBeenModified(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ModelCreator_hasBeenModified(self)

    def resetModifiedFlags(self):
        """
        resetModifiedFlags(self)

        @internal

        @internal

        """
        return _libsbml.ModelCreator_resetModifiedFlags(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

ModelCreator_swigregister = _libsbml.ModelCreator_swigregister
ModelCreator_swigregister(ModelCreator)

class ModelHistory(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html MIRIAM-compliant data about a model's history.

    @htmlinclude not-sbml-warning.html

    The SBML specification beginning with Level&nbsp;2 Version&nbsp;2 defines
    a standard approach to recording optional model history and model creator
    information in a form that complies with MIRIAM (<a target='_blank'
    href='http://www.nature.com/nbt/journal/v23/n12/abs/nbt1156.html'>'Minimum
    Information Requested in the Annotation of biochemical Models'</a>,
    <i>Nature Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  LibSBML
    provides the ModelHistory class as a convenient high-level interface for
    working with model history data.

    Model histories in SBML consist of one or more <em>model creators</em>,
    a single date of @em creation, and one or more @em modification dates.
    The overall XML form of this data takes the following form:

     <pre class='fragment'>
     &lt;dc:creator&gt;
       &lt;rdf:Bag&gt;
         &lt;rdf:li rdf:parseType='Resource'&gt;
           <span style='background-color: #d0eed0'>+++</span>
           &lt;vCard:N rdf:parseType='Resource'&gt;
             &lt;vCard:Family&gt;<span style='background-color: #bbb'>family name</span>&lt;/vCard:Family&gt;
             &lt;vCard:Given&gt;<span style='background-color: #bbb'>given name</span>&lt;/vCard:Given&gt;
           &lt;/vCard:N&gt;
           <span style='background-color: #d0eed0'>+++</span>
           <span style='border-bottom: 2px dotted #888'>&lt;vCard:EMAIL&gt;<span style='background-color: #bbb'>email address</span>&lt;/vCard:EMAIL&gt;</span>
           <span style='background-color: #d0eed0'>+++</span>
           <span style='border-bottom: 2px dotted #888'>&lt;vCard:ORG rdf:parseType='Resource'&gt;</span>
            <span style='border-bottom: 2px dotted #888'>&lt;vCard:Orgname&gt;<span style='background-color: #bbb'>organization name</span>&lt;/vCard:Orgname&gt;</span>
           <span style='border-bottom: 2px dotted #888'>&lt;/vCard:ORG&gt;</span>
           <span style='background-color: #d0eed0'>+++</span>
         &lt;/rdf:li&gt;
         <span style='background-color: #edd'>...</span>
       &lt;/rdf:Bag&gt;
     &lt;/dc:creator&gt;
     &lt;dcterms:created rdf:parseType='Resource'&gt;
       &lt;dcterms:W3CDTF&gt;<span style='background-color: #bbb'>creation date</span>&lt;/dcterms:W3CDTF&gt;
     &lt;/dcterms:created&gt;
     &lt;dcterms:modified rdf:parseType='Resource'&gt;
       &lt;dcterms:W3CDTF&gt;<span style='background-color: #bbb'>modification date</span>&lt;/dcterms:W3CDTF&gt;
     &lt;/dcterms:modified&gt;
     <span style='background-color: #edd'>...</span>
     </pre>

    In the template above, the <span style='border-bottom: 2px dotted #888'>underlined</span>
    portions are optional, the symbol
    <span class='code' style='background-color: #d0eed0'>+++</span> is a placeholder
    for either no content or valid XML content that is not defined by
    the annotation scheme, and the ellipses
    <span class='code' style='background-color: #edd'>...</span>
    are placeholders for zero or more elements of the same form as the
    immediately preceding element.  The various placeholders for content, namely
    <span class='code' style='background-color: #bbb'>family name</span>,
    <span class='code' style='background-color: #bbb'>given name</span>,
    <span class='code' style='background-color: #bbb'>email address</span>,
    <span class='code' style='background-color: #bbb'>organization</span>,
    <span class='code' style='background-color: #bbb'>creation date</span>, and
    <span class='code' style='background-color: #bbb'>modification date</span>
    are data that can be filled in using the various methods on
    the ModelHistory class described below.

    @see ModelCreator
    @see Date

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelHistory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelHistory, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ModelHistory
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> ModelHistory
        __init__(self, ModelHistory orig) -> ModelHistory

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModelHistory(ModelHistory orig)</pre>

        Copy constructor; creates a copy of this ModelHistory object.

        @param orig the object to copy.

        @throws SBMLConstructorException
        Thrown if the argument @p orig is @c None.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ModelHistory()</pre>

        Creates a new ModelHistory object.

        """
        this = _libsbml.new_ModelHistory(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> ModelHistory

        Creates and returns a deep copy of this ModelHistory object.

        @return the (deep) copy of this ModelHistory object.

        """
        return _libsbml.ModelHistory_clone(self)

    def getCreatedDate(self):
        """
        getCreatedDate(self) -> Date

        Returns the 'creation date' portion of this ModelHistory object.

        @return a Date object representing the creation date stored in
        this ModelHistory object.

        """
        return _libsbml.ModelHistory_getCreatedDate(self)

    def isSetCreatedDate(self):
        """
        isSetCreatedDate(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        ModelHistory's 'creation date' is set.

        @return @c True if the creation date value of this ModelHistory is
        set, @c False otherwise.

        """
        return _libsbml.ModelHistory_isSetCreatedDate(self)

    def isSetModifiedDate(self):
        """
        isSetModifiedDate(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        ModelHistory's 'modified date' is set.

        @return @c True if the modification date value of this ModelHistory
        object is set, @c False otherwise.

        """
        return _libsbml.ModelHistory_isSetModifiedDate(self)

    def setCreatedDate(self, *args):
        """
        setCreatedDate(self, Date date) -> int

        Sets the creation date of this ModelHistory object.

        @param date a Date object representing the date to which the 'created
        date' portion of this ModelHistory should be set.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.ModelHistory_setCreatedDate(self, *args)

    def setModifiedDate(self, *args):
        """
        setModifiedDate(self, Date date) -> int

        Sets the modification date of this ModelHistory object.

        @param date a Date object representing the date to which the 'modified
        date' portion of this ModelHistory should be set.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.ModelHistory_setModifiedDate(self, *args)

    def addModifiedDate(self, *args):
        """
        addModifiedDate(self, Date date) -> int

        Adds a copy of a Date object to the list of 'modified date' values
        stored in this ModelHistory object.

        In the MIRIAM format for annotations, there can be multiple
        modification dates.  The libSBML ModelHistory class supports this by
        storing a list of 'modified date' values.

        @param date a Date object representing the 'modified date' that should
        be added to this ModelHistory object.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        """
        return _libsbml.ModelHistory_addModifiedDate(self, *args)

    def getListModifiedDates(self):
      """
      getListModifiedDates(self) -> DateList

      Get the DateList of Date objects in this ModelHistory.

      Returns the DateList for this ModelHistory.
            

      """
      return _libsbml.ModelHistory_getListModifiedDates(self)


    def getModifiedDate(self, *args):
        """
        getModifiedDate(self) -> Date
        getModifiedDate(self, unsigned int n) -> Date

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getModifiedDate()</pre>

        Returns the 'modified date' portion of this ModelHistory object.

        Note that in the MIRIAM format for annotations, there can be multiple
        modification dates.  The libSBML ModelHistory class supports this by
        storing a list of 'modified date' values.  If this ModelHistory object
        contains more than one 'modified date' value in the list, this method
        will return the first one in the list.

        @return a Date object representing the date of modification
        stored in this ModelHistory object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>getModifiedDate(long n)</pre>

        Get the nth Date object in the list of 'modified date' values stored
        in this ModelHistory object.

        In the MIRIAM format for annotations, there can be multiple
        modification dates.  The libSBML ModelHistory class supports this by
        storing a list of 'modified date' values.

        @return the nth Date in the list of ModifiedDates of this
        ModelHistory.

        """
        return _libsbml.ModelHistory_getModifiedDate(self, *args)

    def getNumModifiedDates(self):
        """
        getNumModifiedDates(self) -> unsigned int

        Get the number of Date objects in this ModelHistory object's list of
        'modified dates'.

        In the MIRIAM format for annotations, there can be multiple
        modification dates.  The libSBML ModelHistory class supports this by
        storing a list of 'modified date' values.

        @return the number of ModifiedDates in this ModelHistory.

        """
        return _libsbml.ModelHistory_getNumModifiedDates(self)

    def addCreator(self, *args):
        """
        addCreator(self, ModelCreator mc) -> int

        Adds a copy of a ModelCreator object to the list of 'model creator'
        values stored in this ModelHistory object.

        In the MIRIAM format for annotations, there can be multiple model
        creators.  The libSBML ModelHistory class supports this by storing a
        list of 'model creator' values.

        @param mc the ModelCreator to add

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ModelHistory_addCreator(self, *args)

    def getListCreators(self):
      """
      getListCreators(self) -> ModelCreatorList

      Get the ModelCreatorList of ModelCreator objects in this 
      ModelHistory.

      Returns the ModelCreatorList for this ModelHistory.
            

      """
      return _libsbml.ModelHistory_getListCreators(self)


    def getCreator(self, *args):
        """
        getCreator(self, unsigned int n) -> ModelCreator

        Get the nth ModelCreator object stored in this ModelHistory object.

        In the MIRIAM format for annotations, there can be multiple model
        creators.  The libSBML ModelHistory class supports this by storing a
        list of 'model creator' values.

        @return the nth ModelCreator object.

        """
        return _libsbml.ModelHistory_getCreator(self, *args)

    def getNumCreators(self):
        """
        getNumCreators(self) -> unsigned int

        Get the number of ModelCreator objects stored in this ModelHistory
        object.

        In the MIRIAM format for annotations, there can be multiple model
        creators.  The libSBML ModelHistory class supports this by storing a
        list of 'model creator' values.

        @return the number of ModelCreators objects.

        """
        return _libsbml.ModelHistory_getNumCreators(self)

    def hasRequiredAttributes(self):
        """
        hasRequiredAttributes(self) -> bool

        Predicate returning @c True if all the required elements for this
        ModelHistory object have been set.

        The required elements for a ModelHistory object are 'created
        name', 'modified date', and at least one 'model creator'.

        @return a boolean value indicating whether all the required
        elements for this object have been defined.

        """
        return _libsbml.ModelHistory_hasRequiredAttributes(self)

    def hasBeenModified(self):
        """
        hasBeenModified(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ModelHistory_hasBeenModified(self)

    def resetModifiedFlags(self):
        """
        resetModifiedFlags(self)

        @internal

        @internal

        """
        return _libsbml.ModelHistory_resetModifiedFlags(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

ModelHistory_swigregister = _libsbml.ModelHistory_swigregister
ModelHistory_swigregister(ModelHistory)

class RDFAnnotationParser(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html MIRIAM-compliant RDF annotation reader/writer.

    @htmlinclude not-sbml-warning.html

    RDFAnnotationParser is a libSBML construct used as part of the libSBML
    support for annotations conforming to the guidelines specified by MIRIAM
    (<a target='_blank'
    href='http://www.nature.com/nbt/journal/v23/n12/abs/nbt1156.html'>'Minimum
    Information Requested in the Annotation of biochemical Models'</a>,
    <i>Nature Biotechnology</i>, vol. 23, no. 12, Dec. 2005).  Section 6 of
    the SBML Level&nbsp;2 and Level&nbsp;3 specification documents defines a
    recommended way of encoding MIRIAM information using a subset of RDF (<a
    target='_blank' href='http://www.w3.org/RDF/'>Resource Description
    Format</a>).  The general scheme is as follows.  A set of RDF-based
    annotations attached to a given SBML <code>&lt;annotation&gt;</code>
    element are read by RDFAnnotationParser and converted into a list of
    CVTerm objects.  There are different versions of the main method, @if clike RDFAnnotationParser.parseRDFAnnotation() @endif@if java RDFAnnotationParser.parseRDFAnnotation() @endif@~ and
    RDFAnnotationParser.parseRDFAnnotation(), used
    depending on whether the annotation in question concerns the MIRIAM model
    history or other MIRIAM resource annotations.  A special object class,
    ModelHistory, is used to make it easier to manipulate model history
    annotations.

    All of the methods on RDFAnnotationParser are static; the class exists
    only to encapsulate the annotation and CVTerm parsing and manipulation
    functionality.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RDFAnnotationParser, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RDFAnnotationParser, name)
    __repr__ = _swig_repr
    def createAnnotation():
        """
        createAnnotation() -> XMLNode

        Creates a blank annotation and returns its root XMLNode object.

        This creates a completely empty SBML <code>&lt;annotation&gt;</code>
        element.  It is not attached to any SBML element.  An example of how
        this might be used is illustrated in the following code fragment.  In
        this example, suppose that @c content is an XMLNode object previously
        created, containing MIRIAM-style annotations, and that @c sbmlObject
        is an SBML object derived from SBase (e.g., a Model, or a Species, or
        a Compartment, etc.).  Then:@if clike
        @code{.cpp}
        int success;                              // Status code variable, used below.

        XMLNodeRDF = createRDFAnnotation();     // Create RDF annotation XML structure.
        success = RDF->addChild(...content...);   // Put some content into it.
        ...                                       // Check 'success' return code value.

        XMLNodeann = createAnnotation();        // Create <annotation> container.
        success = ann->addChild(RDF);             // Put the RDF annotation into it.
        ...                                       // Check 'success' return code value.

        success = sbmlObject->setAnnotation(ann); // Set object's annotation to what we built.
        ...                                       // Check 'success' return code value.
        @endcode
        @endif@if java
        @code{.java}
        int success;                                   // Status code variable, used below.

        XMLNode RDF = createRDFAnnotation();          // Create RDF annotation XML structure.
        success      = RDF.addChild(...content...);    // Put some content into it.
        ...                                            // Check 'success' return code value.

        XMLNode ann = createAnnotation();             // Create <annotation> container.
        success      = ann.addChild(RDF);              // Put the RDF annotation into it.
        ...                                            // Check 'success' return code value.

        success      = sbmlObject.setAnnotation(ann); // Set object's annotation to what we built.
        ...                                            // Check 'success' return code value.
        @endcode
        @endif@if python
        @code{.py}
        RDF     = RDFAnnotationParser.createRDFAnnotation() # Create RDF annotation XML structure.
        success = RDF.addChild(...content...)               # Put some content into it.
        ...                                                 # Check 'success' return code value.

        annot   = RDFAnnotationParser.createAnnotation()    # Create <annotation> container.
        success = annot.addChild(RDF)                       # Put the RDF annotation into it.
        ...                                                 # Check 'success' return code value.

        success = sbmlObject.setAnnotation(annot)           # Set object's annotation to what we built.
        ...                                                 # Check 'success' return code value.
        @endcode
        @endif@~
        The SBML specification contains more information about the format of
        annotations.  We urge readers to consult Section&nbsp;6 of the SBML
        Level&nbsp;2 (Versions 2&ndash;4) and SBML Level&nbsp;3 specification
        documents.

        @return a pointer to an XMLNode for the annotation

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike createRDFAnnotation() @else RDFAnnotationParser.createRDFAnnotation() @endif@~

        """
        return _libsbml.RDFAnnotationParser_createAnnotation()

    if _newclass:createAnnotation = staticmethod(createAnnotation)
    __swig_getmethods__["createAnnotation"] = lambda x: createAnnotation
    def createRDFAnnotation():
        """
        createRDFAnnotation() -> XMLNode

        Creates a blank RDF element suitable for use in SBML annotations.

        The annotation created by this method has namespace declarations for
        all the relevant XML namespaces used in RDF annotations and also has
        an empty RDF element.  The result is the following XML:
        @verbatim
        <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
                 xmlns:dc='http://purl.org/dc/elements/1.1/'
                 xmlns:dcterms='http://purl.org/dc/terms/'
                 xmlns:vCard='http://www.w3.org/2001/vcard-rdf/3.0#'
                 xmlns:bqbiol='http://biomodels.net/biology-qualifiers/'
                 xmlns:bqmodel='http://biomodels.net/model-qualifiers/' >

        </rdf:RDF>
        @endverbatim

        Note that this does not create the containing SBML
        <code>&lt;annotation&gt;</code> element; the method
        @if clike createAnnotation()@else RDFAnnotationParser.createAnnotation()@endif@~
        is available for creating the container.

        @return a pointer to an XMLNode

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @see @if clike createAnnotation() @else RDFAnnotationParser.createAnnotation() @endif@~

        """
        return _libsbml.RDFAnnotationParser_createRDFAnnotation()

    if _newclass:createRDFAnnotation = staticmethod(createRDFAnnotation)
    __swig_getmethods__["createRDFAnnotation"] = lambda x: createRDFAnnotation
    def createCVTerms(*args):
        """
        createCVTerms(SBase obj) -> XMLNode

        Takes a list of CVTerm objects and creates a the RDF 'Description'
        element.

        This essentially takes the given SBML object, reads out the CVTerm
        objects attached to it, creates an RDF 'Description' element to hold
        the terms, and adds each term with appropriate qualifiers.

        @param obj the SBML object to start from

        @return the XMLNode tree corresponding to the Description element of
        an RDF annotation.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_createCVTerms(*args)

    if _newclass:createCVTerms = staticmethod(createCVTerms)
    __swig_getmethods__["createCVTerms"] = lambda x: createCVTerms
    def parseCVTerms(*args):
        """
        parseCVTerms(SBase obj) -> XMLNode

        Takes a list of CVTerm objects and creates a complete SBML annotation
        around it.

        This essentially takes the given SBML object, reads out the CVTerm
        objects attached to it, calls @if clike createRDFAnnotation()@else
        RDFAnnotationParser.createRDFAnnotation()@endif@~ to create an RDF
        annotation to hold the terms, and finally calls @if clike
        createAnnotation()@else
        RDFAnnotationParser.createAnnotation()@endif@~ to wrap the result as
        an SBML <code>&lt;annotation&gt;</code> element.

        @param obj the SBML object to start from

        @return the XMLNode tree corresponding to the annotation.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_parseCVTerms(*args)

    if _newclass:parseCVTerms = staticmethod(parseCVTerms)
    __swig_getmethods__["parseCVTerms"] = lambda x: parseCVTerms
    def parseModelHistory(*args):
        """
        parseModelHistory(SBase obj) -> XMLNode

        Reads the model history and cvTerms stored in @p obj and creates the
        XML structure for an SBML annotation representing that metadata if 
        there is a model history stored in @p obj.

        @param obj any SBase object

        @return the XMLNode corresponding to an annotation containing 
        MIRIAM-compliant model history and CV term information in RDF format.

        @note If the object does not have a history element stored then
        @c None is returned even if CVTerms are present.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_parseModelHistory(*args)

    if _newclass:parseModelHistory = staticmethod(parseModelHistory)
    __swig_getmethods__["parseModelHistory"] = lambda x: parseModelHistory
    def parseOnlyModelHistory(*args):
        """
        parseOnlyModelHistory(SBase obj) -> XMLNode

        Reads the model history stored in @p obj and creates the
        XML structure for an SBML annotation representing that history.

        @param obj any SBase object

        @return the XMLNode corresponding to an annotation containing 
        MIRIAM-compliant model history information in RDF format.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_parseOnlyModelHistory(*args)

    if _newclass:parseOnlyModelHistory = staticmethod(parseOnlyModelHistory)
    __swig_getmethods__["parseOnlyModelHistory"] = lambda x: parseOnlyModelHistory
    def deleteRDFAnnotation(*args):
        """
        deleteRDFAnnotation(XMLNode annotation) -> XMLNode

        Deletes any SBML MIRIAM RDF annotation found in the given XMLNode 
        tree and returns
        any remaining annotation content.

        The name of the XMLNode given as parameter @p annotation must be
        'annotation', or else this method returns @c None.  The method will
        walk down the XML structure looking for elements that are in the
        RDF XML namespace, and remove them if they conform to the syntax
        of a History or CVTerm element.

        @param annotation the XMLNode tree within which the RDF annotation is
        to be found and deleted

        @return the XMLNode structure that is left after RDF annotations are
        deleted.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_deleteRDFAnnotation(*args)

    if _newclass:deleteRDFAnnotation = staticmethod(deleteRDFAnnotation)
    __swig_getmethods__["deleteRDFAnnotation"] = lambda x: deleteRDFAnnotation
    def deleteRDFHistoryAnnotation(*args):
        """
        deleteRDFHistoryAnnotation(XMLNode annotation) -> XMLNode

        Deletes any SBML MIRIAM RDF 'History' annotation found in the given 
        XMLNode tree and returns
        any remaining annotation content.

        The name of the XMLNode given as parameter @p annotation must be
        'annotation', or else this method returns @c None.  The method will
        walk down the XML structure looking for elements that are in the
        RDF XML namespace, and remove any that conform to the syntax of a
        History element.

        @param annotation the XMLNode tree within which the RDF annotation is
        to be found and deleted

        @return the XMLNode structure that is left after RDF annotations are
        deleted.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_deleteRDFHistoryAnnotation(*args)

    if _newclass:deleteRDFHistoryAnnotation = staticmethod(deleteRDFHistoryAnnotation)
    __swig_getmethods__["deleteRDFHistoryAnnotation"] = lambda x: deleteRDFHistoryAnnotation
    def deleteRDFCVTermAnnotation(*args):
        """
        deleteRDFCVTermAnnotation(XMLNode annotation) -> XMLNode

        Deletes any SBML MIRIAM RDF 'CVTerm' annotation found in the given 
        XMLNode tree and returns
        any remaining annotation content.

        The name of the XMLNode given as parameter @p annotation must be
        'annotation', or else this method returns @c None.  The method will
        walk down the XML structure looking for elements that are in the
        RDF XML namespace, and remove any that conform to the syntax of a
        CVTerm element.

        @param annotation the XMLNode tree within which the RDF annotation is
        to be found and deleted

        @return the XMLNode structure that is left after RDF annotations are
        deleted.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        """
        return _libsbml.RDFAnnotationParser_deleteRDFCVTermAnnotation(*args)

    if _newclass:deleteRDFCVTermAnnotation = staticmethod(deleteRDFCVTermAnnotation)
    __swig_getmethods__["deleteRDFCVTermAnnotation"] = lambda x: deleteRDFCVTermAnnotation
    def parseRDFAnnotation(*args):
        """
        parseRDFAnnotation(XMLNode annotation, char metaId = None, XMLInputStream stream = None) -> ModelHistory
        parseRDFAnnotation(XMLNode annotation, char metaId = None) -> ModelHistory
        parseRDFAnnotation(XMLNode annotation) -> ModelHistory
        parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms)
        parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms, char metaId = None, 
            XMLInputStream stream = None)
        parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms, char metaId = None)

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>parseRDFAnnotation(XMLNodeannotation, List *CVTerms, string metaId = None, XMLInputStream stream = None)</pre>

        Parses an annotation (given as an XMLNode tree) into a list of
        CVTerm objects.

        This is used to take an annotation that has been read into an SBML
        model, identify the RDF elements within it, and create a list of
        corresponding CVTerm (controlled vocabulary term) objects.

        @param annotation XMLNode containing the annotation.
        @param CVTerms list of CVTerm objects to be created.
        @param metaId optional metaId, if set only the RDF annotation for this metaId will be returned.
        @param stream optional XMLInputStream that facilitates error logging.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>parseRDFAnnotation(XMLNodeannotation, string metaId = None, XMLInputStream stream = None)</pre>

        Parses an annotation into a ModelHistory class instance.

        This is used to take an annotation that has been read into an SBML
        model, identify the RDF elements representing model history
        information, and create a list of corresponding CVTerm objects.

        @param annotation XMLNode containing the annotation.
        @param stream optional XMLInputStream that facilitates error logging
        @param metaId optional metaId, if set only the RDF annotation for this metaId will be returned.

        @if python @note Because this is a static method on a class, the Python
        language interface for libSBML will contain two variants.  One will be the
        expected, normal static method on the class (i.e., a regular
        <em>methodName</em>), and the other will be a standalone top-level
        function with the name <em>ClassName_methodName()</em>. This is merely an
        artifact of how the language interfaces are created in libSBML.  The
        methods are functionally identical. @endif@~

        @return a pointer to the ModelHistory created.

        """
        return _libsbml.RDFAnnotationParser_parseRDFAnnotation(*args)

    if _newclass:parseRDFAnnotation = staticmethod(parseRDFAnnotation)
    __swig_getmethods__["parseRDFAnnotation"] = lambda x: parseRDFAnnotation
    def __init__(self): 
        """__init__(self) -> RDFAnnotationParser"""
        this = _libsbml.new_RDFAnnotationParser()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_RDFAnnotationParser
    __del__ = lambda self : None;
RDFAnnotationParser_swigregister = _libsbml.RDFAnnotationParser_swigregister
RDFAnnotationParser_swigregister(RDFAnnotationParser)

def RDFAnnotationParser_createAnnotation():
  """
    RDFAnnotationParser_createAnnotation() -> XMLNode

    Creates a blank annotation and returns its root XMLNode object.

    This creates a completely empty SBML <code>&lt;annotation&gt;</code>
    element.  It is not attached to any SBML element.  An example of how
    this might be used is illustrated in the following code fragment.  In
    this example, suppose that @c content is an XMLNode object previously
    created, containing MIRIAM-style annotations, and that @c sbmlObject
    is an SBML object derived from SBase (e.g., a Model, or a Species, or
    a Compartment, etc.).  Then:@if clike
    @code{.cpp}
    int success;                              // Status code variable, used below.

    XMLNodeRDF = createRDFAnnotation();     // Create RDF annotation XML structure.
    success = RDF->addChild(...content...);   // Put some content into it.
    ...                                       // Check 'success' return code value.

    XMLNodeann = createAnnotation();        // Create <annotation> container.
    success = ann->addChild(RDF);             // Put the RDF annotation into it.
    ...                                       // Check 'success' return code value.

    success = sbmlObject->setAnnotation(ann); // Set object's annotation to what we built.
    ...                                       // Check 'success' return code value.
    @endcode
    @endif@if java
    @code{.java}
    int success;                                   // Status code variable, used below.

    XMLNode RDF = createRDFAnnotation();          // Create RDF annotation XML structure.
    success      = RDF.addChild(...content...);    // Put some content into it.
    ...                                            // Check 'success' return code value.

    XMLNode ann = createAnnotation();             // Create <annotation> container.
    success      = ann.addChild(RDF);              // Put the RDF annotation into it.
    ...                                            // Check 'success' return code value.

    success      = sbmlObject.setAnnotation(ann); // Set object's annotation to what we built.
    ...                                            // Check 'success' return code value.
    @endcode
    @endif@if python
    @code{.py}
    RDF     = RDFAnnotationParser.createRDFAnnotation() # Create RDF annotation XML structure.
    success = RDF.addChild(...content...)               # Put some content into it.
    ...                                                 # Check 'success' return code value.

    annot   = RDFAnnotationParser.createAnnotation()    # Create <annotation> container.
    success = annot.addChild(RDF)                       # Put the RDF annotation into it.
    ...                                                 # Check 'success' return code value.

    success = sbmlObject.setAnnotation(annot)           # Set object's annotation to what we built.
    ...                                                 # Check 'success' return code value.
    @endcode
    @endif@~
    The SBML specification contains more information about the format of
    annotations.  We urge readers to consult Section&nbsp;6 of the SBML
    Level&nbsp;2 (Versions 2&ndash;4) and SBML Level&nbsp;3 specification
    documents.

    @return a pointer to an XMLNode for the annotation

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike createRDFAnnotation() @else RDFAnnotationParser.createRDFAnnotation() @endif@~

    """
  return _libsbml.RDFAnnotationParser_createAnnotation()

def RDFAnnotationParser_createRDFAnnotation():
  """
    RDFAnnotationParser_createRDFAnnotation() -> XMLNode

    Creates a blank RDF element suitable for use in SBML annotations.

    The annotation created by this method has namespace declarations for
    all the relevant XML namespaces used in RDF annotations and also has
    an empty RDF element.  The result is the following XML:
    @verbatim
    <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
             xmlns:dc='http://purl.org/dc/elements/1.1/'
             xmlns:dcterms='http://purl.org/dc/terms/'
             xmlns:vCard='http://www.w3.org/2001/vcard-rdf/3.0#'
             xmlns:bqbiol='http://biomodels.net/biology-qualifiers/'
             xmlns:bqmodel='http://biomodels.net/model-qualifiers/' >

    </rdf:RDF>
    @endverbatim

    Note that this does not create the containing SBML
    <code>&lt;annotation&gt;</code> element; the method
    @if clike createAnnotation()@else RDFAnnotationParser.createAnnotation()@endif@~
    is available for creating the container.

    @return a pointer to an XMLNode

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @see @if clike createAnnotation() @else RDFAnnotationParser.createAnnotation() @endif@~

    """
  return _libsbml.RDFAnnotationParser_createRDFAnnotation()

def RDFAnnotationParser_createCVTerms(*args):
  """
    RDFAnnotationParser_createCVTerms(SBase obj) -> XMLNode

    Takes a list of CVTerm objects and creates a the RDF 'Description'
    element.

    This essentially takes the given SBML object, reads out the CVTerm
    objects attached to it, creates an RDF 'Description' element to hold
    the terms, and adds each term with appropriate qualifiers.

    @param obj the SBML object to start from

    @return the XMLNode tree corresponding to the Description element of
    an RDF annotation.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_createCVTerms(*args)

def RDFAnnotationParser_parseCVTerms(*args):
  """
    RDFAnnotationParser_parseCVTerms(SBase obj) -> XMLNode

    Takes a list of CVTerm objects and creates a complete SBML annotation
    around it.

    This essentially takes the given SBML object, reads out the CVTerm
    objects attached to it, calls @if clike createRDFAnnotation()@else
    RDFAnnotationParser.createRDFAnnotation()@endif@~ to create an RDF
    annotation to hold the terms, and finally calls @if clike
    createAnnotation()@else
    RDFAnnotationParser.createAnnotation()@endif@~ to wrap the result as
    an SBML <code>&lt;annotation&gt;</code> element.

    @param obj the SBML object to start from

    @return the XMLNode tree corresponding to the annotation.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_parseCVTerms(*args)

def RDFAnnotationParser_parseModelHistory(*args):
  """
    RDFAnnotationParser_parseModelHistory(SBase obj) -> XMLNode

    Reads the model history and cvTerms stored in @p obj and creates the
    XML structure for an SBML annotation representing that metadata if 
    there is a model history stored in @p obj.

    @param obj any SBase object

    @return the XMLNode corresponding to an annotation containing 
    MIRIAM-compliant model history and CV term information in RDF format.

    @note If the object does not have a history element stored then
    @c None is returned even if CVTerms are present.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_parseModelHistory(*args)

def RDFAnnotationParser_parseOnlyModelHistory(*args):
  """
    RDFAnnotationParser_parseOnlyModelHistory(SBase obj) -> XMLNode

    Reads the model history stored in @p obj and creates the
    XML structure for an SBML annotation representing that history.

    @param obj any SBase object

    @return the XMLNode corresponding to an annotation containing 
    MIRIAM-compliant model history information in RDF format.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_parseOnlyModelHistory(*args)

def RDFAnnotationParser_deleteRDFAnnotation(*args):
  """
    RDFAnnotationParser_deleteRDFAnnotation(XMLNode annotation) -> XMLNode

    Deletes any SBML MIRIAM RDF annotation found in the given XMLNode 
    tree and returns
    any remaining annotation content.

    The name of the XMLNode given as parameter @p annotation must be
    'annotation', or else this method returns @c None.  The method will
    walk down the XML structure looking for elements that are in the
    RDF XML namespace, and remove them if they conform to the syntax
    of a History or CVTerm element.

    @param annotation the XMLNode tree within which the RDF annotation is
    to be found and deleted

    @return the XMLNode structure that is left after RDF annotations are
    deleted.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_deleteRDFAnnotation(*args)

def RDFAnnotationParser_deleteRDFHistoryAnnotation(*args):
  """
    RDFAnnotationParser_deleteRDFHistoryAnnotation(XMLNode annotation) -> XMLNode

    Deletes any SBML MIRIAM RDF 'History' annotation found in the given 
    XMLNode tree and returns
    any remaining annotation content.

    The name of the XMLNode given as parameter @p annotation must be
    'annotation', or else this method returns @c None.  The method will
    walk down the XML structure looking for elements that are in the
    RDF XML namespace, and remove any that conform to the syntax of a
    History element.

    @param annotation the XMLNode tree within which the RDF annotation is
    to be found and deleted

    @return the XMLNode structure that is left after RDF annotations are
    deleted.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_deleteRDFHistoryAnnotation(*args)

def RDFAnnotationParser_deleteRDFCVTermAnnotation(*args):
  """
    RDFAnnotationParser_deleteRDFCVTermAnnotation(XMLNode annotation) -> XMLNode

    Deletes any SBML MIRIAM RDF 'CVTerm' annotation found in the given 
    XMLNode tree and returns
    any remaining annotation content.

    The name of the XMLNode given as parameter @p annotation must be
    'annotation', or else this method returns @c None.  The method will
    walk down the XML structure looking for elements that are in the
    RDF XML namespace, and remove any that conform to the syntax of a
    CVTerm element.

    @param annotation the XMLNode tree within which the RDF annotation is
    to be found and deleted

    @return the XMLNode structure that is left after RDF annotations are
    deleted.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    """
  return _libsbml.RDFAnnotationParser_deleteRDFCVTermAnnotation(*args)

def RDFAnnotationParser_parseRDFAnnotation(*args):
  """
    parseRDFAnnotation(XMLNode annotation, char metaId = None, XMLInputStream stream = None) -> ModelHistory
    parseRDFAnnotation(XMLNode annotation, char metaId = None) -> ModelHistory
    parseRDFAnnotation(XMLNode annotation) -> ModelHistory
    parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms)
    parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms, char metaId = None, 
        XMLInputStream stream = None)
    RDFAnnotationParser_parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms, char metaId = None)

    This method has multiple variants; they differ in the arguments
     they accept.  Each variant is described separately below.

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>parseRDFAnnotation(XMLNodeannotation, List *CVTerms, string metaId = None, XMLInputStream stream = None)</pre>

    Parses an annotation (given as an XMLNode tree) into a list of
    CVTerm objects.

    This is used to take an annotation that has been read into an SBML
    model, identify the RDF elements within it, and create a list of
    corresponding CVTerm (controlled vocabulary term) objects.

    @param annotation XMLNode containing the annotation.
    @param CVTerms list of CVTerm objects to be created.
    @param metaId optional metaId, if set only the RDF annotation for this metaId will be returned.
    @param stream optional XMLInputStream that facilitates error logging.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~
       

    @par
    <hr>
    <span class='variant-sig-heading'>Method variant with the following signature</span>:
     <pre class='signature'>parseRDFAnnotation(XMLNodeannotation, string metaId = None, XMLInputStream stream = None)</pre>

    Parses an annotation into a ModelHistory class instance.

    This is used to take an annotation that has been read into an SBML
    model, identify the RDF elements representing model history
    information, and create a list of corresponding CVTerm objects.

    @param annotation XMLNode containing the annotation.
    @param stream optional XMLInputStream that facilitates error logging
    @param metaId optional metaId, if set only the RDF annotation for this metaId will be returned.

    @if python @note Because this is a static method on a class, the Python
    language interface for libSBML will contain two variants.  One will be the
    expected, normal static method on the class (i.e., a regular
    <em>methodName</em>), and the other will be a standalone top-level
    function with the name <em>ClassName_methodName()</em>. This is merely an
    artifact of how the language interfaces are created in libSBML.  The
    methods are functionally identical. @endif@~

    @return a pointer to the ModelHistory created.

    """
  return _libsbml.RDFAnnotationParser_parseRDFAnnotation(*args)

class ISBMLExtensionNamespaces(SBMLNamespaces):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html 

    @internal

    """
    __swig_setmethods__ = {}
    for _s in [SBMLNamespaces]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISBMLExtensionNamespaces, name, value)
    __swig_getmethods__ = {}
    for _s in [SBMLNamespaces]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ISBMLExtensionNamespaces, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ISBMLExtensionNamespaces
    __del__ = lambda self : None;
    def getURI(self):
        """
        getURI(self) -> string

        Returns a string representing the SBML XML namespace of this
        object.

        @return a string representing the SBML namespace that reflects the
        SBML Level and Version of this object.

        """
        return _libsbml.ISBMLExtensionNamespaces_getURI(self)

    def getPackageVersion(self):
        """getPackageVersion(self) -> unsigned int"""
        return _libsbml.ISBMLExtensionNamespaces_getPackageVersion(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        Returns the name of the main package for this namespace.

        @return the name of the main package for this namespace.
        'core' will be returned if this namespace is defined in the SBML 
        core.

        """
        return _libsbml.ISBMLExtensionNamespaces_getPackageName(self)

    def setPackageVersion(self, *args):
        """setPackageVersion(self, unsigned int pkgVersion)"""
        return _libsbml.ISBMLExtensionNamespaces_setPackageVersion(self, *args)

ISBMLExtensionNamespaces_swigregister = _libsbml.ISBMLExtensionNamespaces_swigregister
ISBMLExtensionNamespaces_swigregister(ISBMLExtensionNamespaces)

class SBaseExtensionPoint(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Extension of an element by an SBML Level 3 package.

    @ifnot clike @internal @endif@~

    SBaseExtensionPoint represents an element to be extended (extension point) and the
    extension point is identified by a combination of a package name and a typecode of the 
    element.

    <p>
    For example, an SBaseExtensionPoint object which represents an extension point of the model
    element defined in the <em>core</em> package can be created as follows:

    @verbatim
          SBaseExtensionPoint  modelextp('core', SBML_MODEL);
    @endverbatim

    Similarly, an SBaseExtensionPoint object which represents an extension point of
    the layout element defined in the layout extension can be created as follows:

    @verbatim
          SBaseExtensionPoint  layoutextp('layout', SBML_LAYOUT_LAYOUT);
    @endverbatim

    SBaseExtensionPoint object is required as one of arguments of the constructor 
    of SBasePluginCreator&lt;class SBasePluginType, class SBMLExtensionType&gt;
    template class to identify an extension poitnt to which the plugin object created
    by the creator class is plugged in.
    For example, the SBasePluginCreator class which creates a LayoutModelPlugin object
    of the layout extension which is plugged in to the model element of the <em>core</em>
    package can be created with the corresponding SBaseExtensionPoint object as follows:

    @verbatim
      // std::vector object that contains a list of URI (package versions) supported 
      // by the plugin object.
      std::vector<string> packageURIs;
      packageURIs.push_back(getXmlnsL3V1V1());
      packageURIs.push_back(getXmlnsL2());  

      // creates an extension point (model element of the 'core' package)
      SBaseExtensionPoint  modelExtPoint('core',SBML_MODEL);
       
      // creates an SBasePluginCreator object 
      SBasePluginCreator<LayoutModelPlugin, LayoutExtension>  modelPluginCreator(modelExtPoint,packageURIs);
    @endverbatim

    This kind of code is implemented in init() function of each SBMLExtension derived classes.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBaseExtensionPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBaseExtensionPoint, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBaseExtensionPoint
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self, string pkgName, int typeCode) -> SBaseExtensionPoint
        __init__(self, SBaseExtensionPoint rhs) -> SBaseExtensionPoint

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBaseExtensionPoint(SBaseExtensionPoint rhs)</pre>

        copy constructor
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBaseExtensionPoint(string pkgName, int typeCode)</pre>

        constructor

        """
        this = _libsbml.new_SBaseExtensionPoint(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """
        clone(self) -> SBaseExtensionPoint

        Creates and returns a deep copy of this SBaseExtensionPoint object.

        @return the (deep) copy of this SBaseExtensionPoint object.

        """
        return _libsbml.SBaseExtensionPoint_clone(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        Returns the package name of this extension point.

        """
        return _libsbml.SBaseExtensionPoint_getPackageName(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        Returns the typecode of this extension point.

        """
        return _libsbml.SBaseExtensionPoint_getTypeCode(self)

SBaseExtensionPoint_swigregister = _libsbml.SBaseExtensionPoint_swigregister
SBaseExtensionPoint_swigregister(SBaseExtensionPoint)

class SBasePlugin(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html A libSBML plug-in object for an SBML Level 3 package.

    Additional attributes and/or elements of a package extension which are directly 
    contained by some pre-defined element are contained/accessed by <a href='#SBasePlugin'> 
    SBasePlugin </a> class which is extended by package developers for each extension point.
    The extension point, which represents an element to be extended, is identified by a 
    combination of a Package name and a typecode of the element, and is represented by
    SBaseExtensionPoint class.
    </p>

    <p>
    For example, the layout extension defines <em>&lt;listOfLayouts&gt;</em> element which is 
    directly contained in <em>&lt;model&gt;</em> element of the core package. 
    In the layout package (provided as one of example packages in libSBML-5), the additional 
    element for the model element is implemented as ListOfLayouts class (an SBase derived class) and 
    the object is contained/accessed by a LayoutModelPlugin class (an SBasePlugin derived class). 
    </p>

    <p>
    SBasePlugin class defines basic virtual functions for reading/writing/checking 
    additional attributes and/or top-level elements which should or must be overridden by 
    subclasses like SBase class and its derived classes.
    </p>

    <p>
    Package developers must implement an SBasePlugin exntended class for 
    each element to be extended (e.g. SBMLDocument, Model, ...) in which additional 
    attributes and/or top-level elements of the package extension are directly contained.
    </p>

    To implement reading/writing functions for attributes and/or top-level 
    elements of the SBsaePlugin extended class, package developers should or must
    override the corresponding virtual functions below provided in the SBasePlugin class:

    <ul>
    <li> <p>reading elements : </p>
    <ol>
    <li> <code>virtual SBase createObject (XMLInputStream stream) </code>
    <p>This function must be overridden if one or more additional elements are defined.</p>
    </li>
    <li> <code>virtual bool readOtherXML (SBase parentObject, XMLInputStream stream)</code>
    <p>This function should be overridden if elements of annotation, notes, MathML, etc. need 
    to be directly parsed from the given XMLInputStream object @if clike instead of the
    SBase.readAnnotation()
    and/or SBase.readNotes() functions@endif.
    </p> 
    </li>
    </ol>
    </li>
    <li> <p>reading attributes (must be overridden if additional attributes are defined) :</p>
    <ol>
    <li><code>virtual void addExpectedAttributes(ExpectedAttributes& attributes) </code></li>
    <li><code>virtual void readAttributes (XMLAttributes attributes, const ExpectedAttributes& expectedAttributes)</code></li>
    </ol>
    </li>
    <li> <p>writing elements (must be overridden if additional elements are defined) :</p>
    <ol>
    <li><code>virtual void writeElements (XMLOutputStream stream) const </code></li>
    </ol>
    </li>
    <li> <p>writing attributes : </p>
    <ol>
    <li><code>virtual void writeAttributes (XMLOutputStream stream) const </code>
    <p>This function must be overridden if one or more additional attributes are defined.</p>
    </li>
    <li><code>virtual void writeXMLNS (XMLOutputStream stream) const </code>
    <p>This function must be overridden if one or more additional xmlns attributes are defined.</p>
    </li>
    </ol>
    </li>

    <li> <p>checking elements (should be overridden) :</p>
    <ol>
    <li><code>virtual bool hasRequiredElements() const </code></li>
    </ol>
    </li>

    <li> <p>checking attributes (should be overridden) :</p>
    <ol>
    <li><code>virtual bool hasRequiredAttributes() const </code></li>
    </ol>
    </li>
    </ul>

    <p>
    To implement package-specific creating/getting/manipulating functions of the
    SBasePlugin derived class (e.g., getListOfLayouts(), createLyout(), getLayout(),
    and etc are implemented in LayoutModelPlugin class of the layout package), package
    developers must newly implement such functions (as they like) in the derived class.
    </p>

    <p>
    SBasePlugin class defines other virtual functions of internal implementations
    such as:

    <ul>
    <li><code> virtual void setSBMLDocument(SBMLDocument d) </code>
    <li><code> virtual void connectToParent(SBasesbase) </code>
    <li><code> virtual void enablePackageInternal(string pkgURI, string pkgPrefix, bool flag) </code>
    </ul>

    These functions must be overridden by subclasses in which one or more top-level elements are defined.
    </p>

    <p>
    For example, the following three SBasePlugin extended classes are implemented in
    the layout extension:
    </p>

    <ol>

    <li> <p><a href='class_s_b_m_l_document_plugin.html'> SBMLDocumentPlugin </a> class for SBMLDocument element</p>

    <ul>
    <li> <em> required </em> attribute is added to SBMLDocument object.
    </li>
    </ul>

    <p>
    (<a href='class_s_b_m_l_document_plugin.html'> SBMLDocumentPlugin </a> class is a common SBasePlugin 
    extended class for SBMLDocument class. Package developers can use this class as-is if no additional 
    elements/attributes (except for <em> required </em> attribute) is needed for the SBMLDocument class 
    in their packages, otherwise package developers must implement a new SBMLDocumentPlugin derived class.)
    </p>

    <li> <p>LayoutModelPlugin class for Model element</p>
    <ul>
    <li> &lt;listOfLayouts&gt; element is added to Model object.
    </li>

    <li> <p>
    The following virtual functions for reading/writing/checking
    are overridden: (type of arguments and return values are omitted)
    </p>
    <ul>
    <li> <code> createObject() </code> : (read elements)
    </li>
    <li> <code> readOtherXML() </code> : (read elements in annotation of SBML L2)
    </li>
    <li> <code> writeElements() </code> : (write elements)
    </li>
    </ul>
    </li>

    <li> <p>
    The following virtual functions of internal implementations
    are overridden: (type of arguments and return values are omitted)
    </p>  
    <ul>
    <li> <code> setSBMLDocument() </code> 
    </li>
    <li> <code> connectToParent() </code>
    </li>
    <li> <code> enablePackageInternal() </code>
    </li>
    </ul>
    </li>


    <li> <p>
    The following creating/getting/manipulating functions are newly 
    implemented: (type of arguments and return values are omitted)
    </p>
    <ul>
    <li> <code> getListOfLayouts() </code>
    </li>
    <li> <code> getLayout ()  </code>
    </li>
    <li> <code> addLayout() </code>
    </li>
    <li> <code> createLayout() </code>
    </li>
    <li> <code> removeLayout() </code>
    </li>	   
    <li> <code> getNumLayouts() </code>
    </li>
    </ul>
    </li>

    </ul>
    </li>

    <li> <p>LayoutSpeciesReferencePlugin class for SpeciesReference element (used only for SBML L2V1) </p>

    <ul>
    <li>
    <em> id </em> attribute is internally added to SpeciesReference object
    only for SBML L2V1 
    </li>

    <li>
    The following virtual functions for reading/writing/checking
    are overridden: (type of arguments and return values are omitted)
    </li>

    <ul>
    <li>
    <code> readOtherXML() </code>
    </li>
    <li>
    <code> writeAttributes() </code>
    </li>
    </ul>
    </ul>
    </li>

    </ol>

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBasePlugin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBasePlugin, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBasePlugin
    __del__ = lambda self : None;
    def getElementNamespace(self):
        """
        getElementNamespace(self) -> string

        Returns the XML namespace (URI) of the package extension
        of this plugin object.

        @return the URI of the package extension of this plugin object.

        """
        return _libsbml.SBasePlugin_getElementNamespace(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        Returns the prefix of the package extension of this plugin object.

        @return the prefix of the package extension of this plugin object.

        """
        return _libsbml.SBasePlugin_getPrefix(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        Returns the package name of this plugin object.

        @return the package name of this plugin object.

        """
        return _libsbml.SBasePlugin_getPackageName(self)

    def clone(self):
        """
        clone(self) -> SBasePlugin

        Creates and returns a deep copy of this SBasePlugin object.

        @return the (deep) copy of this SBasePlugin object.

        """
        return _libsbml.SBasePlugin_clone(self)

    def getElementBySId(self, *args):
        """
        getElementBySId(self, string id) -> SBase

        Returns the first child element found that has the given @p id in the model-wide SId namespace, or @c None if no such object is found.

        @param id string representing the id of objects to find

        @return pointer to the first element found with the given @p id.

        """
        return _libsbml.SBasePlugin_getElementBySId(self, *args)

    def getElementByMetaId(self, *args):
        """
        getElementByMetaId(self, string metaid) -> SBase

        Returns the first child element it can find with the given @p metaid, or @c None if no such object is found.

        @param metaid string representing the metaid of objects to find

        @return pointer to the first element found with the given @p metaid.

        """
        return _libsbml.SBasePlugin_getElementByMetaId(self, *args)

    def connectToParent(self, *args):
        """
        connectToParent(self, SBase sbase)

        @internal
        Sets the parent SBML object of this plugin object to
        this object and child elements (if any).
        (Creates a child-parent relationship by this plugin object)

        This function is called when this object is created by
        the parent element.
        Subclasses must override this this function if they have one
        or more child elements. Also, SBasePlugin.connectToParent()
        must be called in the overridden function.

        @param sbase the SBase object to use

        @if cpp 
        @see setSBMLDocument()
        @see enablePackageInternal()
        @endif

        @internal

        """
        return _libsbml.SBasePlugin_connectToParent(self, *args)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with child elements in this plugin 
        object (if any).
        (This is an internal implementation invoked from 
        SBase.enablePackageInternal() function)

        Subclasses which contain one or more SBase derived elements should 
        override this function if elements defined in them can be extended by
        some other package extension.

        @if cpp 
        @see setSBMLDocument()
        @see connectToParent()
        @endif

        @internal

        """
        return _libsbml.SBasePlugin_enablePackageInternal(self, *args)

    def stripPackage(self, *args):
        """
        stripPackage(self, string pkgPrefix, bool flag) -> bool

        @internal

        @internal

        """
        return _libsbml.SBasePlugin_stripPackage(self, *args)

    def getSBMLDocument(self, *args):
        """
        getSBMLDocument(self) -> SBMLDocument
        getSBMLDocument(self) -> SBMLDocument

        Returns the parent SBMLDocument of this plugin object.

        @return the parent SBMLDocument object of this plugin object.

        """
        return _libsbml.SBasePlugin_getSBMLDocument(self, *args)

    def getURI(self):
        """
        getURI(self) -> string

        Gets the URI to which this element belongs to.
        For example, all elements that belong to SBML Level 3 Version 1 Core
        must would have the URI 'http://www.sbml.org/sbml/level3/version1/core'; 
        all elements that belong to Layout Extension Version 1 for SBML Level 3
        Version 1 Core must would have the URI
        'http://www.sbml.org/sbml/level3/version1/layout/version1/'

        Unlike getElementNamespace, this function first returns the URI for this 
        element by looking into the SBMLNamespaces object of the document with 
        the its package name. if not found it will return the result of 
        getElementNamespace

        @return the URI this elements  

        @see getPackageName()
        @see getElementNamespace()
        @see SBMLDocument.getSBMLNamespaces()
        @see getSBMLDocument()

        """
        return _libsbml.SBasePlugin_getURI(self)

    def getParentSBMLObject(self, *args):
        """
        getParentSBMLObject(self) -> SBase
        getParentSBMLObject(self) -> SBase

        Returns the parent SBase object to which this plugin 
        object connected.

        @return the parent SBase object to which this plugin 
        object connected.

        """
        return _libsbml.SBasePlugin_getParentSBMLObject(self, *args)

    def setElementNamespace(self, *args):
        """
        setElementNamespace(self, string uri) -> int

        Sets the XML namespace to which this element belongs to.
        For example, all elements that belong to SBML Level 3 Version 1 Core
        must set the namespace to 'http://www.sbml.org/sbml/level3/version1/core'; 
        all elements that belong to Layout Extension Version 1 for SBML Level 3
        Version 1 Core must set the namespace to 
        'http://www.sbml.org/sbml/level3/version1/layout/version1/'

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.SBasePlugin_setElementNamespace(self, *args)

    def getLevel(self):
        """
        getLevel(self) -> unsigned int

        Returns the SBML level of the package extension of 
        this plugin object.

        @return the SBML level of the package extension of
        this plugin object.

        """
        return _libsbml.SBasePlugin_getLevel(self)

    def getVersion(self):
        """
        getVersion(self) -> unsigned int

        Returns the SBML version of the package extension of
        this plugin object.

        @return the SBML version of the package extension of
        this plugin object.

        """
        return _libsbml.SBasePlugin_getVersion(self)

    def getPackageVersion(self):
        """
        getPackageVersion(self) -> unsigned int

        Returns the package version of the package extension of
        this plugin object.

        @return the package version of the package extension of
        this plugin object.

        """
        return _libsbml.SBasePlugin_getPackageVersion(self)

    def replaceSIDWithFunction(self, *args):
        """
        replaceSIDWithFunction(self, string id, ASTNode function)

        @internal
        If this object has a child 'math' object (or anything with ASTNodes in general), replace all nodes with the name 'id' with the provided function. 

        @note This function does nothing itself--subclasses with ASTNode subelements must override this function.

        @internal

        """
        return _libsbml.SBasePlugin_replaceSIDWithFunction(self, *args)

    def divideAssignmentsToSIdByFunction(self, *args):
        """
        divideAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If the function of this object is to assign a value has a child 'math' object (or anything with ASTNodes in general), replace  the 'math' object with the function (existing/function).  

        @note This function does nothing itself--subclasses with ASTNode subelements must override this function.

        @internal

        """
        return _libsbml.SBasePlugin_divideAssignmentsToSIdByFunction(self, *args)

    def multiplyAssignmentsToSIdByFunction(self, *args):
        """
        multiplyAssignmentsToSIdByFunction(self, string id, ASTNode function)

        @internal
        If this assignment assigns a value to the 'id' element, replace the 'math' object with the function (existing*function).

        @internal

        """
        return _libsbml.SBasePlugin_multiplyAssignmentsToSIdByFunction(self, *args)

    def hasIdentifierBeginningWith(self, *args):
        """
        hasIdentifierBeginningWith(self, string prefix) -> bool

        @internal
        Check to see if the given prefix is used by any of the IDs defined by extension elements.  A package that defines its own 'id' attribute for a core element would check that attribute here.

        @internal

        """
        return _libsbml.SBasePlugin_hasIdentifierBeginningWith(self, *args)

    def prependStringToAllIdentifiers(self, *args):
        """
        prependStringToAllIdentifiers(self, string prefix) -> int

        @internal
        Add the given string to all identifiers in the object.  If the string is added to anything other than an id or a metaid, this code is responsible for tracking down and renaming all *idRefs in the package extention that identifier comes from.

        @internal

        """
        return _libsbml.SBasePlugin_prependStringToAllIdentifiers(self, *args)

    def transformIdentifiers(self, *args):
        """
        transformIdentifiers(self, IdentifierTransformer sidTransformer) -> int

        @internal

        @internal

        """
        return _libsbml.SBasePlugin_transformIdentifiers(self, *args)

    def getLine(self):
        """
        getLine(self) -> unsigned int

        @internal
        Returns the line number on which this object first appears in the XML
        representation of the SBML document.

        @return the line number of the underlying SBML object.

        @note The line number for each construct in an SBML model is set upon
        reading the model.  The accuracy of the line number depends on the
        correctness of the XML representation of the model, and on the
        particular XML parser library being used.  The former limitation
        relates to the following problem: if the model is actually invalid
        XML, then the parser may not be able to interpret the data correctly
        and consequently may not be able to establish the real line number.
        The latter limitation is simply that different parsers seem to have
        their own accuracy limitations, and out of all the parsers supported
        by libSBML, none have been 100% accurate in all situations. (At this
        time, libSBML supports the use of <a target='_blank'
        href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'
        href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'
        href='http://xerces.apache.org/xerces-c/'>Xerces</a>.)

        @see getColumn()

        @internal

        """
        return _libsbml.SBasePlugin_getLine(self)

    def getColumn(self):
        """
        getColumn(self) -> unsigned int

        @internal
        Returns the column number on which this object first appears in the XML
        representation of the SBML document.

        @return the column number of the underlying SBML object.

        @note The column number for each construct in an SBML model is set
        upon reading the model.  The accuracy of the column number depends on
        the correctness of the XML representation of the model, and on the
        particular XML parser library being used.  The former limitation
        relates to the following problem: if the model is actually invalid
        XML, then the parser may not be able to interpret the data correctly
        and consequently may not be able to establish the real column number.
        The latter limitation is simply that different parsers seem to have
        their own accuracy limitations, and out of all the parsers supported
        by libSBML, none have been 100% accurate in all situations. (At this
        time, libSBML supports the use of <a target='_blank'
        href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'
        href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'
        href='http://xerces.apache.org/xerces-c/'>Xerces</a>.)

        @see getLine()

        @internal

        """
        return _libsbml.SBasePlugin_getColumn(self)

    def getSBMLNamespaces(self):
        """
        getSBMLNamespaces(self) -> SBMLNamespaces

        @internal

        @internal

        """
        return _libsbml.SBasePlugin_getSBMLNamespaces(self)

    def logUnknownElement(self, *args):
        """
        logUnknownElement(self, string element, unsigned int sbmlLevel, unsigned int sbmlVersion, 
            unsigned int pkgVersion)

        @internal
        Helper to log a common type of error for elements.

        @internal

        """
        return _libsbml.SBasePlugin_logUnknownElement(self, *args)

    __metaclass__ = AutoProperty

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    def getListOfAllElements(self, filter = None):
        """
        getListOfAllElements(self, ElementFilter filter = None) -> SBaseList
        getListOfAllElements(self) -> SBaseList

        @return an SBaseList of all child SBase objects, including those
        nested to an arbitrary depth.

        @return a list of all child objects.

        """
        return _libsbml.SBasePlugin_getListOfAllElements(self, filter)

SBasePlugin_swigregister = _libsbml.SBasePlugin_swigregister
SBasePlugin_swigregister(SBasePlugin)

class SBMLDocumentPlugin(SBasePlugin):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base class for SBML Level 3 package plug-ins.

    Plug-in objects for the SBMLDocument element must be this class or a
    derived class of this class.  Package developers should use this class
    as-is if only 'required' attribute is added in the SBMLDocument element by
    their packages.  Otherwise, developers must implement a derived class of
    this class and use that class as the plugin object for the SBMLDocument
    element.

    """
    __swig_setmethods__ = {}
    for _s in [SBasePlugin]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLDocumentPlugin, name, value)
    __swig_getmethods__ = {}
    for _s in [SBasePlugin]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLDocumentPlugin, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string uri, string prefix, SBMLNamespaces sbmlns) -> SBMLDocumentPlugin
        __init__(self, SBMLDocumentPlugin orig) -> SBMLDocumentPlugin

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLDocumentPlugin(string &uri, string &prefix, SBMLNamespacessbmlns)</pre>

        Constructor

        @param uri the URI of package 
        @param prefix the prefix for the given package
        @param sbmlns the SBMLNamespaces object for the package
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>SBMLDocumentPlugin(SBMLDocumentPlugin orig)</pre>

        Copy constructor. Creates a copy of this object.

        """
        this = _libsbml.new_SBMLDocumentPlugin(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLDocumentPlugin
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> SBMLDocumentPlugin

        Creates and returns a deep copy of this SBMLDocumentPlugin object.

        @return the (deep) copy of this SBMLDocumentPlugin object.

        """
        return _libsbml.SBMLDocumentPlugin_clone(self)

    def setRequired(self, *args):
        """
        setRequired(self, bool value) -> int

        Sets the bool value of 'required' attribute of corresponding package
        in SBMLDocument element.

        @param value the bool value of 'required' attribute of corresponding 
        package in SBMLDocument element.

        @return integer value indicating success/failure of the
        function.  The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.SBMLDocumentPlugin_setRequired(self, *args)

    def getRequired(self):
        """
        getRequired(self) -> bool

        Returns the bool value of 'required' attribute of corresponding 
        package in SBMLDocument element.

        @return the bool value of 'required' attribute of corresponding
        package in SBMLDocument element.

        """
        return _libsbml.SBMLDocumentPlugin_getRequired(self)

    def isSetRequired(self):
        """
        isSetRequired(self) -> bool

        Predicate returning @c True or @c False depending on whether this
        SBMLDocumentPlugin's 'required' attribute has been set.

        @return @c True if the 'required' attribute of this SBMLDocument has been
        set, @c False otherwise.

        """
        return _libsbml.SBMLDocumentPlugin_isSetRequired(self)

    def unsetRequired(self):
        """
        unsetRequired(self) -> int

        Unsets the value of the 'required' attribute of this SBMLDocumentPlugin.

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.SBMLDocumentPlugin_unsetRequired(self)

    def isCompFlatteningImplemented(self):
        """
        isCompFlatteningImplemented(self) -> bool

        @internal

        @internal

        """
        return _libsbml.SBMLDocumentPlugin_isCompFlatteningImplemented(self)

    def checkConsistency(self):
        """
        checkConsistency(self) -> unsigned int

        @internal
        Check consistency function.

        @internal

        """
        return _libsbml.SBMLDocumentPlugin_checkConsistency(self)

SBMLDocumentPlugin_swigregister = _libsbml.SBMLDocumentPlugin_swigregister
SBMLDocumentPlugin_swigregister(SBMLDocumentPlugin)

class SBMLExtension(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Core class for SBML Level 3 package plug-ins.

    @ifnot clike @internal @endif@~

    SBMLExtension class (abstract class) is a core component of package extension
    which needs to be extended by package developers. 
    The class provides functions for getting common attributes of package extension 
    (e.g., package name, package version, and etc.), functions for adding (registering) 
    each instantiated SBasePluginCreator object, and a static function (defined in each 
    SBMLExtension extended class) for initializing/registering the package extension 
    when the library of the package is loaded.

    @section howto How to implement an SBMLExtension extended class for each package extension

    Package developers must implement an SBMLExtension extended class for
    their packages (e.g. GroupsExtension class is implemented for groups extension).
    The extended class is implemented based on the following steps:

    (NOTE: 
    'src/packages/groups/extension/GroupsExtension.{h,cpp}' and
    'src/packages/layout/extension/LayoutExtension.{h,cpp}' are
    example files in which SBMLExtension derived classes are implemented)

    <ol>

    <li> Define the following static functions in the extended class:
    (examples of groups extension are shown respectively)
    <ol>
    <li> <p>A string of package name (label) (The function name must be 'getPackageName'.)</p>

    @verbatim
      string GroupsExtension.getPackageName ()
      {
    	static string pkgName = 'groups';
    	return pkgName;
      }
    @endverbatim
    </li>

    <li> <p>
    Methods returning an integer of Default SBML level, version, and package version
    (The method names must be 'getDefaultLevel()', 'getDefaultVersion()', and 
    'getDefaultPackageVersion()' respectively.)
    </p>
    @verbatim
      long GroupsExtension.getDefaultLevel()
      {
    	return 3;
      }  
      long GroupsExtension.getDefaultVersion()
      {
    	return 1; 
      }
      long GroupsExtension.getDefaultPackageVersion()
      {
    	return 1;
      }  
    @endverbatim
    </li>
    <li> <p> Methods returning Strings that represent the URI of packages </p>
    @verbatim
      string GroupsExtension.getXmlnsL3V1V1 ()
      {
    	static string xmlns = 'http://www.sbml.org/sbml/level3/version1/groups/version1';
    	return xmlns;
      }
    @endverbatim 
    </li>
    <li> <p>Strings that represent the other URI needed in this package (if any) </p>
    </li>
    </ol> 
    </li>

    <li> Override the following pure virtual functions
          <ul>
           <li> <code>virtual string getName () const =0</code>. This function returns the name of the package (e.g., 'layout', 'groups'). </li>
           <li> <code>virtual long getLevel (string &uri) const =0</code>. This function returns the SBML level with the given URI of this package. </li>
           <li> <code>virtual long getVersion (string &uri) const =0</code>. This function returns the SBML version with the given URI of this package. </li>
           <li> <code>virtual long getPackageVersion (string &uri) const =0</code>. This function returns the package version with the given URI of this package.</li>
           <li> <code>virtual long getURI (long sbmlLevel, long sbmlVersion, long pkgVersion) const =0</code>. 
                 This function returns the URI (namespace) of the package corresponding to the combination of the given sbml level, sbml version, and pacakege version</li>
           <li> <code>virtual SBMLExtension clone () const = 0</code>. This function creates and returns a deep copy of this derived object.</li>
          </ul>
          <p>For example, the above functions are overridden in the groups
    	package ('src/packages/groups/extension/GroupsExtension.cpp') as follows:</p>
    @verbatim
    string
    GroupsExtension.getName() const
    {
      return getPackageName();
    }

    long 
    GroupsExtension.getLevel() const
    {
      if (uri == getXmlnsL3V1V1())
      {
        return 3;
      }
      
      return 0;
    }

    long 
    GroupsExtension.getVersion() const
    {
      if (uri == getXmlnsL3V1V1())
      {
        return 1;
      }

      return 0;
    }

    long
    GroupsExtension.getPackageVersion() const
    {
      if (uri == getXmlnsL3V1V1())
      {
        return 1;
      }

      return 0;
    }

    string 
    GroupsExtension.getURI() const
    {
      if (sbmlLevel == 3)
      {
        if (sbmlVersion == 1)
        {
          if (pkgVersion == 1)
          {
            return getXmlnsL3V1V1();
          }
        }
      }

      static string empty = '';

      return empty;
    }

    GroupsExtension* 
    GroupsExtension.clone () const
    {
      return new GroupsExtension(*this);  
    }
    @endverbatim

    Constructor, copy Constructor, and destructor also must be overridden
    if additional data members are defined in the derived class.

    </li>

    <li> <p>
    Define typedef and template instantiation code for the package specific SBMLExtensionNamespaces template class
    </p>

    <ol>
    <li> typedef for the package specific SBMLExtensionNamespaces template class
    <p> For example, the typedef for GroupsExtension (defined in the groups package) is implemented in GroupsExtension.h as follows:</p>
    @verbatim
      // GroupsPkgNamespaces is derived from the SBMLNamespaces class and used when creating an object of 
      // SBase derived classes defined in groups package.
      typedef SBMLExtensionNamespaces<GroupsExtension> GroupsPkgNamespaces;
    @endverbatim
    </li>

    <li> template instantiation code for the above typedef definition in the implementation file (i.e., *.cpp file).
    <p> For example, the template instantiation code for GroupsExtension is implemented in GroupsExtension.cpp 
    as follows:
    </p>

    @verbatim
      // Instantiate SBMLExtensionNamespaces<GroupsExtension> (GroupsPkgNamespaces) for DLL.
      template class LIBSBML_EXTERN SBMLExtensionNamespaces<GroupsExtension>;
    @endverbatim

    </li>
    </ol>

    <p> The SBMLExtensionNamespaces template class is a derived class of
    SBMLNamespaces and can be used as an argument of constructors 
    of SBase derived classes defined in the package extensions.
    For example, a GroupsPkgNamespaces object can be used when creating a group 
    object as follows:
    </P>
    @verbatim
       GroupPkgNamespaces gpns(3,1,1);  // The arguments are SBML Level, SBML Version, and Groups Package Version.

       Group g = new Group(&gpns);      // Creates a group object of L3V1 Groups V1.
    @endverbatim

    <p>
    Also, the GroupsPkgNamespaces object can be used when creating an
    SBMLDocument object with the groups package as follows:
    </p>

    @verbatim
       GroupsPkgNamespaces gpns(3,1,1);
       SBMLDocument doc;

       doc  = new SBMLDocument(&gnps); // Creates an SBMLDocument of L3V1 with Groups V1.
    @endverbatim

    </li>

    <li> Override the following pure virtual function which returns the SBMLNamespaces derived object 
    @verbatim
           virtual SBMLNamespaces getSBMLExtensionNamespaces (string &uri) const =0
    @endverbatim
    <p> For example, the function is overridden in GroupsExtension
     class as follows:</p>
    @verbatim
    SBMLNamespaces
    GroupsExtension.getSBMLExtensionNamespaces() const
    {
      GroupsPkgNamespaces* pkgns = None;
      if ( uri == getXmlnsL3V1V1())
      {
        pkgns = new GroupsPkgNamespaces(3,1,1);    
      }  
      return pkgns;
    }
    @endverbatim
       </li>


    <li> Define an enum type for representing the typecode of elements (SBase extended classes) defined in the package extension

    <p>  For example, SBMLGroupsTypeCode_t for groups package is
    defined in GroupsExtension.h as follows: </p>
    @verbatim
          typedef enum
          {
             SBML_GROUPS_GROUP  = 200
           , SBML_GROUPS_MEMBER = 201
          } SBMLGroupsTypeCode_t;
    @endverbatim    

    <p> <em>SBML_GROUPS_GROUP</em> corresponds to the Group class (&lt;group&gt;)
    and <em>SBML_GROUPS_MEMBER</em> corresponds to the Member (&lt;member&gt;) class, respectively.


    <p> Similarly, SBMLLayoutTypeCode_t 
    for layout package is defined in LayoutExtension.h as follows: </p>

    @verbatim  
          typedef enum
          {
             SBML_LAYOUT_BOUNDINGBOX           = 100
           , SBML_LAYOUT_COMPARTMENTGLYPH      = 101
           , SBML_LAYOUT_CUBICBEZIER           = 102
           , SBML_LAYOUT_CURVE                 = 103
           , SBML_LAYOUT_DIMENSIONS            = 104
           , SBML_LAYOUT_GRAPHICALOBJECT       = 105
           , SBML_LAYOUT_LAYOUT                = 106   
           , SBML_LAYOUT_LINESEGMENT           = 107   
           , SBML_LAYOUT_POINT                 = 108    
           , SBML_LAYOUT_REACTIONGLYPH         = 109    
           , SBML_LAYOUT_SPECIESGLYPH          = 110    
           , SBML_LAYOUT_SPECIESREFERENCEGLYPH = 111
           , SBML_LAYOUT_TEXTGLYPH             = 112
          } SBMLLayoutTypeCode_t;
    @endverbatim

    <p>
    These enum values are returned by corresponding getTypeCode() functions.
    (e.g. SBML_GROUPS_GROUP is returned in Group.getTypeCode())
    </p>

    <p>
    The value of each typecode can be duplicated between those of different 
    packages (In the above SBMLLayoutTypeCode_t and SBMLGroupsTypeCode_t types, 
    unique values are assigned to enum values, but this is not mandatory.)
    </p>

    <p>
    Thus, to distinguish the typecodes of different packages, not only the return
    value of getTypeCode() function but also that of getPackageName()
    function should be checked as follows:
    </p>
    @verbatim
              void example (SBasesb)
              {
                string pkgName = sb->getPackageName();
                if (pkgName == 'core') {
                  switch (sb->getTypeCode()) {
                    case SBML_MODEL:
                       ....
                       break;
                    case SBML_REACTION:
                       ....
                  }
                } 
                else if (pkgName == 'layout') {
                  switch (sb->getTypeCode()) {
                    case SBML_LAYOUT_LAYOUT:
                       ....
                       break;
                    case SBML_LAYOUT_REACTIONGLYPH:
                       ....
                  }
                } 
                else if (pkgName == 'groups') {
                  switch (sb->getTypeCode()) {
                    case SBML_GROUPS_GROUP:
                       ....
                       break;
                    case SBML_GROUPS_MEMBER:
                       ....
                  }
                }
                ...
              } 
    @endverbatim

    </li>
    <li> Override the following pure virtual function which returns a string corresponding to the given typecode:

    @verbatim  
           virtual string SBMLExtension.getStringFromTypeCode() const;
    @endverbatim 

    <p> For example, the function for groups extension is implemented as follows: </p>
    @verbatim  
    static
    string SBML_GROUPS_TYPECODE_STRINGS[] =
    {
        'Group'
      , 'Member'
    };

    string 
    GroupsExtension.getStringFromTypeCode() const
    {
      int min = SBML_GROUPS_GROUP;
      int max = SBML_GROUPS_MEMBER;

      if ( typeCode < min || typeCode > max)
      {
        return '(Unknown SBML Groups Type)';  
      }

      return SBML_GROUPS_TYPECODE_STRINGS[typeCode - min];
    }
    @endverbatim 

    </li>

    <li> Implements a 'static void init()' function in the derived class

    <p> In the init() function, initialization code which creates an instance of 
    the derived class and registering code which registers the instance to 
    SBMLExtensionRegistry class are implemented.
    </p>

    For example, the init() function for groups package is implemented as follows: 
    @verbatim
    void 
    GroupsExtension.init()
    {
      //-------------------------------------------------------------------------
      //
      // 1. Checks if the groups package has already been registered.
      //
      //-------------------------------------------------------------------------

      if ( SBMLExtensionRegistry.getInstance().isRegistered(getPackageName()) )
      {
        // do nothing;
        return;
      }

      //-------------------------------------------------------------------------
      //
      // 2. Creates an SBMLExtension derived object.
      //
      //-------------------------------------------------------------------------

      GroupsExtension groupsExtension;

      //-------------------------------------------------------------------------------------
      //
      // 3. Creates SBasePluginCreatorBase derived objects required for this 
      //    extension. The derived classes can be instantiated by using the following 
      //     template class.
      //
      //    temaplate<class SBasePluginType> class SBasePluginCreator
      //
      //    The constructor of the creator class has two arguments:
      //
      //        (1) SBaseExtensionPoint : extension point to which the plugin object connected
      //        (2) std::vector<string> : a std::vector object that contains a list of URI
      //                                       (package versions) supported by the plugin object.
      //
      //    For example, two plugin objects (plugged in SBMLDocument and Model elements) are 
      //    required for the groups extension.
      //
      //    Since only 'required' attribute is used in SBMLDocument by the groups package, and
      //    the 'required' flag must always be 'false', the existing
      //    SBMLDocumentPluginNotRequired class can be used as-is for the plugin.
      //
      //    Since the lists of supported package versions (currently only L3V1-groups-V1 supported )
      //    are equal in the both plugin objects, the same vector object is given to each 
      //    constructor.
      //
      //---------------------------------------------------------------------------------------

      std::vector<string> packageURIs;
      packageURIs.push_back(getXmlnsL3V1V1());

      SBaseExtensionPoint sbmldocExtPoint('core',SBML_DOCUMENT);
      SBaseExtensionPoint modelExtPoint('core',SBML_MODEL);

      SBasePluginCreator<SBMLDocumentPluginNotRequired, GroupsExtension> sbmldocPluginCreator(sbmldocExtPoint,packageURIs);
      SBasePluginCreator<GroupsModelPlugin,   GroupsExtension> modelPluginCreator(modelExtPoint,packageURIs);

      //--------------------------------------------------------------------------------------
      //
      // 3. Adds the above SBasePluginCreatorBase derived objects to the SBMLExtension derived object.
      //
      //--------------------------------------------------------------------------------------

      groupsExtension.addSBasePluginCreator(&sbmldocPluginCreator);
      groupsExtension.addSBasePluginCreator(&modelPluginCreator);

      //-------------------------------------------------------------------------
      //
      // 4. Registers the SBMLExtension derived object to SBMLExtensionRegistry
      //
      //-------------------------------------------------------------------------

      int result = SBMLExtensionRegistry.getInstance().addExtension(&groupsExtension);

      if (result != LIBSBML_OPERATION_SUCCESS)
      {
        std::cerr << '[Error] GroupsExtension.init() failed.' << std::endl;
      }
    }
    @endverbatim
    </p> 
    </li>

    <li> Instantiate a global SBMLExtensionRegister variable in appropriate 
    implementation file

    <p> For example, the global variable for the groups extension is instantiated in GroupsExtension.cpp as follows: </p>
    @verbatim
      static SBMLExtensionRegister<GroupsExtension> groupsExtensionRegister;
    @endverbatim
    The init() function is invoked when the global variable is instantiated,
    by which initialization and registering the package extension are performed.
    </li>


    </ol>

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLExtension, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLExtension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_SBMLExtension
    __del__ = lambda self : None;
    def getNumOfSBasePlugins(self):
        """
        getNumOfSBasePlugins(self) -> int

        Returns the number of SBasePlugin objects stored in this object.

        @return the number of SBasePlugin objects stored in this object.

        """
        return _libsbml.SBMLExtension_getNumOfSBasePlugins(self)

    def getNumOfSupportedPackageURI(self):
        """
        getNumOfSupportedPackageURI(self) -> unsigned int

        Returns the number of supported package Namespace (package versions) of this 
        package extension.

        @return the number of supported package Namespace (package versions) of this 
        package extension.

        """
        return _libsbml.SBMLExtension_getNumOfSupportedPackageURI(self)

    def isSupported(self, *args):
        """
        isSupported(self, string uri) -> bool

        Returns a flag indicating, whether the given URI (package version) is 
        supported by this package extension.

        @return true if the given URI (package version) is supported by this 
        package extension, otherwise false is returned.

        """
        return _libsbml.SBMLExtension_isSupported(self, *args)

    def getSupportedPackageURI(self, *args):
        """
        getSupportedPackageURI(self, unsigned int i) -> string

        Returns the ith URI (the supported package version)

        @param i the index of the list of URI (the list of supporeted package versions)
        @return the URI of supported package version with the given index.

        """
        return _libsbml.SBMLExtension_getSupportedPackageURI(self, *args)

    def clone(self):
        """
        clone(self) -> SBMLExtension

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        Creates and returns a deep copy of this SBMLExtension object.

        @return a (deep) copy of this SBase object

        """
        return _libsbml.SBMLExtension_clone(self)

    def getName(self):
        """
        getName(self) -> string

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        Returns the name of this package (e.g. 'layout', 'multi').

        @return the name of package extension

        """
        return _libsbml.SBMLExtension_getName(self)

    def getURI(self, *args):
        """
        getURI(self, unsigned int sbmlLevel, unsigned int sbmlVersion, unsigned int pkgVersion) -> string

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        Returns the uri corresponding to the given SBML level, SBML version, and package version.

        @param sbmlLevel the level of SBML
        @param sbmlVersion the version of SBML
        @param pkgVersion the version of package

        @return a string of the package URI

        """
        return _libsbml.SBMLExtension_getURI(self, *args)

    def getLevel(self, *args):
        """
        getLevel(self, string uri) -> unsigned int

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        Returns the SBML level associated with the given URI of this package.

        @param uri the string of URI that represents a versions of the package
        @return the SBML level associated with the given URI of this package.

        """
        return _libsbml.SBMLExtension_getLevel(self, *args)

    def getVersion(self, *args):
        """
        getVersion(self, string uri) -> unsigned int

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        Returns the SBML version associated with the given URI of this package.

        @param uri the string of URI that represents a versions of the package
        @return the SBML version associated with the given URI of this package.

        """
        return _libsbml.SBMLExtension_getVersion(self, *args)

    def getPackageVersion(self, *args):
        """
        getPackageVersion(self, string uri) -> unsigned int

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        Returns the package version associated with the given URI of this package.

        @param uri the string of URI that represents a versions of this package
        @return the package version associated with the given URI of this package.

        """
        return _libsbml.SBMLExtension_getPackageVersion(self, *args)

    def getStringFromTypeCode(self, *args):
        """
        getStringFromTypeCode(self, int typeCode) -> char

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function 
        in their derived class.

        This method takes a type code of this package and returns a string 
        representing the code.

        """
        return _libsbml.SBMLExtension_getStringFromTypeCode(self, *args)

    def getSBMLExtensionNamespaces(self, *args):
        """
        getSBMLExtensionNamespaces(self, string uri) -> SBMLNamespaces

        (NOTICE) Package developers MUST OVERRIDE this pure virtual function in 
        their derived class.

        Returns an SBMLExtensionNamespaces<class SBMLExtensionType> object 
        (e.g. SBMLExtensionNamespaces<LayoutExtension> whose alias type is 
        LayoutPkgNamespaces) corresponding to the given uri.
        Null will be returned if the given uri is not defined in the corresponding 
        package.

        @param uri the string of URI that represents one of versions of the package
        @return an SBMLExtensionNamespaces<class SBMLExtensionType> object. None
        will be returned if the given uri is not defined in the corresponding 
        package.

        """
        return _libsbml.SBMLExtension_getSBMLExtensionNamespaces(self, *args)

    def setEnabled(self, *args):
        """
        setEnabled(self, bool isEnabled) -> bool

        enable/disable this package.
        Returned value is the result of this function.

        @param isEnabled the bool value: true (enabled) or false (disabled)

        @return true if this function call succeeded, otherwise false is returned.

        """
        return _libsbml.SBMLExtension_setEnabled(self, *args)

    def isEnabled(self):
        """
        isEnabled(self) -> bool

        Check if this package is enabled (true) or disabled (false).

        @return true if this package is enabled, otherwise false is returned.

        """
        return _libsbml.SBMLExtension_isEnabled(self)

    def removeL2Namespaces(self, *args):
        """
        removeL2Namespaces(self, XMLNamespaces xmlns)

        Removes the L2 Namespaces. 

        This method should be overridden by all extensions that want to serialize
        to an L2 annotation.

        """
        return _libsbml.SBMLExtension_removeL2Namespaces(self, *args)

    def addL2Namespaces(self, *args):
        """
        addL2Namespaces(self, XMLNamespaces xmlns)

        Adds all L2 Extension namespaces to the namespace list. 

        This method should be overridden by all extensions that want to serialize
        to an L2 annotation.

        """
        return _libsbml.SBMLExtension_addL2Namespaces(self, *args)

    def enableL2NamespaceForDocument(self, *args):
        """
        enableL2NamespaceForDocument(self, SBMLDocument doc)

        Adds the L2 Namespace to the document and enables the extension.

        If the extension supports serialization to SBML L2 Annotations, this 
        method should be overrridden, so it will be activated.

        """
        return _libsbml.SBMLExtension_enableL2NamespaceForDocument(self, *args)

    def isInUse(self, *args):
        """
        isInUse(self, SBMLDocument doc) -> bool

        Indicates whether this extension is being used by the given SBMLDocument.

        The default implementation returns true. This means that when a document
        had this extension enabled, it will not be possible to convert it to L2
        as we cannot make sure that the extension can be converted.

        @param doc the SBML document to test. 

        @return a boolean indicating whether the extension is actually being used
        by the document.

        """
        return _libsbml.SBMLExtension_isInUse(self, *args)

    def getErrorTableIndex(self, *args):
        """
        getErrorTableIndex(self, unsigned int errorId) -> unsigned int

        @internal

        @internal

        """
        return _libsbml.SBMLExtension_getErrorTableIndex(self, *args)

    def getErrorIdOffset(self):
        """getErrorIdOffset(self) -> unsigned int"""
        return _libsbml.SBMLExtension_getErrorIdOffset(self)

    def getSeverity(self, *args):
        """getSeverity(self, unsigned int index, unsigned int pkgVersion) -> unsigned int"""
        return _libsbml.SBMLExtension_getSeverity(self, *args)

    def getCategory(self, *args):
        """getCategory(self, unsigned int index) -> unsigned int"""
        return _libsbml.SBMLExtension_getCategory(self, *args)

    def getMessage(self, *args):
        """getMessage(self, unsigned int index, unsigned int pkgVersion, string details) -> string"""
        return _libsbml.SBMLExtension_getMessage(self, *args)

    def getShortMessage(self, *args):
        """getShortMessage(self, unsigned int index) -> string"""
        return _libsbml.SBMLExtension_getShortMessage(self, *args)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

SBMLExtension_swigregister = _libsbml.SBMLExtension_swigregister
SBMLExtension_swigregister(SBMLExtension)

class SBMLExtensionException(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Exceptions thrown by SBML Level 3 package plug-ins.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLExtensionException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLExtensionException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string errmsg) -> SBMLExtensionException

        constructor

        """
        this = _libsbml.new_SBMLExtensionException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_SBMLExtensionException
    __del__ = lambda self : None;
SBMLExtensionException_swigregister = _libsbml.SBMLExtensionException_swigregister
SBMLExtensionException_swigregister(SBMLExtensionException)

class SBMLExtensionRegistry(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Registry where package plug-ins are registered.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLExtensionRegistry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLExtensionRegistry, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def getInstance():
        """
        getInstance() -> SBMLExtensionRegistry

        Returns an instance (singleton) of the SBMLExtensionRegistry class.
        This function needs to be invoked when manipulating the SBMLExtensionRegistry class. 

        @return the instance of the SBMLExtensionRegistry object.

        """
        return _libsbml.SBMLExtensionRegistry_getInstance()

    if _newclass:getInstance = staticmethod(getInstance)
    __swig_getmethods__["getInstance"] = lambda x: getInstance
    def addExtension(self, *args):
        """
        addExtension(self, SBMLExtension ext) -> int

        Add the given SBMLExtension to this SBMLExtensionRegistry.

        @param ext the SBMLExtension object to be added.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_PKG_CONFLICT LIBSBML_PKG_CONFLICT@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        """
        return _libsbml.SBMLExtensionRegistry_addExtension(self, *args)

    def getExtension(self, *args):
        """
        getExtension(self, string package) -> SBMLExtension

        Returns an SBMLExtension object with the given package URI or package name (string).

        @param package the URI or name of the package extension

        @return a clone of the SBMLExtension object with the given package URI or name. The returned 
        extension is to be freed (i.e.: deleted) by the caller!

        """
        return _libsbml.SBMLExtensionRegistry_getExtension(self, *args)

    def removeL2Namespaces(self, *args):
        """
        removeL2Namespaces(self, XMLNamespaces xmlns)

        Remove all L2 Extension namespaces from the namespace list. This will call all 
        overriden SBMLExtension::removeL2Namespaces methods.

        """
        return _libsbml.SBMLExtensionRegistry_removeL2Namespaces(self, *args)

    def addL2Namespaces(self, *args):
        """
        addL2Namespaces(self, XMLNamespaces xmlns)

        adds all L2 Extension namespaces to the namespace list. This will call all 
        overriden SBMLExtension::addL2Namespaces methods.

        """
        return _libsbml.SBMLExtensionRegistry_addL2Namespaces(self, *args)

    def enableL2NamespaceForDocument(self, *args):
        """
        enableL2NamespaceForDocument(self, SBMLDocument doc)

        Enables all extensions that support serialization / deserialization with
        SBML Annotations.

        """
        return _libsbml.SBMLExtensionRegistry_enableL2NamespaceForDocument(self, *args)

    def disableUnusedPackages(self, *args):
        """
        disableUnusedPackages(self, SBMLDocument doc)

        Goes through all extensions in the list of plugins of the given document
        and disables all plugins that are not being used.

        """
        return _libsbml.SBMLExtensionRegistry_disableUnusedPackages(self, *args)

    def disablePackage(*args):
        """
        disablePackage(string package)

        Disables the package with the given URI / name.

        """
        return _libsbml.SBMLExtensionRegistry_disablePackage(*args)

    if _newclass:disablePackage = staticmethod(disablePackage)
    __swig_getmethods__["disablePackage"] = lambda x: disablePackage
    def isPackageEnabled(*args):
        """
        isPackageEnabled(string package) -> bool

        If the given @p package is enabled, returns @c True; otherwise,
        returns @c False.

        @return the status (enabled = <b>true</b>, disabled = <b>false</b> of the given package.

        """
        return _libsbml.SBMLExtensionRegistry_isPackageEnabled(*args)

    if _newclass:isPackageEnabled = staticmethod(isPackageEnabled)
    __swig_getmethods__["isPackageEnabled"] = lambda x: isPackageEnabled
    def enablePackage(*args):
        """
        enablePackage(string package)

        Enables the package with the given URI / name.

        """
        return _libsbml.SBMLExtensionRegistry_enablePackage(*args)

    if _newclass:enablePackage = staticmethod(enablePackage)
    __swig_getmethods__["enablePackage"] = lambda x: enablePackage
    def getNumExtension(self, *args):
        """
        getNumExtension(self, SBaseExtensionPoint extPoint) -> unsigned int

        Returns the number of SBMLExtension with the given extension point.

        @param extPoint the SBaseExtensionPoint

        @return the number of SBMLExtension with the given extension point.

        """
        return _libsbml.SBMLExtensionRegistry_getNumExtension(self, *args)

    def setEnabled(self, *args):
        """
        setEnabled(self, string uri, bool isEnabled) -> bool

        Enable/disable the package with the given uri.

        @param uri the URI of the target package.
        @param isEnabled the bool value corresponding to enabled (true) or 
        disabled (false)

        @return false will be returned if the given bool value is false 
        or the given package is not registered, otherwise true will be
        returned.

        """
        return _libsbml.SBMLExtensionRegistry_setEnabled(self, *args)

    def isEnabled(self, *args):
        """
        isEnabled(self, string uri) -> bool

        Checks if the extension with the given URI is enabled (true) or 
        disabled (false)

        @param uri the URI of the target package.

        @return false will be returned if the given package is disabled 
        or not registered, otherwise true will be returned.

        """
        return _libsbml.SBMLExtensionRegistry_isEnabled(self, *args)

    def isRegistered(self, *args):
        """
        isRegistered(self, string uri) -> bool

        Checks if the extension with the given URI is registered (true) 
        or not (false)

        @param uri the URI of the target package.

        @return true will be returned if the package with the given URI
        is registered, otherwise false will be returned.

        """
        return _libsbml.SBMLExtensionRegistry_isRegistered(self, *args)

    def getNumRegisteredPackages():
        """
        getNumRegisteredPackages() -> unsigned int

        Returns the number of registered packages.

        @return the number of registered packages.

        """
        return _libsbml.SBMLExtensionRegistry_getNumRegisteredPackages()

    if _newclass:getNumRegisteredPackages = staticmethod(getNumRegisteredPackages)
    __swig_getmethods__["getNumRegisteredPackages"] = lambda x: getNumRegisteredPackages
    def getRegisteredPackageName(*args):
        """
        getRegisteredPackageName(unsigned int index) -> string

        Returns the registered package name at the given index

        @param index zero based index of the package name to return

        @return the package name with the given index or None

        """
        return _libsbml.SBMLExtensionRegistry_getRegisteredPackageName(*args)

    if _newclass:getRegisteredPackageName = staticmethod(getRegisteredPackageName)
    __swig_getmethods__["getRegisteredPackageName"] = lambda x: getRegisteredPackageName
SBMLExtensionRegistry_swigregister = _libsbml.SBMLExtensionRegistry_swigregister
SBMLExtensionRegistry_swigregister(SBMLExtensionRegistry)

def SBMLExtensionRegistry_getInstance():
  """
    SBMLExtensionRegistry_getInstance() -> SBMLExtensionRegistry

    Returns an instance (singleton) of the SBMLExtensionRegistry class.
    This function needs to be invoked when manipulating the SBMLExtensionRegistry class. 

    @return the instance of the SBMLExtensionRegistry object.

    """
  return _libsbml.SBMLExtensionRegistry_getInstance()

def SBMLExtensionRegistry_disablePackage(*args):
  """
    SBMLExtensionRegistry_disablePackage(string package)

    Disables the package with the given URI / name.

    """
  return _libsbml.SBMLExtensionRegistry_disablePackage(*args)

def SBMLExtensionRegistry_isPackageEnabled(*args):
  """
    SBMLExtensionRegistry_isPackageEnabled(string package) -> bool

    If the given @p package is enabled, returns @c True; otherwise,
    returns @c False.

    @return the status (enabled = <b>true</b>, disabled = <b>false</b> of the given package.

    """
  return _libsbml.SBMLExtensionRegistry_isPackageEnabled(*args)

def SBMLExtensionRegistry_enablePackage(*args):
  """
    SBMLExtensionRegistry_enablePackage(string package)

    Enables the package with the given URI / name.

    """
  return _libsbml.SBMLExtensionRegistry_enablePackage(*args)

def SBMLExtensionRegistry_getNumRegisteredPackages():
  """
    SBMLExtensionRegistry_getNumRegisteredPackages() -> unsigned int

    Returns the number of registered packages.

    @return the number of registered packages.

    """
  return _libsbml.SBMLExtensionRegistry_getNumRegisteredPackages()

def SBMLExtensionRegistry_getRegisteredPackageName(*args):
  """
    SBMLExtensionRegistry_getRegisteredPackageName(unsigned int index) -> string

    Returns the registered package name at the given index

    @param index zero based index of the package name to return

    @return the package name with the given index or None

    """
  return _libsbml.SBMLExtensionRegistry_getRegisteredPackageName(*args)

AST_PLUS = _libsbml.AST_PLUS
AST_MINUS = _libsbml.AST_MINUS
AST_TIMES = _libsbml.AST_TIMES
AST_DIVIDE = _libsbml.AST_DIVIDE
AST_POWER = _libsbml.AST_POWER
AST_INTEGER = _libsbml.AST_INTEGER
AST_REAL = _libsbml.AST_REAL
AST_REAL_E = _libsbml.AST_REAL_E
AST_RATIONAL = _libsbml.AST_RATIONAL
AST_NAME = _libsbml.AST_NAME
AST_NAME_AVOGADRO = _libsbml.AST_NAME_AVOGADRO
AST_NAME_TIME = _libsbml.AST_NAME_TIME
AST_CONSTANT_E = _libsbml.AST_CONSTANT_E
AST_CONSTANT_FALSE = _libsbml.AST_CONSTANT_FALSE
AST_CONSTANT_PI = _libsbml.AST_CONSTANT_PI
AST_CONSTANT_TRUE = _libsbml.AST_CONSTANT_TRUE
AST_LAMBDA = _libsbml.AST_LAMBDA
AST_FUNCTION = _libsbml.AST_FUNCTION
AST_FUNCTION_ABS = _libsbml.AST_FUNCTION_ABS
AST_FUNCTION_ARCCOS = _libsbml.AST_FUNCTION_ARCCOS
AST_FUNCTION_ARCCOSH = _libsbml.AST_FUNCTION_ARCCOSH
AST_FUNCTION_ARCCOT = _libsbml.AST_FUNCTION_ARCCOT
AST_FUNCTION_ARCCOTH = _libsbml.AST_FUNCTION_ARCCOTH
AST_FUNCTION_ARCCSC = _libsbml.AST_FUNCTION_ARCCSC
AST_FUNCTION_ARCCSCH = _libsbml.AST_FUNCTION_ARCCSCH
AST_FUNCTION_ARCSEC = _libsbml.AST_FUNCTION_ARCSEC
AST_FUNCTION_ARCSECH = _libsbml.AST_FUNCTION_ARCSECH
AST_FUNCTION_ARCSIN = _libsbml.AST_FUNCTION_ARCSIN
AST_FUNCTION_ARCSINH = _libsbml.AST_FUNCTION_ARCSINH
AST_FUNCTION_ARCTAN = _libsbml.AST_FUNCTION_ARCTAN
AST_FUNCTION_ARCTANH = _libsbml.AST_FUNCTION_ARCTANH
AST_FUNCTION_CEILING = _libsbml.AST_FUNCTION_CEILING
AST_FUNCTION_COS = _libsbml.AST_FUNCTION_COS
AST_FUNCTION_COSH = _libsbml.AST_FUNCTION_COSH
AST_FUNCTION_COT = _libsbml.AST_FUNCTION_COT
AST_FUNCTION_COTH = _libsbml.AST_FUNCTION_COTH
AST_FUNCTION_CSC = _libsbml.AST_FUNCTION_CSC
AST_FUNCTION_CSCH = _libsbml.AST_FUNCTION_CSCH
AST_FUNCTION_DELAY = _libsbml.AST_FUNCTION_DELAY
AST_FUNCTION_EXP = _libsbml.AST_FUNCTION_EXP
AST_FUNCTION_FACTORIAL = _libsbml.AST_FUNCTION_FACTORIAL
AST_FUNCTION_FLOOR = _libsbml.AST_FUNCTION_FLOOR
AST_FUNCTION_LN = _libsbml.AST_FUNCTION_LN
AST_FUNCTION_LOG = _libsbml.AST_FUNCTION_LOG
AST_FUNCTION_PIECEWISE = _libsbml.AST_FUNCTION_PIECEWISE
AST_FUNCTION_POWER = _libsbml.AST_FUNCTION_POWER
AST_FUNCTION_ROOT = _libsbml.AST_FUNCTION_ROOT
AST_FUNCTION_SEC = _libsbml.AST_FUNCTION_SEC
AST_FUNCTION_SECH = _libsbml.AST_FUNCTION_SECH
AST_FUNCTION_SIN = _libsbml.AST_FUNCTION_SIN
AST_FUNCTION_SINH = _libsbml.AST_FUNCTION_SINH
AST_FUNCTION_TAN = _libsbml.AST_FUNCTION_TAN
AST_FUNCTION_TANH = _libsbml.AST_FUNCTION_TANH
AST_LOGICAL_AND = _libsbml.AST_LOGICAL_AND
AST_LOGICAL_NOT = _libsbml.AST_LOGICAL_NOT
AST_LOGICAL_OR = _libsbml.AST_LOGICAL_OR
AST_LOGICAL_XOR = _libsbml.AST_LOGICAL_XOR
AST_RELATIONAL_EQ = _libsbml.AST_RELATIONAL_EQ
AST_RELATIONAL_GEQ = _libsbml.AST_RELATIONAL_GEQ
AST_RELATIONAL_GT = _libsbml.AST_RELATIONAL_GT
AST_RELATIONAL_LEQ = _libsbml.AST_RELATIONAL_LEQ
AST_RELATIONAL_LT = _libsbml.AST_RELATIONAL_LT
AST_RELATIONAL_NEQ = _libsbml.AST_RELATIONAL_NEQ
AST_QUALIFIER_BVAR = _libsbml.AST_QUALIFIER_BVAR
AST_QUALIFIER_LOGBASE = _libsbml.AST_QUALIFIER_LOGBASE
AST_QUALIFIER_DEGREE = _libsbml.AST_QUALIFIER_DEGREE
AST_SEMANTICS = _libsbml.AST_SEMANTICS
AST_CONSTRUCTOR_PIECE = _libsbml.AST_CONSTRUCTOR_PIECE
AST_CONSTRUCTOR_OTHERWISE = _libsbml.AST_CONSTRUCTOR_OTHERWISE
AST_UNKNOWN = _libsbml.AST_UNKNOWN
AST_ORIGINATES_IN_PACKAGE = _libsbml.AST_ORIGINATES_IN_PACKAGE
AST_TYPECODE_BASE = _libsbml.AST_TYPECODE_BASE
AST_TYPECODE_CN_BASE = _libsbml.AST_TYPECODE_CN_BASE
AST_TYPECODE_FUNCTION_BASE = _libsbml.AST_TYPECODE_FUNCTION_BASE
AST_TYPECODE_NUMBER = _libsbml.AST_TYPECODE_NUMBER
AST_TYPECODE_CN_INTEGER = _libsbml.AST_TYPECODE_CN_INTEGER
AST_TYPECODE_CN_EXPONENTIAL = _libsbml.AST_TYPECODE_CN_EXPONENTIAL
AST_TYPECODE_CN_RATIONAL = _libsbml.AST_TYPECODE_CN_RATIONAL
AST_TYPECODE_CN_REAL = _libsbml.AST_TYPECODE_CN_REAL
AST_TYPECODE_CONSTANT_NUMBER = _libsbml.AST_TYPECODE_CONSTANT_NUMBER
AST_TYPECODE_CI_NUMBER = _libsbml.AST_TYPECODE_CI_NUMBER
AST_TYPECODE_CSYMBOL = _libsbml.AST_TYPECODE_CSYMBOL
AST_TYPECODE_CSYMBOL_AVOGADRO = _libsbml.AST_TYPECODE_CSYMBOL_AVOGADRO
AST_TYPECODE_CSYMBOL_DELAY = _libsbml.AST_TYPECODE_CSYMBOL_DELAY
AST_TYPECODE_CSYMBOL_TIME = _libsbml.AST_TYPECODE_CSYMBOL_TIME
AST_TYPECODE_FUNCTION = _libsbml.AST_TYPECODE_FUNCTION
AST_TYPECODE_FUNCTION_UNARY = _libsbml.AST_TYPECODE_FUNCTION_UNARY
AST_TYPECODE_FUNCTION_BINARY = _libsbml.AST_TYPECODE_FUNCTION_BINARY
AST_TYPECODE_FUNCTION_NARY = _libsbml.AST_TYPECODE_FUNCTION_NARY
AST_TYPECODE_FUNCTION_PIECEWISE = _libsbml.AST_TYPECODE_FUNCTION_PIECEWISE
AST_TYPECODE_FUNCTION_LAMBDA = _libsbml.AST_TYPECODE_FUNCTION_LAMBDA
AST_TYPECODE_FUNCTION_CI = _libsbml.AST_TYPECODE_FUNCTION_CI
AST_TYPECODE_FUNCTION_SEMANTIC = _libsbml.AST_TYPECODE_FUNCTION_SEMANTIC
AST_TYPECODE_FUNCTION_QUALIFIER = _libsbml.AST_TYPECODE_FUNCTION_QUALIFIER
AST_TYPECODE_ASTNODE = _libsbml.AST_TYPECODE_ASTNODE

def representsNumber(*args):
  """
    representsNumber(int type) -> bool

    @internal
    Note to developers: leave at least one comment here.  Without it, something
    doesn't go right when docs are generated.

    @internal

    """
  return _libsbml.representsNumber(*args)

def representsFunctionRequiringAtLeastTwoArguments(*args):
  """
    representsFunctionRequiringAtLeastTwoArguments(int type) -> bool

    @internal

    @internal

    """
  return _libsbml.representsFunctionRequiringAtLeastTwoArguments(*args)

def getCoreTypeFromName(*args):
  """
    getCoreTypeFromName(string name) -> int

    @internal

    @internal

    """
  return _libsbml.getCoreTypeFromName(*args)

def getNameFromCoreType(*args):
  """
    getNameFromCoreType(int type) -> char

    @internal

    @internal

    """
  return _libsbml.getNameFromCoreType(*args)

def isCoreTopLevelMathMLFunctionNodeTag(*args):
  """
    isCoreTopLevelMathMLFunctionNodeTag(string name) -> bool

    @internal

    @internal

    """
  return _libsbml.isCoreTopLevelMathMLFunctionNodeTag(*args)

def isCoreTopLevelMathMLNumberNodeTag(*args):
  """
    isCoreTopLevelMathMLNumberNodeTag(string name) -> bool

    @internal

    @internal

    """
  return _libsbml.isCoreTopLevelMathMLNumberNodeTag(*args)
class ASTBase(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base node for AST classes.
    @internal

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASTBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ASTBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ASTBase
    __del__ = lambda self : None;
    def deepCopy(self):
        """
        deepCopy(self) -> ASTBase

        @internal
        Creates a copy (clone).

        @internal

        """
        return _libsbml.ASTBase_deepCopy(self)

    def loadASTPlugins(self, *args):
        """
        loadASTPlugins(self, SBMLNamespaces sbmlns)

        @internal

        @internal

        """
        return _libsbml.ASTBase_loadASTPlugins(self, *args)

    def getType(self):
        """
        getType(self) -> ASTNodeType_t

        @internal
        Get the type of this ASTNode.  The value returned is one of the
        enumeration values such as @link libsbml#AST_LAMBDA AST_LAMBDA@endlink, @link libsbml#AST_PLUS AST_PLUS@endlink,
        etc.

        @return the type of this ASTNode.

        @internal

        """
        return _libsbml.ASTBase_getType(self)

    def getExtendedType(self):
        """
        getExtendedType(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_getExtendedType(self)

    def isSetType(self):
        """
        isSetType(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSetType(self)

    def setType(self, *args):
        """
        setType(self, ASTNodeType_t type) -> int
        setType(self, int type) -> int
        """
        return _libsbml.ASTBase_setType(self, *args)

    def isAvogadro(self):
        """
        isAvogadro(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isAvogadro(self)

    def isBoolean(self):
        """
        isBoolean(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isBoolean(self)

    def isBinaryFunction(self):
        """
        isBinaryFunction(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isBinaryFunction(self)

    def isConstant(self):
        """
        isConstant(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isConstant(self)

    def isExponential(self):
        """
        isExponential(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isExponential(self)

    def isCiNumber(self):
        """
        isCiNumber(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isCiNumber(self)

    def isConstantNumber(self):
        """
        isConstantNumber(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isConstantNumber(self)

    def isCSymbolFunction(self):
        """
        isCSymbolFunction(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isCSymbolFunction(self)

    def isCSymbolNumber(self):
        """
        isCSymbolNumber(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isCSymbolNumber(self)

    def isFunction(self):
        """
        isFunction(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isFunction(self)

    def isInteger(self):
        """
        isInteger(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isInteger(self)

    def isLambda(self):
        """
        isLambda(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isLambda(self)

    def isLogical(self):
        """
        isLogical(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isLogical(self)

    def isName(self):
        """
        isName(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isName(self)

    def isNaryFunction(self):
        """
        isNaryFunction(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isNaryFunction(self)

    def isNumber(self):
        """
        isNumber(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isNumber(self)

    def isOperator(self):
        """
        isOperator(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isOperator(self)

    def isPiecewise(self):
        """
        isPiecewise(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isPiecewise(self)

    def isQualifier(self):
        """
        isQualifier(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isQualifier(self)

    def isRational(self):
        """
        isRational(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isRational(self)

    def isReal(self):
        """
        isReal(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isReal(self)

    def isRelational(self):
        """
        isRelational(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isRelational(self)

    def isSemantics(self):
        """
        isSemantics(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSemantics(self)

    def isUnaryFunction(self):
        """
        isUnaryFunction(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isUnaryFunction(self)

    def isUnknown(self):
        """
        isUnknown(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isUnknown(self)

    def isUserFunction(self):
        """
        isUserFunction(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isUserFunction(self)

    def representsBvar(self):
        """
        representsBvar(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_representsBvar(self)

    def setIsBvar(self, *args):
        """
        setIsBvar(self, bool isbvar) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_setIsBvar(self, *args)

    def isNumberNode(self):
        """
        isNumberNode(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isNumberNode(self)

    def isFunctionNode(self):
        """
        isFunctionNode(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isFunctionNode(self)

    def isTopLevelMathMLFunctionNodeTag(self, *args):
        """
        isTopLevelMathMLFunctionNodeTag(self, string name) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isTopLevelMathMLFunctionNodeTag(self, *args)

    def isTopLevelMathMLNumberNodeTag(self, *args):
        """
        isTopLevelMathMLNumberNodeTag(self, string name) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isTopLevelMathMLNumberNodeTag(self, *args)

    def write(self, *args):
        """
        write(self, XMLOutputStream stream)

        @internal

        @internal

        """
        return _libsbml.ASTBase_write(self, *args)

    def read(self, *args):
        """
        read(self, XMLInputStream stream, string reqd_prefix = "") -> bool
        read(self, XMLInputStream stream) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_read(self, *args)

    def addExpectedAttributes(self, *args):
        """
        addExpectedAttributes(self, ExpectedAttributes attributes, XMLInputStream stream)

        @internal

        @internal

        """
        return _libsbml.ASTBase_addExpectedAttributes(self, *args)

    def readAttributes(self, *args):
        """
        readAttributes(self, XMLAttributes attributes, ExpectedAttributes expectedAttributes, 
            XMLInputStream stream, XMLToken element) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_readAttributes(self, *args)

    def logError(self, *args):
        """
        logError(self, XMLInputStream stream, XMLToken element, SBMLErrorCode_t code, 
            string msg = "")
        logError(self, XMLInputStream stream, XMLToken element, SBMLErrorCode_t code)

        @internal

        @internal

        """
        return _libsbml.ASTBase_logError(self, *args)

    def isChild(self):
        """
        isChild(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isChild(self)

    def setIsChildFlag(self, *args):
        """
        setIsChildFlag(self, bool flag)

        @internal

        @internal

        """
        return _libsbml.ASTBase_setIsChildFlag(self, *args)

    def getClass(self):
        """
        getClass(self) -> string

        @internal

        @internal

        """
        return _libsbml.ASTBase_getClass(self)

    def getId(self):
        """
        getId(self) -> string

        @internal

        @internal

        """
        return _libsbml.ASTBase_getId(self)

    def getStyle(self):
        """
        getStyle(self) -> string

        @internal

        @internal

        """
        return _libsbml.ASTBase_getStyle(self)

    def getParentSBMLObject(self):
        """
        getParentSBMLObject(self) -> SBase

        @internal

        @internal

        """
        return _libsbml.ASTBase_getParentSBMLObject(self)

    def isSetClass(self):
        """
        isSetClass(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSetClass(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSetId(self)

    def isSetStyle(self):
        """
        isSetStyle(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSetStyle(self)

    def isSetParentSBMLObject(self):
        """
        isSetParentSBMLObject(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSetParentSBMLObject(self)

    def setClass(self, *args):
        """
        setClass(self, string className) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_setClass(self, *args)

    def setId(self, *args):
        """
        setId(self, string id) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_setId(self, *args)

    def setStyle(self, *args):
        """
        setStyle(self, string style) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_setStyle(self, *args)

    def unsetClass(self):
        """
        unsetClass(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_unsetClass(self)

    def unsetId(self):
        """
        unsetId(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_unsetId(self)

    def unsetStyle(self):
        """
        unsetStyle(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_unsetStyle(self)

    def unsetParentSBMLObject(self):
        """
        unsetParentSBMLObject(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_unsetParentSBMLObject(self)

    def getFunction(self):
        """
        getFunction(self) -> ASTBase

        @internal

        @internal

        """
        return _libsbml.ASTBase_getFunction(self)

    def addPlugin(self, *args):
        """
        addPlugin(self, ASTBasePlugin plugin)

        @internal

        @internal

        """
        return _libsbml.ASTBase_addPlugin(self, *args)

    def getPlugin(self, *args):
        """
        getPlugin(self, string package) -> ASTBasePlugin
        getPlugin(self, string package) -> ASTBasePlugin
        getPlugin(self, unsigned int n) -> ASTBasePlugin
        getPlugin(self, unsigned int n) -> ASTBasePlugin
        """
        return _libsbml.ASTBase_getPlugin(self, *args)

    def getNumPlugins(self):
        """
        getNumPlugins(self) -> unsigned int

        @internal
        Returns the number of plug-in objects (extenstion interfaces) for SBML
        Level&nbsp;3 package extensions known.

        @return the number of plug-in objects (extension interfaces) of
        package extensions known by this instance of libSBML.

        @internal

        """
        return _libsbml.ASTBase_getNumPlugins(self)

    def getTypeFromName(self, *args):
        """
        getTypeFromName(self, string name) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_getTypeFromName(self, *args)

    def getNameFromType(self, *args):
        """
        getNameFromType(self, int type) -> char

        @internal

        @internal

        """
        return _libsbml.ASTBase_getNameFromType(self, *args)

    def isSetUserData(self):
        """
        isSetUserData(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isSetUserData(self)

    def unsetUserData(self):
        """
        unsetUserData(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_unsetUserData(self)

    def writeNodeOfType(self, *args):
        """
        writeNodeOfType(self, XMLOutputStream stream, int type, bool inChildNode = False)
        writeNodeOfType(self, XMLOutputStream stream, int type)

        @internal

        @internal

        """
        return _libsbml.ASTBase_writeNodeOfType(self, *args)

    def isWellFormedNode(self):
        """
        isWellFormedNode(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_isWellFormedNode(self)

    def hasCorrectNumberArguments(self):
        """
        hasCorrectNumberArguments(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_hasCorrectNumberArguments(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_getTypeCode(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        @internal

        @internal

        """
        return _libsbml.ASTBase_getPackageName(self)

    def setPackageName(self, *args):
        """
        setPackageName(self, string name) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBase_setPackageName(self, *args)

    def hasCnUnits(self):
        """
        hasCnUnits(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBase_hasCnUnits(self)

    def getUnitsPrefix(self):
        """
        getUnitsPrefix(self) -> string

        @internal

        @internal

        """
        return _libsbml.ASTBase_getUnitsPrefix(self)

    def isPackageInfixFunction(self):
        """
        isPackageInfixFunction(self) -> bool

        @internal
        Returns true if this is a package function which should be written as
        'functionname(argumentlist)', false otherwise.

        @internal

        """
        return _libsbml.ASTBase_isPackageInfixFunction(self)

    def hasPackageOnlyInfixSyntax(self):
        """
        hasPackageOnlyInfixSyntax(self) -> bool

        @internal
        Returns true if this is a package function which should be written
        special syntax that the package knows about, false otherwise.

        @internal

        """
        return _libsbml.ASTBase_hasPackageOnlyInfixSyntax(self)

    def getL3PackageInfixPrecedence(self):
        """
        getL3PackageInfixPrecedence(self) -> int

        @internal
        Returns the precedence of the functions within the package

        @internal

        """
        return _libsbml.ASTBase_getL3PackageInfixPrecedence(self)

    def hasUnambiguousPackageInfixGrammar(self, *args):
        """
        hasUnambiguousPackageInfixGrammar(self, ASTNode child) -> bool

        @internal
        Returns true if this is a package function which needs no special
        consideration when writng as infix, false otherwise.

        @internal

        """
        return _libsbml.ASTBase_hasUnambiguousPackageInfixGrammar(self, *args)

ASTBase_swigregister = _libsbml.ASTBase_swigregister
ASTBase_swigregister(ASTBase)

def representsFunction(*args):
  """
    representsFunction(int type, ASTBasePlugin plugin = None) -> bool
    representsFunction(int type) -> bool

    @internal

    @internal

    """
  return _libsbml.representsFunction(*args)

def representsUnaryFunction(*args):
  """
    representsUnaryFunction(int type, ASTBasePlugin plugin = None) -> bool
    representsUnaryFunction(int type) -> bool

    @internal

    @internal

    """
  return _libsbml.representsUnaryFunction(*args)

def representsBinaryFunction(*args):
  """
    representsBinaryFunction(int type, ASTBasePlugin plugin = None) -> bool
    representsBinaryFunction(int type) -> bool

    @internal

    @internal

    """
  return _libsbml.representsBinaryFunction(*args)

def representsNaryFunction(*args):
  """
    representsNaryFunction(int type, ASTBasePlugin plugin = None) -> bool
    representsNaryFunction(int type) -> bool

    @internal

    @internal

    """
  return _libsbml.representsNaryFunction(*args)

def representsQualifier(*args):
  """
    representsQualifier(int type, ASTBasePlugin plugin = None) -> bool
    representsQualifier(int type) -> bool

    @internal

    @internal

    """
  return _libsbml.representsQualifier(*args)

class ASTNode(ASTBase):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Abstract Syntax Trees for mathematical expressions.

    @htmlinclude not-sbml-warning.html

    <a target='_blank'
    href='http://en.wikipedia.org/wiki/Abstract_syntax_tree'>Abstract Syntax
    Trees</a> (ASTs) are a simple kind of data structure used in libSBML for
    storing mathematical expressions.  LibSBML ASTs provide a canonical,
    in-memory representation for all mathematical formulas regardless of their
    original format (which might be MathML or might be text strings).

    @par
    An AST @em node in libSBML is a recursive tree structure; each node has a
    type, a pointer to a value, and a list of children nodes.  Each ASTNode
    node may have none, one, two, or more children depending on its type.
    There are node types to represent numbers (with subtypes to distinguish
    integer, real, and rational numbers), names (e.g., constants or
    variables), simple mathematical operators, logical or relational operators
    and functions.  The following diagram illustrates an example of how the
    mathematical expression <code>'1 + 2'</code> is represented as an AST with
    one @em plus node having two @em integer children nodes for the numbers
    <code>1</code> and <code>2</code>.  The figure also shows the
    corresponding MathML representation:

    @htmlinclude astnode-illustration.html

    The following are other noteworthy points about the AST representation
    in libSBML:
    @li A numerical value represented in MathML as a real number with an
    exponent is preserved as such in the AST node representation, even if the
    number could be stored in a @c float data type.  This is done so that
    when an SBML model is read in and then written out again, the amount of
    change introduced by libSBML to the SBML during the round-trip activity is
    minimized.

    @li Rational numbers are represented in an AST node using separate
    numerator and denominator values.  These can be retrieved using the
    methods ASTNode.getNumerator() and ASTNode.getDenominator().

    @li The children of an ASTNode are other ASTNode objects.  The list of
    children is empty for nodes that are leaf elements, such as numbers.
    For nodes that are actually roots of expression subtrees, the list of
    children points to the parsed objects that make up the rest of the
    expression.

    For many applications, the details of ASTs are irrelevant because libSBML
    provides text-string based translation functions such as
    @sbmlfunction{formulaToL3String, ASTNode} and
    @sbmlfunction{parseL3Formula, String}.  If you find the complexity
    of using the AST representation of expressions too high for your purposes,
    perhaps the string-based functions will be more suitable.

    @if clike <h3><a class='anchor' name='ASTNodeType_t'>
    ASTNodeType_t</a></h3> @else <h3><a class='anchor'
    name='ASTNodeType_t'>The set of possible %ASTNode types</a></h3> @endif@~

    @par
    Every ASTNode has an associated type code to indicate whether, for
    example, it holds a number or stands for an arithmetic operator.
    @if clike The type is recorded as a value drawn from the enumeration
    @link ASTNode.h::ASTNodeType_t <code>ASTNodeType_t</code>@endlink.@endif
    @if java The type is recorded as a value drawn from a
    set of static integer constants defined in the class @link
    libsbmlConstants@endlink. Their names begin with the characters @c AST_.@endif
    @if python The type is recorded as a value drawn from a
    set of static integer constants defined in the class @link
    libsbml@endlink. Their names begin with the characters @c AST_.@endif
    @if csharp The type is recorded as a value drawn from a
    set of static integer constants defined in the class @link
    libsbml@endlink. Their names begin with the characters @c AST_.@endif
    The list of possible types is quite long, because it covers all the
    mathematical functions that are permitted in SBML. The values are shown
    in the following table:

    @htmlinclude astnode-types.html

    The types have the following meanings:

    @li If the node is basic mathematical operator (e.g., @c '+'), then the
    node's type will be @link libsbml#AST_PLUS AST_PLUS@endlink,
    @link libsbml#AST_MINUS AST_MINUS@endlink,
    @link libsbml#AST_TIMES AST_TIMES@endlink,
    @link libsbml#AST_DIVIDE AST_DIVIDE@endlink, or
    @link libsbml#AST_POWER AST_POWER@endlink, as appropriate.

    @li If the node is a predefined function or operator from %SBML
    Level&nbsp;1 (in the string-based formula syntax used in Level&nbsp;1) or
    %SBML Level&nbsp;2 and&nbsp;3 (in the subset of MathML used in SBML
    Levels&nbsp;2 and&nbsp;3), then the node's type
    will be either <code style='margin-right: 0'>AST_FUNCTION_</code><span
    class='placeholder-nospace'>X</span>, <code style='margin-right: 0'>AST_LOGICAL_</code><span
    class='placeholder-nospace'>X</span>, or <code style='margin-right: 0'>AST_RELATIONAL_</code><span
    class='placeholder-nospace'>X</span>, as appropriate.  (Examples:
    @link libsbml#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink,
    @link libsbml#AST_RELATIONAL_LEQ AST_RELATIONAL_LEQ@endlink.)

    @li If the node refers to a user-defined function, the node's type will
    be @link libsbml#AST_FUNCTION AST_FUNCTION@endlink (because it holds the
    name of the function).

    @li If the node is a lambda expression, its type will be
    @link libsbml#AST_LAMBDA AST_LAMBDA@endlink.

    @li If the node is a predefined constant (@c 'ExponentialE', @c 'Pi', @c
    'True' or @c 'False'), then the node's type will be
    @link libsbml#AST_CONSTANT_E AST_CONSTANT_E@endlink,
    @link libsbml#AST_CONSTANT_PI AST_CONSTANT_PI@endlink,
    @link libsbml#AST_CONSTANT_TRUE AST_CONSTANT_TRUE@endlink, or
    @link libsbml#AST_CONSTANT_FALSE AST_CONSTANT_FALSE@endlink.

    @li (Levels&nbsp;2 and&nbsp;3 only) If the node is the special MathML
    csymbol @c time, the value of the node will be
    @link libsbml#AST_NAME_TIME AST_NAME_TIME@endlink.  (Note, however, that the
    MathML csymbol @c delay is translated into a node of type
    @link libsbml#AST_FUNCTION_DELAY AST_FUNCTION_DELAY@endlink.  The difference is due to
    the fact that @c time is a single variable, whereas @c delay is actually a
    function taking arguments.)

    @li (Level&nbsp;3 only) If the node is the special MathML csymbol @c
    avogadro, the value of the node will be
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.

    @li If the node contains a numerical value, its type will be
    @link libsbml#AST_INTEGER AST_INTEGER@endlink,
    @link libsbml#AST_REAL AST_REAL@endlink,
    @link libsbml#AST_REAL_E AST_REAL_E@endlink, or
    @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, as appropriate.

    <h3><a class='anchor' name='math-convert'>Converting between ASTs and text
    strings</a></h3>

    The text-string form of mathematical formulas produced by
    @sbmlfunction{formulaToString, String} and
    @sbmlfunction{formulaToL3String, String}, and read by
    @sbmlfunction{parseFormula, ASTNode} and
    @sbmlfunction{parseL3Formula, ASTNode}, are in a simple C-inspired
    infix notation.  A formula in one of these two text-string formats can be
    handed to a program that understands SBML mathematical expressions, or
    used as part of a translation system.  The libSBML distribution comes with
    example programs in the @c 'examples' subdirectory that demonstrate such
    things as translating infix formulas into MathML and vice-versa.

    Please see the documentation for the functions @sbmlfunction{parseFormula,
    ASTNode} and @sbmlfunction{parseL3Formula, ASTNode} for detailed
    explanations of the infix syntax they accept.

    <h3><a class='anchor' name='math-history'>Historical notes</a></h3>

    Readers may wonder why this part of libSBML uses a seemingly less
    object-oriented design than other parts.  Originally, much of libSBML was
    written in&nbsp;C.  All subsequent development was done in C++, but the
    complexity of some of the functionality for converting between infix, AST
    and MathML, coupled with the desire to maintain stability and backward
    compatibility, means that some of the underlying code is still written
    in&nbsp;C.  This has lead to the exposed API being more C-like.
    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see @sbmlfunction{formulaToL3String, ASTNode}
    @see @sbmlfunction{formulaToString, ASTNode}
    @see @sbmlfunction{getDefaultL3ParserSettings,}

    """
    __swig_setmethods__ = {}
    for _s in [ASTBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASTNode, name, value)
    __swig_getmethods__ = {}
    for _s in [ASTBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ASTNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, int type = AST_UNKNOWN) -> ASTNode
        __init__(self) -> ASTNode
        __init__(self, SBMLNamespaces sbmlns, int type = AST_UNKNOWN) -> ASTNode
        __init__(self, SBMLNamespaces sbmlns) -> ASTNode
        __init__(self, ASTNode orig) -> ASTNode

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ASTNode(Token_t *token)</pre>

        Creates a new ASTNode from the given Token.

        The resulting ASTNode will contain the same data as the given @p token.

        @param token the token to use as a starting point for creating the
        ASTNode object.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ASTNode(ASTNode orig)</pre>

        Copy constructor; creates a deep copy of the given ASTNode.

        @param orig the ASTNode to be copied.
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>ASTNode(ASTNodeType_t type)</pre>

        Creates a new ASTNode.

        Unless the argument @p type is given, the returned node will by default
        have a type of @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.  If the type
        isn't supplied when caling this constructor, the caller should set the
        node type to something else as soon as possible using @if clike
        setType()@else ASTNode.setType()@endif.

        @param type an optional
        @if clike @link libsbml#ASTNodeType_t ASTNodeType_t@endlink@else type@endif@~
        code indicating the type of node to create.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        """
        this = _libsbml.new_ASTNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_ASTNode
    __del__ = lambda self : None;
    def freeName(self):
        """
        freeName(self) -> int

        Frees the name of this ASTNode and sets it to @c None.

        This operation is only applicable to ASTNode objects corresponding to
        operators, numbers, or @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.  This
        method has no effect on other types of nodes.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink

        """
        return _libsbml.ASTNode_freeName(self)

    def canonicalize(self):
        """
        canonicalize(self) -> bool

        Converts this ASTNode to a canonical form.

        The rules determining the canonical form conversion are as follows:

        @li If the node type is @link libsbml#AST_NAME AST_NAME@endlink
        and the node name matches @c 'ExponentialE', @c 'Pi', @c 'True' or @c
        'False' the node type is converted to the corresponding
        <code>AST_CONSTANT_</code><em><span class='placeholder'>X</span></em> type.
        @li If the node type is an @link libsbml#AST_FUNCTION AST_FUNCTION@endlink and
        the node name matches an SBML (MathML) function name, logical operator name,
        or relational operator name, the node is converted to the corresponding
        <code>AST_FUNCTION_</code><em><span class='placeholder'>X</span></em> or
        <code>AST_LOGICAL_</code><em><span class='placeholder'>X</span></em> type.

        SBML Level&nbsp;1 function names are searched first; thus, for example,
        canonicalizing @c log will result in a node type of
        @link libsbml#AST_FUNCTION_LN AST_FUNCTION_LN@endlink.  (See the SBML
        Level&nbsp;1 Version&nbsp;2 Specification, Appendix C.)

        Sometimes, canonicalization of a node results in a structural conversion
        of the node as a result of adding a child.  For example, a node with the
        SBML Level&nbsp;1 function name @c sqr and a single child node (the
        argument) will be transformed to a node of type
        @link libsbml#AST_FUNCTION_POWER AST_FUNCTION_POWER@endlink with two children.  The
        first child will remain unchanged, but the second child will be an
        ASTNode of type @link libsbml#AST_INTEGER AST_INTEGER@endlink and a value of
        2.  The function names that result in structural changes are: @c log10,
        @c sqr, and @c sqrt.

        @return @c True if this node was successfully converted to
        canonical form, @c False otherwise.

        """
        return _libsbml.ASTNode_canonicalize(self)

    def addChild(self, *args):
        """
        addChild(self, ASTNode child) -> int

        Adds the given node as a child of this ASTNode.

        Child nodes are added in-order, from left to right.

        @param child the ASTNode instance to add

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @warning Explicitly adding, removing or replacing children of an
        @if conly ASTNode_t structure@else ASTNode object@endif@~ may change the
        structure of the mathematical formula it represents, and may even render
        the representation invalid.  Callers need to be careful to use this method
        in the context of other operations to create complete and correct
        formulas.  The method
        @if conly ASTNode_isWellFormedASTNode()@else ASTNode.isWellFormedASTNode()@endif@~
        may also be useful for checking the results of node modifications.

        @see prependChild()
        @see replaceChild()
        @see insertChild()
        @see removeChild()
        @see isWellFormedASTNode()

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ASTNode_addChild(self, *args)

    def prependChild(self, *args):
        """
        prependChild(self, ASTNode child) -> int

        Adds the given node as a child of this ASTNode.

        This method adds child nodes from right to left.

        @param child the ASTNode instance to add

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @warning Explicitly adding, removing or replacing children of an
        @if conly ASTNode_t structure@else ASTNode object@endif@~ may change the
        structure of the mathematical formula it represents, and may even render
        the representation invalid.  Callers need to be careful to use this method
        in the context of other operations to create complete and correct
        formulas.  The method
        @if conly ASTNode_isWellFormedASTNode()@else ASTNode.isWellFormedASTNode()@endif@~
        may also be useful for checking the results of node modifications.

        @see addChild()
        @see replaceChild()
        @see insertChild()
        @see removeChild()

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ASTNode_prependChild(self, *args)

    def removeChild(self, *args):
        """
        removeChild(self, unsigned int n) -> int

        Removes the nth child of this ASTNode object.

        @param n long the index of the child to remove

        @return integer value indicating success/failure of the
        function. The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink

        @warning Explicitly adding, removing or replacing children of an
        @if conly ASTNode_t structure@else ASTNode object@endif@~ may change the
        structure of the mathematical formula it represents, and may even render
        the representation invalid.  Callers need to be careful to use this method
        in the context of other operations to create complete and correct
        formulas.  The method
        @if conly ASTNode_isWellFormedASTNode()@else ASTNode.isWellFormedASTNode()@endif@~
        may also be useful for checking the results of node modifications.

        @see addChild()
        @see prependChild()
        @see replaceChild()
        @see insertChild()

        """
        return _libsbml.ASTNode_removeChild(self, *args)

    def replaceChild(self, *args):
        """
        replaceChild(self, unsigned int n, ASTNode newChild) -> int

        Replaces the nth child of this ASTNode with the given ASTNode.

        @param n long the index of the child to replace
        @param newChild ASTNode to replace the nth child

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @warning Explicitly adding, removing or replacing children of an
        @if conly ASTNode_t structure@else ASTNode object@endif@~ may change the
        structure of the mathematical formula it represents, and may even render
        the representation invalid.  Callers need to be careful to use this method
        in the context of other operations to create complete and correct
        formulas.  The method
        @if conly ASTNode_isWellFormedASTNode()@else ASTNode.isWellFormedASTNode()@endif@~
        may also be useful for checking the results of node modifications.

        @see addChild()
        @see prependChild()
        @see insertChild()
        @see removeChild()

        """
        if args[1] is not None: args[1].thisown = 0


        return _libsbml.ASTNode_replaceChild(self, *args)

    def insertChild(self, *args):
        """
        insertChild(self, unsigned int n, ASTNode newChild) -> int

        Inserts the given ASTNode node at a given point in the current ASTNode's
        list of children.

        @param n long the index of the ASTNode being added
        @param newChild ASTNode to insert as the nth child

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @warning Explicitly adding, removing or replacing children of an
        @if conly ASTNode_t structure@else ASTNode object@endif@~ may change the
        structure of the mathematical formula it represents, and may even render
        the representation invalid.  Callers need to be careful to use this method
        in the context of other operations to create complete and correct
        formulas.  The method
        @if conly ASTNode_isWellFormedASTNode()@else ASTNode.isWellFormedASTNode()@endif@~
        may also be useful for checking the results of node modifications.

        @see addChild()
        @see prependChild()
        @see replaceChild()
        @see removeChild()

        """
        if args[1] is not None: args[1].thisown = 0


        return _libsbml.ASTNode_insertChild(self, *args)

    def deepCopy(self):
        """
        deepCopy(self) -> ASTNode

        Creates a recursive copy of this node and all its children.

        @return a copy of this ASTNode and all its children.  The caller owns
        the returned ASTNode and is responsible for deleting it.

        """
        return _libsbml.ASTNode_deepCopy(self)

    def getChild(self, *args):
        """
        getChild(self, unsigned int n) -> ASTNode

        Returns the child at index n of this node.

        @param n the index of the child to get

        @return the nth child of this ASTNode or @c None if this node has no nth
        child (<code>n &gt; </code>
        @if clike getNumChildren()@else ASTNode.getNumChildren()@endif@~
        <code>- 1</code>).

        @see getNumChildren()
        @see getLeftChild()
        @see getRightChild()

        """
        return _libsbml.ASTNode_getChild(self, *args)

    def getLeftChild(self):
        """
        getLeftChild(self) -> ASTNode

        Returns the left child of this node.

        @return the left child of this ASTNode.  This is equivalent to calling
        @if clike getChild()@else ASTNode.getChild()@endif@~
        with an argument of @c 0.

        @see getNumChildren()
        @see getChild()
        @see getRightChild()

        """
        return _libsbml.ASTNode_getLeftChild(self)

    def getRightChild(self):
        """
        getRightChild(self) -> ASTNode

        Returns the right child of this node.

        @return the right child of this ASTNode, or @c None if this node has no
        right child.  If
        @if clike getNumChildren()@else ASTNode.getNumChildren()@endif@~
        <code>&gt; 1</code>, then this is equivalent to:
        @verbatim
        getChild( getNumChildren() - 1 );
        @endverbatim

        @see getNumChildren()
        @see getLeftChild()
        @see getChild()

        """
        return _libsbml.ASTNode_getRightChild(self)

    def getNumChildren(self):
        """
        getNumChildren(self) -> unsigned int

        Returns the number of children of this node.

        @return the number of children of this ASTNode, or 0 is this node has
        no children.

        """
        return _libsbml.ASTNode_getNumChildren(self)

    def addSemanticsAnnotation(self, *args):
        """
        addSemanticsAnnotation(self, XMLNode sAnnotation) -> int

        Adds the given XMLNode as a MathML <code>&lt;semantics&gt;</code>
        element to this ASTNode.

        The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
        that can be used to associate additional information with a MathML
        construct.  The construct can be used to decorate a MathML expressions with
        a sequence of one or more <code>&lt;annotation&gt;</code> or
        <code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
        pair of items; the first is a symbol that acts as an attribute or key, and
        the second is the value associated with the attribute or key.  Please refer
        to the MathML&nbsp;2.0 documentation, particularly the <a target='_blank'
        href='http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations'>Section
        5.2, Semantic Annotations</a> for more information about these constructs.

        @param sAnnotation the annotation to add.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @note Although SBML permits the use of the MathML
        <code>&lt;semantics&gt;</code> annotation construct, the truth is that
        this construct has so far (at this time of this writing, which is early
        2014) seen very little use in SBML software.  The full implications of
        using these annotations are still poorly understood.  If you wish to
        use this construct, we urge you to discuss possible uses and applications
        on the SBML discussion lists, particularly <a target='_blank'
        href='http://sbml.org/Forums'>sbml-discuss</a> and/or <a target='_blank'
        href='http://sbml.org/Forums'>sbml-interoperability</a>.

        @see ASTNode.getNumSemanticsAnnotations()
        @see ASTNode.getSemanticsAnnotation()

        """
        if args[0] is not None: args[0].thisown = 0


        return _libsbml.ASTNode_addSemanticsAnnotation(self, *args)

    def getNumSemanticsAnnotations(self):
        """
        getNumSemanticsAnnotations(self) -> unsigned int

        Returns the number of MathML <code>&lt;semantics&gt;</code> element
        elements on this node.

        The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
        that can be used to associate additional information with a MathML
        construct.  The construct can be used to decorate a MathML expressions with
        a sequence of one or more <code>&lt;annotation&gt;</code> or
        <code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
        pair of items; the first is a symbol that acts as an attribute or key, and
        the second is the value associated with the attribute or key.  Please refer
        to the MathML&nbsp;2.0 documentation, particularly the <a target='_blank'
        href='http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations'>Section
        5.2, Semantic Annotations</a> for more information about these constructs.

        @return the number of annotations of this ASTNode.

        @note Although SBML permits the use of the MathML
        <code>&lt;semantics&gt;</code> annotation construct, the truth is that
        this construct has so far (at this time of this writing, which is early
        2014) seen very little use in SBML software.  The full implications of
        using these annotations are still poorly understood.  If you wish to
        use this construct, we urge you to discuss possible uses and applications
        on the SBML discussion lists, particularly <a target='_blank'
        href='http://sbml.org/Forums'>sbml-discuss</a> and/or <a target='_blank'
        href='http://sbml.org/Forums'>sbml-interoperability</a>.

        @see ASTNode.addSemanticsAnnotation()
        @see ASTNode.getSemanticsAnnotation()

        """
        return _libsbml.ASTNode_getNumSemanticsAnnotations(self)

    def getSemanticsAnnotation(self, *args):
        """
        getSemanticsAnnotation(self, unsigned int n) -> XMLNode

        Returns the nth MathML <code>&lt;semantics&gt;</code> element on this
        ASTNode.

        The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
        that can be used to associate additional information with a MathML
        construct.  The construct can be used to decorate a MathML expressions with
        a sequence of one or more <code>&lt;annotation&gt;</code> or
        <code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
        pair of items; the first is a symbol that acts as an attribute or key, and
        the second is the value associated with the attribute or key.  Please refer
        to the MathML&nbsp;2.0 documentation, particularly the <a target='_blank'
        href='http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations'>Section
        5.2, Semantic Annotations</a> for more information about these constructs.

        @param n the index of the annotation to return.  Callers should
        use ASTNode.getNumSemanticsAnnotations() to first find out how
        many annotations there are.

        @return the nth annotation inside this ASTNode, or @c None if this node has
        no nth annotation (<code>n &gt;</code>
        @if clike getNumSemanticsAnnotations()@else ASTNode.getNumSemanticsAnnotations()@endif@~
        <code>- 1</code>).

        @note Although SBML permits the use of the MathML
        <code>&lt;semantics&gt;</code> annotation construct, the truth is that
        this construct has so far (at this time of this writing, which is early
        2014) seen very little use in SBML software.  The full implications of
        using these annotations are still poorly understood.  If you wish to
        use this construct, we urge you to discuss possible uses and applications
        on the SBML discussion lists, particularly <a target='_blank'
        href='http://sbml.org/Forums'>sbml-discuss</a> and/or <a target='_blank'
        href='http://sbml.org/Forums'>sbml-interoperability</a>.

        @see ASTNode.addSemanticsAnnotation()
        @see ASTNode.getNumSemanticsAnnotations()

        """
        return _libsbml.ASTNode_getSemanticsAnnotation(self, *args)

    def getCharacter(self):
        """
        getCharacter(self) -> char

        Returns the value of this node as a single character.

        This function should be called only when ASTNode.getType() returns
        @link libsbml#AST_MINUS AST_MINUS@endlink, @link libsbml#AST_TIMES AST_TIMES@endlink, @link libsbml#AST_DIVIDE AST_DIVIDE@endlink or
        @link libsbml#AST_POWER AST_POWER@endlink.

        @return the value of this ASTNode as a single character

        """
        return _libsbml.ASTNode_getCharacter(self)

    def getId(self):
        """
        getId(self) -> string

        Returns the MathML @c id attribute value of this ASTNode.

        @return the MathML id of this ASTNode.

        @see isSetId()
        @see setId()
        @see unsetId()

        """
        return _libsbml.ASTNode_getId(self)

    def getClass(self):
        """
        getClass(self) -> string

        Returns the MathML @c class attribute value of this ASTNode.

        @return the MathML class of this ASTNode, if any exists.

        @see isSetClass()
        @see @if java setClassName(string id)@else setClass()@endif@~
        @see unsetClass()

        """
        return _libsbml.ASTNode_getClass(self)

    def getStyle(self):
        """
        getStyle(self) -> string

        Returns the MathML @c style attribute value of this ASTNode.

        @return the MathML style of this ASTNode, if any exists.

        @see isSetStyle()
        @see setStyle()
        @see unsetStyle()

        """
        return _libsbml.ASTNode_getStyle(self)

    def getInteger(self):
        """
        getInteger(self) -> long

        Returns the value of this node as an integer.

        If this node type is @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, this
        method returns the value of the numerator.

        @return the value of this ASTNode as a (<code>long</code>) integer.

        @note This function should be called only when
        @if clike getType()@else ASTNode.getType()@endif@~ returns
        @link libsbml#AST_INTEGER AST_INTEGER@endlink or
        @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
        It will return @c 0 if the node type is @em not one of these, but since
        @c 0 may be a valid value for integer, it is important to be sure that
        the node type is one of the expected types in order to understand if @c
        0 is the actual value.

        """
        return _libsbml.ASTNode_getInteger(self)

    def getName(self):
        """
        getName(self) -> char

        Returns the value of this node as a string.

        This function may be called on nodes that (1) are not operators, i.e.,
        nodes for which @if clike isOperator()@else ASTNode.isOperator()@endif@~
        returns @c False, and (2) are not numbers, i.e.,
        @if clike isNumber()@else ASTNode.isNumber()@endif@~ returns @c False.

        @return the value of this ASTNode as a string, or @c None if it is
        a node that does not have a name equivalent (e.g., if it is a number).

        """
        return _libsbml.ASTNode_getName(self)

    def getOperatorName(self):
        """
        getOperatorName(self) -> char

        Returns the value of this operator node as a string.

        This function may be called on nodes that are operators, i.e., nodes for
        which @if clike isOperator()@else ASTNode.isOperator()@endif@~ returns
        @c True.

        @return the name of this operator ASTNode as a string (or @c None if not
        an operator).

        """
        return _libsbml.ASTNode_getOperatorName(self)

    def getNumerator(self):
        """
        getNumerator(self) -> long

        Returns the value of the numerator of this node.

        This function should be called only when
        @if clike getType()@else ASTNode.getType()@endif@~ returns
        @link libsbml#AST_RATIONAL AST_RATIONAL@endlink or
        @link libsbml#AST_INTEGER AST_INTEGER@endlink.

        @return the value of the numerator of this ASTNode.

        """
        return _libsbml.ASTNode_getNumerator(self)

    def getDenominator(self):
        """
        getDenominator(self) -> long

        Returns the value of the denominator of this node.

        @return the value of the denominator of this ASTNode, or @c 1 if
        this node has no numerical value.

        @note This function should be called only when
        @if clike getType()@else ASTNode.getType()@endif@~ returns
        @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
        It will return @c 1 if the node type is another type, but since @c 1 may
        be a valid value for the denominator of a rational number, it is
        important to be sure that the node type is the correct type in order to
        correctly interpret the returned value.

        """
        return _libsbml.ASTNode_getDenominator(self)

    def getReal(self):
        """
        getReal(self) -> double

        Returns the real-numbered value of this node.

        This function performs the necessary arithmetic if the node type is
        @link libsbml#AST_REAL_E AST_REAL_E@endlink (<em>mantissa *
        10<sup> exponent</sup></em>) or
        @link libsbml#AST_RATIONAL AST_RATIONAL@endlink
        (<em>numerator / denominator</em>).

        @return the value of this ASTNode as a real (double), or @c 0
        if this is not a node that holds a number.

        @note This function should be called only when this ASTNode has a
        numerical value type.  It will return @c 0 if the node type is another
        type, but since @c 0 may be a valid value, it is important to be sure
        that the node type is the correct type in order to correctly interpret
        the returned value.

        """
        return _libsbml.ASTNode_getReal(self)

    def getMantissa(self):
        """
        getMantissa(self) -> double

        Returns the mantissa value of this node.

        If @if clike getType()@else ASTNode.getType()@endif@~ returns
        @link libsbml#AST_REAL AST_REAL@endlink, this method is
        identical to ASTNode.getReal().

        @return the value of the mantissa of this ASTNode, or @c 0 if this
        node is not a type that has a real-numbered value.

        @note This function should be called only when
        @if clike getType()@else ASTNode.getType()@endif@~ returns
        @link libsbml#AST_REAL_E AST_REAL_E@endlink,
        @link libsbml#AST_REAL AST_REAL@endlink or
        @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.  It
        will return @c 0 if the node type is another type, but since @c 0 may be
        a valid value, it is important to be sure that the node type is the
        correct type in order to correctly interpret the returned value.

        """
        return _libsbml.ASTNode_getMantissa(self)

    def getExponent(self):
        """
        getExponent(self) -> long

        Returns the exponent value of this ASTNode.

        @return the value of the exponent of this ASTNode, or @c 0 if this
        is not a type of node that has an exponent.

        @note This function should be called only when
        @if clike getType()@else ASTNode.getType()@endif@~
        returns @link libsbml#AST_REAL_E AST_REAL_E@endlink.
        It will return @c 0 if the node type is another type, but since @c 0 may
        be a valid value, it is important to be sure that the node type is the
        correct type in order to correctly interpret the returned value.

        """
        return _libsbml.ASTNode_getExponent(self)

    def getPrecedence(self):
        """
        getPrecedence(self) -> int

        Returns the precedence of this node in the infix math syntax of SBML
        Level&nbsp;1.

        For more information about the infix syntax, see the discussion about <a
        href='#math-convert'>text string formulas</a> at the top of the
        documentation for ASTNode.

        @return an integer indicating the precedence of this ASTNode

        """
        return _libsbml.ASTNode_getPrecedence(self)

    def getType(self):
        """
        getType(self) -> ASTNodeType_t

        Returns the type of this ASTNode.

        The value returned is one of the Core AST type codes such as
        @link libsbml#AST_LAMBDA AST_LAMBDA@endlink,
        @link libsbml#AST_PLUS AST_PLUS@endlink, etc.

        @return the type of this ASTNode.

        @note The introduction of extensibility in SBML Level&nbsp;3 brings with
        it a need to allow for the possibility of node types that are defined by
        plug-ins implementing SBML Level&nbsp;3 packages.  If a given ASTNode is
        a construct created by a package rather than libSBML Core, then
        getType() will return
        @link libsbml#AST_ORIGINATES_IN_PACKAGE AST_ORIGINATES_IN_PACKAGE@endlink.
        Callers can then obtain the package-specific type by
        calling getExtendedType().

        @see getExtendedType()

        """
        return _libsbml.ASTNode_getType(self)

    def getExtendedType(self):
        """
        getExtendedType(self) -> int

        Returns the extended type of this ASTNode.

        The type may be either a core
        @ifnot clike integer type code@else ASTNodeType_t value@endif
        or a value of a type code defined by an SBML Level&nbsp;3 package.

        @return the type of this ASTNode.

        @note When the ASTNode is of a type from a package, the value returned
        by ASTNode.getType() will be
        @link libsbml#AST_ORIGINATES_IN_PACKAGE AST_ORIGINATES_IN_PACKAGE@endlink
        and getExtendedType() will return a package-specific type
        code.  To find out the possible package-specific types (if any), please
        consult the documentation for the particular package.

        @see getType()

        """
        return _libsbml.ASTNode_getExtendedType(self)

    def getUnits(self):
        """
        getUnits(self) -> string

        Returns the units of this ASTNode.

        @htmlinclude about-sbml-units-attrib.html

        @return the units of this ASTNode.

        @note The <code>sbml:units</code> attribute is only available in SBML
        Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.

        @see @sbmlfunction{parseL3Formula, String}

        """
        return _libsbml.ASTNode_getUnits(self)

    def isAvogadro(self):
        """
        isAvogadro(self) -> bool

        Returns @c True if this node represents the predefined
        value for Avogadro's constant.

        SBML Level&nbsp;3 introduced a predefined MathML <code>&lt;csymbol&gt;</code>
        for the value of Avogadro's constant.  LibSBML stores this internally as
        a node of type @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.
        This method returns @c True if this node has that type.

        @return @c True if this ASTNode is the special symbol avogadro,
        @c False otherwise.

        @see @sbmlfunction{parseL3Formula, String}

        """
        return _libsbml.ASTNode_isAvogadro(self)

    def isBoolean(self):
        """
        isBoolean(self) -> bool

        Returns @c True if this node has a Boolean type.

        The ASTNode objects that have Boolean types are the logical operators,
        relational operators, and the constants @c True or @c False.

        @return @c True if this ASTNode has a Boolean type, @c False otherwise.

        """
        return _libsbml.ASTNode_isBoolean(self)

    def returnsBoolean(self, model = None):
        """
        returnsBoolean(self, Model model = None) -> bool
        returnsBoolean(self) -> bool

        Returns @c True if this node returns a Boolean value.

        This function looks at the whole ASTNode rather than just the top level
        of the ASTNode. Thus, it will consider return values from piecewise
        statements.  In addition, if this ASTNode uses a function call to a
        user-defined function, the return value of the corresponding
        FunctionDefinition object will be determined.  Note that this is only
        possible where the ASTNode can trace its parent Model; that is, the
        ASTNode must represent the <code>&lt;math&gt;</code> element of some
        SBML object that has already been added to an instance of an
        SBMLDocument.

        @param model the Model to use as context

        @see isBoolean()

        @return true if this ASTNode returns a boolean, @c False otherwise.

        """
        return _libsbml.ASTNode_returnsBoolean(self, model)

    def isConstant(self):
        """
        isConstant(self) -> bool

        Returns @c True if this node represents a MathML
        constant.

        Examples of MathML constants include such things as pi.

        @return @c True if this ASTNode is a MathML constant, @c False
        otherwise.

        @note This function will also return @c True for nodes of type
        @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink in SBML Level&nbsp;3.

        """
        return _libsbml.ASTNode_isConstant(self)

    def isFunction(self):
        """
        isFunction(self) -> bool

        Returns @c True if this node represents a function.

        The three types of functions in SBML are MathML functions (e.g.,
        <code>abs()</code>), SBML Level&nbsp;1 functions (in the SBML
        Level&nbsp;1 math syntax), and user-defined functions (using
        FunctionDefinition in SBML Level&nbsp;2 and&nbsp;3).

        @return @c True if this ASTNode is a function, @c False otherwise.

        """
        return _libsbml.ASTNode_isFunction(self)

    def isInfinity(self):
        """
        isInfinity(self) -> bool

        Returns @c True if this node represents the special IEEE 754
        value for infinity.

        @return @c True if this ASTNode is the special IEEE 754 value infinity,
        @c False otherwise.

        """
        return _libsbml.ASTNode_isInfinity(self)

    def isInteger(self):
        """
        isInteger(self) -> bool

        Returns @c True if this node contains an integer value.

        @return @c True if this ASTNode is of type @link libsbml#AST_INTEGER AST_INTEGER@endlink, @c False otherwise.

        """
        return _libsbml.ASTNode_isInteger(self)

    def isLambda(self):
        """
        isLambda(self) -> bool

        Returns @c True if this node is a MathML
        <code>&lt;lambda&gt;</code>.

        @return @c True if this ASTNode is of type @link libsbml#AST_LAMBDA AST_LAMBDA@endlink, @c False otherwise.

        """
        return _libsbml.ASTNode_isLambda(self)

    def isLog10(self):
        """
        isLog10(self) -> bool

        Returns @c True if this node represents a @c log10 function.

        More precisely, this predicate returns @c True if the node type is
        @link libsbml#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink with two children, the
        first of which is an @link libsbml#AST_INTEGER AST_INTEGER@endlink equal to
        10.

        @return @c True if the given ASTNode represents a @c log10() function, @c False otherwise.

        @see @sbmlfunction{parseL3Formula, String}

        """
        return _libsbml.ASTNode_isLog10(self)

    def isLogical(self):
        """
        isLogical(self) -> bool

        Returns @c True if this node is a MathML logical operator.

        The possible MathML logical operators are @c and, @c or, @c not, and @c
        xor.

        @return @c True if this ASTNode is a MathML logical operator, @c False
        otherwise.

        """
        return _libsbml.ASTNode_isLogical(self)

    def isName(self):
        """
        isName(self) -> bool

        Returns @c True if this node is a user-defined variable name
        or the symbols for time or Avogadro's constant.

        SBML Levels&nbsp;2 and&nbsp;3 provides <code>&lt;csymbol&gt;</code>
        definitions for 'time' and 'avogadro', which can be used to represent
        simulation time and Avogadro's constant in MathML.

        @return @c True if this ASTNode is a user-defined variable name in SBML
        or the special symbols for time or Avogadro's constant. It returns @c False otherwise.

        """
        return _libsbml.ASTNode_isName(self)

    def isNaN(self):
        """
        isNaN(self) -> bool

        Returns @c True if this node represents the special IEEE 754
        value 'not a number' (NaN).

        @return @c True if this ASTNode is the special IEEE 754 NaN, @c False
        otherwise.

        """
        return _libsbml.ASTNode_isNaN(self)

    def isNegInfinity(self):
        """
        isNegInfinity(self) -> bool

        Returns @c True if this node represents the special IEEE 754
        value 'negative infinity'.

        @return @c True if this ASTNode is the special IEEE 754 value negative
        infinity, @c False otherwise.

        """
        return _libsbml.ASTNode_isNegInfinity(self)

    def isNumber(self):
        """
        isNumber(self) -> bool

        Returns @c True if this node contains a number.

        @return @c True if this ASTNode is a number, @c False otherwise.

        """
        return _libsbml.ASTNode_isNumber(self)

    def isOperator(self):
        """
        isOperator(self) -> bool

        Returns @c True if this node is a mathematical
        operator.

        The possible mathematical operators in the MathML syntax supported by
        SBML are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>
        and <code>^</code> (power).

        @return @c True if this ASTNode is an operator, @c False otherwise.

        """
        return _libsbml.ASTNode_isOperator(self)

    def isPiecewise(self):
        """
        isPiecewise(self) -> bool

        Returns @c True if this node is the MathML
        <code>&lt;piecewise&gt;</code> construct.

        @return @c True if this ASTNode is a MathML @c piecewise function,
        @c False otherwise.

        """
        return _libsbml.ASTNode_isPiecewise(self)

    def isQualifier(self):
        """
        isQualifier(self) -> bool

        Predicate returning @c True if this node is a MathML
        qualifier.

        The MathML qualifier node types are @c bvar, @c degree, @c base, @c
        piece, and @c otherwise.

        @return @c True if this ASTNode is a MathML qualifier, @c False
        otherwise.

        """
        return _libsbml.ASTNode_isQualifier(self)

    def isRational(self):
        """
        isRational(self) -> bool

        Returns @c True if this node represents a rational number.

        @return @c True if this ASTNode is of type @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, @c False otherwise.

        """
        return _libsbml.ASTNode_isRational(self)

    def isReal(self):
        """
        isReal(self) -> bool

        Returns @c True if this node can represent a real number.

        More precisely, this node must be of one of the following types:
        @link libsbml#AST_REAL AST_REAL@endlink, @link libsbml#AST_REAL_E AST_REAL_E@endlink or @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.

        @return @c True if the value of this ASTNode can represented as a real
        number, @c False otherwise.

        """
        return _libsbml.ASTNode_isReal(self)

    def isRelational(self):
        """
        isRelational(self) -> bool

        Returns @c True if this node is a MathML
        relational operator.

        The MathML relational operators are <code>==</code>, <code>&gt;=</code>,
        <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.

        @return @c True if this ASTNode is a MathML relational operator, @c False otherwise.

        """
        return _libsbml.ASTNode_isRelational(self)

    def isSemantics(self):
        """
        isSemantics(self) -> bool

        Predicate returning @c True if this node is a MathML
        semantics node.

        @return @c True if this ASTNode is a MathML semantics node, @c False
        otherwise.

        """
        return _libsbml.ASTNode_isSemantics(self)

    def isSqrt(self):
        """
        isSqrt(self) -> bool

        Returns @c True if this node represents a square root
        function.

        More precisely, the node type must be @link libsbml#AST_FUNCTION_ROOT AST_FUNCTION_ROOT@endlink with two children, the first of which is an
        @link libsbml#AST_INTEGER AST_INTEGER@endlink node having value equal to 2.

        @return @c True if the given ASTNode represents a <code>sqrt()</code>
        function, @c False otherwise.

        """
        return _libsbml.ASTNode_isSqrt(self)

    def isUMinus(self):
        """
        isUMinus(self) -> bool

        Returns @c True if this node is a unary minus operator.

        A node is defined as a unary minus node if it is of type
        @link libsbml#AST_MINUS AST_MINUS@endlink and has exactly one child.

        For numbers, unary minus nodes can be 'collapsed' by negating the
        number.  In fact, @sbmlfunction{parseFormula, String} does this during
        its parsing process, and @sbmlfunction{parseL3Formula, String} has a
        configuration option that allows this behavior to be turned on or off.
        However, unary minus nodes for symbols (@link libsbml#AST_NAME AST_NAME@endlink) cannot be 'collapsed', so this predicate function is
        necessary.

        @return @c True if this ASTNode is a unary minus, @c False
        otherwise.

        @see @sbmlfunction{parseL3Formula, String}

        """
        return _libsbml.ASTNode_isUMinus(self)

    def isUPlus(self):
        """
        isUPlus(self) -> bool

        Returns @c True if this node is a unary plus operator.

        A node is defined as a unary plus node if it is of type
        @link libsbml#AST_PLUS AST_PLUS@endlink and has exactly one child.

        @return @c True if this ASTNode is a unary plus, @c False otherwise.

        """
        return _libsbml.ASTNode_isUPlus(self)

    def hasTypeAndNumChildren(self, *args):
        """
        hasTypeAndNumChildren(self, int type, unsigned int numchildren) -> int

        Returns @c True if this node is of a certain type with a specific number
        of children.

        Designed for use in cases where it is useful to discover if the node is a
        unary not or unary minus, or a times node with no children, etc.

        @param type the type of ASTNode sought.
        @param numchildren the number of child nodes sought.

        @return @c True if this ASTNode is has the specified type and number of
        children, @c False otherwise.

        """
        return _libsbml.ASTNode_hasTypeAndNumChildren(self, *args)

    def isUnknown(self):
        """
        isUnknown(self) -> bool

        Returns @c True if this node has an unknown type.

        'Unknown' nodes have the type @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.
        Nodes with unknown types will not appear in an ASTNode tree returned by
        libSBML based upon valid SBML input; the only situation in which a node
        with type @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink may appear is
        immediately after having create a new, untyped node using the ASTNode
        constructor.  Callers creating nodes should endeavor to set the type to
        a valid node type as soon as possible after creating new nodes.

        @return @c True if this ASTNode is of type @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink, @c False otherwise.

        """
        return _libsbml.ASTNode_isUnknown(self)

    def isSetId(self):
        """
        isSetId(self) -> bool

        Returns @c True if this node has a value for the MathML
        attribute @c id.

        @return true if this ASTNode has an attribute id, @c False
        otherwise.

        @see isSetClass()
        @see isSetStyle()
        @see setId()
        @see unsetId()

        """
        return _libsbml.ASTNode_isSetId(self)

    def isSetClass(self):
        """
        isSetClass(self) -> bool

        Returns @c True if this node has a value for the MathML
        attribute @c class.

        @return true if this ASTNode has an attribute class, @c False
        otherwise.

        @see isSetId()
        @see isSetStyle()
        @see @if java setClassName(string id)@else setClass()@endif@~
        @see unsetClass()

        """
        return _libsbml.ASTNode_isSetClass(self)

    def isSetStyle(self):
        """
        isSetStyle(self) -> bool

        Returns @c True if this node has a value for the MathML
        attribute @c style.

        @return true if this ASTNode has an attribute style, @c False
        otherwise.

        @see isSetClass()
        @see isSetId()
        @see setStyle()
        @see unsetStyle()

        """
        return _libsbml.ASTNode_isSetStyle(self)

    def isSetUnits(self):
        """
        isSetUnits(self) -> bool

        Returns @c True if this node has the attribute
        <code>sbml:units</code>.

        @htmlinclude about-sbml-units-attrib.html

        @return @c True if this ASTNode has units associated with it, @c False
        otherwise.

        @note The <code>sbml:units</code> attribute is only available in SBML
        Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.

        @see hasUnits()
        @see setUnits()

        """
        return _libsbml.ASTNode_isSetUnits(self)

    def hasUnits(self):
        """
        hasUnits(self) -> bool

        Returns @c True if this node or any of its
        children nodes have the attribute <code>sbml:units</code>.

        @htmlinclude about-sbml-units-attrib.html

        @return @c True if this ASTNode or its children has units associated
        with it, @c False otherwise.

        @note The <code>sbml:units</code> attribute is only available in SBML
        Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.

        @see isSetUnits()
        @see setUnits()

        """
        return _libsbml.ASTNode_hasUnits(self)

    def setCharacter(self, *args):
        """
        setCharacter(self, char value) -> int

        Sets the value of this ASTNode to the given character.  If character
        is one of @c +, @c -, <code>*</code>, <code>/</code> or @c ^, the node
        type will be set accordingly.  For all other characters, the node type
        will be set to @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.

        @param value the character value to which the node's value should be
        set.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ASTNode_setCharacter(self, *args)

    def setId(self, *args):
        """
        setId(self, string id) -> int

        Sets the MathML attribute @c id of this ASTNode.

        @param id @c string representing the identifier.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see isSetId()
        @see getId()
        @see unsetId()

        """
        return _libsbml.ASTNode_setId(self, *args)

    def setClass(self, *args):
        """
        setClass(self, string className) -> int

        Sets the MathML attribute @c class of this ASTNode.

        @param className @c string representing the MathML class for this node.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @if java
        @note In the API interfaces for languages other than Java, this method
        is named <code>setClass()</code>, but in Java it is renamed
        <code>setClassName()</code> to avoid a name collision with Java's
        standard object method of the same name.
        @endif@~

        @see isSetClass()
        @see getClass()
        @see unsetClass()

        """
        return _libsbml.ASTNode_setClass(self, *args)

    def setStyle(self, *args):
        """
        setStyle(self, string style) -> int

        Sets the MathML attribute @c style of this ASTNode.

        @param style @c string representing the identifier.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        @see isSetStyle()
        @see getStyle()
        @see unsetStyle()

        """
        return _libsbml.ASTNode_setStyle(self, *args)

    def setName(self, *args):
        """
        setName(self, char name) -> int

        Sets the value of this ASTNode to the given name.

        As a side effect, this ASTNode object's type will be reset to
        @link libsbml#AST_NAME AST_NAME@endlink if (and <em>only if</em>) the
        ASTNode was previously an operator (i.e., @if clike isOperator()@else
        ASTNode.isOperator()@endif@~ returns @c True), number (i.e., @if clike
        isNumber()@else ASTNode.isNumber()@endif@~ returns @c True), or
        unknown.  This allows names to be set for @link libsbml#AST_FUNCTION AST_FUNCTION@endlink nodes and the like.

        @param name the string containing the name to which this node's value
        should be set.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ASTNode_setName(self, *args)

    def setValue(self, *args):
        """
        setValue(self, long value) -> int
        setValue(self, long numerator, long denominator) -> int
        setValue(self, double value) -> int
        setValue(self, double mantissa, long exponent) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setValue(long numerator, long denominator)</pre>

        Sets the value of this ASTNode to the given rational.

        As a side effect, this operation sets the node type to
        @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.

        @param numerator the numerator value of the rational.
        @param denominator the denominator value of the rational.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setValue(double mantissa, long exponent)</pre>

        Sets the value of this ASTNode to the given real (@c float)

        As a side effet, this operation sets the node type to
        @link libsbml#AST_REAL_E AST_REAL_E@endlink.

        @param mantissa the mantissa of this node's real-numbered value.
        @param exponent the exponent of this node's real-numbered value.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setValue(int value)</pre>

        Sets the value of this ASTNode to the given integer

        As a side effect, this operation sets the node type to
        @link libsbml#AST_INTEGER AST_INTEGER@endlink.

        @param value the integer to which this node's value should be set.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setValue(double value)</pre>

        Sets the value of this ASTNode to the given real (@c float).

        As a side effect, this operation sets the node type to
        @link libsbml#AST_REAL AST_REAL@endlink.

        This is functionally equivalent to:
        @verbatim
        setValue(value, 0);
        @endverbatim

        @param value the @c float format number to which this node's value
        should be set.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setValue(long value)</pre>

        Sets the value of this ASTNode to the given (@c long) integer

        As a side effect, this operation sets the node type to
        @link libsbml#AST_INTEGER AST_INTEGER@endlink.

        @param value the integer to which this node's value should be set.

        @return integer value indicating success/failure of the function.  The
        possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink

        """
        return _libsbml.ASTNode_setValue(self, *args)

    def setType(self, *args):
        """
        setType(self, int type) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setType(int type)</pre>

        Sets the type of this ASTNode.

        This uses integer type codes, which may come from ASTNodeType_t or an
        enumeration of AST types in an SBML Level&nbsp;3 package.

        @param type the integer representing the type to which this node should
        be set.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note A side-effect of doing this is that any numerical values
        previously stored in this node are reset to zero.

        @see getType()
        @see setType()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setType(ASTNodeType_t type)</pre>

        Sets the type of this ASTNode to the given type code.

        @param type the type to which this node should be set.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note A side-effect of doing this is that any numerical values
        previously stored in this node are reset to zero.

        @see getType()
        @see setType()

        """
        return _libsbml.ASTNode_setType(self, *args)

    def setUnits(self, *args):
        """
        setUnits(self, string units) -> int

        Sets the units of this ASTNode to units.

        The units will be set @em only if this ASTNode object represents a
        MathML <code>&lt;cn&gt;</code> element, i.e., represents a number.
        Callers may use
        @if clike isNumber()@else ASTNode.isNumber()@endif@~
        to inquire whether the node is of that type.

        @htmlinclude about-sbml-units-attrib.html

        @param units @c string representing the unit identifier.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @note The <code>sbml:units</code> attribute is only available in SBML
        Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.

        @see isSetUnits()
        @see hasUnits()

        """
        return _libsbml.ASTNode_setUnits(self, *args)

    def swapChildren(self, *args):
        """
        swapChildren(self, ASTNode that) -> int

        Swaps the children of this node with the children of another node.

        @param that the other node whose children should be used to replace
        <em>this</em> node's children.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ASTNode_swapChildren(self, *args)

    def renameSIdRefs(self, *args):
        """
        renameSIdRefs(self, string oldid, string newid)

        Renames all the SIdRef attributes on this node and its child nodes.

        @param oldid the old identifier.
        @param newid the new identifier.

        """
        return _libsbml.ASTNode_renameSIdRefs(self, *args)

    def renameUnitSIdRefs(self, *args):
        """
        renameUnitSIdRefs(self, string oldid, string newid)

        Renames all the UnitSIdRef attributes on this node and its child nodes.

        The only place UnitSIDRefs appear in MathML <code>&lt;cn&gt;</code>
        elements, so the effects of this method are limited to that.

        @param oldid the old identifier.
        @param newid the new identifier.

        """
        return _libsbml.ASTNode_renameUnitSIdRefs(self, *args)

    def replaceIDWithFunction(self, *args):
        """
        replaceIDWithFunction(self, string id, ASTNode function)

        @internal
        Replace any nodes of type AST_NAME with the name 'id' from the child
        'math' object with the provided ASTNode.

        @internal

        """
        return _libsbml.ASTNode_replaceIDWithFunction(self, *args)

    def setIsChildFlag(self, *args):
        """
        setIsChildFlag(self, bool flag)

        @internal
        Replaces any 'AST_NAME_TIME' nodes with a node that multiplies time by
        the given function.

        @internal

        """
        return _libsbml.ASTNode_setIsChildFlag(self, *args)

    def unsetUnits(self):
        """
        unsetUnits(self) -> int

        Unsets the units of this ASTNode.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ASTNode_unsetUnits(self)

    def unsetId(self):
        """
        unsetId(self) -> int

        Unsets the MathML @c id attribute of this ASTNode.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ASTNode_unsetId(self)

    def unsetClass(self):
        """
        unsetClass(self) -> int

        Unsets the MathML @c class attribute of this ASTNode.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ASTNode_unsetClass(self)

    def unsetStyle(self):
        """
        unsetStyle(self) -> int

        Unsets the MathML @c style attribute of this ASTNode.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        """
        return _libsbml.ASTNode_unsetStyle(self)

    def setDefinitionURL(self, *args):
        """
        setDefinitionURL(self, XMLAttributes url) -> int
        setDefinitionURL(self, string url) -> int

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setDefinitionURL(XMLAttributes url)</pre>

        Sets the MathML attribute @c definitionURL.

        @param url the URL value for the @c definitionURL attribute.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see setDefinitionURL()
        @see getDefinitionURL()
        @see getDefinitionURLString()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>setDefinitionURL(string url)</pre>

        Sets the MathML attribute @c definitionURL.

        @param url the URL value for the @c definitionURL attribute.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink

        @see setDefinitionURL()
        @see getDefinitionURL()
        @see getDefinitionURLString()

        """
        return _libsbml.ASTNode_setDefinitionURL(self, *args)

    def getDefinitionURL(self):
        """
        getDefinitionURL(self) -> XMLAttributes

        Returns the MathML @c definitionURL attribute value.

        @return the value of the @c definitionURL attribute, in the form of
        a libSBML XMLAttributes object.

        @see setDefinitionURL()
        @see setDefinitionURL()
        @see getDefinitionURLString()

        """
        return _libsbml.ASTNode_getDefinitionURL(self)

    def replaceArgument(self, *args):
        """
        replaceArgument(self, string bvar, ASTNode arg)

        Replaces occurrences of a given name with a given ASTNode.

        For example, if the formula in this ASTNode is <code>x + y</code>,
        then the <code>&lt;bvar&gt;</code> is @c x and @c arg is an ASTNode
        representing the real value @c 3.  This method substitutes @c 3 for @c
        x within this ASTNode object.

        @param bvar a string representing the variable name to be substituted.

        @param arg an ASTNode representing the name/value/formula to use as
        a replacement.

        """
        return _libsbml.ASTNode_replaceArgument(self, *args)

    def getParentSBMLObject(self):
        """
        getParentSBMLObject(self) -> SBase

        Returns the parent SBML object.

        @return the parent SBML object of this ASTNode.

        @see isSetParentSBMLObject()
        @if clike @see setParentSBMLObject()@endif@~

        """
        return _libsbml.ASTNode_getParentSBMLObject(self)

    def unsetParentSBMLObject(self):
        """
        unsetParentSBMLObject(self) -> int

        Unsets the parent SBML object.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @see isSetParentSBMLObject()
        @see getParentSBMLObject()

        """
        return _libsbml.ASTNode_unsetParentSBMLObject(self)

    def isSetParentSBMLObject(self):
        """
        isSetParentSBMLObject(self) -> bool

        Returns @c True if this node has a value for the parent SBML
        object.

        @return true if this ASTNode has an parent SBML object set, @c False otherwise.

        @see getParentSBMLObject()
        @if clike @see setParentSBMLObject()@endif@~

        """
        return _libsbml.ASTNode_isSetParentSBMLObject(self)

    def reduceToBinary(self):
        """
        reduceToBinary(self)

        Reduces this ASTNode to a binary tree.

        Example: if this ASTNode is <code>and(x, y, z)</code>, then the
        formula of the reduced node is <code>and(and(x, y), z)</code>.  The
        operation replaces the formula stored in the current ASTNode object.

        """
        return _libsbml.ASTNode_reduceToBinary(self)

    def unsetUserData(self):
        """
        unsetUserData(self) -> int

        Unsets the user data of this node.

        The user data can be used by the application developer to attach custom
        information to the node.  In case of a deep copy, this attribute will
        passed as it is. The attribute will be never interpreted by this class.

        @return integer value indicating success/failure of the
        function.  The possible values returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink

        @if clike
        @see ASTNode.setUserData()
        @see ASTNode.getUserData()
        @see ASTNode.isSetUserData()
        @endif@~

        """
        return _libsbml.ASTNode_unsetUserData(self)

    def isSetUserData(self):
        """
        isSetUserData(self) -> bool

        Returns @c True if this node has a user data object.

        @return true if this ASTNode has a user data object set, @c False
        otherwise.

        @if clike
        @see ASTNode.setUserData()
        @see ASTNode.getUserData()
        @see ASTNode.unsetUserData()
        @endif@~

        """
        return _libsbml.ASTNode_isSetUserData(self)

    def isWellFormedASTNode(self):
        """
        isWellFormedASTNode(self) -> bool

        Returns @c True or @c False depending on whether this
        ASTNode is well-formed.

        @note An ASTNode may be well-formed, with each node and its children
        having the appropriate number of children for the given type, but may
        still be invalid in the context of its use within an SBML model.

        @return @c True if this ASTNode is well-formed, @c False otherwise.

        @see hasCorrectNumberArguments()

        """
        return _libsbml.ASTNode_isWellFormedASTNode(self)

    def hasCorrectNumberArguments(self):
        """
        hasCorrectNumberArguments(self) -> bool

        Returns @c True if this ASTNode has the correct number of children for
        its type.

        For example, an ASTNode with type @link libsbml#AST_PLUS AST_PLUS@endlink
        expects 2 child nodes.

        @return @c True if this ASTNode has the appropriate number of children
        for its type, @c False otherwise.

        @note This function performs a check on the top-level node only.  Child
        nodes are not checked.

        @see isWellFormedASTNode()

        """
        return _libsbml.ASTNode_hasCorrectNumberArguments(self)

    def getDefinitionURLString(self):
        """
        getDefinitionURLString(self) -> string

        Returns the MathML @c definitionURL attribute value as a string.

        @return the value of the @c definitionURL attribute, as a string.

        @see getDefinitionURL()
        @see setDefinitionURL()
        @see setDefinitionURL()

        """
        return _libsbml.ASTNode_getDefinitionURLString(self)

    def representsBvar(self):
        """
        representsBvar(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTNode_representsBvar(self)

    def write(self, *args):
        """
        write(self, XMLOutputStream stream)

        @internal

        @internal

        """
        return _libsbml.ASTNode_write(self, *args)

    def read(self, *args):
        """
        read(self, XMLInputStream stream, string reqd_prefix = "") -> bool
        read(self, XMLInputStream stream) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTNode_read(self, *args)

    def writeNodeOfType(self, *args):
        """
        writeNodeOfType(self, XMLOutputStream stream, int type, bool inChildNode = False)
        writeNodeOfType(self, XMLOutputStream stream, int type)

        @internal

        @internal

        """
        return _libsbml.ASTNode_writeNodeOfType(self, *args)

    def getNumBvars(self):
        """
        getNumBvars(self) -> unsigned int

        @internal

        @internal

        """
        return _libsbml.ASTNode_getNumBvars(self)

    def getTypeCode(self):
        """
        getTypeCode(self) -> int

        @internal

        @internal

        """
        return _libsbml.ASTNode_getTypeCode(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        @internal

        @internal

        """
        return _libsbml.ASTNode_getPackageName(self)

    def __eq__(self, rhs):
      if ((self is None) and (rhs is None)): return True
      if ((self is None) or  (rhs is None)): return False
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return True
      return False

    def __ne__(self, rhs):
      if ((self is None) and (rhs is None)): return False
      if ((self is None) or  (rhs is None)): return True
      if (hasattr(self, 'this') and hasattr(rhs, 'this')):
        if (self.this == rhs.this): return False
      return True

    def getListOfNodes(self):
        """
        getListOfNodes(self) -> ASTNodeList

        @return an ASTNodeList of all ASTNode objects.

        Unlike the equivalent method in the libSBML C/C++ interface, this method does
        not offer the ability to pass a predicate as an argument.  The method always
        returns the list of all ASTNode objects.

        @return the ASTNodeList of nodes.

        @warning The list returned is owned by the caller and should be deleted after
        the caller is done using it.  The ASTNode objects in the list; however, are
        <strong>not</strong> owned by the caller (as they still belong to the tree
        itself), and therefore should not be deleted.

        """
        return _libsbml.ASTNode_getListOfNodes(self)

ASTNode_swigregister = _libsbml.ASTNode_swigregister
ASTNode_swigregister(ASTNode)


def readMathMLFromString(*args):
  """
    readMathMLFromString(char xml) -> ASTNode_t

    Reads the MathML from the given XML string, constructs a corresponding
    abstract syntax tree, and returns a pointer to the root of the tree.

    @param xml a string containing a full MathML expression

    @return the root of an AST corresponding to the given mathematical
    expression, otherwise @c None is returned if the given string is @c None
    or invalid.

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.readMathMLFromString(*args)

def readMathMLFromStringWithNamespaces(*args):
  """
    readMathMLFromStringWithNamespaces(char xml, XMLNamespaces_t xmlns) -> ASTNode_t

    Reads the MathML from the given XML string, constructs a corresponding
    abstract syntax tree, and returns a pointer to the root of the tree.

    @param xml a string containing a full MathML expression
    @param xmlns a XMLNamespaces_t object containing namespaces that
    are considered active during the read e.g. an L3 package namespace

    @return the root of an AST corresponding to the given mathematical
    expression, otherwise @c None is returned if the given string is @c None
    or invalid.

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.readMathMLFromStringWithNamespaces(*args)

def writeMathMLToString(*args):
  """
    writeMathMLToString(ASTNode_t node) -> char

    Writes the given ASTNode_t (and its children) to a string as MathML, and
    returns the string.

    @param node the root of an AST to write out to the stream.

    @return a string containing the written-out MathML representation
    of the given AST.

    @note The string is owned by the caller and should be freed (with
    free()) when no longer needed.  @c None is returned if the given
    argument is @c None.

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.writeMathMLToString(*args)

def parseFormula(*args):
  """
    parseFormula(char formula) -> ASTNode_t

    Parses a text string as a mathematical formula and returns an AST
    representation of it.

    @par
    The text-string form of mathematical formulas produced by
    @sbmlfunction{formulaToString, ASTNode} and read by
    @sbmlfunction{parseFormula, String} use a simple C-inspired infix
    notation taken from SBML Level&nbsp;1.  A formula in this text-string form
    therefore can be handed to a program that understands SBML Level&nbsp;1
    mathematical expressions, or used as part of a formula translation system.
    The syntax is described in detail in the documentation for ASTNode.  The
    following are illustrative examples of formulas expressed using this syntax:
    @verbatim
    0.10 * k4^2
    @endverbatim
    @verbatim
    (vm * s1)/(km + s1)
    @endverbatim

    Note that this facility is provided as a convenience by libSBML---the
    MathML standard does not actually define a 'string-form' equivalent to
    MathML expression trees, so the choice of formula syntax is somewhat
    arbitrary.  The approach taken by libSBML is to use the syntax defined by
    SBML Level&nbsp;1 (which in fact used a text-string representation of
    formulas and not MathML).  This formula syntax is based mostly on C
    programming syntax, and may contain operators, function calls, symbols,
    and white space characters.  The following table provides the precedence
    rules for the different entities that may appear in formula strings.

    @htmlinclude math-precedence-table.html

    In the table above, @em operand implies the construct is an operand, @em
    prefix implies the operation is applied to the following arguments, @em
    unary implies there is one argument, and @em binary implies there are
    two arguments.  The values in the <b>Precedence</b> column show how the
    order of different types of operation are determined.  For example, the
    expression <code>a * b + c</code> is evaluated as <code>(a * b) +
    c</code> because the @c * operator has higher precedence.  The
    <b>Associates</b> column shows how the order of similar precedence
    operations is determined; for example, <code>a - b + c</code> is
    evaluated as <code>(a - b) + c</code> because the @c + and @c -
    operators are left-associative.

    The function call syntax consists of a function name, followed by optional
    white space, followed by an opening parenthesis token, followed by a
    sequence of zero or more arguments separated by commas (with each comma
    optionally preceded and/or followed by zero or more white space
    characters, followed by a closing parenthesis token.  The function name
    must be chosen from one of the pre-defined functions in SBML or a
    user-defined function in the model.  The following table lists the names
    of certain common mathematical functions; this table corresponds to
    Table&nbsp;6 in the <a target='_blank' href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML Level&nbsp;1 Version&nbsp;2 specification</a>:

    @htmlinclude string-functions-table.html

    @warning <span class='warning'>There are differences between the symbols
    used to represent the common mathematical functions and the corresponding
    MathML token names.  This is a potential source of incompatibilities.
    Note in particular that in this text-string syntax, <code>log(x)</code>
    represents the natural logarithm, whereas in MathML, the natural logarithm
    is <code>&lt;ln/&gt;</code>.  Application writers are urged to be careful
    when translating between text forms and MathML forms, especially if they
    provide a direct text-string input facility to users of their software
    systems.</span>

    @param formula the text-string formula expression to be parsed

    @return the root node of the AST corresponding to the @p formula, or @c
    None if an error occurred in parsing the formula

    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{formulaToString, ASTNode}
    @see @sbmlfunction{formulaToL3String, ASTNode}
    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see L3ParserSettings

    @note
    Callers using SBML Level&nbsp;3 are encouraged to use the facilities
    provided by libSBML's newer and more powerful Level&nbsp;3-oriented
    formula parser and formatter.  The entry points to this second system are
    @sbmlfunction{parseL3Formula, String} and
    @sbmlfunction{formulaToL3String, ASTNode}.  The Level&nbsp;1-oriented
    system (i.e., what is provided by @sbmlfunction{formulaToString, String}
    and @sbmlfunction{parseFormula, ASTNode}) is provided 
    untouched for backwards compatibility.

    @note We urge developers to keep in mind that the text-string formula
    syntax is specific to libSBML.  <em>Neither MathML nor SBML define a
    text-string format for mathematical formulas.</em> LibSBML's particular
    syntax should not be considered to be a canonical or standard
    general-purpose mathematical expression syntax.  LibSBML provides methods
    for parsing and transforming text-string math formulas back and forth from
    AST structures for the convenience of calling applications, but it is
    important to keep the system's limitations in mind.

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.parseFormula(*args)

def formulaToL3String(*args):
  """
    formulaToL3String(ASTNode_t tree) -> char

    Converts an AST to a text string representation of a formula using an
    extended syntax.

    @par
    The text-string form of mathematical formulas read by the function
    @sbmlfunction{parseL3Formula, String} and written by the function
    @sbmlfunction{formulaToL3String, ASTNode} uses an expanded version of
    the syntax read and written by @sbmlfunction{parseFormula, String}
    and @sbmlfunction{formulaToString, ASTNode}, respectively.  The
    latter two libSBML functions were originally developed to support
    conversion between SBML Levels&nbsp;1 and&nbsp;2, and were focused on the
    syntax of mathematical formulas used in SBML Level&nbsp;1.  With time, and
    the use of MathML in SBML Levels&nbsp;2 and&nbsp;3, it became clear that
    supporting Level&nbsp;2 and&nbsp;3's expanded mathematical syntax would be
    useful for software developers.  To maintain backwards compatibility for
    libSBML users, the original @sbmlfunction{formulaToString, ASTNode}
    and @sbmlfunction{parseFormula, String} have been left untouched,
    and instead, the new functionality is provided in the form of
    @sbmlfunction{parseL3Formula, String} and
    @sbmlfunction{formulaToL3String, ASTNode}.

    The following lists the main differences in the formula syntax supported by
    the 'Level 3' or L3 versions of the formula parsers and formatters,
    compared to what is supported by the Level&nbsp;1-oriented
    @sbmlfunction{parseFormula, String} and
    @sbmlfunction{formulaToString, ASTNode}:

    @li Units may be asociated with bare numbers, using the following syntax:
    <div style='margin: 10px auto 10px 25px; display: block'>
    <span class='code' style='background-color: #d0d0ee'>number</span>
    <span class='code' style='background-color: #edd'>unit</span>
    </div>
    The <span class='code' style='background-color: #d0d0ee'>number</span>
    may be in any form (an integer, real, or rational
    number), and the
    <span class='code' style='background-color: #edd'>unit</span>
    must conform to the syntax of an SBML identifier (technically, the
    type defined as @c SId in the SBML specifications).  The whitespace between
    <span class='code' style='background-color: #d0d0ee'>number</span>
    and <span class='code' style='background-color: #edd'>unit</span>
    is optional.

    @li The Boolean function symbols @c &&, @c ||, @c !, and @c != may be
    used.

    @li The @em modulo operation is allowed as the symbol @c @% and will
    produce a <code>&lt;piecewise&gt;</code> function in the corresponding
    MathML output.

    @li All inverse trigonometric functions may be defined in the infix either
    using @c arc as a prefix or simply @c a; in other words, both @c arccsc
    and @c acsc are interpreted as the operator @em arccosecant as defined in
    MathML&nbsp;2.0.  (Many functions in the simpler SBML Level&nbsp;1
    oriented parser implemented by @sbmlfunction{parseFormula, String}
    are defined this way as well, but not all.)

    @li The following expression is parsed as a rational number instead of
    as a numerical division:
    <pre style='display: block; margin-left: 25px'>
    (<span class='code' style='background-color: #d0d0ee'>integer</span>/<span class='code' style='background-color: #d0d0ee'>integer</span>)</pre>
    <strong>Spaces are not allowed</strong> in this construct; in other words,
    &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and
    the operator) will be parsed into the MathML <code>&lt;divide&gt;</code>
    construct rather than a rational number.  You can, however, assign units to a
    rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;.
    (In the case of division rather than a rational number, units are not interpreted
    in this way.)

    @li Various parser and formatter behaviors may be altered through the use
    of a L3ParserSettings object in conjunction with the functions
    @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings} and
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    The settings available include the following:
    <ul style='list-style-type: circle'>

    <li style='margin-bottom: 0.5em'> The function @c log with a single
    argument (&quot;<code>log(x)</code>&quot;) can be parsed as
    <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as
    desired.

    <li style='margin-bottom: 0.5em'> Unary minus signs can be collapsed or
    preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>-
    -3</code>&quot;) can be removed from the input entirely and single unary
    minuses can be incorporated into the number node, or all minuses can be
    preserved in the AST node structure.

    <li style='margin-bottom: 0.5em'> Parsing of units embedded in the input
    string can be turned on and off.

    <li style='margin-bottom: 0.5em'> The string @c avogadro can be parsed as
    a MathML @em csymbol or as an identifier.

    <li style='margin-bottom: 0.5em'> A Model object may optionally be
    provided to the parser using the variant function call
    @sbmlfunction{parseL3FormulaWithModel, String\, Model} or
    stored in a L3ParserSettings object passed to the variant function
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.  When a Model object is provided, identifiers
    (values of type @c SId) from that model are used in preference to
    pre-defined MathML definitions for both symbols and functions.
    More precisely:
    <ul style='list-style-type: square'>

    <li style='margin-bottom: 0.5em'> <em>In the case of symbols</em>: the
    Model entities whose identifiers will shadow identical symbols in the
    mathematical formula are: Species, Compartment, Parameter, Reaction, and
    SpeciesReference.  For instance, if the parser is given a Model containing
    a Species with the identifier &quot;<code>pi</code>&quot;, and the formula
    to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will
    contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of
    the construct <code>&lt;pi/&gt;</code>.

    <li style='margin-bottom: 0.5em'> <em>In the case of user-defined
    functions</em>: when a Model object is provided, @c SId values of
    user-defined functions present in the model will be used preferentially
    over pre-defined MathML functions.  For example, if the passed-in Model
    contains a FunctionDefinition object with the identifier
    &quot;<code>sin</code>&quot;, that function will be used instead of the
    predefined MathML function <code>&lt;sin/&gt;</code>.
    </ul>

    <li style='margin-bottom: 0.5em'> An SBMLNamespaces object may optionally
    be provided to identify SBML Level&nbsp;3 packages that extend the
    syntax understood by the formula parser.  When the namespaces are provided,
    the parser will interpret possible additional syntax defined by the libSBML
    plug-ins implementing the SBML Level&nbsp;3 packages; for example, it may
    understand vector/array extensions introduced by the SBML Level&nbsp;3 @em
    Arrays package.
    </ul>

    These configuration settings cannot be changed directly using the basic
    parser and formatter functions, but @em can be changed on a per-call basis
    by using the alternative functions @sbmlfunction{parseL3FormulaWithSettings,
    String\, L3ParserSettings} and
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\,
    L3ParserSettings}.

    Neither SBML nor the MathML standard define a 'string-form' equivalent to
    MathML expressions.  The approach taken by libSBML is to start with the
    formula syntax defined by SBML Level&nbsp;1 (which in fact used a custom
    text-string representation of formulas, and not MathML), and expand it to
    include the functionality described above.  This formula syntax is based
    mostly on C programming syntax, and may contain operators, function calls,
    symbols, and white space characters.  The following table provides the
    precedence rules for the different entities that may appear in formula
    strings.

    @htmlinclude math-precedence-table-l3.html

    In the table above, @em operand implies the construct is an operand, @em
    prefix implies the operation is applied to the following arguments, @em
    unary implies there is one argument, and @em binary implies there are
    two arguments.  The values in the <b>Precedence</b> column show how the
    order of different types of operation are determined.  For example, the
    expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code>
    because the @c * operator has higher precedence.  The
    <b>Associates</b> column shows how the order of similar precedence
    operations is determined; for example, <code>a && b || c</code> is
    evaluated as <code>(a && b) || c</code> because the @c && and @c ||
    operators are left-associative and have the same precedence.

    The function call syntax consists of a function name, followed by optional
    white space, followed by an opening parenthesis token, followed by a
    sequence of zero or more arguments separated by commas (with each comma
    optionally preceded and/or followed by zero or more white space
    characters), followed by a closing parenthesis token.  The function name
    must be chosen from one of the pre-defined functions in SBML or a
    user-defined function in the model.  The following table lists the names
    of certain common mathematical functions; this table corresponds to
    Table&nbsp;6 in the <a target='_blank'
    href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML
    Level&nbsp;1 Version&nbsp;2 specification</a> with additions based on the
    functions added in SBML Level 2 and Level 3:

    @htmlinclude string-functions-table-l3.html

    Parsing of the various MathML functions and constants are all
    case-insensitive by default: function names such as <code>cos</code>,
    <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine
    operator, <code>&lt;cos&gt;</code>.  However, <em>when a Model object is
    used</em> in conjunction with either
    @sbmlfunction{parseL3FormulaWithModel, String\, Model} or
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}, any identifiers found in that model will be
    parsed in a case-<em>sensitive</em> way.  For example, if a model contains
    a Species having the identifier <code>Pi</code>, the parser will parse
    &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi
    &lt;/ci&gt;</code>&quot; but will continue to parse the symbols
    &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as
    &quot;<code>&lt;pi&gt;</code>&quot;.

    As mentioned above, the manner in which the 'L3' versions of the formula
    parser and formatter interpret the function &quot;<code>log</code>&quot;
    can be changed.  To do so, callers should use the function
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings} and pass it an appropriate L3ParserSettings
    object.  By default, unlike the SBML Level&nbsp;1 parser implemented by
    @sbmlfunction{parseFormula, String}, the string
    &quot;<code>log</code>&quot; is interpreted as the base&nbsp;10 logarithm,
    and @em not as the natural logarithm.  However, you can change the
    interpretation to be base-10 log, natural log, or as an error; since the
    name 'log' by itself is ambiguous, you require that the parser uses @c
    log10 or @c ln instead, which are more clear.  Please refer to
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.

    In addition, the following symbols will be translated to their MathML
    equivalents, if no symbol with the same @c SId identifier string exists
    in the Model object provided:

    @htmlinclude string-values-table-l3.html

    Again, as mentioned above, whether the string
    &quot;<code>avogadro</code>&quot; is parsed as an AST node of type
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink or
    @link libsbml#AST_NAME AST_NAME@endlink is configurable; use the version of
    the parser function called @sbmlfunction{parseL3FormulaWithSettings,
    String\, L3ParserSettings}.  This Avogadro-related
    functionality is provided because SBML Level&nbsp;2 models may not use
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink AST nodes.

    @param tree the AST to be converted.

    @return the formula from the given AST as text string, with a syntax
    oriented towards the capabilities defined in SBML Level&nbsp;3.  The
    caller owns the returned string and is responsible for freeing it when it
    is no longer needed.  If @p tree is a null pointer, then a null pointer is
    returned.

    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see @sbmlfunction{formulaToString, ASTNode}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see L3ParserSettings
    @see @sbmlfunction{getDefaultL3ParserSettings,}
    @see @sbmlfunction{getLastParseL3Error,}

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.formulaToL3String(*args)

def formulaToL3StringWithSettings(*args):
  """
    formulaToL3StringWithSettings(ASTNode_t tree, L3ParserSettings_t settings) -> char

    Converts an AST to a text string representation of a formula, using
    specific formatter settings.

    This function behaves identically to @sbmlfunction{formulaToL3String,
    ASTNode} but its behavior is controlled by two fields in the @p
    settings object, namely:

    @li <em>parseunits</em> ('parse units'): If this field in the @p settings
    object is set to <code>true</code> (the default), the function will
    write out the units of any numerical ASTNodes that have them,
    producing (for example) &quot;<code>3 mL</code>&quot;,
    &quot;<code>(3/4) m</code>&quot;, or &quot;<code>5.5e-10
    M</code>&quot;.  If this is set to <code>false</code>, this function
    will only write out the number itself (&quot;<code>3</code>&quot;,
    &quot;<code>(3/4)</code>&quot;, and &quot;<code>5.5e-10</code>&quot;,
    in the previous examples).
    @li <em>collapseminus</em> ('collapse minus'): If this field in the @p
    settings object is set to <code>false</code> (the default), the
    function will write out explicitly any doubly-nested unary minus
    ASTNodes, producing (for example) &quot;<code>- -x</code>&quot; or
    even &quot;<code>- - - - -3.1</code>&quot;.  If this is set to
    <code>true</code>, the function will collapse the nodes before
    producing the infix form, producing &quot;<code>x</code>&quot; and
    &quot;<code>-3.1</code>&quot; in the previous examples.

    All the other settings of the L3ParserSettings object passed in as @p
    settings will be ignored for the purposes of this function: the
    <em>parselog</em> ('parse log') setting is ignored so that
    &quot;<code>log10(x)</code>&quot;, &quot;<code>ln(x)</code>&quot;, and
    &quot;<code>log(x, y)</code>&quot; are always produced; the
    <em>avocsymbol</em> ('Avogadro csymbol') is irrelevant to the behavior
    of this function; and nothing in the Model object set via the
    <em>model</em> setting is used.

    @param tree the AST to be converted.
    @param settings the L3ParserSettings object used to modify the behavior of
    this function.

    @return the formula from the given AST as text string, with a syntax
    oriented towards the capabilities defined in SBML Level&nbsp;3.  The
    caller owns the returned string and is responsible for freeing it when it
    is no longer needed.  If @p tree is a null pointer, then a null pointer is
    returned.

    @see @sbmlfunction{formulaToL3String, ASTNode}
    @see @sbmlfunction{formulaToString, ASTNode}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see L3ParserSettings
    @see @sbmlfunction{getDefaultL3ParserSettings,}
    @see @sbmlfunction{getLastParseL3Error,}

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.formulaToL3StringWithSettings(*args)

def formulaToString(*args):
  """
    formulaToString(ASTNode_t tree) -> char

    Converts an AST to a text string representation of a formula using a
    basic syntax derived from SBML Level&nbsp;1.

    @par
    The text-string form of mathematical formulas produced by
    @sbmlfunction{formulaToString, ASTNode} and read by
    @sbmlfunction{parseFormula, String} use a simple C-inspired infix
    notation taken from SBML Level&nbsp;1.  A formula in this text-string form
    therefore can be handed to a program that understands SBML Level&nbsp;1
    mathematical expressions, or used as part of a formula translation system.
    The syntax is described in detail in the documentation for ASTNode.  The
    following are illustrative examples of formulas expressed using this syntax:
    @verbatim
    0.10 * k4^2
    @endverbatim
    @verbatim
    (vm * s1)/(km + s1)
    @endverbatim

    Note that this facility is provided as a convenience by libSBML---the
    MathML standard does not actually define a 'string-form' equivalent to
    MathML expression trees, so the choice of formula syntax is somewhat
    arbitrary.  The approach taken by libSBML is to use the syntax defined by
    SBML Level&nbsp;1 (which in fact used a text-string representation of
    formulas and not MathML).  This formula syntax is based mostly on C
    programming syntax, and may contain operators, function calls, symbols,
    and white space characters.  The following table provides the precedence
    rules for the different entities that may appear in formula strings.

    @htmlinclude math-precedence-table.html

    In the table above, @em operand implies the construct is an operand, @em
    prefix implies the operation is applied to the following arguments, @em
    unary implies there is one argument, and @em binary implies there are
    two arguments.  The values in the <b>Precedence</b> column show how the
    order of different types of operation are determined.  For example, the
    expression <code>a * b + c</code> is evaluated as <code>(a * b) +
    c</code> because the @c * operator has higher precedence.  The
    <b>Associates</b> column shows how the order of similar precedence
    operations is determined; for example, <code>a - b + c</code> is
    evaluated as <code>(a - b) + c</code> because the @c + and @c -
    operators are left-associative.

    The function call syntax consists of a function name, followed by optional
    white space, followed by an opening parenthesis token, followed by a
    sequence of zero or more arguments separated by commas (with each comma
    optionally preceded and/or followed by zero or more white space
    characters, followed by a closing parenthesis token.  The function name
    must be chosen from one of the pre-defined functions in SBML or a
    user-defined function in the model.  The following table lists the names
    of certain common mathematical functions; this table corresponds to
    Table&nbsp;6 in the <a target='_blank' href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML Level&nbsp;1 Version&nbsp;2 specification</a>:

    @htmlinclude string-functions-table.html

    @warning <span class='warning'>There are differences between the symbols
    used to represent the common mathematical functions and the corresponding
    MathML token names.  This is a potential source of incompatibilities.
    Note in particular that in this text-string syntax, <code>log(x)</code>
    represents the natural logarithm, whereas in MathML, the natural logarithm
    is <code>&lt;ln/&gt;</code>.  Application writers are urged to be careful
    when translating between text forms and MathML forms, especially if they
    provide a direct text-string input facility to users of their software
    systems.</span>

    @param tree the AST to be converted.

    @return the formula from the given AST as a text-string mathematical
    formula oriented towards SBML Level&nbsp;1.  The caller owns the returned
    string and is responsible for freeing it when it is no longer needed.

    @see @sbmlfunction{formulaToL3String, ASTNode}
    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}

    @note
    Callers using SBML Level&nbsp;3 are encouraged to use the facilities
    provided by libSBML's newer and more powerful Level&nbsp;3-oriented
    formula parser and formatter.  The entry points to this second system are
    @sbmlfunction{parseL3Formula, String} and
    @sbmlfunction{formulaToL3String, ASTNode}.  The Level&nbsp;1-oriented
    system (i.e., what is provided by @sbmlfunction{formulaToString, String}
    and @sbmlfunction{parseFormula, ASTNode}) is provided 
    untouched for backwards compatibility.

    @note We urge developers to keep in mind that the text-string formula
    syntax is specific to libSBML.  <em>Neither MathML nor SBML define a
    text-string format for mathematical formulas.</em> LibSBML's particular
    syntax should not be considered to be a canonical or standard
    general-purpose mathematical expression syntax.  LibSBML provides methods
    for parsing and transforming text-string math formulas back and forth from
    AST structures for the convenience of calling applications, but it is
    important to keep the system's limitations in mind.

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.formulaToString(*args)

def parseL3Formula(*args):
  """
    parseL3Formula(char formula) -> ASTNode_t

    Parses a text string as a mathematical formula and returns an AST
    representation of it.

    @par
    The text-string form of mathematical formulas read by the function
    @sbmlfunction{parseL3Formula, String} and written by the function
    @sbmlfunction{formulaToL3String, ASTNode} uses an expanded version of
    the syntax read and written by @sbmlfunction{parseFormula, String}
    and @sbmlfunction{formulaToString, ASTNode}, respectively.  The
    latter two libSBML functions were originally developed to support
    conversion between SBML Levels&nbsp;1 and&nbsp;2, and were focused on the
    syntax of mathematical formulas used in SBML Level&nbsp;1.  With time, and
    the use of MathML in SBML Levels&nbsp;2 and&nbsp;3, it became clear that
    supporting Level&nbsp;2 and&nbsp;3's expanded mathematical syntax would be
    useful for software developers.  To maintain backwards compatibility for
    libSBML users, the original @sbmlfunction{formulaToString, ASTNode}
    and @sbmlfunction{parseFormula, String} have been left untouched,
    and instead, the new functionality is provided in the form of
    @sbmlfunction{parseL3Formula, String} and
    @sbmlfunction{formulaToL3String, ASTNode}.

    The following lists the main differences in the formula syntax supported by
    the 'Level 3' or L3 versions of the formula parsers and formatters,
    compared to what is supported by the Level&nbsp;1-oriented
    @sbmlfunction{parseFormula, String} and
    @sbmlfunction{formulaToString, ASTNode}:

    @li Units may be asociated with bare numbers, using the following syntax:
    <div style='margin: 10px auto 10px 25px; display: block'>
    <span class='code' style='background-color: #d0d0ee'>number</span>
    <span class='code' style='background-color: #edd'>unit</span>
    </div>
    The <span class='code' style='background-color: #d0d0ee'>number</span>
    may be in any form (an integer, real, or rational
    number), and the
    <span class='code' style='background-color: #edd'>unit</span>
    must conform to the syntax of an SBML identifier (technically, the
    type defined as @c SId in the SBML specifications).  The whitespace between
    <span class='code' style='background-color: #d0d0ee'>number</span>
    and <span class='code' style='background-color: #edd'>unit</span>
    is optional.

    @li The Boolean function symbols @c &&, @c ||, @c !, and @c != may be
    used.

    @li The @em modulo operation is allowed as the symbol @c @% and will
    produce a <code>&lt;piecewise&gt;</code> function in the corresponding
    MathML output.

    @li All inverse trigonometric functions may be defined in the infix either
    using @c arc as a prefix or simply @c a; in other words, both @c arccsc
    and @c acsc are interpreted as the operator @em arccosecant as defined in
    MathML&nbsp;2.0.  (Many functions in the simpler SBML Level&nbsp;1
    oriented parser implemented by @sbmlfunction{parseFormula, String}
    are defined this way as well, but not all.)

    @li The following expression is parsed as a rational number instead of
    as a numerical division:
    <pre style='display: block; margin-left: 25px'>
    (<span class='code' style='background-color: #d0d0ee'>integer</span>/<span class='code' style='background-color: #d0d0ee'>integer</span>)</pre>
    <strong>Spaces are not allowed</strong> in this construct; in other words,
    &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and
    the operator) will be parsed into the MathML <code>&lt;divide&gt;</code>
    construct rather than a rational number.  You can, however, assign units to a
    rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;.
    (In the case of division rather than a rational number, units are not interpreted
    in this way.)

    @li Various parser and formatter behaviors may be altered through the use
    of a L3ParserSettings object in conjunction with the functions
    @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings} and
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    The settings available include the following:
    <ul style='list-style-type: circle'>

    <li style='margin-bottom: 0.5em'> The function @c log with a single
    argument (&quot;<code>log(x)</code>&quot;) can be parsed as
    <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as
    desired.

    <li style='margin-bottom: 0.5em'> Unary minus signs can be collapsed or
    preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>-
    -3</code>&quot;) can be removed from the input entirely and single unary
    minuses can be incorporated into the number node, or all minuses can be
    preserved in the AST node structure.

    <li style='margin-bottom: 0.5em'> Parsing of units embedded in the input
    string can be turned on and off.

    <li style='margin-bottom: 0.5em'> The string @c avogadro can be parsed as
    a MathML @em csymbol or as an identifier.

    <li style='margin-bottom: 0.5em'> A Model object may optionally be
    provided to the parser using the variant function call
    @sbmlfunction{parseL3FormulaWithModel, String\, Model} or
    stored in a L3ParserSettings object passed to the variant function
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.  When a Model object is provided, identifiers
    (values of type @c SId) from that model are used in preference to
    pre-defined MathML definitions for both symbols and functions.
    More precisely:
    <ul style='list-style-type: square'>

    <li style='margin-bottom: 0.5em'> <em>In the case of symbols</em>: the
    Model entities whose identifiers will shadow identical symbols in the
    mathematical formula are: Species, Compartment, Parameter, Reaction, and
    SpeciesReference.  For instance, if the parser is given a Model containing
    a Species with the identifier &quot;<code>pi</code>&quot;, and the formula
    to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will
    contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of
    the construct <code>&lt;pi/&gt;</code>.

    <li style='margin-bottom: 0.5em'> <em>In the case of user-defined
    functions</em>: when a Model object is provided, @c SId values of
    user-defined functions present in the model will be used preferentially
    over pre-defined MathML functions.  For example, if the passed-in Model
    contains a FunctionDefinition object with the identifier
    &quot;<code>sin</code>&quot;, that function will be used instead of the
    predefined MathML function <code>&lt;sin/&gt;</code>.
    </ul>

    <li style='margin-bottom: 0.5em'> An SBMLNamespaces object may optionally
    be provided to identify SBML Level&nbsp;3 packages that extend the
    syntax understood by the formula parser.  When the namespaces are provided,
    the parser will interpret possible additional syntax defined by the libSBML
    plug-ins implementing the SBML Level&nbsp;3 packages; for example, it may
    understand vector/array extensions introduced by the SBML Level&nbsp;3 @em
    Arrays package.
    </ul>

    These configuration settings cannot be changed directly using the basic
    parser and formatter functions, but @em can be changed on a per-call basis
    by using the alternative functions @sbmlfunction{parseL3FormulaWithSettings,
    String\, L3ParserSettings} and
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\,
    L3ParserSettings}.

    Neither SBML nor the MathML standard define a 'string-form' equivalent to
    MathML expressions.  The approach taken by libSBML is to start with the
    formula syntax defined by SBML Level&nbsp;1 (which in fact used a custom
    text-string representation of formulas, and not MathML), and expand it to
    include the functionality described above.  This formula syntax is based
    mostly on C programming syntax, and may contain operators, function calls,
    symbols, and white space characters.  The following table provides the
    precedence rules for the different entities that may appear in formula
    strings.

    @htmlinclude math-precedence-table-l3.html

    In the table above, @em operand implies the construct is an operand, @em
    prefix implies the operation is applied to the following arguments, @em
    unary implies there is one argument, and @em binary implies there are
    two arguments.  The values in the <b>Precedence</b> column show how the
    order of different types of operation are determined.  For example, the
    expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code>
    because the @c * operator has higher precedence.  The
    <b>Associates</b> column shows how the order of similar precedence
    operations is determined; for example, <code>a && b || c</code> is
    evaluated as <code>(a && b) || c</code> because the @c && and @c ||
    operators are left-associative and have the same precedence.

    The function call syntax consists of a function name, followed by optional
    white space, followed by an opening parenthesis token, followed by a
    sequence of zero or more arguments separated by commas (with each comma
    optionally preceded and/or followed by zero or more white space
    characters), followed by a closing parenthesis token.  The function name
    must be chosen from one of the pre-defined functions in SBML or a
    user-defined function in the model.  The following table lists the names
    of certain common mathematical functions; this table corresponds to
    Table&nbsp;6 in the <a target='_blank'
    href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML
    Level&nbsp;1 Version&nbsp;2 specification</a> with additions based on the
    functions added in SBML Level 2 and Level 3:

    @htmlinclude string-functions-table-l3.html

    Parsing of the various MathML functions and constants are all
    case-insensitive by default: function names such as <code>cos</code>,
    <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine
    operator, <code>&lt;cos&gt;</code>.  However, <em>when a Model object is
    used</em> in conjunction with either
    @sbmlfunction{parseL3FormulaWithModel, String\, Model} or
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}, any identifiers found in that model will be
    parsed in a case-<em>sensitive</em> way.  For example, if a model contains
    a Species having the identifier <code>Pi</code>, the parser will parse
    &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi
    &lt;/ci&gt;</code>&quot; but will continue to parse the symbols
    &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as
    &quot;<code>&lt;pi&gt;</code>&quot;.

    As mentioned above, the manner in which the 'L3' versions of the formula
    parser and formatter interpret the function &quot;<code>log</code>&quot;
    can be changed.  To do so, callers should use the function
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings} and pass it an appropriate L3ParserSettings
    object.  By default, unlike the SBML Level&nbsp;1 parser implemented by
    @sbmlfunction{parseFormula, String}, the string
    &quot;<code>log</code>&quot; is interpreted as the base&nbsp;10 logarithm,
    and @em not as the natural logarithm.  However, you can change the
    interpretation to be base-10 log, natural log, or as an error; since the
    name 'log' by itself is ambiguous, you require that the parser uses @c
    log10 or @c ln instead, which are more clear.  Please refer to
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.

    In addition, the following symbols will be translated to their MathML
    equivalents, if no symbol with the same @c SId identifier string exists
    in the Model object provided:

    @htmlinclude string-values-table-l3.html

    Again, as mentioned above, whether the string
    &quot;<code>avogadro</code>&quot; is parsed as an AST node of type
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink or
    @link libsbml#AST_NAME AST_NAME@endlink is configurable; use the version of
    the parser function called @sbmlfunction{parseL3FormulaWithSettings,
    String\, L3ParserSettings}.  This Avogadro-related
    functionality is provided because SBML Level&nbsp;2 models may not use
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink AST nodes.

    @param formula the text-string formula expression to be parsed

    @return the root node of an AST representing the mathematical formula, or
    @c None if an error occurred while parsing the formula.  When @c None is
    returned, an error is recorded internally; information about the error can
    be retrieved using @sbmlfunction{getLastParseL3Error,}.

    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see @sbmlfunction{formulaToL3String, ASTNode}
    @see @sbmlfunction{formulaToString, ASTNode}
    @see L3ParserSettings
    @see @sbmlfunction{getDefaultL3ParserSettings,}
    @see @sbmlfunction{getLastParseL3Error,}

    @note We urge developers to keep in mind that the text-string formula
    syntax is specific to libSBML.  <em>Neither MathML nor SBML define a
    text-string format for mathematical formulas.</em> LibSBML's particular
    syntax should not be considered to be a canonical or standard
    general-purpose mathematical expression syntax.  LibSBML provides methods
    for parsing and transforming text-string math formulas back and forth from
    AST structures for the convenience of calling applications, but it is
    important to keep the system's limitations in mind.

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.parseL3Formula(*args)

def parseL3FormulaWithModel(*args):
  """
    parseL3FormulaWithModel(char formula, Model_t model) -> ASTNode_t

    Parses a text string as a mathematical formula using a Model to resolve
    symbols, and returns an AST representation of the result.

    This is identical to @sbmlfunction{parseL3Formula, String}, except
    that this function uses the given model in the argument @p model to check
    against identifiers that appear in the @p formula.  For more information
    about the parser, please see the definition of L3ParserSettings and
    the function @sbmlfunction{parseL3Formula, String}.

    @param formula the mathematical formula expression to be parsed

    @param model the Model object to use for checking identifiers

    @return the root node of an AST representing the mathematical formula,
    or @c None if an error occurred while parsing the formula.  When @c None
    is returned, an error is recorded internally; information about the
    error can be retrieved using @sbmlfunction{getLastParseL3Error,}.

    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see @sbmlfunction{getLastParseL3Error,}
    @see L3ParserSettings

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.parseL3FormulaWithModel(*args)

def parseL3FormulaWithSettings(*args):
  """
    parseL3FormulaWithSettings(char formula, L3ParserSettings_t settings) -> ASTNode_t

    Parses a text string as a mathematical formula using specific parser
    settings and returns an AST representation of the result.

    This is identical to @sbmlfunction{parseL3Formula, String}, except
    that this function uses the parser settings given in the argument @p
    settings.  The settings override the default parsing behavior.  The
    following parsing behaviors can be configured:

    @li A Model object may optionally be provided to use identifiers (values
    of type @c SId) from the model in preference to pre-defined MathML symbols
    More precisely, the Model entities whose identifiers will shadow identical
    symbols in the mathematical formula are: Species, Compartment, Parameter,
    Reaction, and SpeciesReference.  For instance, if the parser is given a
    Model containing a Species with the identifier
    &quot;<code>pi</code>&quot;, and the formula to be parsed is
    &quot;<code>3*pi</code>&quot;, the MathML produced by the parser will
    contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of
    the construct <code>&lt;pi/&gt;</code>.  Another example, if the passed-in
    Model contains a FunctionDefinition with the identifier
    &quot;<code>sin</code>&quot;, that function will be used instead of the
    predefined MathML function <code>&lt;sin/&gt;</code>.
    @li The function @c log with a single argument
    (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>,
    <code>ln(x)</code>, or treated as an error, as desired.
    @li Unary minus signs can be either collapsed or preserved; that is, the
    parser can either (1) remove sequential pairs of unary minuses (e.g.,
    &quot;<code>- -3</code>&quot;) from the input and incorporate single unary
    minuses into the number node, or (2) preserve all minuses in the AST node
    structure, turning them into ASTNode objects of type
    @link libsbml#AST_MINUS AST_MINUS@endlink.
    @li The character sequence &quot;<code>number id</code>&quot; can be
    interpreted as a numerical value @c number followed by units of measurement
    indicated by @c id, or it can be treated as a syntax error.  (In
    Level&nbsp;3, MathML <code>&lt;cn&gt;</code> elements can have an
    attribute named @c units placed in the SBML namespace, which can be used
    to indicate the units to be associated with the number.  The text-string
    infix formula parser allows units to be placed after raw numbers; they are
    interpreted as unit identifiers for units defined by the SBML
    specification or in the containing Model object.)
    @li The symbol @c avogadro can be parsed either as a MathML @em csymbol or
    as a identifier.  More specifically, &quot;<code>avogadro</code>&quot; can
    be treated as an ASTNode of type
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink or of type
    @link libsbml#AST_NAME AST_NAME@endlink.
    @li Strings that match built-in functions and constants can either be parsed
    as a match regardless of capitalization, or may be required to be
    all-lower-case to be considered a match.  
    @li LibSBML plug-ins implementing support for SBML Level&nbsp;3 packages
    may introduce extensions to the syntax understood by the parser.  The
    precise nature of the extensions will be documented by the individual
    package plug-ins.  An example of a possible extension is a notation for
    vectors and arrays, introduced by the SBML Level&nbsp;3 @em Arrays
    package.

    For more details about the parser, please see the definition of
    L3ParserSettings and @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.

    @param formula the mathematical formula expression to be parsed

    @param settings the settings to be used for this parser invocation

    @return the root node of an AST representing the mathematical formula,
    or @c None if an error occurred while parsing the formula.  When @c None
    is returned, an error is recorded internally; information about the
    error can be retrieved using @sbmlfunction{getLastParseL3Error,}.

    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see @sbmlfunction{getLastParseL3Error,}
    @see L3ParserSettings

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.parseL3FormulaWithSettings(*args)

def getDefaultL3ParserSettings():
  """
    getDefaultL3ParserSettings() -> L3ParserSettings_t

    Returns a copy of the default Level&nbsp;3 ('L3') formula parser settings.

    The data structure storing the settings allows callers to change the
    following parsing behaviors:

    @par
    The text-string form of mathematical formulas read by the function
    @sbmlfunction{parseL3Formula, String} and written by the function
    @sbmlfunction{formulaToL3String, ASTNode} uses an expanded version of
    the syntax read and written by @sbmlfunction{parseFormula, String}
    and @sbmlfunction{formulaToString, ASTNode}, respectively.  The
    latter two libSBML functions were originally developed to support
    conversion between SBML Levels&nbsp;1 and&nbsp;2, and were focused on the
    syntax of mathematical formulas used in SBML Level&nbsp;1.  With time, and
    the use of MathML in SBML Levels&nbsp;2 and&nbsp;3, it became clear that
    supporting Level&nbsp;2 and&nbsp;3's expanded mathematical syntax would be
    useful for software developers.  To maintain backwards compatibility for
    libSBML users, the original @sbmlfunction{formulaToString, ASTNode}
    and @sbmlfunction{parseFormula, String} have been left untouched,
    and instead, the new functionality is provided in the form of
    @sbmlfunction{parseL3Formula, String} and
    @sbmlfunction{formulaToL3String, ASTNode}.

    The following lists the main differences in the formula syntax supported by
    the 'Level 3' or L3 versions of the formula parsers and formatters,
    compared to what is supported by the Level&nbsp;1-oriented
    @sbmlfunction{parseFormula, String} and
    @sbmlfunction{formulaToString, ASTNode}:

    @li Units may be asociated with bare numbers, using the following syntax:
    <div style='margin: 10px auto 10px 25px; display: block'>
    <span class='code' style='background-color: #d0d0ee'>number</span>
    <span class='code' style='background-color: #edd'>unit</span>
    </div>
    The <span class='code' style='background-color: #d0d0ee'>number</span>
    may be in any form (an integer, real, or rational
    number), and the
    <span class='code' style='background-color: #edd'>unit</span>
    must conform to the syntax of an SBML identifier (technically, the
    type defined as @c SId in the SBML specifications).  The whitespace between
    <span class='code' style='background-color: #d0d0ee'>number</span>
    and <span class='code' style='background-color: #edd'>unit</span>
    is optional.

    @li The Boolean function symbols @c &&, @c ||, @c !, and @c != may be
    used.

    @li The @em modulo operation is allowed as the symbol @c @% and will
    produce a <code>&lt;piecewise&gt;</code> function in the corresponding
    MathML output.

    @li All inverse trigonometric functions may be defined in the infix either
    using @c arc as a prefix or simply @c a; in other words, both @c arccsc
    and @c acsc are interpreted as the operator @em arccosecant as defined in
    MathML&nbsp;2.0.  (Many functions in the simpler SBML Level&nbsp;1
    oriented parser implemented by @sbmlfunction{parseFormula, String}
    are defined this way as well, but not all.)

    @li The following expression is parsed as a rational number instead of
    as a numerical division:
    <pre style='display: block; margin-left: 25px'>
    (<span class='code' style='background-color: #d0d0ee'>integer</span>/<span class='code' style='background-color: #d0d0ee'>integer</span>)</pre>
    <strong>Spaces are not allowed</strong> in this construct; in other words,
    &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and
    the operator) will be parsed into the MathML <code>&lt;divide&gt;</code>
    construct rather than a rational number.  You can, however, assign units to a
    rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;.
    (In the case of division rather than a rational number, units are not interpreted
    in this way.)

    @li Various parser and formatter behaviors may be altered through the use
    of a L3ParserSettings object in conjunction with the functions
    @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings} and
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    The settings available include the following:
    <ul style='list-style-type: circle'>

    <li style='margin-bottom: 0.5em'> The function @c log with a single
    argument (&quot;<code>log(x)</code>&quot;) can be parsed as
    <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as
    desired.

    <li style='margin-bottom: 0.5em'> Unary minus signs can be collapsed or
    preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>-
    -3</code>&quot;) can be removed from the input entirely and single unary
    minuses can be incorporated into the number node, or all minuses can be
    preserved in the AST node structure.

    <li style='margin-bottom: 0.5em'> Parsing of units embedded in the input
    string can be turned on and off.

    <li style='margin-bottom: 0.5em'> The string @c avogadro can be parsed as
    a MathML @em csymbol or as an identifier.

    <li style='margin-bottom: 0.5em'> A Model object may optionally be
    provided to the parser using the variant function call
    @sbmlfunction{parseL3FormulaWithModel, String\, Model} or
    stored in a L3ParserSettings object passed to the variant function
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.  When a Model object is provided, identifiers
    (values of type @c SId) from that model are used in preference to
    pre-defined MathML definitions for both symbols and functions.
    More precisely:
    <ul style='list-style-type: square'>

    <li style='margin-bottom: 0.5em'> <em>In the case of symbols</em>: the
    Model entities whose identifiers will shadow identical symbols in the
    mathematical formula are: Species, Compartment, Parameter, Reaction, and
    SpeciesReference.  For instance, if the parser is given a Model containing
    a Species with the identifier &quot;<code>pi</code>&quot;, and the formula
    to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will
    contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of
    the construct <code>&lt;pi/&gt;</code>.

    <li style='margin-bottom: 0.5em'> <em>In the case of user-defined
    functions</em>: when a Model object is provided, @c SId values of
    user-defined functions present in the model will be used preferentially
    over pre-defined MathML functions.  For example, if the passed-in Model
    contains a FunctionDefinition object with the identifier
    &quot;<code>sin</code>&quot;, that function will be used instead of the
    predefined MathML function <code>&lt;sin/&gt;</code>.
    </ul>

    <li style='margin-bottom: 0.5em'> An SBMLNamespaces object may optionally
    be provided to identify SBML Level&nbsp;3 packages that extend the
    syntax understood by the formula parser.  When the namespaces are provided,
    the parser will interpret possible additional syntax defined by the libSBML
    plug-ins implementing the SBML Level&nbsp;3 packages; for example, it may
    understand vector/array extensions introduced by the SBML Level&nbsp;3 @em
    Arrays package.
    </ul>

    These configuration settings cannot be changed directly using the basic
    parser and formatter functions, but @em can be changed on a per-call basis
    by using the alternative functions @sbmlfunction{parseL3FormulaWithSettings,
    String\, L3ParserSettings} and
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\,
    L3ParserSettings}.

    Neither SBML nor the MathML standard define a 'string-form' equivalent to
    MathML expressions.  The approach taken by libSBML is to start with the
    formula syntax defined by SBML Level&nbsp;1 (which in fact used a custom
    text-string representation of formulas, and not MathML), and expand it to
    include the functionality described above.  This formula syntax is based
    mostly on C programming syntax, and may contain operators, function calls,
    symbols, and white space characters.  The following table provides the
    precedence rules for the different entities that may appear in formula
    strings.

    @htmlinclude math-precedence-table-l3.html

    In the table above, @em operand implies the construct is an operand, @em
    prefix implies the operation is applied to the following arguments, @em
    unary implies there is one argument, and @em binary implies there are
    two arguments.  The values in the <b>Precedence</b> column show how the
    order of different types of operation are determined.  For example, the
    expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code>
    because the @c * operator has higher precedence.  The
    <b>Associates</b> column shows how the order of similar precedence
    operations is determined; for example, <code>a && b || c</code> is
    evaluated as <code>(a && b) || c</code> because the @c && and @c ||
    operators are left-associative and have the same precedence.

    The function call syntax consists of a function name, followed by optional
    white space, followed by an opening parenthesis token, followed by a
    sequence of zero or more arguments separated by commas (with each comma
    optionally preceded and/or followed by zero or more white space
    characters), followed by a closing parenthesis token.  The function name
    must be chosen from one of the pre-defined functions in SBML or a
    user-defined function in the model.  The following table lists the names
    of certain common mathematical functions; this table corresponds to
    Table&nbsp;6 in the <a target='_blank'
    href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML
    Level&nbsp;1 Version&nbsp;2 specification</a> with additions based on the
    functions added in SBML Level 2 and Level 3:

    @htmlinclude string-functions-table-l3.html

    Parsing of the various MathML functions and constants are all
    case-insensitive by default: function names such as <code>cos</code>,
    <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine
    operator, <code>&lt;cos&gt;</code>.  However, <em>when a Model object is
    used</em> in conjunction with either
    @sbmlfunction{parseL3FormulaWithModel, String\, Model} or
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}, any identifiers found in that model will be
    parsed in a case-<em>sensitive</em> way.  For example, if a model contains
    a Species having the identifier <code>Pi</code>, the parser will parse
    &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi
    &lt;/ci&gt;</code>&quot; but will continue to parse the symbols
    &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as
    &quot;<code>&lt;pi&gt;</code>&quot;.

    As mentioned above, the manner in which the 'L3' versions of the formula
    parser and formatter interpret the function &quot;<code>log</code>&quot;
    can be changed.  To do so, callers should use the function
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings} and pass it an appropriate L3ParserSettings
    object.  By default, unlike the SBML Level&nbsp;1 parser implemented by
    @sbmlfunction{parseFormula, String}, the string
    &quot;<code>log</code>&quot; is interpreted as the base&nbsp;10 logarithm,
    and @em not as the natural logarithm.  However, you can change the
    interpretation to be base-10 log, natural log, or as an error; since the
    name 'log' by itself is ambiguous, you require that the parser uses @c
    log10 or @c ln instead, which are more clear.  Please refer to
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}.

    In addition, the following symbols will be translated to their MathML
    equivalents, if no symbol with the same @c SId identifier string exists
    in the Model object provided:

    @htmlinclude string-values-table-l3.html

    Again, as mentioned above, whether the string
    &quot;<code>avogadro</code>&quot; is parsed as an AST node of type
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink or
    @link libsbml#AST_NAME AST_NAME@endlink is configurable; use the version of
    the parser function called @sbmlfunction{parseL3FormulaWithSettings,
    String\, L3ParserSettings}.  This Avogadro-related
    functionality is provided because SBML Level&nbsp;2 models may not use
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink AST nodes.

    For more details about the parser, please see the definition of
    L3ParserSettings and @sbmlfunction{parseL3Formula, String}.

    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see L3ParserSettings

    @if conly
    @memberof L3ParserSettings_t
    @endif

    """
  return _libsbml.getDefaultL3ParserSettings()

def getLastParseL3Error():
  """
    getLastParseL3Error() -> char

    Returns the last error reported by the 'L3' mathematical formula parser.

    If the functions @sbmlfunction{parseL3Formula, String},
    @sbmlfunction{parseL3FormulaWithSettings, String\,
    L3ParserSettings}, or @sbmlfunction{parseL3FormulaWithModel,
    String\, Model} return @c None, an error is set internally.
    This function allows callers to retrieve information about the error.

    @return a string describing the error that occurred.  This will contain
    the input string the parser was trying to parse, the character it had
    parsed when it encountered the error, and a description of the error.

    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{getDefaultL3ParserSettings,}

    @if conly
    @memberof ASTNode_t
    @endif

    """
  return _libsbml.getLastParseL3Error()
L3P_PARSE_LOG_AS_LOG10 = _libsbml.L3P_PARSE_LOG_AS_LOG10
L3P_PARSE_LOG_AS_LN = _libsbml.L3P_PARSE_LOG_AS_LN
L3P_PARSE_LOG_AS_ERROR = _libsbml.L3P_PARSE_LOG_AS_ERROR
L3P_COLLAPSE_UNARY_MINUS = _libsbml.L3P_COLLAPSE_UNARY_MINUS
L3P_EXPAND_UNARY_MINUS = _libsbml.L3P_EXPAND_UNARY_MINUS
L3P_PARSE_UNITS = _libsbml.L3P_PARSE_UNITS
L3P_NO_UNITS = _libsbml.L3P_NO_UNITS
L3P_AVOGADRO_IS_CSYMBOL = _libsbml.L3P_AVOGADRO_IS_CSYMBOL
L3P_AVOGADRO_IS_NAME = _libsbml.L3P_AVOGADRO_IS_NAME
L3P_COMPARE_BUILTINS_CASE_INSENSITIVE = _libsbml.L3P_COMPARE_BUILTINS_CASE_INSENSITIVE
L3P_COMPARE_BUILTINS_CASE_SENSITIVE = _libsbml.L3P_COMPARE_BUILTINS_CASE_SENSITIVE
INFIX_SYNTAX_NAMED_SQUARE_BRACKETS = _libsbml.INFIX_SYNTAX_NAMED_SQUARE_BRACKETS
INFIX_SYNTAX_CURLY_BRACES = _libsbml.INFIX_SYNTAX_CURLY_BRACES
INFIX_SYNTAX_CURLY_BRACES_SEMICOLON = _libsbml.INFIX_SYNTAX_CURLY_BRACES_SEMICOLON
class L3ParserSettings(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Controls the behavior of the Level 3 formula parser.

    @htmlinclude not-sbml-warning.html

    The function
    @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings},
    along with its variants @sbmlfunction{parseL3Formula, String} and
    @sbmlfunction{parseL3FormulaWithModel, String\, Model},
    are the interfaces to a parser for mathematical formulas written as
    text strings.  The inverse function is @sbmlfunction{formulaToL3String,
    ASTNode} and its variants such as
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}.
    The parsers and the formula writers convert between a text-string
    representation of mathematical formulas and Abstract Syntax Trees (ASTs),
    represented in libSBML using ASTNode objects.
    Compared to the parser and writer implemented by the functions
    @sbmlfunction{parseFormula, String} and
    @sbmlfunction{formulaToString, ASTNode},
    which were designed primarily for converting the mathematical formula
    strings in SBML Level&nbsp;1, the SBML Level&nbsp;3 or 'L3' variants of
    the parser and writer use an extended formula syntax.  They also have a
    number of configurable behaviors.  This class (L3ParserSettings) is an
    object used to communicate the configuration settings with callers.

    The following aspects of the parser are configurable using
    L3ParserSettings objects.  (For the formula writer, only a subset of these
    settings is relevant; please see the documentation for
    @sbmlfunction{formulaToL3StringWithSettings, ASTNode\,
    L3ParserSettings} for more information about which ones).

    @li A Model object may optionally be provided to use identifiers (values
    of type @c SId) from the model in preference to pre-defined MathML symbols
    More precisely, the Model entities whose identifiers will shadow identical
    symbols in the mathematical formula are: Species, Compartment, Parameter,
    Reaction, and SpeciesReference.  For instance, if the parser is given a
    Model containing a Species with the identifier
    &quot;<code>pi</code>&quot;, and the formula to be parsed is
    &quot;<code>3*pi</code>&quot;, the MathML produced by the parser will
    contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of
    the construct <code>&lt;pi/&gt;</code>.  Another example, if the passed-in
    Model contains a FunctionDefinition with the identifier
    &quot;<code>sin</code>&quot;, that function will be used instead of the
    predefined MathML function <code>&lt;sin/&gt;</code>.
    @li The function @c log with a single argument
    (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>,
    <code>ln(x)</code>, or treated as an error, as desired.
    @li Unary minus signs can be either collapsed or preserved; that is, the
    parser can either (1) remove sequential pairs of unary minuses (e.g.,
    &quot;<code>- -3</code>&quot;) from the input and incorporate single unary
    minuses into the number node, or (2) preserve all minuses in the AST node
    structure, turning them into ASTNode objects of type
    @link libsbml#AST_MINUS AST_MINUS@endlink.
    @li The character sequence &quot;<code>number id</code>&quot; can be
    interpreted as a numerical value @c number followed by units of measurement
    indicated by @c id, or it can be treated as a syntax error.  (In
    Level&nbsp;3, MathML <code>&lt;cn&gt;</code> elements can have an
    attribute named @c units placed in the SBML namespace, which can be used
    to indicate the units to be associated with the number.  The text-string
    infix formula parser allows units to be placed after raw numbers; they are
    interpreted as unit identifiers for units defined by the SBML
    specification or in the containing Model object.)
    @li The symbol @c avogadro can be parsed either as a MathML @em csymbol or
    as a identifier.  More specifically, &quot;<code>avogadro</code>&quot; can
    be treated as an ASTNode of type
    @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink or of type
    @link libsbml#AST_NAME AST_NAME@endlink.
    @li Strings that match built-in functions and constants can either be parsed
    as a match regardless of capitalization, or may be required to be
    all-lower-case to be considered a match.  
    @li LibSBML plug-ins implementing support for SBML Level&nbsp;3 packages
    may introduce extensions to the syntax understood by the parser.  The
    precise nature of the extensions will be documented by the individual
    package plug-ins.  An example of a possible extension is a notation for
    vectors and arrays, introduced by the SBML Level&nbsp;3 @em Arrays
    package.

    To obtain the default configuration values, callers can use the function
    @sbmlfunction{getDefaultL3ParserSettings,}.  To change the configuration,
    callers can create an L3ParserSettings object, set the desired
    characteristics using the methods provided, and pass that object to
    @sbmlfunction{parseL3FormulaWithSettings, String formula\, L3ParserSettings settings}.

    @see @sbmlfunction{parseL3Formula, String}
    @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
    @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
    @see @sbmlfunction{parseFormula, String}
    @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
    @see @sbmlfunction{formulaToL3String, ASTNode}
    @see @sbmlfunction{formulaToString, ASTNode}
    @see @sbmlfunction{getDefaultL3ParserSettings,}

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, L3ParserSettings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, L3ParserSettings, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> L3ParserSettings
        __init__(self, Model model, ParseLogType_t parselog, bool collapseminus, 
            bool parseunits, bool avocsymbol, bool caseSensitive = False, 
            SBMLNamespaces sbmlns = None) -> L3ParserSettings
        __init__(self, Model model, ParseLogType_t parselog, bool collapseminus, 
            bool parseunits, bool avocsymbol, bool caseSensitive = False) -> L3ParserSettings
        __init__(self, Model model, ParseLogType_t parselog, bool collapseminus, 
            bool parseunits, bool avocsymbol) -> L3ParserSettings

        This method has multiple variants; they differ in the arguments
         they accept.  Each variant is described separately below.

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>L3ParserSettings(Model model, ParseLogType_t parselog, bool collapseminus, bool parseunits, bool avocsymbol, bool caseSensitive = false, SBMLNamespaces sbmlns = None)</pre>

        Creates a new L3ParserSettings object with specific values for all
        possible settings.

        @param model a Model object to be used for disambiguating identifiers
        encountered by @sbmlfunction{parseL3FormulaWithSettings, String\,
        L3ParserSettings} in mathematical formulas.

        @param parselog ('parse log') a flag that controls how the parser will
        handle the symbol @c log in mathematical formulas. The function @c log
        with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed
        as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as
        desired, by using the parameter values
        @link libsbml#L3P_PARSE_LOG_AS_LOG10 L3P_PARSE_LOG_AS_LOG10@endlink,
        @link libsbml#L3P_PARSE_LOG_AS_LN L3P_PARSE_LOG_AS_LN@endlink, or
        @link libsbml#L3P_PARSE_LOG_AS_ERROR L3P_PARSE_LOG_AS_ERROR@endlink, respectively.

        @param collapseminus ('collapse minus') a flag that controls how the
        parser will handle minus signs in formulas.  Unary minus signs can be
        collapsed or preserved; that is, sequential pairs of unary minuses
        (e.g., &quot;<code>- -3</code>&quot;) can be removed from the input
        entirely and single unary minuses can be incorporated into the number
        node, or all minuses can be preserved in the AST node structure.
        The possible values of this field are
        @link libsbml#L3P_COLLAPSE_UNARY_MINUS L3P_COLLAPSE_UNARY_MINUS@endlink (to collapse unary minuses) and
        @link libsbml#L3P_EXPAND_UNARY_MINUS L3P_EXPAND_UNARY_MINUS@endlink (to expand unary minuses).

        @param parseunits ('parse units') a flag that controls how the parser
        will handle apparent references to units of measurement associated with
        raw numbers in a formula.  If set to the value
        @link libsbml#L3P_PARSE_UNITS L3P_PARSE_UNITS@endlink, units are parsed; if set to the value
        @link libsbml#L3P_NO_UNITS L3P_NO_UNITS@endlink, units are not parsed.

        @param avocsymbol ('Avogadro csymbol') a flag that controls how the
        parser will handle the appearance of the symbol @c avogadro in a
        formula.  If set to the value @link libsbml#L3P_AVOGADRO_IS_CSYMBOL L3P_AVOGADRO_IS_CSYMBOL@endlink,
        the symbol is interpreted as the SBML/MathML @em csymbol @c avogadro; if
        set to the value @link libsbml#L3P_AVOGADRO_IS_NAME L3P_AVOGADRO_IS_NAME@endlink, the symbol is
        interpreted as a plain symbol name.

        @param caseSensitive a flag that controls how the
        parser will handle case sensitivity of any function name.
        If set to the value @link libsbml#L3P_COMPARE_BUILTINS_CASE_INSENSITIVE L3P_COMPARE_BUILTINS_CASE_INSENSITIVE@endlink,
        the name is interpreted as teh relevant math function regardless of case; if
        set to the value @link libsbml#L3P_COMPARE_BUILTINS_CASE_SENSITIVE L3P_COMPARE_BUILTINS_CASE_SENSITIVE@endlink, the name is
        interpreted as a user defined function unless it is all lower case.

        @param sbmlns ('SBML namespaces') an SBML namespaces object.  The
        namespaces identify the SBML Level&nbsp;3 packages that can extend the
        syntax understood by the formula parser.  When non-@c None, the parser
        will interpret additional syntax defined by the packages; for example,
        it may understand vector/array extensions introduced by the SBML
        Level&nbsp;3 @em Arrays package.

        @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif@~

        @see getModel()
        @see setModel()
        @see unsetModel()
        @see getParseLog()
        @see setParseLog()
        @see getParseUnits()
        @see setParseUnits()
        @see getParseCollapseMinus()
        @see setParseCollapseMinus()
        @see getParseAvogadroCsymbol()
        @see setParseAvogadroCsymbol()
           

        @par
        <hr>
        <span class='variant-sig-heading'>Method variant with the following signature</span>:
         <pre class='signature'>L3ParserSettings()</pre>

        Creates a new L3ParserSettings object with default values.

        This is the default constructor for the L3ParserSettings object.  It
        sets the stored Model object to @c None and sets the following
        field values in the L3ParserSettings object:

        @li <em>parseunits</em> ('parse units') is set to
        @link libsbml#L3P_PARSE_UNITS L3P_PARSE_UNITS@endlink.

        @li <em>collapseminus</em> ('collapse minus') is set to
        @link libsbml#L3P_EXPAND_UNARY_MINUS L3P_EXPAND_UNARY_MINUS@endlink.

        @li <em>parselog</em> ('parse log') is set to
        @link libsbml#L3P_PARSE_LOG_AS_LOG10 L3P_PARSE_LOG_AS_LOG10@endlink.

        @li <em>avocsymbol</em> ('Avogadro csymbol') is set to
        @link libsbml#L3P_AVOGADRO_IS_CSYMBOL L3P_AVOGADRO_IS_CSYMBOL@endlink.

        @li <em>sbmlns</em> ('SBML namespaces') is set to @c None (which
        indicates that no syntax extensions due to SBML Level&nbsp;3 packages
        will be assumed---the formula parser will only understand the
        core syntax described in the documentation for
        @sbmlfunction{parseL3Formula, String}).

        """
        this = _libsbml.new_L3ParserSettings(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libsbml.delete_L3ParserSettings
    __del__ = lambda self : None;
    def setModel(self, *args):
        """
        setModel(self, Model model)

        Sets the model reference in this L3ParserSettings object.

        @par
        When a Model object is provided, identifiers (values of type @c SId)
        from that model are used in preference to pre-defined MathML symbol
        definitions.  More precisely, the Model entities whose identifiers will
        shadow identical symbols in the mathematical formula are: Species,
        Compartment, Parameter, Reaction, and SpeciesReference.  For instance, if
        the parser is given a Model containing a Species with the identifier
        &quot;<code>pi</code>&quot;, and the formula to be parsed is
        &quot;<code>3*pi</code>&quot;, the MathML produced will contain the
        construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct
        <code>&lt;pi/&gt;</code>.  Similarly, when a Model object is provided, @c
        SId values of user-defined functions present in the Model will be used
        preferentially over pre-defined MathML functions.  For example, if the
        passed-in Model contains a FunctionDefinition with the identifier
        &quot;<code>sin</code>&quot;, that function will be used instead of the
        predefined MathML function <code>&lt;sin/&gt;</code>.

        @param model a Model object to be used for disambiguating identifiers.

        @warning <span class='warning'>This does @em not copy the Model object.
        This means that modifications made to the Model after invoking this
        method may affect parsing behavior, because the parser will query the
        @em current contents of the model.</span>

        @see getModel()
        @see unsetModel()

        """
        return _libsbml.L3ParserSettings_setModel(self, *args)

    def getModel(self):
        """
        getModel(self) -> Model

        Returns the Model object referenced by this L3ParserSettings object.

        @par
        When a Model object is provided, identifiers (values of type @c SId)
        from that model are used in preference to pre-defined MathML symbol
        definitions.  More precisely, the Model entities whose identifiers will
        shadow identical symbols in the mathematical formula are: Species,
        Compartment, Parameter, Reaction, and SpeciesReference.  For instance, if
        the parser is given a Model containing a Species with the identifier
        &quot;<code>pi</code>&quot;, and the formula to be parsed is
        &quot;<code>3*pi</code>&quot;, the MathML produced will contain the
        construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct
        <code>&lt;pi/&gt;</code>.  Similarly, when a Model object is provided, @c
        SId values of user-defined functions present in the Model will be used
        preferentially over pre-defined MathML functions.  For example, if the
        passed-in Model contains a FunctionDefinition with the identifier
        &quot;<code>sin</code>&quot;, that function will be used instead of the
        predefined MathML function <code>&lt;sin/&gt;</code>.

        @see setModel()
        @see unsetModel()

        """
        return _libsbml.L3ParserSettings_getModel(self)

    def unsetModel(self):
        """
        unsetModel(self)

        Unsets the Model reference in this L3ParserSettings object.

        The effect of calling this method is to set the stored model value
        to @c None.

        @see setModel()
        @see getModel()

        """
        return _libsbml.L3ParserSettings_unsetModel(self)

    def setParseLog(self, *args):
        """
        setParseLog(self, ParseLogType_t type)

        Sets the behavior for handling @c log in mathematical formulas.

        The function @c log with a single argument
        (&quot;<code>log(x)</code>&quot;) can be parsed as
        <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error.
        These three behaviors are set, respectively, by using the value
        @link libsbml#L3P_PARSE_LOG_AS_LOG10 L3P_PARSE_LOG_AS_LOG10@endlink,
        @link libsbml#L3P_PARSE_LOG_AS_LN L3P_PARSE_LOG_AS_LN@endlink, or
        @link libsbml#L3P_PARSE_LOG_AS_ERROR L3P_PARSE_LOG_AS_ERROR@endlink
        for the @p type parameter.

        @param type a constant, one of following three possibilities:
        @li @link libsbml#L3P_PARSE_LOG_AS_LOG10 L3P_PARSE_LOG_AS_LOG10@endlink
        @li @link libsbml#L3P_PARSE_LOG_AS_LN L3P_PARSE_LOG_AS_LN@endlink
        @li @link libsbml#L3P_PARSE_LOG_AS_ERROR L3P_PARSE_LOG_AS_ERROR@endlink

        @see getParseLog()

        """
        return _libsbml.L3ParserSettings_setParseLog(self, *args)

    def getParseLog(self):
        """
        getParseLog(self) -> ParseLogType_t

        Indicates the current behavior set for handling the function @c log with
        one argument.

        The function @c log with a single argument
        (&quot;<code>log(x)</code>&quot;) can be parsed as
        <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as
        desired.  These three possible behaviors are indicated, respectively, by
        the values
        @link libsbml#L3P_PARSE_LOG_AS_LOG10 L3P_PARSE_LOG_AS_LOG10@endlink,
        @link libsbml#L3P_PARSE_LOG_AS_LN L3P_PARSE_LOG_AS_LN@endlink, and
        @link libsbml#L3P_PARSE_LOG_AS_ERROR L3P_PARSE_LOG_AS_ERROR@endlink.

        @return One of following three constants:
        @li @link libsbml#L3P_PARSE_LOG_AS_LOG10 L3P_PARSE_LOG_AS_LOG10@endlink
        @li @link libsbml#L3P_PARSE_LOG_AS_LN L3P_PARSE_LOG_AS_LN@endlink
        @li @link libsbml#L3P_PARSE_LOG_AS_ERROR L3P_PARSE_LOG_AS_ERROR@endlink

        @see setParseLog()

        """
        return _libsbml.L3ParserSettings_getParseLog(self)

    def setParseCollapseMinus(self, *args):
        """
        setParseCollapseMinus(self, bool collapseminus)

        Sets the behavior for handling unary minuses appearing in mathematical
        formulas.

        @par
        This setting affects two behaviors.  First, pairs of multiple unary
        minuses in a row (e.g., &quot;<code>- -3</code>&quot;) can be collapsed
        and ignored in the input, or the multiple minuses can be preserved in the
        AST node tree that is generated by the parser.  Second, minus signs in
        front of numbers can be collapsed into the number node itself; for
        example, a &quot;<code>- 4.1</code>&quot; can be turned into a single
        ASTNode of type @link libsbml#AST_REAL AST_REAL@endlink with a value of
        <code>-4.1</code>, or it can be turned into a node of type
        @link libsbml#AST_MINUS AST_MINUS@endlink having a child node of type
        @link libsbml#AST_REAL AST_REAL@endlink.

        This method lets you tell the parser which behavior to use---either
        collapse minuses or always preserve them.  The two possibilities are
        represented using the following constants:

        <ul>
        <li> @link libsbml#L3P_COLLAPSE_UNARY_MINUS L3P_COLLAPSE_UNARY_MINUS@endlink (value = @c True): collapse
        unary minuses where possible.
        <li> @link libsbml#L3P_EXPAND_UNARY_MINUS L3P_EXPAND_UNARY_MINUS@endlink (value = @c False): do not
        collapse unary minuses, and instead translate each one into an AST node of
        type @link libsbml#AST_MINUS AST_MINUS@endlink.
        </ul>

        @param collapseminus a boolean value (one of the constants
        @link libsbml#L3P_COLLAPSE_UNARY_MINUS L3P_COLLAPSE_UNARY_MINUS@endlink or
        @link libsbml#L3P_EXPAND_UNARY_MINUS L3P_EXPAND_UNARY_MINUS@endlink)
        indicating how unary minus signs in the input should be handled.

        @see getParseCollapseMinus()

        """
        return _libsbml.L3ParserSettings_setParseCollapseMinus(self, *args)

    def getParseCollapseMinus(self):
        """
        getParseCollapseMinus(self) -> bool

        Indicates the current behavior set for handling multiple unary minuses
        in formulas.

        @par
        This setting affects two behaviors.  First, pairs of multiple unary
        minuses in a row (e.g., &quot;<code>- -3</code>&quot;) can be collapsed
        and ignored in the input, or the multiple minuses can be preserved in the
        AST node tree that is generated by the parser.  Second, minus signs in
        front of numbers can be collapsed into the number node itself; for
        example, a &quot;<code>- 4.1</code>&quot; can be turned into a single
        ASTNode of type @link libsbml#AST_REAL AST_REAL@endlink with a value of
        <code>-4.1</code>, or it can be turned into a node of type
        @link libsbml#AST_MINUS AST_MINUS@endlink having a child node of type
        @link libsbml#AST_REAL AST_REAL@endlink.

        @return A boolean indicating the behavior currently set.  The possible
        values are as follows:
        <ul>
        <li> @link libsbml#L3P_COLLAPSE_UNARY_MINUS L3P_COLLAPSE_UNARY_MINUS@endlink (value = @c True): collapse
        unary minuses where possible.
        <li> @link libsbml#L3P_EXPAND_UNARY_MINUS L3P_EXPAND_UNARY_MINUS@endlink (value = @c False): do not
        collapse unary minuses, and instead translate each one into an AST node of
        type @link libsbml#AST_MINUS AST_MINUS@endlink.
        </ul>

        @see setParseCollapseMinus()

        """
        return _libsbml.L3ParserSettings_getParseCollapseMinus(self)

    def setParseUnits(self, *args):
        """
        setParseUnits(self, bool units)

        Sets the parser's behavior in handling units associated with numbers
        in a mathematical formula.

        @par
        In SBML Level&nbsp;2, there is no means of associating a unit of
        measurement with a pure number in a formula, while SBML Level&nbsp;3 does
        define a syntax for this.  In Level&nbsp;3, MathML <code>&lt;cn&gt;</code>
        elements can have an attribute named @c units placed in the SBML
        namespace, which can be used to indicate the units to be associated with
        the number.  The text-string infix formula parser allows units to be
        placed after raw numbers; they are interpreted as unit identifiers for
        units defined by the SBML specification or in the containing Model object.
        Some examples include: &quot;<code>4 mL</code>&quot;, &quot;<code>2.01
        Hz</code>&quot;, &quot;<code>3.1e-6 M</code>&quot;, and &quot;<code>(5/8)
        inches</code>&quot;.  To produce a valid SBML model, there must either
        exist a UnitDefinition corresponding to the identifier of the unit, or the
        unit must be defined in Table&nbsp;2 of the SBML Level&nbsp;3 specification.

        This method sets the formula parser's behavior with respect to units.

        @param units A boolean indicating whether to parse units.  The
        possible values are as follows:
        <ul>
        <li> @link libsbml#L3P_PARSE_UNITS L3P_PARSE_UNITS@endlink (value = @c True): parse units in the
        text-string formula.
        <li> @link libsbml#L3P_NO_UNITS L3P_NO_UNITS@endlink (value = @c False): treat units in the
        text-string formula as errors.
        </ul>

        @see getParseUnits()

        """
        return _libsbml.L3ParserSettings_setParseUnits(self, *args)

    def getParseUnits(self):
        """
        getParseUnits(self) -> bool

        Indicates the current behavior set for handling units in text-string
        mathematical formulas.

        @par
        In SBML Level&nbsp;2, there is no means of associating a unit of
        measurement with a pure number in a formula, while SBML Level&nbsp;3 does
        define a syntax for this.  In Level&nbsp;3, MathML <code>&lt;cn&gt;</code>
        elements can have an attribute named @c units placed in the SBML
        namespace, which can be used to indicate the units to be associated with
        the number.  The text-string infix formula parser allows units to be
        placed after raw numbers; they are interpreted as unit identifiers for
        units defined by the SBML specification or in the containing Model object.
        Some examples include: &quot;<code>4 mL</code>&quot;, &quot;<code>2.01
        Hz</code>&quot;, &quot;<code>3.1e-6 M</code>&quot;, and &quot;<code>(5/8)
        inches</code>&quot;.  To produce a valid SBML model, there must either
        exist a UnitDefinition corresponding to the identifier of the unit, or the
        unit must be defined in Table&nbsp;2 of the SBML Level&nbsp;3 specification.

        Since SBML Level&nbsp;2 does not have the ability to associate units
        with pure numbers, the value should be expected to be @c False
        (@link libsbml#L3P_NO_UNITS L3P_NO_UNITS@endlink) when parsing text-string
        formulas intended for use in SBML Level&nbsp;2 documents.

        @return A boolean indicating whether to parse units.  The
        possible values are as follows:
        <ul>
        <li> @link libsbml#L3P_PARSE_UNITS L3P_PARSE_UNITS@endlink (value = @c True): parse units in the
        text-string formula.
        <li> @link libsbml#L3P_NO_UNITS L3P_NO_UNITS@endlink (value = @c False): treat units in the
        text-string formula as errors.
        </ul>

        @see setParseUnits()

        """
        return _libsbml.L3ParserSettings_getParseUnits(self)

    def setParseAvogadroCsymbol(self, *args):
        """
        setParseAvogadroCsymbol(self, bool l2only)

        Sets the parser's behavior in handling the symbol @c avogadro in
        mathematical formulas.

        @par
        SBML Level&nbsp;3 defines a symbol for representing the value of
        Avogadro's constant, but it is not defined in SBML Level&nbsp;2.  As a
        result, the text-string formula parser must behave differently
        depending on which SBML Level is being targeted.  For Level&nbsp;3
        documents, it can interpret instances of @c avogadro in the input
        as a reference to the MathML @em csymbol for Avogadro's constant
        defined in the SBML Level&nbsp;3 specification.  For Level&nbsp;2,
        it must treat @c avogadro as just another plain symbol.

        This method allows callers to set the <code>avogadro</code>-handling
        behavior in this L3ParserSettings object.  The possible values of @p
        l2only are as follows:

        <ul>
        <li> @link libsbml#L3P_AVOGADRO_IS_CSYMBOL L3P_AVOGADRO_IS_CSYMBOL@endlink (value = @c True): tells the
        parser to translate the string @c avogadro (in any capitalization) into an
        AST node of type @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.
        <li> @link libsbml#L3P_AVOGADRO_IS_NAME L3P_AVOGADRO_IS_NAME@endlink (value = @c False): tells the
        parser to translate the string @c avogadro into an AST of type
        @link libsbml#AST_NAME AST_NAME@endlink.
        </ul>

        Since SBML Level&nbsp;2 does not define a symbol for Avogadro's
        constant, the value should be set to
        @link libsbml#L3P_AVOGADRO_IS_NAME L3P_AVOGADRO_IS_NAME@endlink when parsing text-string formulas
        intended for use in SBML Level&nbsp;2 documents.

        @param l2only a boolean value indicating how the string @c avogadro
        should be treated when encountered in a formula.  This will be one of
        the values @link libsbml#L3P_AVOGADRO_IS_CSYMBOL L3P_AVOGADRO_IS_CSYMBOL@endlink or
        @link libsbml#L3P_AVOGADRO_IS_NAME L3P_AVOGADRO_IS_NAME@endlink.

        @see getParseAvogadroCsymbol()

        """
        return _libsbml.L3ParserSettings_setParseAvogadroCsymbol(self, *args)

    def getParseAvogadroCsymbol(self):
        """
        getParseAvogadroCsymbol(self) -> bool

        Indicates the current behavior set for handling @c avogadro for SBML
        Level&nbsp;3.

        @par
        SBML Level&nbsp;3 defines a symbol for representing the value of
        Avogadro's constant, but it is not defined in SBML Level&nbsp;2.  As a
        result, the text-string formula parser must behave differently
        depending on which SBML Level is being targeted.  For Level&nbsp;3
        documents, it can interpret instances of @c avogadro in the input
        as a reference to the MathML @em csymbol for Avogadro's constant
        defined in the SBML Level&nbsp;3 specification.  For Level&nbsp;2,
        it must treat @c avogadro as just another plain symbol.

        This method returns the current setting of the
        <code>avogadro</code>-handling behavior in this L3ParserSettings object.
        The possible values are as follows:

        <ul>
        <li> @link libsbml#L3P_AVOGADRO_IS_CSYMBOL L3P_AVOGADRO_IS_CSYMBOL@endlink (value = @c True): tells the
        parser to translate the string @c avogadro (in any capitalization) into an
        AST node of type @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.
        <li> @link libsbml#L3P_AVOGADRO_IS_NAME L3P_AVOGADRO_IS_NAME@endlink (value = @c False): tells the
        parser to translate the string @c avogadro into an AST of type
        @link libsbml#AST_NAME AST_NAME@endlink.
        </ul>

        @return A boolean indicating which mode is currently set; one of
        @link libsbml#L3P_AVOGADRO_IS_CSYMBOL L3P_AVOGADRO_IS_CSYMBOL@endlink
        or
        @link libsbml#L3P_AVOGADRO_IS_NAME L3P_AVOGADRO_IS_NAME@endlink.

        @see setParseAvogadroCsymbol()

        """
        return _libsbml.L3ParserSettings_getParseAvogadroCsymbol(self)

    def setComparisonCaseSensitivity(self, *args):
        """
        setComparisonCaseSensitivity(self, bool strcmp)

        Sets the parser's behavior with respect to case sensitivity for
        recognizing predefined symbols.

        @par
        By default, the parser compares symbols in a case insensitive manner for
        built-in functions such as @c 'sin' and @c 'piecewise', and for constants
        such as @c 'True' and @c 'avogadro'.  Setting this option to @c False, you
        can force the string comparison to @em only match lower-case strings.
        Thus, for example, @c 'sin' and @c 'True' will match the built-in values, but
        @c 'SIN' and @c 'TRUE' will not.

        @param strcmp a boolean indicating whether to be case sensitive (if @c True) or be case insensitive (if @c False).

        @see getComparisonCaseSensitivity()

        """
        return _libsbml.L3ParserSettings_setComparisonCaseSensitivity(self, *args)

    def getComparisonCaseSensitivity(self):
        """
        getComparisonCaseSensitivity(self) -> bool

        Returns @c True if the parser is configured to match built-in symbols
        in a case-insensitive way.

        @par
        By default, the parser compares symbols in a case insensitive manner for
        built-in functions such as @c 'sin' and @c 'piecewise', and for constants
        such as @c 'True' and @c 'avogadro'.  Setting this option to @c False, you
        can force the string comparison to @em only match lower-case strings.
        Thus, for example, @c 'sin' and @c 'True' will match the built-in values, but
        @c 'SIN' and @c 'TRUE' will not.

        @return @c True if matches are done in a case-sensitive manner, and 
        @c False if the parser will recognize built-in functions and
        constants regardless of case,.

        @see setComparisonCaseSensitivity()

        """
        return _libsbml.L3ParserSettings_getComparisonCaseSensitivity(self)

    def setPlugins(self, *args):
        """
        setPlugins(self, SBMLNamespaces sbmlns)

        Set up the plugins for this L3ParserSettings, based on the
        SBMLNamespaces object.

        When a SBMLNamespaces object is provided, the parser will only interpret
        infix syntax understood by the core libSBML @em plus the packages
        indicated by the SBMLNamespaces objects provided.  ASTNode objects
        returned by the L3Parser will contain those SBMLNamespaces objects, and
        will be used to parse certain constructs that may only be understood by
        packages (e.g., vectors for the SBML Level&nbsp;3 'arrays' package).
        Note that by default, all packages that were compiled with this version
        of libSBML are included, so this function is most useful as a way to
        turn @em off certain namespaces, such as might be desired if your tool
        does not support vectors, for example.

        @param sbmlns a SBMLNamespaces object to be used.  If @c None is given
        as the value, all plugins will be loaded.

        """
        return _libsbml.L3ParserSettings_setPlugins(self, *args)

    def visitPackageInfixSyntax(self, *args):
        """
        visitPackageInfixSyntax(self, ASTNode_t parent, ASTNode_t node, StringBuffer_t sb)

        @internal
        Visits the given ASTNode_t and continues the inorder traversal for nodes
        whose syntax are determined by packages.

        @internal

        """
        return _libsbml.L3ParserSettings_visitPackageInfixSyntax(self, *args)

L3ParserSettings_swigregister = _libsbml.L3ParserSettings_swigregister
L3ParserSettings_swigregister(L3ParserSettings)

class ASTBasePlugin(_object):
    """
    @sbmlpackage{core}

    @htmlinclude pkg-marker-core.html Base class for extensions that plug into AST classes.
    @internal

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASTBasePlugin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ASTBasePlugin, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _libsbml.delete_ASTBasePlugin
    __del__ = lambda self : None;
    def clone(self):
        """
        clone(self) -> ASTBasePlugin

        @internal
        Creates and returns a deep copy of this ASTBasePlugin object.

        @return the (deep) copy of this ASTBasePlugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_clone(self)

    def getElementNamespace(self):
        """
        getElementNamespace(self) -> string

        @internal
        Returns the XML namespace (URI) of the package extension
        of this plugin object.

        @return the URI of the package extension of this plugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_getElementNamespace(self)

    def getPrefix(self):
        """
        getPrefix(self) -> string

        @internal
        Returns the prefix of the package extension of this plugin object.

        @return the prefix of the package extension of this plugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_getPrefix(self)

    def getPackageName(self):
        """
        getPackageName(self) -> string

        @internal
        Returns the package name of this plugin object.

        @return the package name of this plugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_getPackageName(self)

    def setSBMLExtension(self, *args):
        """
        setSBMLExtension(self, SBMLExtension ext) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_setSBMLExtension(self, *args)

    def setPrefix(self, *args):
        """
        setPrefix(self, string prefix) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_setPrefix(self, *args)

    def connectToParent(self, *args):
        """
        connectToParent(self, ASTBase astbase)

        @internal
        Sets the parent SBML object of this plugin object to
        this object and child elements (if any).
        (Creates a child-parent relationship by this plugin object)

        This function is called when this object is created by
        the parent element.
        Subclasses must override this this function if they have one
        or more child elements. Also, ASTBasePlugin.connectToParent()
        must be called in the overridden function.

        @param sbase the SBase object to use

        @see setSBMLDocument
        @see enablePackageInternal

        @internal

        """
        return _libsbml.ASTBasePlugin_connectToParent(self, *args)

    def enablePackageInternal(self, *args):
        """
        enablePackageInternal(self, string pkgURI, string pkgPrefix, bool flag)

        @internal
        Enables/Disables the given package with child elements in this plugin 
        object (if any).
        (This is an internal implementation invoked from 
        SBase.enablePackageInternal() function)

        Subclasses which contain one or more SBase derived elements should 
        override this function if elements defined in them can be extended by
        some other package extension.

        @see setSBMLDocument
        @see connectToParent

        @internal

        """
        return _libsbml.ASTBasePlugin_enablePackageInternal(self, *args)

    def stripPackage(self, *args):
        """
        stripPackage(self, string pkgPrefix, bool flag) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_stripPackage(self, *args)

    def getURI(self):
        """
        getURI(self) -> string

        @internal
        Gets the URI to which this element belongs to.
        For example, all elements that belong to SBML Level 3 Version 1 Core
        must would have the URI 'http://www.sbml.org/sbml/level3/version1/core'; 
        all elements that belong to Layout Extension Version 1 for SBML Level 3
        Version 1 Core must would have the URI
        'http://www.sbml.org/sbml/level3/version1/layout/version1/'

        Unlike getElementNamespace, this function first returns the URI for this 
        element by looking into the SBMLNamespaces object of the document with 
        the its package name. if not found it will return the result of 
        getElementNamespace

        @return the URI this elements  

        @see getPackageName
        @see getElementNamespace
        @see SBMLDocument::getSBMLNamespaces
        @see getSBMLDocument

        @internal

        """
        return _libsbml.ASTBasePlugin_getURI(self)

    def getParentASTObject(self, *args):
        """
        getParentASTObject(self) -> ASTBase
        getParentASTObject(self) -> ASTBase

        @internal
        Returns the parent ASTNode object to which this plugin 
        object connected.

        @return the parent ASTNode object to which this plugin 
        object connected.

        @internal

        """
        return _libsbml.ASTBasePlugin_getParentASTObject(self, *args)

    def setElementNamespace(self, *args):
        """
        setElementNamespace(self, string uri) -> int

        @internal
        Sets the XML namespace to which this element belongs to.
        For example, all elements that belong to SBML Level 3 Version 1 Core
        must set the namespace to 'http://www.sbml.org/sbml/level3/version1/core'; 
        all elements that belong to Layout Extension Version 1 for SBML Level 3
        Version 1 Core must set the namespace to 
        'http://www.sbml.org/sbml/level3/version1/layout/version1/'

        @return integer value indicating success/failure of the
        function.  @if clike The value is drawn from the
        enumeration #OperationReturnValues_t. @endif@~ The possible values
        returned by this function are:
        @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
        @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink

        @internal

        """
        return _libsbml.ASTBasePlugin_setElementNamespace(self, *args)

    def getLevel(self):
        """
        getLevel(self) -> unsigned int

        @internal
        Returns the SBML level of the package extension of 
        this plugin object.

        @return the SBML level of the package extension of
        this plugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_getLevel(self)

    def getVersion(self):
        """
        getVersion(self) -> unsigned int

        @internal
        Returns the SBML version of the package extension of
        this plugin object.

        @return the SBML version of the package extension of
        this plugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_getVersion(self)

    def getPackageVersion(self):
        """
        getPackageVersion(self) -> unsigned int

        @internal
        Returns the package version of the package extension of
        this plugin object.

        @return the package version of the package extension of
        this plugin object.

        @internal

        """
        return _libsbml.ASTBasePlugin_getPackageVersion(self)

    def getSBMLNamespaces(self):
        """
        getSBMLNamespaces(self) -> SBMLNamespaces

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_getSBMLNamespaces(self)

    def isSetMath(self):
        """
        isSetMath(self) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isSetMath(self)

    def getMath(self):
        """
        getMath(self) -> ASTBase

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_getMath(self)

    def createMath(self, *args):
        """
        createMath(self, int type)

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_createMath(self, *args)

    def addChild(self, *args):
        """
        addChild(self, ASTBase child) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_addChild(self, *args)

    def getChild(self, *args):
        """
        getChild(self, unsigned int n) -> ASTBase

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_getChild(self, *args)

    def getNumChildren(self):
        """
        getNumChildren(self) -> unsigned int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_getNumChildren(self)

    def insertChild(self, *args):
        """
        insertChild(self, unsigned int n, ASTBase newChild) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_insertChild(self, *args)

    def prependChild(self, *args):
        """
        prependChild(self, ASTBase newChild) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_prependChild(self, *args)

    def removeChild(self, *args):
        """
        removeChild(self, unsigned int n) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_removeChild(self, *args)

    def replaceChild(self, *args):
        """
        replaceChild(self, unsigned int n, ASTBase newChild) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_replaceChild(self, *args)

    def swapChildren(self, *args):
        """
        swapChildren(self, ASTFunction that) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_swapChildren(self, *args)

    def read(self, *args):
        """
        read(self, XMLInputStream stream, string reqd_prefix, XMLToken currentElement) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_read(self, *args)

    def addExpectedAttributes(self, *args):
        """
        addExpectedAttributes(self, ExpectedAttributes attributes, XMLInputStream stream, 
            int type)

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_addExpectedAttributes(self, *args)

    def readAttributes(self, *args):
        """
        readAttributes(self, XMLAttributes attributes, ExpectedAttributes expectedAttributes, 
            XMLInputStream stream, XMLToken element, 
            int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_readAttributes(self, *args)

    def writeAttributes(self, *args):
        """
        writeAttributes(self, XMLOutputStream stream, int type)

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_writeAttributes(self, *args)

    def writeXMLNS(self, *args):
        """
        writeXMLNS(self, XMLOutputStream stream)

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_writeXMLNS(self, *args)

    def isNumberNode(self, *args):
        """
        isNumberNode(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isNumberNode(self, *args)

    def isFunctionNode(self, *args):
        """
        isFunctionNode(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isFunctionNode(self, *args)

    def isLogical(self, *args):
        """
        isLogical(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isLogical(self, *args)

    def isConstantNumber(self, *args):
        """
        isConstantNumber(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isConstantNumber(self, *args)

    def isCSymbolFunction(self, *args):
        """
        isCSymbolFunction(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isCSymbolFunction(self, *args)

    def isCSymbolNumber(self, *args):
        """
        isCSymbolNumber(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isCSymbolNumber(self, *args)

    def isName(self, *args):
        """
        isName(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isName(self, *args)

    def isNumber(self, *args):
        """
        isNumber(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isNumber(self, *args)

    def isOperator(self, *args):
        """
        isOperator(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isOperator(self, *args)

    def isRelational(self, *args):
        """
        isRelational(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isRelational(self, *args)

    def representsQualifier(self, *args):
        """
        representsQualifier(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_representsQualifier(self, *args)

    def isFunction(self, *args):
        """
        isFunction(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isFunction(self, *args)

    def representsUnaryFunction(self, *args):
        """
        representsUnaryFunction(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_representsUnaryFunction(self, *args)

    def representsBinaryFunction(self, *args):
        """
        representsBinaryFunction(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_representsBinaryFunction(self, *args)

    def representsNaryFunction(self, *args):
        """
        representsNaryFunction(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_representsNaryFunction(self, *args)

    def hasCorrectNumberArguments(self, *args):
        """
        hasCorrectNumberArguments(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_hasCorrectNumberArguments(self, *args)

    def isWellFormedNode(self, *args):
        """
        isWellFormedNode(self, int type) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isWellFormedNode(self, *args)

    def isTopLevelMathMLFunctionNodeTag(self, *args):
        """
        isTopLevelMathMLFunctionNodeTag(self, string name) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isTopLevelMathMLFunctionNodeTag(self, *args)

    def isTopLevelMathMLNumberNodeTag(self, *args):
        """
        isTopLevelMathMLNumberNodeTag(self, string name) -> bool

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_isTopLevelMathMLNumberNodeTag(self, *args)

    def getTypeFromName(self, *args):
        """
        getTypeFromName(self, string name) -> int

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_getTypeFromName(self, *args)

    def getNameFromType(self, *args):
        """
        getNameFromType(self, int type) -> char

        @internal

        @internal

        """
        return _libsbml.ASTBasePlugin_getNameFromType(self, *args)

ASTBasePlugin_swigregister = _libsbml.ASTBasePlugin_swigregister
ASTBasePlugin_swigregister(ASTBasePlugin)

# This file is compatible with both classic and new-style classes.


