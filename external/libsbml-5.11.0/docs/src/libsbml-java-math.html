<!-- 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE ABOUT HOW THIS FILE WAS PRODUCED:

The master file is libsbml-math.txt.  I ran Doxygen to produce the python
version of that file, copied the HTML that it produced, and manually adjusted
the links and sometimes the content, to produce the final version here.

Yes, it's a royal pain in the ass.  No, I can't think of a better way.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<table border="0" class="centered" style="margin-bottom: 2em; margin-top: 2em">
<tr>
<td style="font-size: small;">
<a href="#math-overview">&bull; Basic Concepts</a>
</td></tr><tr><td style="font-size: small;">
<a href="#math-convert">&bull; Converting between ASTs and Text Strings</a>
</td></tr><tr><td style="font-size: small;">
<a href="#math-diffs">&bull; The String Formula Syntax and Differences with MathML</a>
</td></tr><tr><td style="font-size: small;">
<a href="#math-ast">&bull; Methods for working directly with libSBML's Abstract Syntax Trees</a>
</td></tr><tr><td style="font-size: small;">
<a href="#math-reading">&bull; Reading and Writing MathML from/to ASTs</a>
</td></tr><tr><td style="font-size: small;">
</tr>
</table>

<p>This section describes libSBML's facilities for working with SBML
representations of mathematical expressions.  Unless otherwise noted, all
classes are in the Java package <code><a
href="org/sbml/libsbml/package-summary.html">org.sbml.libsbml</a></code>.

<p>Internally, libSBML uses <a
href="http://en.wikipedia.org/wiki/Abstract_syntax_tree"
target="_blank">Abstract Syntax Trees</a> (ASTs) to provide a canonical,
in-memory representation for all mathematical formulas regardless of their
original format (i.e., C-like infix text strings or the XML-based <a
href="http://www.w3.org/TR/MathML2/" target="_blank">MathML&nbsp;2.0</a>
format). LibSBML provides an extensive API for working with ASTs; it also
provides facilities for translating between ASTs and mathematical formulas
writing in a text-string notation, as well as translating between ASTs and
MathML.</p>

<h2><a class="anchor" name="math-overview">Basic concepts</a></h2>

<p>An AST <em>node</em> in libSBML is a recursive tree structure; each node
has a type, a pointer to a value, and a list of children nodes. Each <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code>
node may have none, one, two, or more children depending on its type. There
are node types to represent numbers (with subtypes to distinguish integer,
real, and rational numbers), names (e.g., constants or variables), simple
mathematical operators, logical or relational operators and functions. The
following diagram illustrates an example of how the mathematical expression
<code>"1 + 2"</code> is represented as an AST with one <em>plus</em> node
having two <em>integer</em> children nodes for the numbers <code>1</code> and
<code>2</code>. The figure also shows the corresponding MathML
representation:

<table border="0" class="centered text-table width80 normal-font" style="padding-bottom: 0.5em">
<caption class="top-caption">Example AST representation of a mathematical expression.</caption>
<tr>
<th>Infix</th>
<th>AST</th>
<th>MathML</th>
</tr>
<tr>
<td valign="middle">
<code>1 + 2</code>
</td>
<td valign="middle">
<iframe src="simple-ast.svg" width="140" height="120" scrolling="no" frameborder="0"></iframe>
</td>
<td valign="middle">
<code>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;</code><br>
<code>&nbsp;&nbsp;&lt;apply&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;plus/&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 1 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 2 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&lt;/apply&gt;</code><br>
<code>&lt;/math&gt;</code>
</td>
</tr>
</table>

<p>
The following are noteworthy about the AST representation in libSBML:
</p>

<ul>

<li style="margin-bottom: 1em">A numerical value represented in MathML as a
real number with an exponent is preserved as such in the AST node
representation, even if the number could be stored in a <code>double</code>
data type. This is done so that when an SBML model is read in and then
written out again, the amount of change introduced by libSBML to the SBML
during the round-trip activity is minimized.</li>

<li style="margin-bottom: 1em">Rational numbers are represented in an AST
node using separate numerator and denominator values. These can be retrieved
using the <code><a
href="org/sbml/libsbml/ASTNode.html#getNumerator()">getNumerator()</a></code>
and <code><a
href="org/sbml/libsbml/ASTNode.html#getDenominator()">getDenominator()</a></code>
methods provided by the <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code> class.</li>

<li style="margin-bottom: 1em">The children of an <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code> are other <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code> objects. The list of
children is empty for nodes that are leaf elements, such as numbers. For
nodes that are actually roots of expression subtrees, the list of children
points to the parsed objects that make up the rest of the expression.</li>

</ul>

<p> For many applications, the details of ASTs are irrelevant because the
applications can use libSBML's text-string based translation functions such
as <code><a
href="org/sbml/libsbml/libsbml.html#formulaToL3String(org.sbml.libsbml.ASTNode)">libsbml.formulaToL3String</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code> and <code><a
href="org/sbml/libsbml/libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula</a>(java.lang.String)</code>
If you find the complexity of using the AST representation of expressions too
high for your purposes, perhaps the string-based functions will be more
suitable.  </p>


<h2><a class="anchor" name="math-convert">Converting between ASTs and text strings</a></h2>

<p>SBML Levels 2 and 3 represent mathematical expressions using using <a
href="http://www.w3.org/Math/">MathML&#160;2.0</a> (more specifically, a
subset of the <em>content</em> portion of MathML&#160;2.0), but most
applications using libSBML do not use MathML directly. Instead, applications
generally interact with mathematics using either the API for Abstract Syntax
Trees (described below), or using libSBML's facilities for encoding and
decoding mathematical formulas to/from text strings. The latter is simpler to
use directly, so we describe it first.</p>

<p>The libSBML formula parser has been carefully engineered so that
transformations from MathML to the libSBML infix text notation <em>and
back</em> is possible with a minimum of disruption to the structure of the
mathematical expression. The example below shows a simple program that, when
run, takes a MathML string compiled into the program, converts it to an AST,
converts <em>that</em> to an infix representation of the formula, compares it
to the expected form of that formula, and finally translates that formula
back to MathML and displays it. The output displayed on the terminal should
have the same structure as the MathML it started with. The program is a
simple example of using libSBML's basic MathML and AST reading and writing
methods, and shows that libSBML preserves the ordering and structure of the
mathematical expressions.</p>

<a class="anchor" name="example-program"> </a>
<pre class="fragment">
import org.sbml.libsbml.ASTNode;
import org.sbml.libsbml.libsbml;

public class example
{
  public static void main (String[] args)
  {        
      String expected = "1 + f(x)";
      String input_mathml = "&lt;?xml version='1.0' encoding='UTF-8'?&gt;" 
          + "&lt;math xmlns='http://www.w3.org/1998/Math/MathML'&gt;"
          + "  &lt;apply&gt; &lt;plus/&gt; &lt;cn&gt; 1 &lt;/cn&gt;"
          + "                  &lt;apply&gt; &lt;ci&gt; f &lt;/ci&gt; &lt;ci&gt; x &lt;/ci&gt; &lt;/apply&gt;"
          + "  &lt;/apply&gt;"
          + "&lt;/math&gt;";

      ASTNode ast_result   = libsbml.readMathMLFromString(input_mathml);
      String ast_as_string = libsbml.formulaToString(ast_result);

      if (ast_as_string.equals(expected))
      {
          System.out.println("Got expected result.");
      }
      else
      {
          System.out.println("Mismatch after readMathMLFromString().");
          System.exit(1);
      }

      ASTNode new_mathml = libsbml.parseFormula(ast_as_string);
      String new_string  = libsbml.writeMathMLToString(new_mathml);

      System.out.println("Result of writing AST to string:");
      System.out.print(new_string);
      System.out.println();
  }

  static 
  {
    try 
    {
      System.loadLibrary("sbmlj");
    }
    catch (Exception e)
    {
      System.err.println("Could not load libSBML library:" + e.getMessage());
    }
  }
}
</pre>

<p> The text-string form of mathematical formulas produced by <code><a
 href="org/sbml/libsbml/libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">
 libsbml.formulaToString</a>(<a
 href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code> and <code><a
 href="org/sbml/libsbml/libsbml.html#formulaToL3String(org.sbml.libsbml.ASTNode)">
 libsbml.formulaTol3String</a>(<a
 href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code>, and read by
 <code><a
 href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>
 and <code><a
 href="org/sbml/libsbml/libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula</a>(java.lang.String)</code>
 are in a simple C-inspired infix notation.  It is summarized in the next
 section below.  A formula in this text-string form therefore can be handed
 to a program that understands SBML mathematical expressions, or used as part
 of a translation system.</p>

<h1><a class="anchor" id="math-diffs"></a>
The text-string formula syntax, and differences with MathML</h1>

<p>There are actually two text-based formula parsing/writing systems in
libSBML: one that uses a more limited syntax and was originally designed for
translation between SBML Level&#160;1 (which used a text-string format for
representing mathematics) and higher levels of SBML, and a more recent, more
powerful version that offers features to support SBML Level&#160;3. We
describe both below, beginning with the simpler but more limited system.</p>

<h2><a class="anchor" id="math-original"></a>
Simpler scheme based on SBML Level 1's syntax</h2>

<p>The simpler, more limited translation system is read by <code><a
 href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>
 and written by <code><a
 href="org/sbml/libsbml/libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">
 libsbml.formulaToString</a>(<a
 href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code>. It uses an infix
 notation essentially derived from the syntax of the C programming language
 and was originally used in SBML Level&#160;1. We summarize the syntax here,
 but for more complete details, readers should consult the documentation for
 <code><a
 href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>.</p>

<p>Formula strings in this infix notation may contain operators, function
calls, symbols, and white space characters. The allowable white space
characters are tab and space. The following are illustrative examples of
formulas expressed in the syntax:</p>

<pre class="fragment">0.10 * k4^2
</pre>
<pre class="fragment">(vm * s1)/(km + s1)
</pre>

<p>The following table shows the precedence rules in this syntax. In the
Class column, <em>operand</em> implies the construct is an operand,
<em>prefix</em> implies the operation is applied to the following arguments,
<em>unary</em> implies there is one argument, and <em>binary</em> implies
there are two arguments. The values in the Precedence column show how the
order of different types of operation are determined. For example, the
expression <code>a * b + c</code> is evaluated as <code>(a * b) + c</code>
because the <code>*</code> operator has higher precedence. The Associates
column shows how the order of similar precedence operations is determined;
for example, <code>a - b + c</code> is evaluated as <code>(a - b) + c</code>
because the <code>+</code> and <code>-</code> operators are
left-associative. The precedence and associativity rules are taken from the C
programming language, except for the symbol <code>^</code>, which is used in
C for a different purpose. (Exponentiation can be invoked using either
<code>^</code> or the function <code>power</code>.)</p>

<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>
A program parsing a formula in an SBML model should assume that names
appearing in the formula are the identifiers of 
<code><a href="org/sbml/libsbml/Species.html">Species</a></code>,
<code><a href="org/sbml/libsbml/Compartment.html">Compartment</a></code>,
<code><a href="org/sbml/libsbml/Parameter.html">Parameter</a></code>,
<code><a href="org/sbml/libsbml/FunctionDefinition.html">FunctionDefinition</a></code>,
(in Level&nbsp;2) <code><a href="org/sbml/libsbml/Reaction.html">Reaction</a></code>, or 
(in Level&nbsp;3) <code><a href="org/sbml/libsbml/SpeciesReference.html">SpeciesReference</a></code> 
objects defined in a model.  When a function call is involved, the syntax consists
of a function identifier, followed by optional white space, followed by an
opening parenthesis, followed by a sequence of zero or more arguments
separated by commas (with each comma optionally preceded and/or followed by
zero or more white space characters), followed by a closing parenthesis.
There is an almost one-to-one mapping between the list of predefined
functions available, and those defined in MathML.  All of the MathML
funcctions are recognized; this set is larger than the functions defined in
SBML Level&nbsp;1.  In the subset of functions that overlap between MathML
and SBML Level&nbsp;1, there exist a few differences.  The following table
summarizes the differences between the predefined functions in SBML
Level&nbsp;1 and the MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3:
</p>

<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Text string formula functions</th>
     <th align="left">MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3</th>
 </tr>
 <tr><td><code>acos</code></td><td><code>arccos</code></td></tr>
 <tr><td><code>asin</code></td><td><code>arcsin</code></td></tr>
 <tr><td><code>atan</code></td><td><code>arctan</code></td></tr>
 <tr><td><code>ceil</code></td><td><code>ceiling</code></td></tr>
 <tr><td><code>log</code></td><td><code>ln</code></td></tr>
 <tr><td><code>log10(x)</code></td><td><code>log(x)</code> or <code>log(10, x)</code></td></tr>
 <tr><td><code>pow(x, y)</code></td><td><code>power(x, y)</code></td></tr>
 <tr><td><code>sqr(x)</code></td><td><code>power(x, 2)</code></td></tr>
 <tr><td><code>sqrt(x)</code></td><td><code>root(x)</code> or <code>root(2, x)</code></td></tr>
<caption class="top-caption">Table comparing the names of certain
functions in the SBML text-string formula syntax and MathML.  The left
column shows the names of functions recognized by SBML_parseFormula(); the
right column shows their equivalent function names in MathML&nbsp;2.0, used
in SBML Levels&nbsp;2 and&nbsp;3.</caption>
</table>

<p>Note that <b>there are differences between the symbols used to represent
the common mathematical functions and the corresponding MathML token
names</b>. This is a potential source of incompatibilities. Note in
particular that in this text-string syntax, <code>log(x)</code> always
represents the natural logarithm, whereas in MathML, the natural logarithm is
<code>&lt;ln/&gt;</code>. Application writers are urged to be careful when
translating between text forms and MathML forms, especially if they provide a
direct text-string input facility to users of their software systems. The
more advanced mathematical formula system, described below, offers the
ability to control how <code>log</code> is interpreted as well as other
parsing behaviors.</p>

<h2><a class="anchor" id="math-l3"></a>
Advanced, SBML Level 3-oriented formula scheme</h2>

<p>
The text-string form of mathematical formulas read by the function <code><a
href="org/sbml/libsbml/libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula</a>(java.lang.String)</code>
and written by the function <code><a
href="org/sbml/libsbml/libsbml.html#formulaToL3String(org.sbml.libsbml.ASTNode)">
libsbml.formulaTol3String</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code> uses an expanded
version of the syntax read and written by <code><a
href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>
and written by the function <code><a
href="org/sbml/libsbml/libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">
libsbml.formulaToString</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code>, respectively.  The
latter two libSBML functions were originally developed to support conversion
between SBML Levels&#160;1 and&#160;2, and were focused on the syntax of
mathematical formulas used in SBML Level&#160;1. With time, and the use of
MathML in SBML Levels&#160;2 and&#160;3, it became clear that supporting
Level&#160;2 and&#160;3's expanded mathematical syntax would be useful for
software developers. To maintain backwards compatibility for libSBML users,
the original <code><a
href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>
and <code><a
href="org/sbml/libsbml/libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">
libsbml.formulaToString</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code> have been left
untouched, and instead, the new functionality is provided in the form of
<code><a
href="org/sbml/libsbml/libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula</a>(java.lang.String)</code>
and <code><a
href="org/sbml/libsbml/libsbml.html#formulaToL3String(org.sbml.libsbml.ASTNode)">
libsbml.formulaTol3String</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code>.</p>

<p>The following lists the main differences in the formula syntax supported
by the "Level 3" or L3 versions of the formula parsers and formatters,
compared to what is supported by the Level&#160;1-oriented <code><a
href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>
and <code><a
href="org/sbml/libsbml/libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">
libsbml.formulaToString</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code>:</p>

<ul>

<li>Units may be asociated with bare numbers, using the following syntax:
<div style="margin: 10px auto 10px 25px; display: block"> <span class="code"
style="background-color: #d0d0ee">number</span> <span class="code"
style="background-color: #edd">unit</span> </div> The <span class="code"
style="background-color: #d0d0ee">number</span> may be in any form (an
integer, real, or rational number), and the <span class="code"
style="background-color: #edd">unit</span> must conform to the syntax of an
SBML identifier (technically, the type defined as <code>SId</code> in the
SBML specifications). The whitespace between <span class="code"
style="background-color: #d0d0ee">number</span> and <span class="code"
style="background-color: #edd">unit</span> is optional.</li>

<li>The Boolean function symbols <code>&amp;&amp;</code>, <code>||</code>,
<code>!</code>, and <code>!=</code> may be used.</li>

<li>The <em>modulo</em> operation is allowed as the symbol <code>%</code> and
will produce a <code>&lt;piecewise&gt;</code> function in the corresponding
MathML output.</li>

<li>All inverse trigonometric functions may be defined in the infix either
using <code>arc</code> as a prefix or simply <code>a</code>; in other words,
both <code>arccsc</code> and <code>acsc</code> are interpreted as the
operator <em>arccosecant</em> as defined in MathML&#160;2.0. (Many functions
in the simpler SBML Level&#160;1 oriented parser implemented by <code><a
href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>
are defined this way as well, but not all.)</li>

<li>The following expression is parsed as a rational number instead of as a
numerical division:

<pre style="display: block; margin-left: 25px">
   (<span class="code" style="background-color: #d0d0ee">integer</span>/<span
   class="code" style="background-color: #d0d0ee">integer</span>)
</pre> 

<b>Spaces are not allowed</b> in this construct; in other words,
&quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and the
operator) will be parsed into the MathML <code>&lt;divide&gt;</code>
construct rather than a rational number. You can, however, assign units to a
rational number as a whole; here is an example: &quot;<code>(3/4)
ml</code>&quot;. (In the case of division rather than a rational number,
units are not interpreted in this way.)</li>

<li>Various parser and formatter behaviors may be altered through the use of
a L3ParserSettings object in conjunction with the functions 
<code><a href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String, L3ParserSettings)</a></code>
and <code><a href='org/sbml/libsbml/libsbml.html#formulaToL3StringWithSettings(org.sbml.libsbml.ASTNode, org.sbml.libsbml.L3ParserSettings)'>libsbml.formulaToL3StringWithSettings(ASTNode, L3ParserSettings)</a></code>.
The settings available include the following:

<ul style="list-style-type:circle">

<li style="margin-bottom: 0.5em"> <p class="startli">The function
<code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can
be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an
error, as desired.</p> <p class="endli"></p> </li>

<li style="margin-bottom: 0.5em"> <p class="startli">Unary minus signs can be
collapsed or preserved; that is, sequential pairs of unary minuses (e.g.,
&quot;<code>- -3</code>&quot;) can be removed from the input entirely and
single unary minuses can be incorporated into the number node, or all minuses
can be preserved in the AST node structure.</p> <p class="endli"></p> </li>

<li style="margin-bottom: 0.5em"> <p class="startli">Parsing of units
embedded in the input string can be turned on and off.</p> <p
class="endli"></p> </li>

<li style="margin-bottom: 0.5em"> <p class="startli">The string
<code>avogadro</code> can be parsed as a MathML <em>csymbol</em> or as an
identifier.</p> <p class="endli"></p> </li>

<li style="margin-bottom: 0.5em"> <p class="startli">A Model object may
optionally be provided to the parser using the variant function <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithModel(java.lang.String, org.sbml.libsbml.Model)'>libsbml.parseL3FormulaWithModel(String,
Model)</a></code> or stored in a <code><a
href="org/sbml/libsbml/L3ParserSettings.html" title="class in
org.sbml.libsbml">L3ParserSettings</a></code> object passed to the variant
function <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String,
L3ParserSettings)</a></code>. When a Model object is provided, identifiers
(values of type <code>SId</code>) from that model are used in preference to
pre-defined MathML definitions for both symbols and functions. More
precisely: </p>

<ul style="list-style-type: square">

<li style="margin-bottom: 0.5em"> <p class="startli"><em>In the case of
symbols</em>: the Model entities whose identifiers will shadow identical
symbols in the mathematical formula are: Species, Compartment, Parameter,
Reaction, and SpeciesReference. For instance, if the parser is given a Model
containing a Species with the identifier &quot;<code>pi</code>&quot;, and the
formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced
will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of
the construct <code>&lt;pi/&gt;</code>.</p> <p class="endli"></p> </li>

<li style="margin-bottom: 0.5em"> <em>In the case of user-defined
functions</em>: when a Model object is provided, <code>SId</code> values of
user-defined functions present in the model will be used preferentially over
pre-defined MathML functions. For example, if the passed-in Model contains a
FunctionDefinition object with the identifier &quot;<code>sin</code>&quot;,
that function will be used instead of the predefined MathML function
<code>&lt;sin/&gt;</code>. </li> </ul> <p class="endli"></p> </li>

<li style="margin-bottom: 0.5em"> An SBMLNamespaces object may optionally be
provided to identify SBML Level&#160;3 packages that extend the syntax
understood by the formula parser. When the namespaces are provided, the
parser will interpret possible additional syntax defined by the libSBML
plug-ins implementing the SBML Level&#160;3 packages; for example, it may
understand vector/array extensions introduced by the SBML Level&#160;3
<em>Arrays</em> package. </li> </ul> </li>

</ul>

<p>These configuration settings cannot be changed directly using the basic
parser and formatter functions, but <em>can</em> be changed on a per-call
basis by using the alternative functions <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String, L3ParserSettings)</a></code> and <code><a
href='org/sbml/libsbml/libsbml.html#formulaToL3StringWithSettings(org.sbml.libsbml.ASTNode, org.sbml.libsbml.L3ParserSettings)'>libsbml.formulaToL3StringWithSettings(ASTNode, L3ParserSettings)</a></code>.

<p>Neither SBML nor the MathML standard define a "string-form" equivalent to
MathML expressions. The approach taken by libSBML is to start with the
formula syntax defined by SBML Level&#160;1 (which in fact used a custom
text-string representation of formulas, and not MathML), and expand it to
include the functionality described above. This formula syntax is based
mostly on C programming syntax, and may contain operators, function calls,
symbols, and white space characters. The following table provides the
precedence rules for the different entities that may appear in formula
strings.</p>

<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors"
       style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">8</td><td>left</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">7</td><td>left</td></tr>
<tr><td><code>-, !</code></td><td>negation and boolean 'not'</td><td>unary</td><td align="center">6</td><td>right</td></tr>
<tr><td><code>*, /, %</code></td><td>multiplication, division, and modulo</td><td>binary</td><td align="center">5</td><td>left</td></tr>
<tr><td><code>+, -</code></td><td>addition and subtraction</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>==, &lt;, &gt;, &lt=, &gt=, !=</code></td><td>boolean equality, inequality, and comparison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>&&, ||</code></td><td>boolean 'and' and 'or'</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>

<caption class="top-caption">Expression operators and their precedence in the
"Level&nbsp;3" text-string format for mathematical expressions.
</caption>
</table>

<p>In the table above, <em>operand</em> implies the construct is an operand,
<em>prefix</em> implies the operation is applied to the following arguments,
<em>unary</em> implies there is one argument, and <em>binary</em> implies
there are two arguments. The values in the <b>Precedence</b> column show how
the order of different types of operation are determined. For example, the
expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code>
because the <code>*</code> operator has higher precedence. The
<b>Associates</b> column shows how the order of similar precedence operations
is determined; for example, <code>a &amp;&amp; b || c</code> is evaluated as
<code>(a &amp;&amp; b) || c</code> because the <code>&amp;&amp;</code> and
<code>||</code> operators are left-associative and have the same
precedence.</p>

<p>The function call syntax consists of a function name, followed by optional
white space, followed by an opening parenthesis token, followed by a sequence
of zero or more arguments separated by commas (with each comma optionally
preceded and/or followed by zero or more white space characters), followed by
a closing parenthesis token. The function name must be chosen from one of the
pre-defined functions in SBML or a user-defined function in the model. The
following table lists the names of certain common mathematical functions;
this table corresponds to Table&#160;6 in the <a
href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2"
target="_blank">SBML Level&#160;1 Version&#160;2 specification</a> with
additions based on the functions added in SBML Level 2 and Level 3:</p>

<table border="0" width="95%" 
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="75">Argument(s)</th>
     <th align="left">Formula or meaning</th>
     <th align="left" width="90">Argument Constraints</th>
     <th align="left" width="90">Result constraints</th>
 </tr>
<tr><td><code>abs</code></td>   
    <td><em>x</em></td> 
    <td>Absolute value of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acos</code>, <code>arccos</code></td>
    <td><em>x</em></td>
    <td>Arccosine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>acos(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>acosh</code>, <code>arccosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosine of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acot</code>, <code>arccot</code></td>
    <td><em>x</em></td>
    <td>Arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acoth</code>, <code>arccoth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsc</code>, <code>arccsc</code></td>
    <td><em>x</em></td>
    <td>Arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsch</code>, <code>arccsch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asec</code>, <code>arcsec</code></td>
    <td><em>x</em></td>
    <td>Arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asech</code>, <code>arcsech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asin</code>, <code>arcsin</code></td>
    <td><em>x</em></td><td>Arcsine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>asin(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atan</code>, <code>arctan</code></td>
    <td><em>x</em></td>
    <td>Arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td>0 &le; <em>atan(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atanh</code>, <code>arctanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ceil</code>, <code>ceiling</code></td>
    <td><em>x</em></td>
    <td>Smallest number not less than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cos</code></td>
    <td><em>x</em></td>
    <td>Cosine of <em>x</em></td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cot</code></td>
    <td><em>x</em></td>
    <td>Cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>coth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csc</code></td>
    <td><em>x</em></td>
    <td>Cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>delay</code></td>
    <td><em>x, y</em></td>
    <td>The value of <em>x</em> at <em>y</em> time units in the past.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>factorial</code></td>
    <td><em>n</em></td>
    <td>The factorial of <em>n</em>. Factorials are defined by <em>n! = n*(n&ndash;1)* ... * 1</em>.</td>
    <td><em>n</em> must be an integer.</td>
    <td></td>
</tr>
<tr><td><code>exp</code></td>
    <td><em>x</em></td>
    <td><em>e</em><sup><em> x</em></sup>, where <em>e</em> is the base of the natural logarithm.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>floor</code></td>
    <td><em>x</em></td>
    <td>The largest number not greater than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ln</code></td>
    <td><em>x</em></td>
    <td>Natural logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x</em></td>
    <td>By default, the base 10 logarithm of <em>x</em>, but can be set to be the natural logarithm of <em>x</em>, or to be an illegal construct.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x, y</em></td>
    <td>The base <em>x</em> logarithm of <em>y</em>.</td>
    <td><em>y</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log10</code></td>
    <td><em>x</em></td>
    <td>Base 10 logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>piecewise</code></td>
    <td><em>x1, y1, [x2, y2,] [...] [z]</em></td>
    <td>A piecewise function: if (<em>y1</em>), <em>x1</em>.  Otherwise, if (<em>y2</em>), <em>x2</em>, etc.  Otherwise, z. </td>
    <td><em>y1, y2, y3 [etc]</em> must be boolean</td>
    <td></td>
</tr>
<tr><td><code>pow</code>, <code>power</code> </td>
    <td><em>x, y</em></td>
    <td><em>x</em><sup><em> y</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>root</code></td>
    <td><em>b, x</em></td>
    <td>The root base <em>b</em> of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sec</code></td>
    <td><em>x</em></td>
    <td>Secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqr</code></td>
    <td><em>x</em></td>
    <td><em>x</em><sup><em>2</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqrt</code></td>
    <td><em>x</em></td>
    <td>&radic;<em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td><em>sqrt(x)</em> &ge; 0</td>
</tr>
<tr><td><code>sin</code></td>
    <td><em>x</em></td>
    <td>Sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sinh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>tan</code></td>
    <td><em>x</em></td>
    <td>Tangent of <em>x</em>.</td>
    <td>x &ne; n*&pi;/2, for odd integer <em>n</em></td>
    <td></td>
</tr>
<tr><td><code>tanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic tangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>and</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>and(x, y, z...)</em>: returns <code>true</code> if all of its arguments are true.  Note that <code>and</code> is an n-ary function, taking 0 or more arguments, and that <code>and()</code> returns <code>true</code>.</td>
    <td>All arguments must be boolean</td>
    <td></td>
</tr>
<tr><td><code>not</code></td>
    <td><em>x</em></td>
    <td>Boolean <em>not(x)</em></td>
    <td><em>x</em> must be boolean</td>
    <td></td>
</tr>
<tr><td><code>or</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>or(x, y, z...)</em>: returns <code>true</code> if at least one of its arguments is true.  Note that <code>or</code> is an n-ary function, taking 0 or more arguments, and that <code>or()</code> returns <code>false</code>.</td>
    <td>All arguments must be boolean</td>
    <td></td>
</tr>
<tr><td><code>xor</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>xor(x, y, z...)</em>: returns <code>true</code> if an odd number of its arguments is true.  Note that <code>xor</code> is an n-ary function, taking 0 or more arguments, and that <code>xor()</code> returns <code>false</code>.</td>
    <td>All arguments must be boolean</td>
    <td></td>
</tr>
<tr><td><code>eq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>eq(x, y, z...)</em>: returns <code>true</code> if all arguments are equal.  Note that <code>eq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>geq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>geq(x, y, z...)</em>: returns <code>true</code> if each argument is greater than or equal to the argument following it.  Note that <code>geq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>gt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>gt(x, y, z...)</em>: returns <code>true</code> if each argument is greater than the argument following it.  Note that <code>gt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>leq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>leq(x, y, z...)</em>: returns <code>true</code> if each argument is less than or equal to the argument following it.  Note that <code>leq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>lt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>lt(x, y, z...)</em>: returns <code>true</code> if each argument is less than the argument following it.  Note that <code>lt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>neq</code></td>
    <td><em>x, y</em></td>
    <td>Boolean <em>x</em> != <em>y</em>: returns <code>true</code> unless x and y are equal.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>plus</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> + <em>y</em> + <em>z</em> + <em>...</em>: The sum of the arguments of the function.  Note that <code>plus</code> is an n-ary function taking 0 or more arguments, and that <code>plus()</code> returns <code>0</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>times</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> * <em>y</em> * <em>z</em> * <em>...</em>: The product of the arguments of the function.  Note that <code>times</code> is an n-ary function taking 0 or more arguments, and that <code>times()</code> returns <code>1</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>minus</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> &ndash; <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>divide</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> / <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>

<caption class="top-caption">Mathematical functions defined
in the "Level&nbsp;3" text-string formula syntax.</caption>

</table>

<p>Parsing of the various MathML functions and constants are all
case-insensitive by default: function names such as <code>cos</code>,
<code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine
operator, <code>&lt;cos&gt;</code>. However, <em>when a Model object is
used</em> in conjunction with either <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithModel(java.lang.String, org.sbml.libsbml.Model)'>libsbml.parseL3FormulaWithModel(String,
Model)</a></code> or <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String,
L3ParserSettings)</a></code>, any identifiers found in that model will be
parsed in a case-<em>sensitive</em> way. For example, if a model contains a
Species having the identifier <code>Pi</code>, the parser will parse
&quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi
&lt;/ci&gt;</code>&quot; but will continue to parse the symbols
&quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as
&quot;<code>&lt;pi&gt;</code>&quot;.</p>

<p>As mentioned above, the manner in which the "L3" versions of the formula
parser and formatter interpret the function &quot;<code>log</code>&quot; can
be changed. To do so, callers should use the function <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String,
L3ParserSettings)</a></code> and pass it an appropriate <code><a
href="org/sbml/libsbml/L3ParserSettings.html" title="class in
org.sbml.libsbml">L3ParserSettings</a></code> object. By default, unlike the
SBML Level&#160;1 parser implemented by <code><a
href="org/sbml/libsbml/libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula</a>(java.lang.String)</code>,
the string &quot;<code>log</code>&quot; is interpreted as the base&#160;10
logarithm, and <em>not</em> as the natural logarithm. However, you can change
the interpretation to be base-10 log, natural log, or as an error; since the
name "log" by itself is ambiguous, you require that the parser uses
<code>log10</code> or <code>ln</code> instead, which are more clear. Please
refer to <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String,
L3ParserSettings)</a></code>.</p>

<p>In addition, the following symbols will be translated to their MathML
equivalents, if no symbol with the same <code>SId</code> identifier string
exists in the Model object provided:</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="250">Meaning</th>
     <th align="left">MathML</th>
 </tr>
<tr><td><code>true</code></td>   
    <td>The boolean value <code>true</code></td>
    <td><code>&lt;true/&gt;</code></td>
</tr>
<tr><td><code>false</code></td>   
    <td>The boolean value <code>false</code></td>
    <td><code>&lt;false/&gt;</code></td>
</tr>
<tr><td><code>pi</code></td>   
    <td>The mathematical constant pi</td>
    <td><code>&lt;pi/&gt;</code></td>
</tr>
<tr><td><code>avogadro</code></td>   
    <td>The numerical value of Avogadro's constant, as defined in the SBML specification</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/avogadro"&gt; avogadro &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>time</code></td>   
    <td>Simulation time as defined in SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/time"&gt; time &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>inf</code> or <code>infinity</code></td>   
    <td>The mathematical constant "infinity"</td>
    <td><code>&lt;infinity/&gt;</code></td>
</tr>
<tr><td><code>nan</code> or <code>notanumber</code></td>   
    <td>The mathematical concept "not a number"</td>
    <td><code>&lt;notanumber/&gt;</code></td>
</tr>

<caption class="top-caption">Mathematical symbols defined
in the "Level&nbsp;3" text-string formula syntax.
</caption>
</table>

<p>Again, as mentioned above, whether the string
&quot;<code>avogadro</code>&quot; is parsed as an AST node of type <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_NAME_AVOGADRO">AST_NAME_AVOGADRO</a></code>
or <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_NAME">AST_NAME</a></code>
is configurable; use the version of the parser function called <code><a
href='org/sbml/libsbml/libsbml.html#parseL3FormulaWithSettings(java.lang.String, org.sbml.libsbml.L3ParserSettings)'>libsbml.parseL3FormulaWithSettings(String,
L3ParserSettings)</a></code>. This Avogadro-related functionality is provided
because SBML Level&#160;2 models may not use <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_NAME_AVOGADRO">AST_NAME_AVOGADRO</a></code>
AST nodes.</p>

<h1><a class="anchor" id="math-ast"></a>
Methods for working directly with libSBML's Abstract Syntax Trees</h1>

<p>While it is convenient to read and write mathematical expressions in the
form of text strings, advanced applications usually need more powerful ways
of creating, traversing, and modifying mathematical formulas. For this
reason, libSBML provides a rich API for interacting with ASTs directly. This
section summarizes these facilities; for more information, readers should
consult the documentation for the ASTNode class.</p>

<p> Every <code><a href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code>
in a libSBML abstract syntax tree has an associated type, which is a value
taken from a set of constants having names beginning with <code>AST_</code>
and defined in <code><a
href="org/sbml/libsbml/libsbmlConstants.html">org.sbml.libsbml.libsbmlConstants</a></code>.
The list of possible AST types in libSBML is quite long, because it covers
all the mathematical functions that are permitted in SBML.  The values are
shown in the following table; their names hopefully evoke the construct
that they represent:
</p>

<table border="0" class="centered text-table borderless code">
<tr><td>AST_CONSTANT_E</td><td>         AST_FUNCTION_COT</td><td>       AST_LOGICAL_NOT</td></tr>
<tr><td>AST_CONSTANT_FALSE</td><td>     AST_FUNCTION_COTH</td><td>      AST_LOGICAL_OR</td></tr>
<tr><td>AST_CONSTANT_PI</td><td>        AST_FUNCTION_CSC</td><td>       AST_LOGICAL_XOR</td></tr>
<tr><td>AST_CONSTANT_TRUE</td><td>      AST_FUNCTION_CSCH</td><td>      AST_MINUS</td></tr>
<tr><td>AST_DIVIDE</td><td>             AST_FUNCTION_DELAY</td><td>     AST_NAME</td></tr>
<tr><td>AST_FUNCTION</td><td>           AST_FUNCTION_EXP</td><td>       AST_NAME_AVOGADRO <span class='warning'><em>(Level&nbsp;3 only)</em></span></td></tr>
<tr><td>AST_FUNCTION_ABS</td><td>       AST_FUNCTION_FACTORIAL</td><td> AST_NAME_TIME</td></tr>
<tr><td>AST_FUNCTION_ARCCOS</td><td>    AST_FUNCTION_FLOOR</td><td>     AST_PLUS</td></tr>
<tr><td>AST_FUNCTION_ARCCOSH</td><td>   AST_FUNCTION_LN</td><td>        AST_POWER</td></tr>
<tr><td>AST_FUNCTION_ARCCOT</td><td>    AST_FUNCTION_LOG</td><td>       AST_RATIONAL</td></tr>
<tr><td>AST_FUNCTION_ARCCOTH</td><td>   AST_FUNCTION_PIECEWISE</td><td> AST_REAL</td></tr>
<tr><td>AST_FUNCTION_ARCCSC</td><td>    AST_FUNCTION_POWER</td><td>     AST_REAL_E</td></tr>
<tr><td>AST_FUNCTION_ARCCSCH</td><td>   AST_FUNCTION_ROOT</td><td>      AST_RELATIONAL_EQ</td></tr>
<tr><td>AST_FUNCTION_ARCSEC</td><td>    AST_FUNCTION_SEC</td><td>       AST_RELATIONAL_GEQ</td></tr>
<tr><td>AST_FUNCTION_ARCSECH</td><td>   AST_FUNCTION_SECH</td><td>      AST_RELATIONAL_GT</td></tr>
<tr><td>AST_FUNCTION_ARCSIN</td><td>    AST_FUNCTION_SIN</td><td>       AST_RELATIONAL_LEQ</td></tr>
<tr><td>AST_FUNCTION_ARCSINH</td><td>   AST_FUNCTION_SINH</td><td>      AST_RELATIONAL_LT</td></tr>
<tr><td>AST_FUNCTION_ARCTAN</td><td>    AST_FUNCTION_TAN</td><td>       AST_RELATIONAL_NEQ</td></tr>
<tr><td>AST_FUNCTION_ARCTANH</td><td>   AST_FUNCTION_TANH</td><td>      AST_TIMES</td></tr>
<tr><td>AST_FUNCTION_CEILING</td><td>   AST_INTEGER</td><td>            AST_UNKNOWN</td></tr>
<tr><td>AST_FUNCTION_COS</td><td>       AST_LAMBDA</td></tr>
<tr><td>AST_FUNCTION_COSH</td><td>      AST_LOGICAL_AND</td></tr>
</table>

<p>The types have the following meanings:</p>
<ul>

<li>If the node is basic mathematical operator (e.g., <code>"+"</code>), then
the node's type will be <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_PLUS">AST_PLUS</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_MINUS">AST_MINUS</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_TIMES">AST_TIMES</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_DIVIDE">AST_DIVIDE</a></code>,
or <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_POWER">AST_POWER</a></code>,
as appropriate.</li>

<li>If the node is a predefined function or operator from SBML Level&#160;1
(in the string-based formula syntax used in Level&#160;1) or SBML
Level&#160;2 and&#160;3 (in the subset of MathML used in SBML Levels&#160;2
and&#160;3), then the node's type will be either <code style="margin-right:
0"><code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_FUNCTION_">AST_FUNCTION_</a></code></code><span
class="placeholder-nospace">X</span>, <code style="margin-right: 0"><code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_LOGICAL_">AST_LOGICAL_</a></code></code><span
class="placeholder-nospace">X</span>, or <code style="margin-right:
0"><code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_RELATIONAL_">AST_RELATIONAL_</a></code></code><span
class="placeholder-nospace">X</span>, as appropriate. (Examples: <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_FUNCTION_LOG">AST_FUNCTION_LOG</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_RELATIONAL_LEQ">AST_RELATIONAL_LEQ</a></code>.)</li>

<li>If the node refers to a user-defined function, the node's type will be
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_FUNCTION">AST_FUNCTION</a></code>
(because it holds the name of the function).</li>

<li>If the node is a lambda expression, its type will be <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_LAMBDA">AST_LAMBDA</a></code>.</li>

<li>If the node is a predefined constant (<code>"ExponentialE"</code>,
<code>"Pi"</code>, <code>"True"</code> or <code>"False"</code>), then the
node's type will be <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_CONSTANT_E">AST_CONSTANT_E</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_CONSTANT_PI">AST_CONSTANT_PI</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_CONSTANT_TRUE">AST_CONSTANT_TRUE</a></code>,
or <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_CONSTANT_FALSE">AST_CONSTANT_FALSE</a></code>.</li>

<li>(Levels&#160;2 and&#160;3 only) If the node is the special MathML csymbol
<code>time</code>, the value of the node will be <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_NAME_TIME">AST_NAME_TIME</a></code>. (Note,
however, that the MathML csymbol <code>delay</code> is translated into a node
of type <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_FUNCTION_DELAY">AST_FUNCTION_DELAY</a></code>. The
difference is due to the fact that <code>time</code> is a single variable,
whereas <code>delay</code> is actually a function taking arguments.)</li>

<li>(Level&#160;3 only) If the node is the special MathML csymbol
<code>avogadro</code>, the value of the node will be <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_NAME_AVOGADRO">AST_NAME_AVOGADRO</a></code>.</li>

<li>If the node contains a numerical value, its type will be <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_INTEGER">AST_INTEGER</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_REAL">AST_REAL</a></code>,
<code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_REAL_E">AST_REAL_E</a></code>,
or <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_RATIONAL">AST_RATIONAL</a></code>,
as appropriate.</li>

</ul>

<p> There are a number of methods for interrogating the type of an <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code> and for testing
whether a node belongs to a general category of constructs.  The methods
defined by the <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code> class are the
following:
</p>

<ul>

<li style="margin-bottom: 1em"> <code>int <a
href="org/sbml/libsbml/ASTNode.html#getType()">getType()</a></code> returns the type of
this AST node.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isConstant()">isConstant()</a></code>
returns <code>true</code> if this AST node is a MathML constant
(<code>true</code>, <code>false</code>, <code>pi</code>,
<code>exponentiale</code>), <code>false</code> otherwise.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isBoolean()">isBoolean()</a></code>
returns <code>true</code> if this AST node returns a boolean value (by
being either a logical operator, a relational operator, or the constant
<code> true</code> or <code>false</code>).

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isFunction()">isFunction()</a></code>
returns <code>true</code> if this AST node is a function (i.e., a MathML
defined function such as <code>exp</code> or else a function defined by a
<code><a
href="org/sbml/libsbml/FunctionDefinition.html">FunctionDefinition</a></code>
object in the enclosing <code><a
href="org/sbml/libsbml/Model.html">Model</a></code> object).

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isInfinity()">isInfinity()</a></code>
returns <code>true</code> if this AST node is the special IEEE 754 value
infinity.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isInteger()">isInteger()</a></code>
returns <code>true</code> if this AST node is holding an integer value.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isNumber()">isNumber()</a></code>
returns <code>true</code> if this AST node is holding any number.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isLambda()">isLambda()</a></code>
returns <code>true</code> if this AST node is a MathML <code>lambda</code>
construct.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isLog10()">isLog10()</a></code> returns
<code>true</code> if this AST node represents the <code>log10</code>
function, specifically, that its type code is <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_FUNCTION_LOG">AST_FUNCTION_LOG</a></code>
and it has two children, the first of which is an integer equal to 10.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isLogical()">isLogical()</a></code>
returns <code>true</code> if this AST node is a logical operator
(<code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>).

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isName()">isName()</a></code> returns
<code>true</code> if this AST node is a user-defined name or (in SBML
Levels&nbsp;2 and&nbsp;3) one of the two special <code>csymbol</code>
constructs "delay" or "time".

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isNaN()">isNaN()</a></code> returns
<code>true</code> if this AST node has the special IEEE 754 value "not a
number" (NaN).

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isNegInfinity()">isNegInfinity()</a></code>
returns <code>true</code> if this AST node has the special IEEE 754 value
of negative infinity.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isOperator()">isOperator()</a></code>
returns <code>true</code> if this AST node is an operator (e.g.,
<code>+</code>, <code>-</code>, etc.)

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isPiecewise()">isPiecewise()</a></code>
returns <code>true</code> if this AST node is the MathML
<code>piecewise</code> function.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isRational()">isRational()</a></code>
returns <code>true</code> if this AST node is a rational number having a
numerator and a denominator.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isReal()">isReal()</a></code> returns
<code>true</code> if this AST node is a real number (specifically, <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_REAL_E">AST_REAL_E</a></code>
or <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_RATIONAL">AST_RATIONAL</a></code>).

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isRelational()">isRelational()</a></code>
returns <code>true</code> if this AST node is a relational operator.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isSqrt()">isSqrt()</a></code> returns
<code>true</code> if this AST node is the square-root operator

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isUMinus()">isUMinus()</a></code>
returns <code>true</code> if this AST node is a unary minus.

<li style="margin-bottom: 1em"> <code>boolean <a
href="org/sbml/libsbml/ASTNode.html#isUnknown()">isUnknown()</a></code>
returns <code>true</code> if this AST node's type code is <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_UNKNOWN">AST_UNKNOWN</a></code>.

</ul>

<p>
Programs manipulating AST node structures should check the type of a given
node before calling methods that return a value from the node.  The
following methods are available for returning values from nodes:
</p>

<ul>

<li style="margin-bottom: 1em"> <code>int <a
href="org/sbml/libsbml/ASTNode.html#getInteger()">getInteger()</a></code>

<li style="margin-bottom: 1em"> <code>char <a
href="org/sbml/libsbml/ASTNode.html#getCharacter()">getCharacter()</a></code>

<li style="margin-bottom: 1em"> <code>java.lang.String <a
href="org/sbml/libsbml/ASTNode.html#getName()">getName()</a></code>

<li style="margin-bottom: 1em"> <code>int <a
href="org/sbml/libsbml/ASTNode.html#getNumerator()">getNumerator()</a></code>

<li style="margin-bottom: 1em"> <code>int <a
href="org/sbml/libsbml/ASTNode.html#getDenominator()">getDenominator()</a></code>

<li style="margin-bottom: 1em"> <code>double <a
href="org/sbml/libsbml/ASTNode.html#getReal()">getReal()</a></code>

<li style="margin-bottom: 1em"> <code>double <a
href="org/sbml/libsbml/ASTNode.html#getMantissa()">getMantissa()</a></code>

<li style="margin-bottom: 1em"> <code>int <a
href="org/sbml/libsbml/ASTNode.html#getExponent()">getExponent()</a></code>

</ul>

<p>
Of course, all of this would be of little use if libSBML didn't also
provide methods for <em>setting</em> the values of AST node objects!  And it
does.  The methods are the following:
</p>

<ul>

<li style="margin-bottom: 1em"> <code>void <a
href="org/sbml/libsbml/ASTNode.html#setCharacter(char)">setCharacter</a>(char
value)</code> sets the value of this AST node to the given character.  If
character is one of <code>+</code>, <code>-</code>, <code>void *</code>,
<code>/</code> or <code>^</code>, the node type will be to the appropriate
operator type.  For all other characters, the node type will be set to the
type code <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_UNKNOWN">AST_UNKNOWN</a></code>.

<li style="margin-bottom: 1em"> <code>void <a
href="org/sbml/libsbml/ASTNode.html#setName(java.lang.String)">setName</a>(java.lang.String)</code>
sets the value of this AST node to the given name.  The node type will be
set (to <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_NAME">AST_NAME</a></code>)
<em>only if</em> the AST node was previously an operator
(<code>isOperator(node) != 0</code>) or number (<code>isNumber(node) !=
0</code>).  This allows names to be set for <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_FUNCTION">AST_FUNCTION</a></code>
nodes and the like.

<li style="margin-bottom: 1em"> <code>void <a
href="org/sbml/libsbml/ASTNode.html#setValue(int)">setValue</a>(int
value)</code> sets the value of the node to the given integer,
<code>value</code>.

<li style="margin-bottom: 1em"> <code>void <a
href="org/sbml/libsbml/ASTNode.html#setValue(int, int)">setValue</a>(int
numerator, int denominator)</code> sets the value of this AST node to the
given rational in two parts: the <code>numerator</code> and
<code>denominator</code>.  The node type code is set to <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_RATIONAL">AST_RATIONAL</a></code>.

<li style="margin-bottom: 1em"> <code>void <a
href="org/sbml/libsbml/ASTNode.html#setValue(double)">setValue</a>(double
value)</code> sets the value of this AST node to the given
<code>double</code> <code>value</code> and sets the node type code to <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_REAL">AST_REAL</a></code>.

<li style="margin-bottom: 1em"> <code>void <a
href="org/sbml/libsbml/ASTNode.html#setValue(double,
int)">setValue</a>(double mantissa, int exponent)</code> sets the value of
this AST node to the given real number in two parts: the
<code>mantissa</code> and the <code>exponent</code>.  The node type code is
set to <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_REAL_E">AST_REAL_E</a></code>.

</ul>

<p> Finally, <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a></code> also defines some
miscellaneous methods for manipulating
</p>

<ul>

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> <a
href="org/sbml/libsbml/ASTNode.html#ASTNode(int)">ASTNode</a>(int
type)</code> creates a new AST node object and returns a pointer to it.
The returned node will have the given <code>type</code> code.  The type
value must be chosen from among the constants beginning with the characters
<code>AST_</code> defined in <code><a
href="org/sbml/libsbml/libsbmlConstants.html">org.sbml.libsbml.libsbmlConstants</a></code>.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> <a
href="org/sbml/libsbml/ASTNode.html#ASTNode()">ASTNode</a>()</code> creates
a new AST node object and returns a pointer to it.  The returned node will
have the type <code><a
href="org/sbml/libsbml/libsbmlConstants.html#AST_UNKNOWN">AST_UNKNOWN</a></code>.
Its type should be set by the caller as soon as possible using

<li style="margin-bottom: 1em"> <code>long <a
href="org/sbml/libsbml/ASTNode.html#getNumChildren()">getNumChildren()</a></code>
returns the number of children of this AST node or <code>0</code> is this
node has no children.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html#addChild(org.sbml.libsbml.ASTNode)">addChild</a>(ASTNode)</code>
adds the given node as a child of this AST node.  Child nodes are added in
left-to-right order.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html#prependChild(org.sbml.libsbml.ASTNode)">prependChild()</a></code>
adds the given node as a child of this AST node.  This method adds child
nodes in right-to-left order.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> <a
href="org/sbml/libsbml/ASTNode.html#getChild(long)">getChild</a>(long
n)</code> returns the <code>n</code>th child of this AST node or
<code>NULL</code> if this node has no <code>n</code>th child (<code>n &gt;
(ASTNode.getNumChildren() - 1)</code>).

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> <a
href="org/sbml/libsbml/ASTNode.html#getLeftChild()">getLeftChild()</a></code>
returns the left child of this AST node.  This is equivalent to
<code>ASTNode.getChild(0)</code>.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> <a
href="org/sbml/libsbml/ASTNode.html#getRightChild()">getRightChild()</a></code>
returns the right child of this AST node or <code>NULL</code> if this node
has no right child.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html#swapChildren(org.sbml.libsbml.ASTNode)">swapChildren</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> that)</code> swaps the
children of this AST node with the children of <code>that</code> AST node.

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html#setType(int)">setType</a>(int
type)</code> sets the type of this AST node to the given <code>type</code>
code.  The value must be chosen from among the constants beginning with the
characters <code>AST_</code> defined in <code><a
href="org/sbml/libsbml/libsbmlConstants.html">org.sbml.libsbml.libsbmlConstants</a></code>.

</ul>


<h2><a class="anchor" name="math-reading">Reading and Writing MathML from/to ASTs</a></h2>

<p> As mentioned above, applications often can avoid working with raw
MathML by using either libSBML's text-string interface or the AST API.
However, when needed, reading MathML content directly and creating ASTs, as
well as the converse task of writing MathML, is easily done using two
methods designed for this purpose:
</p>

<ul>

<li style="margin-bottom: 1em"> <code><a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a> <a
href="org/sbml/libsbml/libsbml.html#readMathMLFromString(java.lang.String)">readMathMLFromString</a>(java.lang.String)</code>
reads raw MathML from a text string, constructs an AST from it, then
returns the root AST node of the resulting expression tree.

<li style="margin-bottom: 1em"> <code>java.lang.String <a
href="org/sbml/libsbml/libsbml.html#writeMathMLToString(org.sbml.libsbml.ASTNode)">writeMathMLToString</a>(<a
href="org/sbml/libsbml/ASTNode.html">ASTNode</a>)</code> writes an AST to a
string.  The caller owns the character string returned and should free it
after it is no longer needed.

</ul>


<p> The <a href="#example-program">example program</a> given above
demonstrate the use of these methods.

